//[START OF KOL.pas]
{****************************************************************

        KKKKK    KKKKK    OOOOOOOOO    LLLLL
        KKKKK    KKKKK  OOOOOOOOOOOOO  LLLLL
        KKKKK    KKKKK  OOOOO   OOOOO  LLLLL
        KKKKK  KKKKK    OOOOO   OOOOO  LLLLL
        KKKKKKKKKK      OOOOO   OOOOO  LLLLL
        KKKKK  KKKKK    OOOOO   OOOOO  LLLLL
        KKKKK    KKKKK  OOOOO   OOOOO  LLLLL
        KKKKK    KKKKK  OOOOOOOOOOOOO  LLLLLLLLLLLLL
        KKKKK    KKKKK    OOOOOOOOO    LLLLLLLLLLLLL

  Key Objects Library (C) 2000 by Kladov Vladimir.

//[VERSION]
****************************************************************
* VERSION 1.91
****************************************************************
//[END OF VERSION]
  This is not the original KOL.pas file, but a version
  converted automatically using GlueCut utility.
  Do not modify or redistribute this KOL.pas file !
  Instead, modify or redistribute original KOL.pas
  file and then run GlueCut again with FPC command
  file as a parameter to generate another version of
  this version of the KOL.pas.

  K.O.L. - is a set of objects to create small programs
  with the Delphi, but without the VCL. KOL allows to
  create executables of size about 10 times smaller then
  those created with the VCL. But this does not mean that
  KOL is less power then the VCL - perhaps just the opposite...

  KOL is provided free with the source code.
  Copyright (C) Vladimir Kladov, 2000-2003.

  For code provided by other  developers (even if later
  changed by me) authors are noted in the source.

  mailto: bonanzas@online.sinor.ru
  Web-Page: http://bonanzas.rinet.ru

  See also Mirror Classes Kit (M.C.K.) which allows
  to create KOL programs visually.

****************************************************************}

//[UNIT DEFINES]
{$INCLUDE win32def.inc}
unit KOL;

{$SMARTLINK ON}

{$Q-} // no overflow check: this option makes code wrong
{$R-} // no range checking: this option makes code wrong
{$T-} // not typed @-operator
//{$D+}
{$IFDEF INPACKAGE} // use this symbol in packages requiring kol.pas
  {$WARNINGS OFF}
{$ENDIF}
{$IFDEF _D7orHigher}
  {$WARN UNSAFE_TYPE OFF} // Too many such warnings in Delphi7
  {$WARN UNSAFE_CODE OFF}
  {$WARN UNSAFE_CAST OFF}
{$ENDIF}

//[START OF INTERFACE]
interface

//{$DEFINE DEBUG_GDIOBJECTS}
//{$DEFINE CHK_GDI}

//[USES]
uses
    messages, windows, RichEdit {$IFDEF CHK_GDI}, ChkGdi {$ENDIF};

{$IFDEF DEBUG_GDIOBJECTS}
var
  BrushCount: Integer;
  FontCount: Integer;
  PenCount: Integer;
{$ENDIF}


//{_#IF [DELPHI]}
{$INCLUDE delphicommctrl.inc}
//{_#ENDIF}

type
//[_TObj DEFINITION]



   TObj = class;
  PObj = TObj;
  {* }

   TList = class;
  PList = TList;
  {* }

//[TObjectMethod DECLARATION]
  TObjectMethod = procedure of object;
  {* }
  TOnEvent = procedure( Sender: PObj ) of object;
  {* This type of event is the most common - event handler when called can
     know only what object was a sender of this call. Replaces good known
     VCL TNotifyEvent event type. }

//[TPointerList DECLARATION]
   PPointerList = ^TPointerList;
   TPointerList = array[0..MaxInt div 4 - 1] of Pointer;

{ ---------------------------------------------------------------------

                  TObj - base object to derive all others

---------------------------------------------------------------------- }
//[TObj DEFINITION]
   TObj = class
   {* Prototype for all objects of KOL. All its methods are important to
      implement objects in a manner similar to Delphi TObject class. }
   {= Базовый класс для всех прочих объектов KOL. }
   protected
     fRefCount: Integer;
     fOnDestroy: TOnEvent;
     procedure DoDestroy;
   protected
     fAutoFree: PList;
     {* Is called from a constructor to initialize created object instance
        filling its fields with 0. Can be overriden in descendant objects
        to add another initialization code there. (Main reason of intending
        is what constructors can not be virtual in poor objects). }
     {= Вызывается для инициализации объекта. }
     fTag: DWORD;
     {* Custom data. }
   public
     destructor Destroy;  override;
     {* Disposes memory, allocated to an object. Does not release huge strings,
        dynamic arrays and so on. Such memory should be freeing in overriden
        destructor. }
     {= Освобождает память, выделенную для объекта. Не освобождает память, выделенную
        для строк, динамичиских массивов и т.п. Такая память должна быть освобождена
        в переопределенном деструкторе объекта. }
   protected

     procedure Init; virtual;
     {* Can be overriden in descendant objects
        to add initialization code there. (Main reason of intending
        is what constructors can not be virtual in poor objects). }

     procedure Final;
     {* Is called in destructor to perform OnDestroy event call and to
        released objects, added to fAutoFree list. }
   public
     procedure Free;
     {* Before calling destructor of object, checks if passed pointer is not
        nil - similar what is done in VCL for TObject. It is ALWAYS recommended
        to use Free instead of Destroy - see also comments to RefInc, RefDec. }
     {= До вызова деструктора, проверяет, не передан ли nil в качестве параметра.
        ВСЕГДА рекомендуется использовать Free вместо Destroy - см. так же RefInc,
        RefDec. }



     constructor Create;
     {* Constructor. Do not call it. Instead, use New<objectname> function
        call for certain object, e.g., NewLabel( AParent, 'caption' ); }
     {= Конструктор. Не следует вызывать его. Для конструирования объектов,
        вызывайте соответствующую глобальную функцию New<имя-объекта>. Например,
        NewLabel( MyForm, 'Метка№1' ); }

     procedure RefInc;
     {* See comments below. }
     {= См. RefDec ниже. }
     procedure RefDec;
     {* Decrements reference count. If it is becoming <0, and Free
        method was already called, object is (self-) destroyed. Otherwise,
        Free method does not destroy object, but only sets flag
        "Free was called".
     |<br>
        Use RefInc..RefDec to provide a block of code, where
        object can not be destroyed by call of Free method.
        This makes code more safe from intersecting flows of processing,
        where some code want to destroy object, but others suppose that it
        is yet existing.
     |<br>
        If You want to release object at the end of block RefInc..RefDec,
        do it immediately BEFORE call of last RefDec (to avoid situation,
        when object is released in result of RefDec, and attempt to
        destroy it follow leads to AV exception).
     }
     {= Уменьшает счетчик использования. Если в результате счетчик становится
        < 0, и метод Free уже был вызван, объект (само-) разрушается. Иначе,
        метод Free не разрушает объект, а только устанавливает флаг "Free был
        вызван".
        |<br>
        Используйте RefInc..RefDec для предотвращения разрушения объекта на
        некотором участке кода (если есть такая необходимость).
        |<br>
        Если нужно убить (временный) объект вместе с последним RefDec, сделайте
        вызов Free немедленно ПЕРЕД последним RefDec. }
     property RefCount: Integer read fRefCount;
     {* }
     property OnDestroy: TOnEvent read fOnDestroy write fOnDestroy;
     {* This event is provided for any KOL object, so You can provide your own
        OnDestroy event for it. }
     {= Данное событие обеспечивается для всех объектов KOL. Позволяет сделать
        что-нибудь в связи с разрушением объекта. }
    procedure Add2AutoFree( Obj: PObj );
    {* Adds an object to the list of objects, destroyed automatically
       when the object is destroyed. Do not add here child controls of
       the TControl (these are destroyed by another way). Only non-control
       objects, which are not destroyed automatically, should be added here. }
    procedure Add2AutoFreeEx( Proc: TObjectMethod );
    {* Adds an event handler to the list of events, called in destructor.
       This method is mainly for internal use, and allows to auto-destroy
       VCL components, located on KOL form at design time (in MCK project). }
    property Tag: DWORD read fTag write fTag;
    {* Custom data field. }
   end;
//[END OF TObj DEFINITION]

{ ---------------------------------------------------------------------

        TList - object to implement list of pointers (or dwords)

---------------------------------------------------------------------- }
//[TList DEFINITION]
  TList = class( TObj )
  {* Simple list of pointers. It is used in KOL instead of standard VCL
     TList to store any kind data (or pointers to these ones). Can be created
     calling function NewList. }
  {= Простой список указателей. }
  protected
    fItems: PPointerList;
    fCount: Integer;
    fCapacity: Integer;
    fAddBy: Integer;
    procedure SetCount(const Value: Integer);
    procedure SetAddBy(Value: Integer);
  public
    destructor Destroy; override;
    {* Destroys list, freeing memory, allocated for pointers. Programmer
       is resposible for destroying of data, referenced by the pointers. }
    {= }
  protected
    procedure SetCapacity( Value: Integer );
    function Get( Idx: Integer ): Pointer;
    procedure Put( Idx: Integer; Value: Pointer );
    {$IFDEF USE_CONSTRUCTORS}
    procedure Init; virtual;
    {$ENDIF USE_CONSTRUCTORS}
  public
    procedure Clear;
    {* Makes Count equal to 0. Not responsible for freeing (or destroying)
       data, referenced by released pointers. }
    procedure Add( Value: Pointer );
    {* Adds pointer to the end of list, increasing Count by one. }
    procedure Insert( Idx: Integer; Value: Pointer );
    {* Inserts pointer before given item. Returns Idx, i.e. index of
       inserted item in the list. Indeces of items, located after insertion
       point, are increasing. To add item to the end of list, pass Count
       as index parameter. To insert item before first item, pass 0 there. }
    function IndexOf( Value: Pointer ): Integer;
    {* Searches first (from start) item pointer with given value and returns
       its index (zero-based) if found. If not found, returns -1. }
    procedure Delete( Idx: Integer );
    {* Deletes given (by index) pointer item from the list, shifting all
       follow item indeces up by one. }
    procedure DeleteRange( Idx, Len: Integer );
    {* Deletes Len items starting from Idx. }
    procedure Remove( Value: Pointer );
    {* Removes first entry of a Value in the list. }
    property Count: Integer read fCount write SetCount;
    {* Returns count of items in the list. It is possible to delete a number
       of items at the end of the list, keeping only first Count items alive,
       assigning new value to Count property (less then Count it is). }
    property Capacity: Integer read fCapacity write SetCapacity;
    {* Returns number of pointers which could be stored in the list
       without reallocating of memory. It is possible change this value
       for optimize usage of the list (for minimize number of reallocating
       memory operations). }
    property Items[ Idx: Integer ]: Pointer read Get write Put; default;
    {* Provides access (read and write) to items of the list. Please note,
       that TList is not responsible for freeing memory, referenced by stored
       pointers. }
    function Last: Pointer;
    {* Returns the last item (or nil, if the list is empty). }
    procedure Swap( Idx1, Idx2: Integer );
    {* Swaps two items in list directly (fast, but without testing of
       index bounds). }
    procedure MoveItem( OldIdx, NewIdx: Integer );
    {* Moves item to new position. Pass NewIdx >= Count to move item
       after the last one. }
    procedure Release;
    {* Especially for lists of pointers to dynamically allocated memory.
       Releases all pointed memory blocks and destroys object itself. }
    procedure ReleaseObjects;
    {* Especially for a list of objects derived from TObj.
       Calls Free for every of the object in the list, and then calls
       Free for the object itself. }
    property AddBy: Integer read fAddBy write SetAddBy;
    {* Value to increment capacity when new items are added or inserted
       and capacity need to be increased. }
    property DataMemory: PPointerList read fItems;
    {* Raw data memory. Can be used for direct access to items of a list. }
    procedure Assign( SrcList: PList );
    {* Copies all source list items. }
  end;
//[END OF TList DEFINITION]

//[NewList DECLARATION]
function NewList: PList;
{* Returns pointer to newly created TList object. Use it instead usual
   TList.Create as it is done in VCL or XCL. }

procedure FastIncNum2Elements( List: TList; FromIdx, Count, Value: Integer );
{* Very fast adds Value to List elements from List[FromIdx] to List[FromIdx+Count-1].
   Given elements must exist. Count must be > 0. }

procedure Free_And_Nil( var Obj );
{* Obj.Free and Obj := nil, where Obj *MUST* be TObj or its descendant
   (TControl, TMenu, etc.) This procedure is not compatible with VCL's
   FreeAndNil, which works with TObject, since this it has another name. }

type

//[TListEx DEFINITION]
  TListEx = class;
  PListEx = TListEx;
  TListEx = class( TObj )
  {* Extended list, with Objects[ ] property. Created calling NewListEx function. }
  protected
    fList: PList;
    fObjects: PList;
    function GetEx(Idx: Integer): Pointer;
    procedure PutEx(Idx: Integer; const Value: Pointer);
    function GetCount: Integer;
    function GetAddBy: Integer;
    procedure Set_AddBy(const Value: Integer);
  public
    destructor Destroy; override;
    {* }
    property AddBy: Integer read GetAddBy write Set_AddBy;
    {* }
    property Items[ Idx: Integer ]: Pointer read GetEx write PutEx;
    {* }
    property Count: Integer read GetCount;
    {* }
    procedure Clear;
    {* }
    procedure Add( Value: Pointer );
    {* }
    procedure AddObj( Value, Obj: Pointer );
    {* }
    procedure Insert( Idx: Integer; Value: Pointer );
    {* }
    procedure InsertObj( Idx: Integer; Value, Obj: Pointer );
    {* }
    procedure Delete( Idx: Integer );
    {* }
    procedure DeleteRange( Idx, Len: Integer );
    {* }
    function IndexOf( Value: Pointer ): Integer;
    {* }
    function IndexOfObj( Obj: Pointer ): Integer;
    {* }
    procedure Swap( Idx1, Idx2: Integer );
    {* }
    procedure MoveItem( OldIdx, NewIdx: Integer );
    {* }
    property ItemsList: PList read fList;
    {* }
    property ObjList: PList read fObjects;
    {* }
    function Last: Pointer;
    {* }
    function LastObj: Pointer;
    {* }
  end;
//[END OF TListEx DEFINITION]

//[NewListEx DECLARATION]
function NewListEx: PListEx;
{* Creates extended list. }







type
//[TBits DEFINITION]
  TBits = class;
  PBits = TBits;
  TBits = class( TObj )
  {* Variable-length bits array object. Created using function NewBits. See also
     |<a href="kol_pas.htm#Small bit arrays (max 32 bits in array)">
     Small bit arrays (max 32 bits in array)
     |</a>. }
  protected
    fList: PList;
    fCount: Integer;
    function GetBit(Idx: Integer): Boolean;
    function GetCapacity: Integer;
    function GetSize: Integer;
    procedure SetBit(Idx: Integer; const Value: Boolean);
    procedure SetCapacity(const Value: Integer);
  public
    destructor Destroy; override;
    {* }
    property Bits[ Idx: Integer ]: Boolean read GetBit write SetBit;
    {* }
    property Size: Integer read GetSize;
    {* Size in bytes of the array. To get know number of bits, use property Count. }
    property Count: Integer read fCount;
    {* Number of bits an the array. }
    property Capacity: Integer read GetCapacity write SetCapacity;
    {* Number of bytes allocated. Can be set before assigning bit values
       to improve performance (minimizing amount of memory allocation
       operations).  }
    function Copy( From, BitsCount: Integer ): PBits;
    {* Use this property to get a sub-range of bits starting from given bit
       and of BitsCount bits count. }
    function IndexOf( Value: Boolean ): Integer;
    {* Returns index of first bit with given value (True or False). }
    function OpenBit: Integer;
    {* Returns index of the first bit not set to true. }
  end;
//[END OF TBits DEFINITION]

//[NewBits DECLARATION]
function NewBits: PBits;
{* Creates variable-length bits array object. }



















{ -- tree (non-visual) -- }

type
//[TTree DEFINITION]
  TTree = class;
  PTree = TTree;
  TTree = class( TObj )
  {* Object to store tree-like data in memory (non-visual). }
  protected
    fParent: PTree;
    fChildren: PList;
    fPrev: PTree;
    fNext: PTree;
    fName: String;
    fData: Pointer;
    function GetCount: Integer;
    function GetItems(Idx: Integer): PTree;
    procedure Unlink;
    function GetRoot: PTree;
    function GetLevel: Integer;
    function GetTotal: Integer;
    function GetIndexAmongSiblings: Integer;
  protected
    {$IFDEF USE_CONSTRUCTORS}
    constructor CreateTree( AParent: PTree; const AName: String );
    {* }
    {$ENDIF}
  public
    destructor Destroy; override;
    {* }
  protected
    procedure Init; override;
  public
    procedure Clear;
    {* Destoyes all child nodes. }
    property Name: String read fName write fName;
    {* Optional node name. }
    property Data: Pointer read fData write fData;
    {* Optional user-defined pointer. }
    property Count: Integer read GetCount;
    {* Number of child nodes of given node. }
    property Items[ Idx: Integer ]: PTree read GetItems;
    {* Child nodes list items. }
    procedure Add( Node: PTree );
    {* Adds another node as a child of given tree node. This operation
       as well as Insert can be used to move node together with its children
       to another location of the same tree or even from another tree.
       Anyway, added Node first correctly removed from old place (if it is
       defined for it). But for simplest task, such as filling of tree with
       nodes, code should looking as follows:
       !  Node := NewTree( nil, 'test of creating node without parent' );
       !  RootOfMyTree.Add( Node );
       Though, this code gives the same result as:
       !  Node := NewTree( RootOfMyTree, 'test of creatign node as a child' ); }
    procedure Insert( Before, Node: PTree );
    {* Inserts earlier created 'Node' just before given child node 'Before'
       as a child of given tree node. See also Add method. }
    property Parent: PTree read fParent;
    {* Returns parent node (or nil, if there is no parent). }
    property Index: Integer read GetIndexAmongSiblings;
    {* Returns an index of the node in a list of nodes of the same parent
       (or -1, if Parent is not defined). }
    property PrevSibling: PTree read fPrev;
    {* Returns previous node in a list of children of the Parent. Nil is
       returned, if given node is the first child of the Parent or has
       no Parent. }
    property NextSibling: PTree read fNext;
    {* Returns next node in a list of children of the Parent. Nil is returned,
       if given node is the last child of the Parent or has no Parent at all. }
    property Root: PTree read GetRoot;
    {* Returns root node (i.e. the last Parent, enumerating parents recursively). }
    property Level: Integer read GetLevel;
    {* Returns level of the node, i.e. integer value, equal to 0 for root
       of a tree, 1 for its children, etc. }
    property Total: Integer read GetTotal;
    {* Returns total number of children of the node and all its children
       counting its recursively (but node itself is not considered, i.e.
       Total for node without children is equal to 0). }
    procedure SortByName;
    {* Sorts children of the node in ascending order. Sorting is not
       recursive, i.e. only immediate children are sorted. }
    procedure SwapNodes( i1, i2: Integer );
    {* Swaps two child nodes. }
    function IsParentOfNode( Node: PTree ): Boolean;
    {* Returns true, if Node is the tree itself or is a parent of the given node
       on any level. }
    function IndexOf( Node: PTree ): Integer;
    {* Total index of the child node (on any level under this node). }

  end;
//[END OF TTree DEFINITION]

//[NewTree DECLARATION]
function NewTree( AParent: PTree; const AName: String ): PTree;
{* Constructs tree node, adding it to the end of children list of
   the AParent. If AParent is nil, new root tree node is created. }







//[DummyObjProc, DummyObjProcParam DECLARATION]
procedure DummyObjProc( Sender: PObj );
procedure DummyObjProcParam( Sender: PObj; Param: Pointer );




{ --- threads --- }
//[THREADS]

const
  ABOVE_NORMAL_PRIORITY_CLASS = $8000; // only for Windows 2K
  BELOW_NORMAL_PRIORITY_CLASS = $4000; // and higher !

type
  TThread = class;
  PThread = TThread;

  TThreadMethod = procedure of object;
  TThreadMethodEx = procedure( Sender: PThread; Param: Pointer ) of object;

  TOnThreadExecute = function(Sender:PThread): Integer of object;
  {* Event to be called when Execute method is called for TThread }

{ ---------------------------------------------------------------------

                            TThread object

---------------------------------------------------------------------- }
//[TThread DEFINITION]
  TThread = class(TObj)
  {* Thread object. It is possible not to derive Your own thread-based
     object, but instead create thread Suspended and assign event
     OnExecute. To create, use one of NewThread of NewThreadEx functions,
     or derive Your own descendant object and write creation function
     (or constructor) for it.
     |<br><br>
     Aknowledgements. Originally class ZThread was developed for XCL:
     |<br> * By: Tim Slusher : junior@nlcomm.com
     |<br> * Home: http://www.nlcomm.com/~junior
   }
  protected
    FSuspended,
    FTerminated: boolean;
    FHandle: THandle;
    FThreadId: DWORD;
    FOnSuspend: TObjectMethod;
    FOnResume: TOnEvent;
    FData : Pointer;
    FOnExecute : TOnThreadExecute;
    FMethod: TThreadMethod;
    FMethodEx: TThreadMethodEx;
    F_AutoFree: Boolean;
    function GetPriorityCls: Integer;
    function GetThrdPriority: Integer;
    procedure SetPriorityCls(Value: Integer);
    procedure SetThrdPriority(Value: Integer);
  public
    destructor Destroy; override;
    {* }
  public
    function Execute: integer; virtual;
    {* Executes thread. }
    procedure Resume;
    {* Continues executing. It is necessary to make call for every
       nested Suspend. }
    procedure Suspend;
    {* Suspends thread until it will be resumed. }
    procedure Terminate;
    {* Terminates thread. }
    function WaitFor: Integer;
    {* Waits (infinitively) until thead will be finished. }

    property Handle: THandle read FHandle;
    {* Thread handle. It is created immediately when object is created
       (using NewThread). }
    property Suspended: boolean read FSuspended;
    {* True, if suspended. }
    property Terminated: boolean read FTerminated;
    {* True, if terminated. }
    property ThreadId: DWORD read FThreadId;
    {* Thread id. }
    property PriorityClass: Integer read GetPriorityCls write SetPriorityCls;
    {* Thread priority class. One of following values: HIGH_PRIORITY_CLASS,
       IDLE_PRIORITY_CLASS, NORMAL_PRIORITY_CLASS, REALTIME_PRIORITY_CLASS. }
    property ThreadPriority: Integer read GetThrdPriority write SetThrdPriority;
    {* Thread priority value. One of following values: THREAD_PRIORITY_ABOVE_NORMAL,
       THREAD_PRIORITY_BELOW_NORMAL, THREAD_PRIORITY_HIGHEST, THREAD_PRIORITY_IDLE,
       THREAD_PRIORITY_LOWEST, THREAD_PRIORITY_NORMAL, THREAD_PRIORITY_TIME_CRITICAL. }
    property Data : Pointer read FData write FData;
    {* Custom data pointer. Use it for Youe own purpose. }

    property OnExecute: TOnThreadExecute read FOnExecute write FOnExecute;
    {* Is called, when Execute is starting. }
    property OnSuspend: TObjectMethod read FOnSuspend write FOnSuspend;
    {* Is called, when Suspend is performed. }
    property OnResume: TOnEvent read FOnResume write FOnResume;
    {* Is called, when resumed. }
    procedure Synchronize( Method: TThreadMethod );
    {* Call it to execute given method in main thread context. Applet variable
       must exist for that time. }
    procedure SynchronizeEx( Method: TThreadMethodEx; Param: Pointer );
    {* Call it to execute given method in main thread context, with a given
       parameter. Applet variable must exist for that time. Param must not be nil. }
    {$IFDEF USE_CONSTRUCTORS}
    constructor ThreadCreate;
    constructor ThreadCreateEx( const Proc: TOnThreadExecute );
    {$ENDIF USE_CONSTRUCTORS}

    property AutoFree: Boolean read F_AutoFree write F_AutoFree;
    {* Set this property to true to provide automatic destroying of thread
       object when its executing is finished. }
  end;
//[END OF TThread DEFINITION]

//[NewThread, NewThreadEx, NewThreadAutoFree, Global_Synchronized DECLARATIONS]
function NewThread: PThread;
{* Creates thread object (always suspended). After creating, set event
   OnExecute and perform Resume operation. }

function NewThreadEx( const Proc: TOnThreadExecute ): PThread;
{* Creates thread object, assigns Proc to its OnExecute event and runs
   it. }

function NewThreadAutoFree( const Proc: TOnThreadExecute ): PThread;
{* Creates thread object similar to NewThreadEx, but freeing automatically
   when executing of such thread finished. Be sure that a thread is resumed
   at least to provide its object keeper freeing. }

var Global_Synchronized: procedure( Sender: PObj; Param: Pointer ) = DummyObjProcParam;
// It is not necessary to declare it as threadvar.














{ -- streams -- }
//[STREAMS]

type
  TMoveMethod = ( spBegin, spCurrent, spEnd );

  TStream = class;
  PStream = TStream;

  PStreamMethods = ^TStreamMethods;
  TStreamMethods = Packed Record
    fSeek: function( Strm: PStream; MoveTo: Integer; MoveMethod: TMoveMethod ): DWORD;
    fGetSiz: function( Strm: PStream ): DWORD;
    fSetSiz: procedure( Strm: PStream; Value: DWORD );
    fRead: function( Strm: PStream; var Buffer; Count: DWORD ): DWORD;
    fWrite: function( Strm: PStream; var Buffer; Count: DWORD ): DWORD;
    fClose: procedure( Strm: PStream );
    fCustom: Pointer;
    fWait: procedure( Strm: PStream );
  end;

  TStreamData = Packed Record
    fHandle: THandle;
    fCapacity, fSize, fPosition: DWORD;
    fThread: PThread;
  end;

{ ---------------------------------------------------------------------

                TStream - streaming objects incapsulation

---------------------------------------------------------------------- }
//[TStream DEFINITION]
  TStream = class(TObj)
  {* Simple stream object. Can be opened for file, or as memory stream (see
     NewReadFileStream, NewWriteFileStream, NewMemoryStream, etc.). And, another
     type of streaming object can be derived (without inheriting new object
     type, just by writing another New...Stream method, which calls
     _NewStream and pass methods record to it). }
  protected
    fPMethods: PStreamMethods;
    fMethods: TStreamMethods;
    fMemory: Pointer;
    fData: TStreamData;
    fParam1, fParam2: DWORD; // parameters to use in thread
    function GetCapacity: DWORD;
    procedure SetCapacity(const Value: DWORD);
    function DoAsyncRead( Sender: PThread ): Integer;
    function DoAsyncWrite( Sender: PThread ): Integer;
    function DoAsyncSeek( Sender: PThread ): Integer;
  protected
    function GetFileStreamHandle: THandle;
    procedure SetPosition(Value: DWord);
    function GetPosition: DWord;
    function GetSize: DWord;
    procedure SetSize(NewSize: DWord);
  public
    destructor Destroy; override;
  public
    function Read(var Buffer; Count: DWord): DWord;
    {* Reads Count bytes from a stream. Returns number of bytes read. }
    function Seek(MoveTo: Integer; MoveMethod: TMoveMethod): DWord;
    {* Allows to change current position or to obtain it. Property
       Position uses this method both for get and set position. }
    function Write(var Buffer; Count: DWord): DWord;
    {* Writes Count bytes from Buffer, starting from current position
       in a stream. Returns how much bytes are written. }
    function WriteStr( S: String ): DWORD;
    {* Writes string to the stream, not including ending #0. Exactly
       Length( S ) characters are written. }
    function WriteStrZ( S: String ): DWORD;
    {* Writes string, adding #0. Number of bytes written is returned. }
    function ReadStrZ: String;
    {* Reads string, finished by #0. After reading, current position in
       the stream is set to the byte, follows #0. }
    function ReadStr: String;
    {* Reads string, finished by #13, #10 or #13#10 symbols. Terminating symbols
       #13 and/or #10 are not added to the end of returned string though
       stream positioned follow it. }
    function WriteStrEx(S: String): DWord;
    {* Writes string S to stream, also saving its size for future use by
       ReadStrEx* functions. Returns number of actually written characters. }
    function ReadStrExVar(var S: String): DWord;
    {* Reads string from stream and assigns it to S.
       Returns number of actually read characters.
       Note:
         String must be written by using WriteStrEx function.
         Return value is count of characters READ, not the length of string. }
    function ReadStrEx: String;
    {* Reads string from stream and returns it. }
    property Size: DWord read GetSize write SetSize;
    {* Returns stream size. For some custom streams, can be slow
       operation, or even always return undefined value (-1 recommended). }
    property Position: DWord read GetPosition write SetPosition;
    {* Current position. }

    property Memory: Pointer read fMemory;
    {* Only for memory stream. }
    property Handle: THandle read GetFileStreamHandle;
    {* Only for file stream. It is possible to check that Handle <>
       INVALID_HANDLE_VALUE to ensure that file stream is created OK. }

    //---------- for asynchronous operations (using thread - not tested):
    procedure SeekAsync(MoveTo: Integer; MoveMethod: TMoveMethod);
    {* Changes current position asynchronously. To wait for finishing the
       operation, use method Wait. }
    procedure ReadAsync(var Buffer; Count: DWord);
    {* Reads Count bytes from a stream asynchronously. To wait finishing the
       operation, use method Wait. }
    procedure WriteAsync(var Buffer; Count: DWord);
    {* Writes Count bytes from Buffer, starting from current position
       in a stream - asynchronously. To wait finishing the operation,
       use method Wait. }
    function Busy: Boolean;
    {* Returns TRUE until finishing the last asynchronous operation
       started by calling SeekAsync, ReadAsync, WriteAsync methods. }
    procedure Wait;
    {* Waits for finishing the last asynchronous operation. }

    property Methods: PStreamMethods read fPMethods;
    {* Pointer to TStreamMethods record. Useful to implement custom-defined
       streams, which can access its fCustom field, or even to change
       methods when necessary. }
    property Data: TStreamData read fData;
    {* Pointer to TStreamData record. Useful to implement custom-defined
    streams, which can access Data fields directly when implemented. }

    property Capacity: DWORD read GetCapacity write SetCapacity;
    {* Amound of memory allocated for data (MemoryStream). }

  end;
//[END OF TStream DEFINITION]

//[_NewStream DECLARATION]
function _NewStream( const StreamMethods: TStreamMethods ): PStream;
{* Use this method only to define your own stream type. See also declared
   below (in KOL.pas) methods used to implement standard KOL streams. You can use it in
   your code to create streams, which are partially based on standard
   methods. }

// Methods below are declared here to simplify creating your
// own streams with some methods standard and some non-standard
// together:
function SeekFileStream( Strm: PStream; MoveTo: Integer; MoveFrom: TMoveMethod ): DWORD;
function GetSizeFileStream( Strm: PStream ): DWORD;
function ReadFileStream( Strm: PStream; var Buffer; Count: DWORD ): DWORD;
function WriteFileStream( Strm: PStream; var Buffer; Count: DWORD ): DWORD;
function WriteFileStreamEOF( Strm: PStream; var Buffer; Count: DWORD ): DWORD;
procedure CloseFileStream( Strm: PStream );
function SeekMemStream( Strm: PStream; MoveTo: Integer; MoveFrom: TMoveMethod ): DWORD;
function GetSizeMemStream( Strm: PStream ): DWORD;
procedure SetSizeMemStream( Strm: PStream; NewSize: DWORD );
function ReadMemStream( Strm: PStream; var Buffer; Count: DWORD ): DWORD;
function WriteMemStream( Strm: PStream; var Buffer; Count: DWORD ): DWORD;
procedure CloseMemStream( Strm: PStream );
procedure SetSizeFileStream( Strm: PStream; NewSize: DWORD );

function DummyReadWrite( Strm: PStream; var Buffer; Count: DWORD ): DWORD;
procedure DummySetSize( Strm: PStream; Value: DWORD );
procedure DummyStreamProc(Strm: PStream);


//[NewFileStream DECLARATION]
function NewFileStream( const FileName: String; Options: DWORD ): PStream;
{* Creates file stream for read and write. Exact set of open attributes
   should be passed through Options parameter (see FileCreate where those
   flags are listed). }

function NewReadFileStream( const FileName: String ): PStream;
{* Creates file stream for read only. }

function NewWriteFileStream( const FileName: String ): PStream;
{* Creates file stream for write only. Truncating of file (if needed)
   is provided automatically. }

function NewReadWriteFileStream( const FileName: String ): PStream;
{* Creates stream for read and write file. To truncate file, if it is
   necessary, change Size property. }

//[NewMemoryStream DECLARATION]
function NewMemoryStream: PStream;
{* Creates memory stream (read and write). }

function NewExMemoryStream( ExistingMem: Pointer; Size: DWORD ): PStream;
{* Creates memory stream on base of existing memory. It is not possible
   to write out of top bound given by Size (i.e. memory can not be resized,
   or reallocated. When stream object is destroyed this memory is not freed. }

//[Stream2Stream DECLARATION]
function Stream2Stream( Dst, Src: PStream; Count: DWORD ): DWORD;
{* Copies Count (or less, if the rest of Src is not sufficiently long)
   bytes from Src to Dst, but with optimizing in cases, when Src or/and
   Dst are memory streams (intermediate buffer is not allocated). }
function Stream2StreamEx( Dst, Src: PStream; Count: DWORD ): DWORD;
{* Copies Count bytes from Src to Dst, but without any optimization.
   Unlike Stream2Stream function, it can be applied to very large streams.
   See also Stream2StreamExBufSz. }
function Stream2StreamExBufSz( Dst, Src: PStream; Count, BufSz: DWORD ): DWORD;
{* Copies Count bytes from Src to Dst using buffer of given size, but without
   other optimizations.
   Unlike Stream2Stream function, it can be applied to very large streams }

//[Resource2Stream DECLARATION]
function Resource2Stream( DestStrm : PStream; Inst : HInst;
                          ResName : PChar; ResType : PChar ): Integer;
{* Loads given resource to DestStrm. Useful for non-standard
   resources to load it into memory (use memory stream for such
   purpose). Use one of following resource types to pass as ResType:
   |<pre>
RT_ACCELERATOR	Accelerator table
RT_ANICURSOR	Animated cursor
RT_ANIICON	Animated icon
RT_BITMAP	Bitmap resource
RT_CURSOR	Hardware-dependent cursor resource
RT_DIALOG	Dialog box
RT_FONT	        Font resource
RT_FONTDIR	Font directory resource
RT_GROUP_CURSOR	Hardware-independent cursor resource
RT_GROUP_ICON	Hardware-independent icon resource
RT_ICON	        Hardware-dependent icon resource
RT_MENU	        Menu resource
RT_MESSAGETABLE	Message-table entry
RT_RCDATA	Application-defined resource (raw data)
RT_STRING	String-table entry
RT_VERSION	Version resource
   |</pre>
   |<br>For example:
   !var MemStrm: PStream;
   !    JpgObj: PJpeg;
   !......
   ! MemStrm := NewMemoryStream;
   ! JpgObj := NewJpeg;
   !......
   ! Resource2Stream( MemStrm, hInstance, 'MYJPEG', RT_RCDATA );
   ! MemStrm.Position := 0;
   ! JpgObj.LoadFromStream( MemStrm );
   ! MemStrm.Free;
   !......
   }
























{ -- string list objects -- }
//[TStrList]

type
  TStrList = class;
  PStrList = TStrList;
{ ---------------------------------------------------------------------

                TStrList - string list

---------------------------------------------------------------------- }
//[TStrList DEFINITION]
  TStrList = class(TObj)
  {* Easy string list implementation (non-visual, just to store
     string data). It is well improved and has very high performance
     allowing to work fast with huge text files (more then megabyte
     of text data).
     |
     Please note that #0 charaster if stored in string lines, will cut it
     preventing reading the rest of a line. Be careful, if your data
     contain such characters. }
  protected
    fList: PList;
    fCount: Integer;
    fCaseSensitiveSort: Boolean;
    fTextBuf: PChar;
    fTextSiz: DWORD;
    function GetPChars(Idx: Integer): PChar;
    //procedure AddTextBuf( Src: PChar; Len: DWORD );
  protected
    function Get(Idx: integer): string;
    function GetTextStr: string;
    procedure Put(Idx: integer; const Value: string);
    procedure SetTextStr(const Value: string);
  public
    destructor Destroy; override;
  protected
    // by Dod:
    procedure SetValue(const Name, Value: string);
    function GetValue(const Name: string): string;
  public
    // by Dod:
    function IndexOfName(Name: string): Integer;
    {* by Dod. Returns index of line starting like Name=... }
    property Values[const Name: string]: string read GetValue write SetValue;
    {* by Dod. Returns right side of a line starting like Name=... }
  public
    function Add(const S: string): integer;
    {* Adds a string to list. }
    procedure AddStrings(Strings: PStrList);
    {* Merges string list with given one. Very fast - more preferrable to
       use than any loop with calling Add method. }
    procedure Assign(Strings: PStrList);
    {* Fills string list with strings from other one. The same as AddStrings,
       but Clear is called first. }
    procedure Clear;
    {* Makes string list empty. }
    procedure Delete(Idx: integer);
    {* Deletes string with given index (it *must* exist). }
    function IndexOf(const S: string): integer;
    {* Returns index of first string, equal to given one. }
    function Find(const S: String; var Index: Integer): Boolean;
    {* Returns Index of the first string, equal or greater to given pattern, but
       works only for sorted TStrList object. Returns TRUE if exact string found,
       otherwise nearest (greater then a pattern) string index is returned,
       and the result is FALSE. }
    procedure Insert(Idx: integer; const S: string);
    {* Inserts string before one with given index. }
    function LoadFromFile(const FileName: string): Boolean;
    {* Loads string list from a file. (If file does not exist, nothing
       happens). Very fast even for huge text files. }
    procedure LoadFromStream(Stream: PStream; Append2List: boolean);
    {* Loads string list from a stream (from current position to the end of
       a stream). Very fast even for huge text. }
    procedure MergeFromFile(const FileName: string);
    {* Merges string list with strings in a file. Fast. }
    procedure Move(CurIndex, NewIndex: integer);
    {* Moves string to another location. }
    procedure SetText(const S: string; Append2List: boolean);
    {* Allows to set strings of string list from given string (in which
       strings are separated by $0D,$0A or $0D characters). Text must not
       contain #0 characters. Works very fast. This method is used in
       all others, working with text arrays (LoadFromFile, MergeFromFile,
       Assign, AddStrings). }
    procedure SetUnixText( const S: String; Append2List: Boolean );
    {* Allows to assign UNIX-style text (with #10 as string separator). }
    function SaveToFile(const FileName: string): Boolean;
    {* Stores string list to a file. }
    procedure SaveToStream(Stream: PStream);
    {* Saves string list to a stream (from current position). }
    function AppendToFile(const FileName: string): Boolean;
    {* Appends strings of string list to the end of a file. }
    property Count: integer read fCount;
    {* Number of strings in a string list. }
    property Items[Idx: integer]: string read Get write Put; default;
    {* Strings array items. If item does not exist, empty string is returned.
       But for assign to property, string with given index *must* exist. }
    property ItemPtrs[ Idx: Integer ]: PChar read GetPChars;
    {* Fast access to item strings as PChars. }
    function Last: String;
    {* Last item (or '', if string list is empty). }
    property Text: string read GetTextStr write SetTextStr;
    {* Content of string list as a single string (where strings are separated
       by characters $0D,$0A). }
    procedure Swap( Idx1, Idx2 : Integer );
    {* Swaps to strings with given indeces. }
    procedure Sort( CaseSensitive: Boolean );
    {* Call it to sort string list. }
    procedure AnsiSort( CaseSensitive: Boolean );
    {* Call it to sort ANSI string list. }

    // by Alexander Pravdin:
  protected
    function GetLineName( Idx: Integer ): string;
    procedure SetLineName( Idx: Integer; const NV: string );
    function GetLineValue(Idx: Integer): string;
    procedure SetLineValue(Idx: Integer; const Value: string);
  public
    property LineName[ Idx: Integer ]: string read GetLineName write SetLineName;
    property LineValue[ Idx: Integer ]: string read GetLineValue write SetLineValue;
  end;
//[END OF TStrList DEFINITION]

//[NewStrList DECLARATION]
function NewStrList: PStrList;
{* Creates string list object. }

function  GetFileList(const dir: string): PStrList;
{* By Alexander Shakhaylo. Returns list of file names of the given directory. }




//[TStrListEx]
type
  TStrListEx = class;
  PStrListEx = TStrListEx;

//[TStrListEx DEFINITION]
  TStrListEx = class( TStrList )
  {* Extended string list object. Has additional capability to associate
     numbers or objects with string list items. }
  protected
    FObjects: PList;
    function GetObjects(Idx: Integer): DWORD;
    procedure SetObjects(Idx: Integer; const Value: DWORD);
    procedure Init; override;
    procedure ProvideObjCapacity( NewCap: Integer );
  public
    destructor Destroy; override;
    {* }
    property Objects[ Idx: Integer ]: DWORD read GetObjects write SetObjects;
    {* Objects are just 32-bit values. You can treat and use it as pointers to
       any other data in the memory. But it is your task to free allocated
       memory in such case therefore. }
    procedure AddStrings(Strings: PStrListEx);
    {* Merges string list with given one. Very fast - more preferrable to
       use than any loop with calling Add method. }
    procedure Assign(Strings: PStrListEx);
    {* Fills string list with strings from other one. The same as AddStrings,
       but Clear is called first. }
    procedure Clear;
    {* Makes string list empty. }
    procedure Delete(Idx: integer);
    {* Deletes string with given index (it *must* exist). }
    procedure Move(CurIndex, NewIndex: integer);
    {* Moves string to another location. }
    procedure Swap( Idx1, Idx2 : Integer );
    {* Swaps to strings with given indeces. }
    procedure Sort( CaseSensitive: Boolean );
    {* Call it to sort string list. }
    procedure AnsiSort( CaseSensitive: Boolean );
    {* Call it to sort ANSI string list. }
    function LastObj: DWORD;
    {* Object assotiated with the last string. }
    function AddObject( const S: String; Obj: DWORD ): Integer;
    {* Adds a string and associates given number with it. Index of the item added
       is returned. }
    procedure InsertObject( Before: Integer; const S: String; Obj: DWORD );
    {* Inserts a string together with object associated. }
    function IndexOfObj( Obj: Pointer ): Integer;
    {* Returns an index of a string associated with the object passed as a
       parameter. If there are no such strings, -1 is returned. }
  end;
//[END OF TStrListEx DEFINITION]

//[NewStrListEx DECLARATION]
function NewStrListEx: PStrListEx;
{* Creates extended string list object. }





//[TWStrList]


////////////////////////////////////////////////////////////////////////////////
//                            GRAPHIC OBJECTS                                 //
////////////////////////////////////////////////////////////////////////////////
//[GRAPHIC OBJECTS]
{
  It is very important, that the most of code, implementing graphic objets
  from this section, is included into executable ONLY if really accessed in your
  project directly (e.g., if Font or Brush properies of a control are accessed
  or changed).
}
type
  TColor = Integer;

const
//[COLOR CONSTANTS]
  clScrollBar = TColor(COLOR_SCROLLBAR or $80000000);
  clBackground = TColor(COLOR_BACKGROUND or $80000000);
  clActiveCaption = TColor(COLOR_ACTIVECAPTION or $80000000);
  clInactiveCaption = TColor(COLOR_INACTIVECAPTION or $80000000);
  clMenu = TColor(COLOR_MENU or $80000000);
  clWindow = TColor(COLOR_WINDOW or $80000000);
  clWindowFrame = TColor(COLOR_WINDOWFRAME or $80000000);
  clMenuText = TColor(COLOR_MENUTEXT or $80000000);
  clWindowText = TColor(COLOR_WINDOWTEXT or $80000000);
  clCaptionText = TColor(COLOR_CAPTIONTEXT or $80000000);
  clActiveBorder = TColor(COLOR_ACTIVEBORDER or $80000000);
  clInactiveBorder = TColor(COLOR_INACTIVEBORDER or $80000000);
  clAppWorkSpace = TColor(COLOR_APPWORKSPACE or $80000000);
  clHighlight = TColor(COLOR_HIGHLIGHT or $80000000);
  clHighlightText = TColor(COLOR_HIGHLIGHTTEXT or $80000000);
  clBtnFace = TColor(COLOR_BTNFACE or $80000000);
  clBtnShadow = TColor(COLOR_BTNSHADOW or $80000000);
  clGrayText = TColor(COLOR_GRAYTEXT or $80000000);
  clBtnText = TColor(COLOR_BTNTEXT or $80000000);
  clInactiveCaptionText = TColor(COLOR_INACTIVECAPTIONTEXT or $80000000);
  clBtnHighlight = TColor(COLOR_BTNHIGHLIGHT or $80000000);
  cl3DDkShadow = TColor(COLOR_3DDKSHADOW or $80000000);
  cl3DLight = TColor(COLOR_3DLIGHT or $80000000);
  clInfoText = TColor(COLOR_INFOTEXT or $80000000);
  clInfoBk = TColor(COLOR_INFOBK or $80000000);

  clBlack = TColor($000000);
  clMaroon = TColor($000080);
  clGreen = TColor($008000);
  clOlive = TColor($008080);
  clNavy = TColor($800000);
  clPurple = TColor($800080);
  clTeal = TColor($808000);
  clGray = TColor($808080);
  clSilver = TColor($C0C0C0);
  clRed = TColor($0000FF);
  clLime = TColor($00FF00);
  clYellow = TColor($00FFFF);
  clBlue = TColor($FF0000);
  clFuchsia = TColor($FF00FF);
  clAqua = TColor($FFFF00);
  clLtGray = TColor($C0C0C0);
  clDkGray = TColor($808080);
  clWhite = TColor($FFFFFF);
  clNone = TColor($1FFFFFFF);
  clDefault = TColor($20000000);

  clMoneyGreen = TColor($C0DCC0);
  clSkyBlue = TColor($F0CAA6);
  clCream = TColor($F0FBFF);
  clMedGray = TColor($A4A0A0);
//[END OF COLOR CONSTANTS]

const
//[TGraphicTool FIELD OFFSET CONSTANTS]
  go_Color                 = 0;
  go_FontHeight            = 4;
  go_FontWidth             = 8;
  go_FontEscapement        = 12;
  go_FontOrientation       = 16;
  go_FontWeight            = 20;
  go_FontItalic            = 24;
  go_FontUnderline         = 25;
  go_FontStrikeOut         = 26;
  go_FontCharSet           = 27;
  go_FontOutPrecision      = 28;
  go_FontClipPrecision     = 29;
  go_FontQuality           = 30;
  go_FontPitch             = 31;
  go_FontName              = 32;
  go_BrushBitmap           = 4;
  go_BrushStyle            = 8;
  go_BrushLineColor        = 9;
  go_PenBrushBitmap        = 4;
  go_PenBrushStyle         = 8;
  go_PenStyle              = 9;
  go_PenWidth              = 10;
  go_PenMode               = 14;
  go_PenGeometric          = 15;
  go_PenEndCap             = 16;
  go_PenJoin               = 17;
//[END OF TGraphicTool FIELD OFFSET CONSTANTS]

//[TGraphicTool]
type
   TGraphicToolType = ( gttBrush, gttFont, gttPen );
   {* Graphic object types, mainly for internal use. }

   TGraphicTool = class;
   PGraphicTool = TGraphicTool;
   {* }
   TOnGraphicChange = procedure ( Sender: PGraphicTool ) of object;
   {* An event mainly for internal use. }

   TBrushStyle = (bsSolid, bsClear, bsHorizontal, bsVertical,
    bsFDiagonal, bsBDiagonal, bsCross, bsDiagCross);
   {* Available brush styles. }

   TFontStyles = (fsBold, fsItalic, fsUnderline, fsStrikeOut);
   {* Available font styles. }
   TFontStyle = set of TFontStyles;
   {* Font style is representing as a set of XFontStyles. }
   TFontPitch = (fpDefault, fpFixed, fpVariable);
   {* Availabe font pitch values. }
   TFontName = type string;
   {* Font name is represented as a string. }
   TFontCharset = 0..255;
   {* Font charset is represented by number from 0 to 255. }
   TFontQuality = (fqDefault, fqDraft, fqProof, fqNonAntialiased, fqAntialiased);
   {* Font quality. }

   TPenStyle = (psSolid, psDash, psDot, psDashDot, psDashDotDot, psClear,
    psInsideFrame);
   {* Available pen styles. For more info see Delphi or Win32 help files. }
   TPenMode = (pmBlack, pmNotMerge, pmMaskNotPen, pmNotCopy, pmMaskPenNot,
               pmNot, pmXor, pmNotMask, pmMask, pmNotXor, pmNop, pmMergePenNot,
               pmCopy, pmMergeNotPen, pmMerge, pmWhite);
   {* Available pen modes. For more info see Delphi or Win32 help files. }
   TPenEndCap = (pecRound, pecSquare, pecFlat);
   {* Avalable (for geometric pen) end cap styles. }
   TPenJoin = (pjRound, pjBevel, pjMiter);
   {* Available (for geometric pen) join styles. }

//[TGdiFont]
   TGDIFont = packed record
     Height: Integer;
     Width: Integer;
     Escapement: Integer;
     Orientation: Integer;
     Weight: Integer;
     Italic: Boolean;
     Underline: Boolean;
     StrikeOut: Boolean;
     CharSet: TFontCharset;
     OutPrecision: Byte;
     ClipPrecision: Byte;
     Quality: TFontQuality;
     Pitch: TFontPitch;
     Name: array[0..LF_FACESIZE - 1] of Char;
   end;

//[TGDIBrush]
   TGDIBrush = packed record
     Bitmap: HBitmap;
     Style: TBrushStyle;
     LineColor: TColor;
   end;

//[TGDIPen]
   TGDIPen = packed record
     BrushBitmap: HBitmap;
     BrushStyle: TBrushStyle;
     Style: TPenStyle;
     Width: Integer;
     Mode: TPenMode;
     Geometric: Boolean;
     EndCap: TPenEndCap;
     Join: TPenJoin;
   end;

//[TGDIToolData]
   TGDIToolData = packed record
     Color: TColor;
     case Integer of
     1: (Font: TGDIFont);
     2: (Pen: TGDIPen);
     3: (Brush: TGDIBrush);
   end;

//[TNewGraphicTool]
   TNewGraphicTool = function: PGraphicTool;

{ ---------------------------------------------------------------------

     TGraphicTool - object to implement GDI-tools (brush, pen, font)

---------------------------------------------------------------------- }
//[TGraphicTool DEFINITION]
  TGraphicTool = class( TObj )
  {* Incapsulates all GDI objects: Pen, Brush and Font. }
  protected
    fType: TGraphicToolType;
    fHandle: THandle;
    fParentGDITool: PGraphicTool;
    fOnChange: TOnGraphicChange;
    fColorRGB: TColor;
    fData: TGDIToolData;

    fNewProc: TNewGraphicTool;
    fMakeHandleProc: function( Self_: PGraphicTool ): THandle;

    procedure SetInt( const Index: Integer; Value: Integer );
    {$IFDEF F_P}
    function GetInt( const Index: Integer ): Integer;
    {$ENDIF}
    procedure SetColor( Value: TColor );
    procedure SetBrushBitmap(const Value: HBitmap);
    procedure SetBrushStyle(const Value: TBrushStyle);
    procedure SetFontCharset(const Value: TFontCharset);
    procedure SetFontQuality(const Value: TFontQuality);
    function GetFontName: String;
    procedure SetFontName(const Value: String);
    procedure SetFontOrientation(Value: Integer);
    procedure SetFontPitch(const Value: TFontPitch);
    function GetFontStyle: TFontStyle;
    procedure SetFontStyle(const Value: TFontStyle);
    procedure SetPenMode(const Value: TPenMode);
    procedure SetPenStyle(const Value: TPenStyle);
    procedure SetGeometricPen(const Value: Boolean);
    procedure SetPenEndCap(const Value: TPenEndCap);
    procedure SetPenJoin(const Value: TPenJoin);
    procedure SetFontWeight(const Value: Integer);
    procedure SetLogFontStruct(const Value: TLogFont);
    function GetLogFontStruct: TLogFont;
  protected
    procedure Changed;
    {* }
    function GetHandle: THandle;
    {* }
  public
    destructor Destroy; override;
    {* }
    property Handle: THandle read GetHandle;
    {* Every time, when accessed, real GDI object is created (if it is
       not yet created). So, to prevent creating of the handle, use
       HandleAllocated instead of comparing Handle with value 0. }
    function HandleAllocated: Boolean;
    {* Returns True, if handle is allocated (i.e., if real GDI
       objet is created. }
    property OnChange: TOnGraphicChange read fOnChange write fOnChange;
    {* Called, when object is changed. }
    function ReleaseHandle: Integer;
    {* Returns Handle value (if allocated), releasing it from the
       object (so, it is no more knows about this handle and its
       HandleAllocated function returns False. }
    property Color: TColor {index go_Color} read fData.Color write SetColor;
    {* Color is the most common property for all Pen, Brush and
       Font objects, so it is placed in its common for all of them. }
    function Assign( Value: PGraphicTool ): PGraphicTool;
    {* Assigns properties of the same (only) type graphic object,
       excluding Handle. If assigning is really leading to change
       object, procedure Changed is called. }
    procedure AssignHandle( NewHandle: Integer );
    {* Assigns value to Handle property. }

    property BrushBitmap: HBitmap read fData.Brush.Bitmap write SetBrushBitmap;
    {* Brush bitmap. For more info about using brush bitmap,
       see Delphi or Win32 help files. }
    property BrushStyle: TBrushStyle read fData.Brush.Style write SetBrushStyle;
    {* Brush style. }
    property BrushLineColor: TColor index go_BrushLineColor
             {$IFDEF F_P}
             read GetInt
             {$ELSE DELPHI}
             read fData.Brush.LineColor
             {$ENDIF F_P/DELPHI}
             write SetInt;
    {* Brush line color, used to represent lines in hatched brush. Default value is clBlack. }

    property FontHeight: Integer index go_FontHeight
             {$IFDEF F_P}
             read GetInt
             {$ELSE DELPHI}
             read fData.Font.Height
             {$ENDIF F_P/DELPHI}
             write SetInt;
    {* Font height. Value 0 (default) seys to use system default value,
       negative values are to represent font height in "points", positive
       - in pixels. In XCL usually positive values (if not 0) are used to
       make appearance independent from different local settings. }
    property FontWidth: Integer index go_FontWidth
             {$IFDEF F_P}
             read GetInt
             {$ELSE DELPHI}
             read fData.Font.Width
             {$ENDIF F_P/DELPHI}
             write SetInt;
    {* Font width in logical units. If FontWidth = 0, then as it is said
       in Win32.hlp, "the aspect ratio of the device is matched against the
       digitization aspect ratio of the available fonts to find the closest match,
       determined by the absolute value of the difference." }
    property FontPitch: TFontPitch read fData.Font.Pitch write SetFontPitch;
    {* Font pitch. Change it very rare. }
    property FontStyle: TFontStyle read GetFontStyle write SetFontStyle;
    {* Very useful property to control text appearance. }
    property FontCharset: TFontCharset read fData.Font.Charset write SetFontCharset;
    {* Do not change it if You do not know what You do. }
    property FontQuality: TFontQuality read fData.Font.Quality write SetFontQuality;
    {* Font quality. }
    property FontOrientation: Integer read fData.Font.Orientation write SetFontOrientation;
    {* It is possible to rotate text in XCL just by changing this
       property of a font (tenths of degree, i.e. value 900 represents
       90 degree - text written from bottom to top). }
    property FontWeight: Integer read fData.Font.Weight write SetFontWeight;
    {* Additional font weight for bold fonts (must be 0..1000). When set to
       value <> 0, fsBold is added to FontStyle. And otherwise, when set to 0,
       fsBold is removed from FontStyle. Value 700 corresponds to Bold,
       400 to Normal. }
    property FontName: String read GetFontName write SetFontName;
    {* Font face name. }
    function IsFontTrueType: Boolean;
    {* Returns True, if font is True Type. Requires of creating of a Handle,
       if it is not yet created. }

    property PenWidth: Integer index go_PenWidth
             {$IFDEF F_P}
             read GetInt
             {$ELSE DELPHI}
             read fData.Pen.Width
             {$ENDIF F_P/DELPHI}
             write SetInt;
    {* Value 0 means default pen width. }
    property PenStyle: TPenStyle read fData.Pen.Style write SetPenStyle;
    {* Pen style. }
    property PenMode: TPenMode read fData.Pen.Mode write SetPenMode;
    {* Pen mode. }

    property GeometricPen: Boolean read fData.Pen.Geometric write SetGeometricPen;
    {* True if Pen is geometric. Note, that under Win95/98 only pen styles
       psSolid, psNull, psInsideFrame are supported by OS. }
    property PenBrushStyle: TBrushStyle read fData.Pen.BrushStyle write SetBrushStyle;
    {* Brush style for hatched geometric pen. }
    property PenBrushBitmap: HBitmap read fData.Pen.BrushBitmap write SetBrushBitmap;
    {* Brush bitmap for geometric pen (if assigned Pen is functioning as
       its style = BS_PATTERN, regadless of PenBrushStyle value). }
    property PenEndCap: TPenEndCap read fData.Pen.EndCap write SetPenEndCap;
    {* Pen end cap mode - for GeometricPen only. }
    property PenJoin: TPenJoin read fData.Pen.Join write SetPenJoin;
    {* Pen join mode - for GeometricPen only. }
    property LogFontStruct: TLogFont read GetLogFontStruct write SetLogFontStruct;
    {* by Alex Pravdin: a property to change all font structure items at once. }
  end;
//[END OF TGraphicTool DEFINITION]

//[Color2XXX FUNCTIONS]
function Color2RGB( Color: TColor ): TColor;
{* Function to get RGB color from system color. Parameter can be also RGB
   color, in that case result is just equal to a parameter. }
function ColorsMix( Color1, Color2: TColor ): TColor;
{* Returns color, which RGB components are build as an (approximate)
   arithmetic mean of correspondent RGB components of both source
   colors (these both are first converted from system to RGB, and
   result is always RGB color). Please note: this function is fast,
   but can be not too exact. }
function Color2RGBQuad( Color: TColor ): TRGBQuad;
{* Converts color to RGB, used to represent RGB values in palette entries
   (actually swaps R and B bytes). }
function Color2Color16( Color: TColor ): WORD;
{* Converts Color to RGB, packed to word (as it is used in format pf16bit). }

//[DefFont VARIABLE]
var    // New TFont instances are intialized with the values in this structure:
  DefFont: TGDIFont = (
     Height: 0;
     Width: 0;
     Escapement: 0;
     Orientation: 0;
     Weight: 0;
     Italic: FALSE;
     Underline: FALSE;
     StrikeOut: FALSE;
     CharSet: 1;
     OutPrecision: 0;
     ClipPrecision: 0;
     Quality: fqDefault;
     Pitch: fpDefault;
     Name: 'MS Sans Serif';
  );
  DefFontColor: TColor = clWindowText;
  {* Default font color. }

//[GlobalGraphics_UseFontOrient]
  GlobalGraphics_UseFontOrient: Boolean;
  {* Global flag. If stays False (default), Orientation property of Font
     objects is ignored. This flag is set to True automatically in
     RotateFonts add-on. }

{ -- Constructors for different GDI tools -- }

//[New FUNCTIONS FOR TGraphicTool]
function NewFont: PGraphicTool;
{* Creates and returns font graphic tool object. }
function NewBrush: PGraphicTool;
{* Creates and returns new brush object. }
function NewPen: PGraphicTool;
{* Creates and returns new pen object. }














{ -- TCanvas object -- }
//[TCanvas]
const
  HandleValid = 1;
  PenValid    = 2;
  BrushValid  = 4;
  FontValid   = 8;
  ChangingCanvas = 16;

type
   TFillStyle = (fsSurface, fsBorder);
   {* Available filling styles. For more info see Win32 or Delphi help files. }
   TFillMode = (fmAlternate, fmWinding);
   {* Available filling modes. For more info see Win32 or Delphi help files. }
   TCopyMode = Integer;
   {* Available copying modes are following:
      |  cmBlackness<br>
      |  cmDstInvert<br>
      |  cmMergeCopy<br>
      |  cmMergePaint<br>
      |  cmNotSrcCopy<br>
      |  cmNotSrcErase<br>
      |  cmPatCopy<br>
      |  cmPatInvert<br>
      |  cmPatPaint<br>
      |  cmSrcAnd<br>
      |  cmSrcCopy<br>
      |  cmSrcErase<br>
      |  cmSrcInvert<br>
      |  cmSrcPaint<br>
      |  cmWhiteness<br>&nbsp;&nbsp;&nbsp;
      Also it is possible to use any other available ROP2 modes. For more info,
      see Win32 help files. }

const
  cmBlackness = BLACKNESS;
  cmDstInvert = DSTINVERT;
  cmMergeCopy = MERGECOPY;
  cmMergePaint = MERGEPAINT;
  cmNotSrcCopy = NOTSRCCOPY;
  cmNotSrcErase = NOTSRCERASE;
  cmPatCopy = PATCOPY;
  cmPatInvert = PATINVERT;
  cmPatPaint = PATPAINT;
  cmSrcAnd = SRCAND;
  cmSrcCopy = SRCCOPY;
  cmSrcErase = SRCERASE;
  cmSrcInvert = SRCINVERT;
  cmSrcPaint = SRCPAINT;
  cmWhiteness = WHITENESS;

type
  TCanvas = class;
  PCanvas = TCanvas;
  {* }
  TOnGetHandle = function( Canvas: PCanvas ): HDC of object;
  {* For internal use mainly. }
  TOnTextArea = procedure( Sender: PCanvas; var Size : TSize; var P0 : TPoint );
  {* Event to calculate actual area, occupying by a text. It is used
     to optionally extend calculating of TextArea taking into considaration
     font Orientation property. }

{ ---------------------------------------------------------------------

                TCanvas - high-level drawing helper object

----------------------------------------------------------------------- }
//[TCanvas DEFINITION]
  TCanvas = class( TObj )
  {* Very similar to VCL's TCanvas object. But with some changes, specific
     for KOL: there is no necessary to use canvases in all applications.
     And graphic tools objects are not created with canvas, but only
     if really accessed in program. (Actually, even if paint box used,
     only programmer decides, if to implement painting using Canvas or
     to call low level API drawing functions working directly with DC).
     Therefore TCanvas has some powerful extensions: rotated text support,
     geometric pen support - just by changing correspondent properties
     of certain graphic tool objects (Font.FontOrientation, Pen.GeometricPen).
     See also additional Font properties (Font.FontWeight, Font.FontQuality,
     etc. }
  protected
    fOwnerControl: Pointer; //PControl;
    fHandle : HDC;
    fPenPos : TPoint;
    fBrush, fFont, fPen : PGraphicTool; // order is important for ASM version
    fState : Byte;
    fCopyMode : TCopyMode;
    fOnChange: TOnEvent;
    fOnGetHandle: TOnGetHandle;
    procedure SetHandle( Value : HDC );
    procedure SetPenPos( const Value : TPoint );
    procedure CreatePen;
    procedure CreateBrush;
    procedure CreateFont;
    procedure ObjectChanged( Sender : PGraphicTool );
    procedure Changing;
    function GetBrush: PGraphicTool;
    function GetFont: PGraphicTool;
    function GetPen: PGraphicTool;
    function GetHandle: HDC;
    procedure AssignChangeEvents;
    function GetPixels(X, Y: Integer): TColor;
    procedure SetPixels(X, Y: Integer; const Value: TColor);
  protected
    fIsPaintDC : Boolean;
    {* TRUE, if DC obtained during current WM_PAINT (or WM_ERASEBKGND?)
       processing for a control. This affects a way how Handle is released. }
  public
    destructor Destroy;override;
    {* }
  protected
    property OnGetHandle: TOnGetHandle read fOnGetHandle write fOnGetHandle;
    {* For internal use only. }
  public
    property Handle : HDC read GetHandle write SetHandle;
    {* GDI device context object handle. Never created by
       Canvas itself (to use Canvas with memory bitmaps,
       always create DC by yourself and assign it to the
       Handle property of Canvas object, or use property
       Canvas of a bitmap). }
    property PenPos : TPoint read FPenPos write SetPenPos;
    {* Position of a pen. }
    property Pen : PGraphicTool read GetPen;
    {* Pen of Canvas object. Do not change its Pen.OnChange event value. }
    property Brush : PGraphicTool read GetBrush;
    {* Brush of Canvas object. Do not change its Brush.OnChange event value. }
    property Font : PGraphicTool read GetFont;
    {* Font of Canvas object. Do not change its Font.OnChange event value. }
    procedure Arc(X1, Y1, X2, Y2, X3, Y3, X4, Y4: Integer); stdcall;
    {* Draws arc. For more info, see Delphi TCanvas help. }
    procedure Chord(X1, Y1, X2, Y2, X3, Y3, X4, Y4: Integer); stdcall;
    {* Draws chord. For more info, see Delphi TCanvas help. }
    procedure DrawFocusRect({$IFNDEF FPC}const{$ENDIF} Rect: TRect);
    {* Draws rectangle to represent focused visual object.
       For more info, see Delphi TCanvas help. }
    procedure Ellipse(X1, Y1, X2, Y2: Integer);
    {* Draws an ellipse. For more info, see Delphi TCanvas help. }
    procedure FillRect({$IFNDEF FPC}const{$ENDIF} Rect: TRect);
    {* Fills rectangle. For more info, see Delphi TCanvas help. }
    procedure FillRgn( const Rgn : HRgn );
    {* Fills region. For more info, see Delphi TCanvas help. }
    procedure FloodFill(X, Y: Integer; Color: TColor; FillStyle: TFillStyle);
    {* Fills a figure with givien color, floodfilling its surface.
       For more info, see Delphi TCanvas help. }
    procedure FrameRect({$IFNDEF FPC}const{$ENDIF} Rect: TRect);
    {* Draws a rectangle. For more info, see Delphi TCanvas help. }
    procedure MoveTo( X, Y : Integer );
    {* Moves current PenPos to a new position.
       For more info, see Delphi TCanvas help. }
    procedure LineTo( X, Y : Integer );
    {* Draws a line from current PenPos up to new position.
       For more info, see Delphi TCanvas help. }
    procedure Pie(X1, Y1, X2, Y2, X3, Y3, X4, Y4: Integer); stdcall;
    {* Draws a pie. For more info, see Delphi TCanvas help. }
    procedure Polygon(const Points: array of TPoint);
    {* Draws a polygon. For more info, see Delphi TCanvas help. }
    procedure Polyline(const Points: array of TPoint);
    {* Draws a bound for polygon. For more info, see Delphi TCanvas help. }
    procedure Rectangle(X1, Y1, X2, Y2: Integer);
    {* Draws a rectangle using current Pen and/or Brush.
       For more info, see Delphi TCanvas help. }
    procedure RoundRect(X1, Y1, X2, Y2, X3, Y3: Integer);
    {* Draws a rounded rectangle. For more info, see Delphi TCanvas help. }
    procedure TextOut(X, Y: Integer; const Text: String); stdcall;
    {* Draws a text. For more info, see Delphi TCanvas help. }
    procedure ExtTextOut( X, Y: Integer; Options: DWORD; const Rect: TRect; const Text: String;
              const Spacing: array of Integer );
    {* }
    procedure DrawText(Text:String; var Rect:TRect; Flags:DWord);
    {* }
    procedure TextRect(const Rect: TRect; X, Y: Integer; const Text: string);
    {* Draws a text, clipping output into given rectangle.
       For more info, see Delphi TCanvas help. }
    function TextExtent(const Text: string): TSize;
    {* Calculates size of a Text, using current Font settings.
       Does not need in Handle for Canvas object (if it is not
       yet allocated, temporary device context is created and used. }
    procedure TextArea( const Text : String; var Sz : TSize; var P0 : TPoint );
    {* Calculates size and starting point to output Text,
       taking into considaration all Font attributes, including
       Orientation (only if GlobalGraphics_UseFontOrient flag
       is set to True, i.e. if rotated fonts are used).
       Like for TextExtent, does not need in Handle (and if this
       last is not yet allocated/assigned, temporary device context
       is created and used). }
    function TextWidth(const Text: string): Integer;
    {* Calculates text width (using TextArea). }
    function TextHeight(const Text: string): Integer;
    {* Calculates text height (using TextArea). }
    function ClipRect: TRect;
    {* returns ClipBox. by Dmitry Zharov. }

    {$IFNDEF _FPC}
    {$IFNDEF _D2} //------- WideString not supported in D2
    procedure WTextOut(X, Y: Integer; const WText: WideString); stdcall;
    {* Draws a Unicode text. }
    procedure WExtTextOut( X, Y: Integer; Options: DWORD; const Rect: TRect;
              const WText: WideString; const Spacing: array of Integer );
    {* }
    procedure WDrawText(WText: WideString; var Rect:TRect; Flags:DWord);
    {* }
    procedure WTextRect(const Rect: TRect; X, Y: Integer;
              const WText: WideString);
    {* Draws a Unicode text, clipping output into given rectangle. }
    function WTextExtent( const WText: WideString ): TSize;
    {* Calculates Unicode text width and height. }
    function WTextWidth( const WText: WideString ): Integer;
    {* Calculates Unicode text width. }
    function WTextHeight( const WText: WideString ): Integer;
    {* Calculates Unicode text height. }
    {$ENDIF _D2}
    {$ENDIF _FPC}

    property ModeCopy : TCopyMode read fCopyMode write fCopyMode;
    {* Current copy mode. Is used in CopyRect method. }
    procedure CopyRect( const DstRect : TRect; SrcCanvas : PCanvas; const SrcRect : TRect );
    {* Copyes a rectangle from source to destination, using StretchBlt. }
    property OnChange: TOnEvent read fOnChange write fOnChange;
    {* }
    function Assign( SrcCanvas : PCanvas ) : Boolean;
    {* }
    function RequiredState( ReqState : DWORD ): Integer; stdcall;// public now
    {* It is possible to call this method before using Handle property
       to pass it into API calls - to provide valid combinations of
       pen, brush and font, selected into device context. This method
       can not provide valid Handle - You always must create it by
       yourself and assign to TCanvas.Handle property manually.
       To optimize assembler version, returns Handle value. }
    procedure DeselectHandles;
    {* Call this method to deselect all graphic tool objects from the canvas. }
    property Pixels[ X, Y: Integer ]: TColor read GetPixels write SetPixels;
    {* Obvious. }
  end;
//[END OF TCanvas DEFINITION]

//[GlobalCanvas_OnTextArea]
var
    GlobalCanvas_OnTextArea : TOnTextArea;
    {* Global event to extend Canvas with possible add-ons, applied
       when rotated fonts are used only (to take into consideration
       Font.Orientation property in TextArea method). }

//[NewCanvas DECLARATION]
function NewCanvas( DC: HDC ): PCanvas;
{* Use to construct Canvas on base of memory DC. }

//[Extended FUNCTIONS TO WORK WITH CANVAS]

{$IFDEF F_P}
function Windows_Polygon(DC: HDC; var Points; Count: Integer): BOOL; stdcall;
function Windows_Polyline(DC: HDC; var Points; Count: Integer): BOOL; stdcall;
function FillRect(hDC: HDC; const lprc: TRect; hbr: HBRUSH): Integer; stdcall;
function OffsetRect(var lprc: TRect; dx, dy: Integer): BOOL; stdcall;
function CreateAcceleratorTable(var Accel; Count: Integer): HACCEL; stdcall;
function TrackPopupMenu(hMenu: HMENU; uFlags: UINT; x, y, nReserved: Integer;
  hWnd: HWND; prcRect: PRect): BOOL; stdcall;
function AdjustTokenPrivileges(TokenHandle: THandle; DisableAllPrivileges: BOOL;
  const NewState: TTokenPrivileges; BufferLength: DWORD;
  var PreviousState: TTokenPrivileges; var ReturnLength: DWORD): BOOL; stdcall;
function InflateRect(var lprc: TRect; dx, dy: Integer): BOOL; stdcall;
{$IFDEF F_P105ORBELOW}
function InvalidateRect(hWnd: HWND; lpRect: PRect; bErase: BOOL): BOOL; stdcall;
function ValidateRect(hWnd: HWND; lpRect: PRect): BOOL; stdcall;
{$ENDIF F_P105ORBELOW}
{$ENDIF}















{ -- Image list object -- }
//[IMAGE LIST]

type
  TImageListColors = (ilcColor,ilcColor4,ilcColor8,ilcColor16,
                      ilcColor24,ilcColor32,ilcColorDDB,ilcDefault);
  {* ImageList color schemes available. }

  TDrawingStyles = ( dsBlend25, dsBlend50, dsMask, dsTransparent );
  {* ImageList drawing styles available. }
  TDrawingStyle = Set of TDrawingStyles;
  {* Style of drawing is a combination of all available drawing styles. }

  TImageType = (itBitmap,itIcon,itCursor);
  {* ImageList types available. }

  TImageList = class;
  PImageList = TImageList;
  {* }

  TImgLOVrlayIdx = 1..15;

{ ---------------------------------------------------------------------

                TImageList - images container

----------------------------------------------------------------------- }
//[TImageList DEFINITION]
  TImageList = class( TObj )
  {* ImageList incapsulation. }
  protected
    FHandle: THandle;
    FControl: Pointer; // PControl;
    fPrev, fNext: PImageList;
    FColors: TImageListColors;
    FMasked: Boolean;
    FImgWidth: Integer;
    FImgHeight: Integer;
    FDrawingStyle: TDrawingStyle;
    FBlendColor: TColor;
    fBkColor: TColor;
    FAllocBy: Integer;
    FShareImages: Boolean;
    FOverlay: array[ TImgLOVrlayIdx ] of Integer;
    function HandleNeeded : Boolean;
    procedure SetColors(const Value: TImageListColors);
    procedure SetMasked(const Value: Boolean);
    procedure SetImgWidth(const Value: Integer);
    procedure SetImgHeight(const Value: Integer);
    function GetCount: Integer;
    function GetBkColor: TColor;
    procedure SetBkColor(const Value: TColor);
    function GetBitmap: HBitmap;
    function GetMask: HBitmap;
    function GetDrawStyle : DWord;
    procedure SetAllocBy(const Value: Integer);
    function GetHandle: THandle;
    function GetOverlay(Idx: TImgLOVrlayIdx): Integer;
    procedure SetOverlay(Idx: TImgLOVrlayIdx; const Value: Integer);
  protected
    procedure SetHandle(const Value: THandle);
    {*}
  public
    destructor Destroy; override;
    {*}
    property Handle : THandle read GetHandle write SetHandle;
    {* Handle of ImageList object. }
    property ShareImages : Boolean read FShareImages write FShareImages;
    {* True if images are shared between processes (it is set to True,
       if its Handle is assigned to given value, which is a handle of
       already existing ImageList object). }
    property Colors : TImageListColors read FColors write SetColors;
    {* Colors used to represent images. }
    property Masked : Boolean read FMasked write SetMasked;
    {* True, if mask is used. It is set to True, if first added image
       is icon, e.g. }
    property ImgWidth : Integer read FImgWidth write SetImgWidth;
    {* Width of every image in list. If change, ImageList is cleared. }
    property ImgHeight : Integer read FImgHeight write SetImgHeight;
    {* Height of every image in list. If change, ImageList is cleared. }
    property Count : Integer read GetCount;
    {* Number of images in list. }
    property AllocBy : Integer read FAllocBy write SetAllocBy;
    {* Allocation factor. Default is 1. Set it to size of ImageList if this
       value is known - to optimize speed of allocation. }
    property BkColor : TColor read GetBkColor write SetBkColor;
    {* Background color. }
    property BlendColor : TColor read FBlendColor write FBlendColor;
    {* Blend color. }

    property Bitmap : HBitmap read GetBitmap;
    {* Bitmap, containing all ImageList images (tiled horizontally). }
    property Mask : HBitmap read GetMask;
    {* Monochrome bitmap, containing masks for all images in list (if not
       Masked, always returns nil). }
    function ImgRect( Idx : Integer ) : TRect;
    {* Rectangle occupied of given image in ImageList. }

    function Add( Bmp, Msk : HBitmap ) : Integer;
    {* Adds bitmap and given mask to ImageList. }
    function AddMasked( Bmp : HBitmap; Color : TColor ) : Integer;
    {* Adds bitmap to ImageList, using given color to create mask. }
    function AddIcon( Ico : HIcon ) : Integer;
    {* Adds icon to ImageList (always masked). }
    procedure Delete( Idx : Integer );
    {* Deletes given image from ImageList. }
    procedure Clear;
    {* Makes ImageList empty. }
    function Replace( Idx : Integer; Bmp, Msk : HBitmap ) : Boolean;
    {* Replaces given (by index) image with bitmap and its mask with mask bitmap. }
    function ReplaceIcon( Idx : Integer; Ico : HIcon ) : Boolean;
    {* Replaces given (by index) image with an icon. }
    function Merge( Idx : Integer; ImgList2 : PImageList; Idx2 : Integer; X, Y : Integer )
             : PImageList;
    {* Merges two ImageList objects, returns resulting ImageList. }
    function ExtractIcon( Idx : Integer ) : HIcon;
    {* Extracts icon by index. }
    function ExtractIconEx( Idx : Integer ) : HIcon;
    {* Extracts icon (is created using current drawing style). }

    property DrawingStyle : TDrawingStyle read FDrawingStyle write FDrawingStyle;
    {* Drawing style. }
    procedure Draw( Idx : Integer; DC : HDC; X, Y : Integer );
    {* Draws given (by index) image from ImageList onto passed Device Context. }
    procedure StretchDraw( Idx : Integer; DC : HDC; const Rect : TRect );
    {* Draws given image with stratching. }

    function LoadBitmap( ResourceName : PChar; TranspColor : TColor ) : Boolean;
    {* Loads ImageList from resource. }
    //function LoadIcon( ResourceName : PChar ) : Boolean;
    //function LoadCursor( ResourceName : PChar ) : Boolean;
    function LoadFromFile( FileName : PChar; TranspColor : TColor; ImgType : TImageType ) : Boolean;
    {* Loads ImageList from file. }
    function LoadSystemIcons( SmallIcons : Boolean ) : Boolean;
    {* Assigns ImageList to system icons list (big or small). }

    property Overlay[ Idx: TImgLOVrlayIdx ]: Integer read GetOverlay write SetOverlay;
    {* Overlay images for image list (images, used as overlay images to draw over
       other images from the image list). These overalay images can be used in
       listview and treeview as overlaying images (up to four masks at the same
       time). }
    {$IFDEF USE_CONSTRUCTORS}
    constructor CreateImageList( POwner: Pointer );
    {$ENDIF USE_CONSTRUCTORS}
  end;
//[END OF TImageList DEFINITION]

//[IMAGE LIST API]

const
  CLR_NONE                = $FFFFFFFF;
  CLR_DEFAULT             = $FF000000;

type
  HImageList = THandle;

const
  ILC_MASK                = $0001;
  ILC_COLOR               = $00FE;
  ILC_COLORDDB            = $00FE;
  ILC_COLOR4              = $0004;
  ILC_COLOR8              = $0008;
  ILC_COLOR16             = $0010;
  ILC_COLOR24             = $0018;
  ILC_COLOR32             = $0020;
  ILC_PALETTE             = $0800;

const
  ILD_NORMAL              = $0000;
  ILD_TRANSPARENT         = $0001;
  ILD_MASK                = $0010;
  ILD_IMAGE               = $0020;
  ILD_BLEND25             = $0002;
  ILD_BLEND50             = $0004;
  ILD_OVERLAYMASK         = $0F00;

const
  ILD_SELECTED            = ILD_BLEND50;
  ILD_FOCUS               = ILD_BLEND25;
  ILD_BLEND               = ILD_BLEND50;
  CLR_HILIGHT             = CLR_DEFAULT;

function ImageList_Create(CX, CY: Integer; Flags: UINT;
  Initial, Grow: Integer): HImageList; stdcall;
function ImageList_Destroy(ImageList: HImageList): Bool; stdcall;
function ImageList_GetImageCount(ImageList: HImageList): Integer; stdcall;
function ImageList_SetImageCount(ImageList: HImageList; Count: Integer): Integer; stdcall;
function ImageList_Add(ImageList: HImageList; Image, Mask: HBitmap): Integer; stdcall;
function ImageList_ReplaceIcon(ImageList: HImageList; Index: Integer;
  Icon: HIcon): Integer; stdcall;
function ImageList_SetBkColor(ImageList: HImageList; ClrBk: TColorRef): TColorRef; stdcall;
function ImageList_GetBkColor(ImageList: HImageList): TColorRef; stdcall;
function ImageList_SetOverlayImage(ImageList: HImageList; Image: Integer;
  Overlay: Integer): Bool; stdcall;

function ImageList_AddIcon(ImageList: HImageList; Icon: HIcon): Integer;

function Index2OverlayMask(Index: Integer): Integer;

function ImageList_Draw(ImageList: HImageList; Index: Integer;
  Dest: HDC; X, Y: Integer; Style: UINT): Bool; stdcall;

function ImageList_Replace(ImageList: HImageList; Index: Integer;
  Image, Mask: HBitmap): Bool; stdcall;
function ImageList_AddMasked(ImageList: HImageList; Image: HBitmap;
  Mask: TColorRef): Integer; stdcall;
function ImageList_DrawEx(ImageList: HImageList; Index: Integer;
  Dest: HDC; X, Y, DX, DY: Integer; Bk, Fg: TColorRef; Style: Cardinal): Bool; stdcall;
function ImageList_Remove(ImageList: HImageList; Index: Integer): Bool; stdcall;
function ImageList_GetIcon(ImageList: HImageList; Index: Integer;
  Flags: Cardinal): HIcon; stdcall;
function ImageList_LoadImageA(Instance: THandle; Bmp: PAnsiChar; CX, Grow: Integer;
  Mask: TColorRef; pType, Flags: Cardinal): HImageList; stdcall;
function ImageList_LoadImageW(Instance: THandle; Bmp: PWideChar; CX, Grow: Integer;
  Mask: TColorRef; pType, Flags: Cardinal): HImageList; stdcall;
function ImageList_LoadImage(Instance: THandle; Bmp: PChar; CX, Grow: Integer;
  Mask: TColorRef; pType, Flags: Cardinal): HImageList; stdcall;
function ImageList_BeginDrag(ImageList: HImageList; Track: Integer;
  XHotSpot, YHotSpot: Integer): Bool; stdcall;
function ImageList_EndDrag: Bool; stdcall;
function ImageList_DragEnter(LockWnd: HWnd; X, Y: Integer): Bool; stdcall;
function ImageList_DragLeave(LockWnd: HWnd): Bool; stdcall;
function ImageList_DragMove(X, Y: Integer): Bool; stdcall;
function ImageList_SetDragCursorImage(ImageList: HImageList; Drag: Integer;
  XHotSpot, YHotSpot: Integer): Bool; stdcall;
function ImageList_DragShowNolock(Show: Bool): Bool; stdcall;
function ImageList_GetDragImage(Point, HotSpot: PPoint): HImageList; stdcall;

{ macros }
procedure ImageList_RemoveAll(ImageList: HImageList); stdcall;
function ImageList_ExtractIcon(Instance: THandle; ImageList: HImageList;
  Image: Integer): HIcon; stdcall;
function ImageList_LoadBitmap(Instance: THandle; Bmp: PChar;
  CX, Grow: Integer; MasK: TColorRef): HImageList; stdcall;

//function ImageList_Read(Stream: IStream): HImageList; stdcall;
//function ImageList_Write(ImageList: HImageList; Stream: IStream): BOOL; stdcall;

//[TImageInfo]
type
  PImageInfo = ^TImageInfo;
  TImageInfo = packed record
    hbmImage: HBitmap;
    hbmMask: HBitmap;
    Unused1: Integer;
    Unused2: Integer;
    rcImage: TRect;
  end;

function ImageList_GetIconSize(ImageList: HImageList; var CX, CY: Integer): Bool; stdcall;
function ImageList_SetIconSize(ImageList: HImageList; CX, CY: Integer): Bool; stdcall;
function ImageList_GetImageInfo(ImageList: HImageList; Index: Integer;
  var ImageInfo: TImageInfo): Bool; stdcall;
function ImageList_Merge(ImageList1: HImageList; Index1: Integer;
  ImageList2: HImageList; Index2: Integer; DX, DY: Integer)://Bool - ERROR IN VCL
  HImageList; stdcall;

//[LoadBmp]
function LoadBmp( Instance: Integer; Rsrc: PChar; MasterObj: PObj ): HBitmap;














//[BITMAPS]
type
  tagBitmap = Windows.TBitmap;

  TPixelFormat = ( pfDevice, pf1bit, pf4bit, pf8bit, pf15bit, pf16bit, pf24bit,
                   pf32bit, pfCustom );
  {* Available pixel formats. }
  TBitmapHandleType = ( bmDIB, bmDDB );
  {* Available bitmap handle types. }

  TBitmap = class;
  PBitmap = TBitmap;
{ ----------------------------------------------------------------------

                      TBitmap - bitmap image

----------------------------------------------------------------------- }
//[TBitmap DEFINITION]
  TBitmap = class( TObj )
  {* Bitmap incapsulation object. }
  protected
    fHeight: Integer;
    fWidth: Integer;
    fHandle: HBitmap;
    fCanvas: PCanvas;
    fScanLineSize: Integer;
    fBkColor: TColor;
    fApplyBkColor2Canvas: procedure( Sender: PBitmap );
    fDetachCanvas: procedure( Sender: PBitmap );
    fCanvasAttached : Integer;
    fHandleType: TBitmapHandleType;
    fDIBHeader: PBitmapInfo;
    fDIBBits: Pointer;
    fDIBSize: Integer;
    fNewPixelFormat: TPixelFormat;
    fFillWithBkColor: procedure( BmpObj: PBitmap; DC: HDC; oldW, oldH: Integer );
                        //stdcall;
    fTransMaskBmp: PBitmap;
    fTransColor: TColor;
    fGetDIBPixels: function( Bmp: PBitmap; X, Y: Integer ): TColor;
    fSetDIBPixels: procedure( Bmp: PBitmap; X, Y: Integer; Value: TColor );
    fScanLine0: PByte;
    fScanLineDelta: Integer;
    fPixelMask: DWORD;
    fPixelsPerByteMask: Integer;
    fBytesPerPixel: Integer;
    fDIBAutoFree: Boolean;
    procedure SetHeight(const Value: Integer);
    procedure SetWidth(const Value: Integer);
    function GetEmpty: Boolean;
    function GetHandle: HBitmap;
    function GetHandleAllocated: Boolean;
    procedure SetHandle(const Value: HBitmap);
    procedure SetPixelFormat(Value: TPixelFormat);
    procedure FormatChanged;
    function GetCanvas: PCanvas;
    procedure CanvasChanged( Sender: PObj );
    function GetScanLine(Y: Integer): Pointer;
    function GetScanLineSize: Integer;
    procedure ClearData;
    procedure ClearTransImage;
    procedure SetBkColor(const Value: TColor);
    function GetDIBPalEntries(Idx: Integer): TColor;
    function GetDIBPalEntryCount: Integer;
    procedure SetDIBPalEntries(Idx: Integer; const Value: TColor);
    procedure SetHandleType(const Value: TBitmapHandleType);
    function GetPixelFormat: TPixelFormat;
    function GetPixels(X, Y: Integer): TColor;
    procedure SetPixels(X, Y: Integer; const Value: TColor);
    function GetDIBPixels(X, Y: Integer): TColor;
    procedure SetDIBPixels(X, Y: Integer; const Value: TColor);
    function GetBoundsRect: TRect;
  protected
  public
    destructor Destroy; override;
  public
    property Width: Integer read fWidth write SetWidth;
    {* Width of bitmap. To make code smaller, avoid changing Width or Height
       after bitmap is created (using NewBitmap) or after it is loaded from
       file, stream of resource. }
    property Height: Integer read fHeight write SetHeight;
    {* Height of bitmap. To make code smaller, avoid changing Width or Height
       after bitmap is created (using NewBitmap) or after it is loaded from
       file, stream of resource. }
    property BoundsRect: TRect read GetBoundsRect;
    {* Returns rectangle (0,0,Width,Height). }
    property Empty: Boolean read GetEmpty;
    {* Returns True if Width or Height is 0. }
    procedure Clear;
    {* Makes bitmap empty, setting its Width and Height to 0. }
    procedure LoadFromFile( const Filename: String );
    {* Loads bitmap from file (LoadFromStream used). }
    function LoadFromFileEx( const Filename: String ): Boolean;
    {* Loads bitmap from a file. If necessary, bitmap is RLE-decoded. Code given
       by Vyacheslav A. Gavrik. }
    procedure SaveToFile( const Filename: String );
    {* Stores bitmap to file (SaveToStream used). }
    procedure LoadFromStream( Strm: PStream );
    {* Loads bitmap from stream. Follow loading, bitmap has DIB format (without
       handle allocated). It is possible to draw DIB bitmap without creating
       handle for it, which can economy GDI resources. }
    function LoadFromStreamEx( Strm: PStream ): Boolean;
    {* Loads bitmap from a stream. Difference is that RLE decoding supported.
       Code given by Vyacheslav A. Gavrik. }
    procedure SaveToStream( Strm: PStream );
    {* Saves bitmap to stream. If bitmap is not DIB, it is converted to DIB
       before saving. }
    procedure LoadFromResourceID( Inst: DWORD; ResID: Integer );
    {* Loads bitmap from resource using integer ID of resource. To load by name,
       use LoadFromResurceName. To load resource of application itself, pass
       hInstance as first parameter. This method also can be used to load system
       predefined bitmaps, if 0 is passed as Inst parameter:
       |<pre>
       OBM_BTNCORNERS	OBM_REDUCE
       OBM_BTSIZE       OBM_REDUCED
       OBM_CHECK        OBM_RESTORE
       OBM_CHECKBOXES   OBM_RESTORED
       OBM_CLOSE        OBM_RGARROW
       OBM_COMBO        OBM_RGARROWD
       OBM_DNARROW      OBM_RGARROWI
       OBM_DNARROWD     OBM_SIZE
       OBM_DNARROWI     OBM_UPARROW
       OBM_LFARROW      OBM_UPARROWD
       OBM_LFARROWD     OBM_UPARROWI
       OBM_LFARROWI     OBM_ZOOM
       OBM_MNARROW      OBM_ZOOMD
       |</pre>        }
    procedure LoadFromResourceName( Inst: DWORD; ResName: PChar );
    {* Loads bitmap from resurce (using passed name of bitmap resource. }
    function Assign( SrcBmp: PBitmap ): Boolean;
    {* Assigns bitmap from another. Returns False if not success.
       Note: remember, that Canvas is not assigned - only bitmap image
       is copied. And for DIB, handle is not allocating due this process. }
    property Handle: HBitmap read GetHandle write SetHandle;
    {* Handle of bitmap. Created whenever property accessed. To check if handle
       is allocated (without allocating it), use HandleAllocated property. }
    property HandleAllocated: Boolean read GetHandleAllocated;
    {* Returns True, if Handle already allocated. }
    function ReleaseHandle: HBitmap;
    {* Returns Handle and releases it, so bitmap no more know about handle.
       This method does not destroy bitmap image, but converts it into DIB.
       Returned Handle actually is a handle of copy of original bitmap. If
       You need not in keping it up, use Dormant method instead. }
    procedure Dormant;
    {* Releases handle from bitmap and destroys it. But image is not destroyed
       and its data are preserved in DIB format. Please note, that in KOL, DIB
       bitmaps can be drawn onto given device context without allocating of
       handle. So, it is very useful to call Dormant preparing it using
       Canvas drawing operations - to economy GDI resources. }
    property HandleType: TBitmapHandleType read fHandleType write SetHandleType;
    {* bmDIB, if DIB part of image data is filled and stored internally in
       TBitmap object. DIB image therefore can have Handle allocated, which
       require resources. Use HandleAllocated funtion to determine if handle
       is allocated and Dormant method to remove it, if You want to economy
       GDI resources. (Actually Handle needed for DIB bitmap only in case
       when Canvas is used to draw on bitmap surface). Please note also, that
       before saving bitmap to file or stream, it is converted to DIB. }
    property PixelFormat: TPixelFormat read GetPixelFormat write SetPixelFormat;
    {* Current pixel format. If format of bitmap is unknown, or bitmap is DDB,
       value is pfDevice. Setting PixelFormat to any other format converts
       bitmap to DIB, back to pfDevice converts bitmap to DDB again. Avoid
       such conversations for large bitmaps or for numerous bitmaps in your
       application to keep good performance. }
    function BitsPerPixel: Integer;
    {* Returns bits per pixel if possible. }
    procedure Draw( DC: HDC; X, Y: Integer );
    {* Draws bitmap to given device context. If bitmap is DIB, it is always
       drawing using SetDIBitsToDevice API call, which does not require bitmap
       handle (so, it is very sensible to call Dormant method to free correspondent
       GDI resources). }
    procedure StretchDraw( DC: HDC; const Rect: TRect );
    {* Draws bitmap onto DC, stretching it to fit given rectangle Rect. }
    procedure DrawTransparent( DC: HDC; X, Y: Integer; TranspColor: TColor );
    {* Draws bitmap onto DC transparently, using TranspColor as transparent. }
    procedure StretchDrawTransparent( DC: HDC; const Rect: TRect; TranspColor: TColor );
    {* Draws bitmap onto given rectangle of destination DC (with stretching it
       to fit Rect) - transparently, using TranspColor as transparent. }
    procedure DrawMasked( DC: HDC; X, Y: Integer; Mask: HBitmap );
    {* Draws bitmap to destination DC transparently by mask. It is possible
       to pass as a mask handle of another TBitmap, previously converted to
       monochrome mask using Convert2Mask method. }
    procedure StretchDrawMasked( DC: HDC; const Rect: TRect; Mask: HBitmap );
    {* Like DrawMasked, but with stretching image onto given rectangle. }
    procedure Convert2Mask( TranspColor: TColor );
    {* Converts bitmap to monochrome (mask) bitmap with TranspColor replaced
       to clBlack and all other ones to clWhite. Such mask bitmap can be used
       to draw original bitmap transparently, with given TranspColor as
       transparent. (To preserve original bitmap, create new instance of
       TBitmap and assign original bitmap to it). See also DrawTransparent and
       StretchDrawTransparent methods. }
    procedure Invert;
    {* Obvious. }
    property Canvas: PCanvas read GetCanvas;
    {* Canvas can be used to draw onto bitmap. Whenever it is accessed, handle
       is allocated for bitmap, if it is not yet (to make it possible
       to select bitmap to display compatible device context). }
    procedure RemoveCanvas;
    {* Call this method to destroy Canvas and free GDI resources. }
    property BkColor: TColor read fBkColor write SetBkColor;
    {* Used to fill background for Bitmap, when its width or height is increased.
       Although this value always synchronized with Canvas.Brush.Color, use it
       instead if You do not use Canvas for drawing on bitmap surface. }
    property Pixels[ X, Y: Integer ]: TColor read GetPixels write SetPixels;
    {* Allows to obtain or change certain pixels of a bitmap. This method is
       both for DIB and DDB bitmaps, and leads to allocate handle anyway. For
       DIB bitmaps, it is possible to use property DIBPixels[ ] instead,
       which is much faster and does not require in Handle. }
    property ScanLineSize: Integer read GetScanLineSize;
    {* Returns size of scan line in bytes. Use it to measure size of a single
       ScanLine. To calculate increment value from first byte of ScanLine to
       first byte of next ScanLine, use difference
       !  Integer(ScanLine[1]-ScanLine[0])
       (this is because bitmap can be oriented from bottom to top, so
       step can be negative). }
    property ScanLine[ Y: Integer ]: Pointer read GetScanLine;
    {* Use ScanLine to access DIB bitmap pixels in memory to direct access it
       fast. Take in attention, that for different pixel formats, different
       bit counts are used to represent bitmap pixels. Also do not forget, that
       for formats pf4bit and pf8bit, pixels actually are indices to palette
       entries, and for formats pf16bit, pf24bit and pf32bit are actually
       RGB values (for pf16bit B:5-G:6-R:5, for pf15bit B:5-G:5-R:5 (high order
       bit not used), for pf24bit B:8-G:8-R:8, and for pf32bit high order byte
       of TRGBQuad structure is not used). }
    property DIBPixels[ X, Y: Integer ]: TColor read GetDIBPixels write SetDIBPixels;
    {* Allows direct access to pixels of DIB bitmap, faster then Pixels[ ]
       property. Access to read is slower for pf15bit, pf16bit formats (because
       some conversation needed to translate packed RGB color to TColor). And
       for write, operation performed most slower for pf4bit, pf8bit (searching
       nearest color required) and fastest for pf24bit, pf32bit and pf1bit. }
    property DIBPalEntryCount: Integer read GetDIBPalEntryCount;
    {* Returns palette entries count for DIB image. Always returns 2 for pf1bit,
       16 for pf4bit, 256 for pf8bit and 0 for other pixel formats. }
    property DIBPalEntries[ Idx: Integer ]: TColor read GetDIBPalEntries write
             SetDIBPalEntries;
    {* Provides direct access to DIB palette. }
    function DIBPalNearestEntry( Color: TColor ): Integer;
    {* Returns index of entry in DIB palette with color nearest (or matching)
       to given one. }
    property DIBBits: Pointer read fDIBBits;
    {* This property is mainly for internal use. }
    property DIBSize: Integer read fDIBSize;
    {* Size of DIBBits array. }
    property DIBHeader: PBitmapInfo read fDIBHeader;
    {* This property is mainly for internal use. }
    procedure DIBDrawRect( DC: HDC; X, Y: Integer; const R: TRect );
    {* This procedure copies given rectangle to the target device context,
       but only for DIB bitmap (using SetDIBBitsToDevice API call). }
    procedure RotateRight;
    {* Rotates bitmap right (90 degree). Bitmap must be DIB. If You definitevely
       know format of a bitmap, use instead one of methods RotateRightMono,
       RotateRight4bit, RotateRight8bit, RotateRight16bit or RotateRightTrueColor
       - this will economy code. But if for most of formats such methods are
       called, this can be more economy just to call always universal method
       RotateRight. }
    procedure RotateLeft;
    {* Rotates bitmap left (90 degree). Bitmap must be DIB. If You definitevely
       know format of a bitmap, use instead one of methods RotateLeftMono,
       RotateLeft4bit, RotateLeft8bit, RotateLeft16bit or RotateLeftTrueColor
       - this will economy code. But if for most of formats such methods are
       called, this can be more economy just to call always universal method
       RotateLeft. }
    procedure RotateRightMono;
    {* Rotates bitmat right, but only if bitmap is monochrome (pf1bit). }
    procedure RotateLeftMono;
    {* Rotates bitmap left, but only if bitmap is monochrome (pf1bit). }
    procedure RotateRight4bit;
    {* Rotates bitmap right, but only if PixelFormat is pf4bit. }
    procedure RotateLeft4bit;
    {* Rotates bitmap left, but only if PixelFormat is pf4bit. }
    procedure RotateRight8bit;
    {* Rotates bitmap right, but only if PixelFormat is pf8bit. }
    procedure RotateLeft8bit;
    {* Rotates bitmap left, but only if PixelFormat is pf8bit. }
    procedure RotateRight16bit;
    {* Rotates bitmap right, but only if PixelFormat is pf16bit. }
    procedure RotateLeft16bit;
    {* Rotates bitmap left, but only if PixelFormat is pf16bit. }
    procedure RotateRightTrueColor;
    {* Rotates bitmap right, but only if PixelFormat is pf24bit or pf32bit. }
    procedure RotateLeftTrueColor;
    {* Rotates bitmap left, but only if PixelFormat is pf24bit or pf32bit. }
    procedure FlipVertical;
    {* Flips bitmap vertically }
    procedure FlipHorizontal;
    {* Flips bitmap horizontally }
    procedure CopyRect( const DstRect : TRect; SrcBmp : PBitmap; const SrcRect : TRect );
    {* It is possible to use Canvas.CopyRect for such purpose, but if You
       do not want use TCanvas, it is possible to copy rectangle from one
       bitmap to another using this function. }
    function CopyToClipboard: Boolean;
    {* Copies bitmap to clipboard. }
    function PasteFromClipboard: Boolean;
    {* Takes CF_DIB format bitmap from clipboard and assigns it to the
       TBitmap object. }
  end;
//[END OF TBitmap DEFINITION]

//[NewBitmap DECLARATION]
function NewBitmap( W, H: Integer ): PBitmap;
{* Creates bitmap object of given size. If it is possible, do not change its
   size (Width and Heigth) later - this can economy code a bit. See TBitmap. }

function NewDIBBitmap( W, H: Integer; PixelFormat: TPixelFormat ): PBitmap;
{* Creates DIB bitmap object of given size and pixel format. If it is possible,
   do not change its size (Width and Heigth) later - this can economy code a bit.
   See TBitmap. }

//[CalcScanLineSize DECLARATION]
function CalcScanLineSize( Header: PBitmapInfoHeader ): Integer;
{* May be will be useful. }

//[DefaultPixelFormat VARIABLE]
var
  //DefaultBitsPerPixel: Integer = 16;
  DefaultPixelFormat: TPixelFormat = pf16bit;

//[Mapped bitmaps]

{ -- Function to load bitmap mapping some its colors. -- }
function LoadMappedBitmap( hInst: THandle; BmpResID: Integer; const Map: array of TColor )
         : HBitmap;
{* This function can be used to load bitmap and replace some it colors to
   desired ones. This function especially useful when loaded by the such way
   bitmap is used as toolbar bitmap - to replace some original colors to
   system default colors. To use this function properly, the bitmap shoud
   be prepared as 16-color bitmap, which uses only system colors. To do so,
   create a new 16-color bitmap with needed dimensions in Borland Image Editor
   and paste a bitmap image, copyed in another graphic tool, and then save it.
   If this is not done, bitmap will not be loaded correctly! }
function LoadMappedBitmapEx( MasterObj: PObj; hInst: THandle; BmpResName: PChar; const Map: array of TColor )
         : HBitmap;
{* Like LoadMappedBitmap, but much powerful. It uses CreateMappedBitmapEx
   by Alex Pravdin, so it understands any bitmap color format, including
   pf24bit. Also, LoadMappedBitmapEx provides auto-destroying loaded resource
   when MasterObj is destroyed. }
function CreateMappedBitmap(Instance: THandle; Bitmap: Integer;
  Flags: UINT; ColorMap: PColorMap; NumMaps: Integer): HBitmap; stdcall;
{* Creates mapped bitmap replacing colors correspondently to the
   ColorMap (each pare of colors defines color replaced and a color
   used for replace it in the bitmap). See also CreateMappedBitmapEx. }
function CreateMappedBitmapEx(Instance: THandle; BmpRsrcName: PChar; Flags:
  Cardinal; ColorMap: PColorMap; NumMaps: Integer): HBitmap;
{* By Alex Pravdin.
Creates mapped bitmap independently from bitmap color format (works
correctly with bitmaps having format deeper than 8bit per pixel). }












//[ICONS]

type
  TIcon = class;
  PIcon = TIcon;
{ ----------------------------------------------------------------------

                          TIcon - icon image

----------------------------------------------------------------------- }
//[TIcon DEFINITION]
  TIcon = class( TObj )
  {* Object type to incapsulate icon or cursor image. }
  protected
    FSize : Integer;
    FHandle: HIcon;
    FShareIcon: Boolean;
    procedure SetSize(const Value: Integer);
    procedure SetHandle(const Value: HIcon);
    function GetHotSpot: TPoint;
    function GetEmpty: Boolean;
  protected
  public
    destructor Destroy; override;
  public
    property Size : Integer read FSize write SetSize;
    {* Icon dimension (width and/or height, which are equal to each other always). }
    property Handle : HIcon read FHandle write SetHandle;
    {* Windows icon object handle. }
    procedure Clear;
    {* Clears icon, freeing image and allocated GDI resource (Handle). }
    property Empty: Boolean read GetEmpty;
    {* Returns True if icon is Empty. }
    property ShareIcon : Boolean read FShareIcon write FShareIcon;
    {* True, if icon object is shared and can not be deleted when TIcon object
       is destroyed (set this flag is to True, if an icon is obtained from another
       TIcon object, for example). }
    property HotSpot : TPoint read GetHotSpot;
    {* Hot spot point - for cursors. }
    procedure Draw( DC : HDC; X, Y : Integer );
    {* Draws icon onto given device context. Icon always is drawn transparently
       using its transparency mask (stored internally in icon object). }
    procedure StretchDraw( DC : HDC; Dest : TRect );
    {* Draws icon onto given device context with stretching it to fit destination
       rectangle. See also Draw. }
    procedure LoadFromStream( Strm : PStream );
    {* Loads icon from stream. If stream contains several icons (of
       different dimentions), icon with the most appropriate size is loading. }
    procedure LoadFromFile( const FileName : String );
    {* Load icon from file. If file contains several icons (of
       different dimensions), icon with the most appropriate size is loading. }
    procedure LoadFromResourceID( Inst: Integer; ResID: Integer; DesiredSize: Integer );
    {* Loads icon from resource. To load system default icon, pass 0 as Inst and
       one of followin values as ResID:
       |<pre>
       IDI_APPLICATION  Default application icon.
       IDI_ASTERISK     Asterisk (used in informative messages).
       IDI_EXCLAMATION  Exclamation point (used in warning messages).
       IDI_HAND         Hand-shaped icon (used in serious warning messages).
       IDI_QUESTION     Question mark (used in prompting messages).
       IDI_WINLOGO      Windows logo.
       |</pre> It is also possible to load icon from resources of another module,
       if pass instance handle of loaded module as Inst parameter. }
    procedure LoadFromResourceName( Inst: Integer; ResName: PChar; DesiredSize: Integer );
    {* Loads icon from resource. To load own application resource, pass
       hInstance as Inst parameter. It is possible to load resource from
       another module, if pass its instance handle as Inst. }
    procedure LoadFromExecutable( const FileName: String; IconIdx: Integer );
    {* Loads icon from executable (exe or dll file). Always default sized icon
       is loaded. It is possible also to get know how much icons are contained
       in executable using gloabl function GetFileIconCount. To obtain icon of
       another size, try to load given executable and use LoadFromResourceID
       method. }
    procedure SaveToStream( Strm : PStream );
    {* Saves single icon to stream. To save icons with several different
       dimensions, use global procedure SaveIcons2Stream. }
    procedure SaveToFile( const FileName : String );
    {* Saves single icon to file. To save icons with several different
       dimensions, use global procedure SaveIcons2File. }
    function Convert2Bitmap( TranColor: TColor ): HBitmap;
    {* Converts icon to bitmap, returning Windows GDI bitmap resource as
       a result. It is possible later to assign returned bitmap handle to
       Handle property of TBitmap object to use features of TBitmap.
       Pass TranColor to replace transparent area of icon with given color. }
  end;
//[END OF TIcon DEFINITION]

//[Icon save functions]

  procedure SaveIcons2Stream( const Icons : array of PIcon; Strm : PStream );
  {* Saves several icons (of different dimentions) to stream. }
  function SaveIcons2StreamEx( const BmpHandles: array of HBitmap; Strm: PStream ): Boolean;
  {* Saves icons creating it from pairs of bitmaps and their masks.
     BmpHandles array must contain pairs of bitmap handles, each pair
     of color bitmap and mask bitmap of the same size. }
  procedure SaveIcons2File( const Icons : array of PIcon; const FileName : String );
  {* Saves several icons (of different dimentions) to file. (Single file
     with extension .ico can contain several different sized icon images
     to use later one with the most appropriate size). }

//[NewIcon DECLARATION]
  function NewIcon: PIcon;
  {* Creates new icon object, setting its Size to 32 by default. Created icon
     is Empty. }

//[GetFileIconCount DECLARATION]
  function GetFileIconCount( const FileName: String ): Integer;
  {* Returns number of icon resources stored in given (executable) file. }

//[ICON STRUCTURES]
type
  TIconHeader = packed record
    idReserved: Word; (* Always set to 0 *)
    idType: Word;     (* Always set to 1 *)
    idCount: Word;    (* Number of icon images *)
    (* immediately followed by idCount TIconDirEntries *)
  end;

  TIconDirEntry = packed record
    bWidth: Byte;          (* Width *)
    bHeight: Byte;         (* Height *)
    bColorCount: Byte;     (* Nr. of colors used, see below *)
    bReserved: Byte;       (* not used, 0 *)
    wPlanes: Word;         (* not used, 0 *)
    wBitCount: Word;       (* not used, 0 *)
    dwBytesInRes: Longint; (* total number of bytes in images *)
    dwImageOffset: Longint;(* location of image from the beginning of file *)
  end;

//[LoadImgIcon DECLARATION]
function LoadImgIcon( RsrcName: PChar; Size: Integer ): HIcon;
{* Loads icon of specified size from the resource. }








//[METAFILES]

type
  TMetafile = class;
  PMetafile = TMetafile;
{ ----------------------------------------------------------------------

      TMetafile - Windows metafile and Enchanced Metafile image

----------------------------------------------------------------------- }
//[TMetafile DEFINITION]
  TMetafile = class( TObj )
  {* Object type to incapsulate metafile image. }
  protected
    function GetHeight: Integer;
    function GetWidth: Integer;
    procedure SetHandle(const Value: THandle);
  protected
    fHandle: THandle;
    fHeader: PEnhMetaHeader;
    procedure RetrieveHeader;
  public
    destructor Destroy; override;
    {* }
    procedure Clear;
    {* }
    function Empty: Boolean;
    {* Returns TRUE if empty}
    property Handle: THandle read fHandle write SetHandle;
    {* Returns handle of enchanced metafile. }
    function LoadFromStream( Strm: PStream ): Boolean;
    {* Loads emf or wmf file format from stream. }
    function LoadFromFile( const Filename: String ): Boolean;
    {* Loads emf or wmf from stream. }
    procedure Draw( DC: HDC; X, Y: Integer );
    {* Draws enchanced metafile on DC. }
    procedure StretchDraw( DC: HDC; const R: TRect );
    {* Draws enchanced metafile stretched. }
    property Width: Integer read GetWidth;
    {* Native width of the metafile. }
    property Height: Integer read GetHeight;
    {* Native height of the metafile. }
  end;
//[END OF TMetafile DEFINITION]

//[NewMetafile DECLARATION]
function NewMetafile: PMetafile;
{* Creates metafile object. }

//[Metafile CONSTANTS, STRUCTURES, ETC.]
const
  WMFKey = Integer($9AC6CDD7);
  WMFWord = $CDD7;
type
  TMetafileHeader = packed record
    Key: Longint;
    Handle: SmallInt;
    Box: TSmallRect;
    Inch: Word;
    Reserved: Longint;
    CheckSum: Word;
  end;

function ComputeAldusChecksum(var WMF: TMetafileHeader): Word;


function SetEnhMetaFileBits(p1: UINT; p2: PChar): HENHMETAFILE; stdcall;
function PlayEnhMetaFile(DC: HDC; p2: HENHMETAFILE; const p3: TRect): BOOL; stdcall;




















////////////////////////////////////////////////////////////////////////////////
//                       UNIVERSAL CONTROL OBJECT                             //
////////////////////////////////////////////////////////////////////////////////

//[CM_XXX CONSTANTS]

const
  CM_EXECPROC       = $8FFF;
  CM_BASE           = $B000;
  CM_ACTIVATE       = CM_BASE + 0;
  CM_DEACTIVATE     = CM_BASE + 1;
  CM_ENTER          = CM_BASE + 2;
  CM_RELEASE        = CM_BASE + 3;
  CM_QUIT           = CM_BASE + 4;
  CM_COMMAND        = CM_BASE + 5;
  CM_MEASUREITEM    = CM_BASE + 6;
  CM_DRAWITEM       = CM_BASE + 7;
  CM_TRAYICON       = CM_BASE + 8;
  CM_INVALIDATE     = CM_BASE + 9;
  CM_UPDATE         = CM_BASE + 10;
  CM_NCUPDATE       = CM_BASE + 11;
  CM_SIZEPOS        = CM_BASE + 12;
  CM_SIZE           = CM_BASE + 13;
  CM_SETFOCUS       = CM_BASE + 14;
  CM_CBN_SELCHANGE  = 15;

  CM_UIACTIVATE     = CM_BASE + 16;
  CM_UIDEACTIVATE   = CM_BASE + 17;
  CM_PROCESS        = CM_BASE + 18;
  CM_SHOW           = CM_BASE + 19;

  //CM_CLOSE           = CM_BASE + 20;
  CM_MDIClientShowEdge = CM_BASE + 21;

//[CN_XXX CONSTANTS]

  CN_BASE = $BC00;
  CN_CHARTOITEM        = CN_BASE + WM_CHARTOITEM;
  CN_COMMAND           = CN_BASE + WM_COMMAND;
  CN_COMPAREITEM       = CN_BASE + WM_COMPAREITEM;

  CN_CTLCOLORMSGBOX    = CN_BASE + WM_CTLCOLORMSGBOX;
  CN_CTLCOLOREDIT      = CN_BASE + WM_CTLCOLOREDIT;
  CN_CTLCOLORLISTBOX   = CN_BASE + WM_CTLCOLORLISTBOX;
  CN_CTLCOLORBTN       = CN_BASE + WM_CTLCOLORBTN;
  CN_CTLCOLORDLG       = CN_BASE + WM_CTLCOLORDLG;
  CN_CTLCOLORSCROLLBAR = CN_BASE + WM_CTLCOLORSCROLLBAR;
  CN_CTLCOLORSTATIC    = CN_BASE + WM_CTLCOLORSTATIC;

  CN_DELETEITEM        = CN_BASE + WM_DELETEITEM;
  CN_DRAWITEM          = CN_BASE + WM_DRAWITEM;
  CN_HSCROLL           = CN_BASE + WM_HSCROLL;
  CN_MEASUREITEM       = CN_BASE + WM_MEASUREITEM;
  CN_PARENTNOTIFY      = CN_BASE + WM_PARENTNOTIFY;
  CN_VKEYTOITEM        = CN_BASE + WM_VKEYTOITEM;
  CN_VSCROLL           = CN_BASE + WM_VSCROLL;
  CN_KEYDOWN           = CN_BASE + WM_KEYDOWN;
  CN_KEYUP             = CN_BASE + WM_KEYUP;
  CN_CHAR              = CN_BASE + WM_CHAR;
  CN_SYSKEYDOWN        = CN_BASE + WM_SYSKEYDOWN;
  CN_SYSCHAR           = CN_BASE + WM_SYSCHAR;
  CN_NOTIFY            = CN_BASE + WM_NOTIFY;


//[ID_SELF DEFINED]
  ID_SELF: array[ 0..5 ] of Char = ( 'S','E','L','F','_',#0 );
  {* Identifier for window property "Self", stored directly in window, when
     it is created. This property is used to [fast] find TControl object,
     correspondent to given window handle (using API call GetProp). }

//[ID_PREVPROC DEFINED]
  ID_PREVPROC: array[ 0..9 ] of Char = ( 'P','R','E','V','_','P','R','O','C',#0 );
  {* }

//[MK_ALT DEFINED]
  MK_ALT = $20;

//[RICHEDIT STRUCTURES]
type
  TCharFormat2A = packed record
    cbSize: UINT;
    dwMask: DWORD;
    dwEffects: DWORD;
    yHeight: Longint;
    yOffset: Longint;
    crTextColor: TColorRef;
    bCharSet: Byte;
    bPitchAndFamily: Byte;
    szFaceName: array[0..LF_FACESIZE - 1] of AnsiChar;
    R2Bytes: Word;
    wWeight: Word;                   { Font weight (LOGFONT value)		 }
    sSpacing: Smallint;              { Amount to space between letters	 }
    crBackColor: TColorRef;          { Background color					 }
    lid: LCID;                       { Locale ID						 }
    dwReserved: DWORD;               { Reserved. Must be 0				 }
    sStyle: Smallint;                { Style handle						 }
    wKerning: Word;                  { Twip size above which to kern char pair }
    bUnderlineType: Byte;            { Underline type					 }
    bAnimation: Byte;                { Animated text like marching ants	 }
    bRevAuthor: Byte;                { Revision author index			 }
    bReserved1: Byte;
  end;
  TCharFormat2 = TCharFormat2A;

  TParaFormat2 = packed record
    cbSize: UINT;
    dwMask: DWORD;
    wNumbering: Word;
    wReserved: Word;
    dxStartIndent: Longint;
    dxRightIndent: Longint;
    dxOffset: Longint;
    wAlignment: Word;
    cTabCount: Smallint;
    rgxTabs: array [0..MAX_TAB_STOPS - 1] of Longint;
    dySpaceBefore: Longint;     { Vertical spacing before para			 }
    dySpaceAfter: Longint;      { Vertical spacing after para			 }
    dyLineSpacing: Longint;     { Line spacing depending on Rule		 }
    sStyle: Smallint;           { Style handle							 }
    bLineSpacingRule: Byte;     { Rule for line spacing (see tom.doc)	 }
    bCRC: Byte;                 { Reserved for CRC for rapid searching	 }
    wShadingWeight: Word;       { Shading in hundredths of a per cent	 }
    wShadingStyle: Word;        { Nibble 0: style, 1: cfpat, 2: cbpat	 }
    wNumberingStart: Word;      { Starting value for numbering			 }
    wNumberingStyle: Word;      { Alignment, roman/arabic, (), ), ., etc. }
    wNumberingTab: Word;        { Space bet 1st indent and 1st-line text }
    wBorderSpace: Word;         { Space between border and text (twips) }
    wBorderWidth: Word;         { Border pen width (twips)				 }
    wBorders: Word;             { Byte 0: bits specify which borders	 }
                                { Nibble 2: border style, 3: color index }
  end;

  TGetTextLengthEx = packed record
    flags: DWORD;              { flags (see GTL_XXX defines)				 }
    codepage: UINT;            { code page for translation (CP_ACP for default,
                                 1200 for Unicode 					 }
  end;

const
  PFM_SPACEBEFORE                     = $00000040;
  PFM_SPACEAFTER                      = $00000080;
  PFM_LINESPACING                     = $00000100;
  PFM_STYLE                           = $00000400;
  PFM_BORDER                          = $00000800;      { (*)	 }
  PFM_SHADING                         = $00001000;      { (*)	 }
  PFM_NUMBERINGSTYLE                  = $00002000;      { (*)	 }
  PFM_NUMBERINGTAB                    = $00004000;      { (*)	 }
  PFM_NUMBERINGSTART                  = $00008000;      { (*)	 }

  PFM_RTLPARA                         = $00010000;
  PFM_KEEP                            = $00020000;      { (*)	 }
  PFM_KEEPNEXT                        = $00040000;      { (*)	 }
  PFM_PAGEBREAKBEFORE                 = $00080000;      { (*)	 }
  PFM_NOLINENUMBER                    = $00100000;      { (*)	 }
  PFM_NOWIDOWCONTROL                  = $00200000;      { (*)	 }
  PFM_DONOTHYPHEN                     = $00400000;      { (*)	 }
  PFM_SIDEBYSIDE                      = $00800000;      { (*)	 }

  PFM_TABLE                           = $c0000000;      { (*)	 }
  EM_REDO                             = WM_USER + 84;
  EM_AUTOURLDETECT                    = WM_USER + 91;
  EM_GETAUTOURLDETECT                 = WM_USER + 92;
  CFM_UNDERLINETYPE           = $00800000;              { (*)	 }
  CFM_HIDDEN                  = $0100;                  { (*)	 }
  CFM_BACKCOLOR               = $04000000;
  CFE_AUTOBACKCOLOR           = CFM_BACKCOLOR;
  GTL_USECRLF         = 1;      { compute answer using CRLFs for paragraphs }
  GTL_PRECISE         = 2;      { compute a precise answer					 }
  GTL_CLOSE           = 4;      { fast computation of a "close" answer		 }
  GTL_NUMCHARS        = 8;      { return the number of characters			 }
  GTL_NUMBYTES        = 16;     { return the number of _bytes_				 }
  EM_GETTEXTLENGTHEX                  = WM_USER + 95;
  EM_SETLANGOPTIONS                   = WM_USER + 120;
  EM_GETLANGOPTIONS                   = WM_USER + 121;

  EM_SETEDITSTYLE = $400 + 204;
  EM_GETEDITSTYLE = $400 + 205;

  SES_EMULATESYSEDIT = 1;
  SES_BEEPONMAXTEXT = 2;
  SES_EXTENDBACKCOLOR = 4;
  SES_MAPCPS = 8;
  SES_EMULATE10 = 16;
  SES_USECRLF = 32;
  SES_USEAIMM = 64;
  SES_NOIME = 128;
  SES_ALLOWBEEPS = 256;
  SES_UPPERCASE = 512;
  SES_LOWERCASE = 1024;
  SES_NOINPUTSEQUENCECHK = 2048;
  SES_BIDI = 4096;
  SES_SCROLLONKILLFOCUS = 8192;
  SES_XLTCRCRLFTOCR = 16384;

//[CONTROLS]

type
  TControl = class;
  PControl = TControl;
  {* Type of pointer to TControl visual object. All
     |<a href="kol_pas.htm#visual_objects_constructors">
     constructing functions
     |</a>
     New[ControlName] are returning
     pointer of this type. Do not forget about some difference
     of using objects from using classes. Identifier Self for
     methods of object is not of pointer type, and to pass
     pointer to Self, it is necessary to pass Self instead.
     At the same time, to use pointer to object in 'WITH' operator,
     it is necessary to apply suffix '^' to pointer to get know
     to compiler, what do You want. }

//[TWindowFunc TYPE]
  TWindowFunc = function( Sender: PControl; var Msg: TMsg; var Rslt: Integer )
                          : Boolean;
  {* Event type to define custom extended message handlers (as pointers to
     procedure entry points). Such handlers are usually defined like add-ons,
     extending behaviour of certain controls and attached using AttachProc
     method of TControl. If the handler detects, that it is necessary to stop
     further message processing, it should return True. }


//[Mouse TYPES]
  TMouseButton = ( mbNone, mbLeft, mbRight, mbMiddle );
  {* Available mouse buttons. mbNone is useful to get know, that
     there were no mouse buttons pressed. }

  TMouseEventData = packed Record
  {* Record to pass it to mouse handling routines, assigned to OnMouseXXXX
     events. }
    Button: TMouseButton;
    StopHandling: Boolean; // Set it to True in OnMouseXXXX event handler to
                           // stop further processing
    R1, R2: Byte; // Not used
    Shift : DWORD;    // HiWord( Shift ) = zDelta in WM_MOUSEWHEEL
    X, Y  : SmallInt;
  end;

  TOnMouse = procedure( Sender: PControl; var Mouse: TMouseEventData ) of object;
  {* Common mouse handling event type. }

//[Key TYPES]
  TOnKey = procedure( Sender: PControl; var Key: Longint; Shift: DWORD ) of object;
  {* Key events. }

  TOnChar = procedure( Sender: PControl; var Key: Char; Shift: DWORD ) of object;
  {* Char event. }

  TTabKey = ( tkTab, tkLeftRight, tkUpDown, tkPageUpPageDn );
  {* Available tabulating key groups. }
  TTabKeys = Set of TTabKey;
  {* Set of tabulating key groups, allowed to be used in with a control
     (are installed by TControl.LookTabKey property). }

//[Event TYPES]
  TOnMessage = function( var Msg: TMsg; var Rslt: Integer ): Boolean of object;
  {* Event type for events, which allows to extend behaviour of windowed controls
     descendants using add-ons. }

  TOnEventAccept = procedure( Sender: PObj; var Accept: Boolean ) of object;
  {* Event type for OnClose event. }
  TCloseQueryReason = ( qClose, qShutdown, qLogoff );
  {* Request reason type to call OnClose and OnQueryEndSession. }
  TWindowState = ( wsNormal, wsMinimized, wsMaximized );
  {* Avalable states of TControl's window object. }

  TOnSplit = function( Sender: PControl; NewSize1, NewSize2: Integer ): Boolean of object;
  {* Event type for OnSplit event handler, designed specially for splitter
     control. Event handler must return True to accept new size of previous
     (to splitter) control and new size of the rest of client area of parent. }

  TOnTVBeginDrag = procedure( Sender: PControl; Item: THandle ) of object;
  {* Event type for OnTVBeginDrag event (defined for tree view control). }
  TOnTVBeginEdit = function( Sender: PControl; Item: THandle ): Boolean of object;
  {* Event type for OnTVBeginEdit event (for tree view control). }
  TOnTVEndEdit = function( Sender: PControl; Item: THandle; const NewTxt: String )
               : Boolean of object;
  {* Event type for TOnTVEndEdit event. }
  TOnTVExpanding = function( Sender: PControl; Item: THandle; Expand: Boolean )
                 : Boolean of object;
  {* Event type for TOnTVExpanding event. }
  TOnTVExpanded = procedure( Sender: PControl; Item: THandle; Expand: Boolean )
                of object;
  {* Event type for OnTVExpanded event. }
  TOnTVDelete = procedure( Sender: PControl; Item: THandle ) of object;
  {* Event type for OnTVDelete event. }

  //--------- by Sergey Shisminzev:
  TOnTVSelChanging = function(Sender: PControl; oldItem, newItem: THandle): Boolean  //~ss
                  of object;
  {* When the handler returns False, selection is not changed. }
  //-------------------------------
  TOnDrag = function( Sender: PControl; ScrX, ScrY: Integer; var CursorShape: Integer;
            var Stop: Boolean ): Boolean of object;
  {* Event, called during dragging operation (it is initiated
     with method Drag, where callback function of type TOnDrag is
     passed as a parameter). Callback function receives Stop parameter True,
     when operation is finishing. Otherwise, it can set it to True to force
     finishing the operation (in such case, returning False means cancelling
     drag operation, True - successful drag and in this last case callback is
     no more called). During the operation, when input Stop value is False,
     callback function can control Cursor shape, and return True, if the operation
     can be finished successfully at the given ScrX, ScrY position.
     ScrX, ScrY are screen coordinates of the mouse cursor. }

//[Create Window STRUCTURES]
  TCreateParams = packed record
  {* Record to pass it through CreateSubClass method. }
    Caption: PChar;
    Style: cardinal;
    ExStyle: cardinal;
    X, Y: Integer;
    Width, Height: Integer;
    WndParent: HWnd;
    Param: Pointer;
    WindowClass: TWndClass;
    WinClassName: array[0..63] of Char;
  end;

  TCreateWndParams = packed Record
    ExStyle: DWORD;
    WinClassName: PChar;
    Caption: PChar;
    Style: DWORD;
    X, Y, Width, Height: Integer;
    WndParent: HWnd;
    Menu: HMenu;
    Inst: THandle;
    Param: Pointer;
    WinClsNamBuf: array[ 0..63 ] of Char;
    WindowClass: TWndClass;
  end;


//[COMMAND ACTIONS TYPE FOR DIFFERENT CONTROLS]
  PCommandActions = ^TCommandActions;
  TCommandActions = packed Record
    aClear: procedure( Sender: PControl );
    aAddText: procedure( Sender: PControl; const S: String );
    aClick, aEnter, aLeave: WORD; aChange: SmallInt; aSelChange: SmallInt;
    aGetCount, aSetCount, aGetItemLength, aGetItemText, aSetItemText,
    aGetItemData, aSetItemData: WORD;
    aAddItem, aDeleteItem, aInsertItem: WORD;
    aFindItem, aFindPartial: WORD;
    aItem2Pos, aPos2Item: BYTE;
    aGetSelCount, aGetSelected, aGetSelRange, aExGetSelRange, aGetCurrent,
    aSetSelected, aSetCurrent, aSetSelRange, aExSetSelRange,
    aGetSelection, aReplaceSel: WORD;
    aTextAlignLeft, aTextAlignRight, aTextAlignCenter: WORD;
    aTextAlignMask: Byte;
    aVertAlignCenter, aVertAlignTop, aVertAlignBottom: Byte;
    aDir, aSetLimit: Word; aSetImgList: Word;
    aAutoSzX, aAutoSzY: Word;
    aSetBkColor: Word;
  end;

//[Align TYPES]
  TTextAlign = ( taLeft, taRight, taCenter );
  {* Text alignments available. }
  TRichTextAlign = ( raLeft, raRight, raCenter,
                 // all other are only set but can not be displayed:
                 raJustify, // displayed like raLeft (though stored normally)
                 raInterLetter, raScaled, raGlyphs, raSnapGrid );
  {* Text alignment styles, available for RichEdit control. }
  TVerticalAlign = ( vaCenter, vaTop, vaBottom );
  {* Vertical alignments available. }
  TControlAlign = ( caNone, caLeft, caTop, caRight, caBottom, caClient );
  {* Control alignments available. }

//[BitBtn TYPES]
  TBitBtnOption = ( bboImageList,
                    bboNoBorder,
                    bboNoCaption,
                    bboFixed );
  {* Options available for NewBitBtn. }
  TBitBtnOptions = set of TBitBtnOption;
  {* Set of options, available for NewBitBtn. }
  TGlyphLayout = ( glyphLeft, glyphTop, glyphRight, glyphBottom, glyphOver );
  {* Layout of glyph (for NewBitBtn). Layout glyphOver means that text is
     drawn over glyph. }
  TOnBitBtnDraw = function( Sender: PControl; BtnState: Integer ): Boolean of object;
  {* Event type for TControl.OnBitBtnDraw event (which is called just before
     drawing the BitBtn). If handler returns True, there are no drawing occure.
     BtnState, passed to a handler, determines current button state and can
     be following: 0 - not pressed, 1 - pressed, 2 - disabled, 3 - focused.
     Value 4 is reserved for highlight state (then mouse is over it), but
     highlighting is provided only if property Flat is set to True (or one
     of events OnMouseEnter / OnMouseLeave is assigned to something). }

//[ListView TYPES]
  TListViewStyle = ( lvsIcon, lvsSmallIcon, lvsList, lvsDetail, lvsDetailNoHeader );
  {* Styles of view for ListView control (see NewListVew). }

  TListViewItemStates = ( lvisFocus, lvisSelect, lvisBlend, lvisHighlight );
  TListViewItemState = Set of TListViewItemStates;
  TListViewOption = (
    lvoIconLeft,      // in lvsIcon, lvsSmallIcon plce icon left from text (rather then top)
    lvoAutoArrange,   // keep icons auto arranged in lvsIcon and lvsSmallIcon view
    lvoButton,        // icons look like buttons in lvsIcon view
    lvoEditLabel,     // allows edit labels inplace (first column #0 text)
    lvoNoLabelWrap,   // item text on a single line in lvsIcon view (by default, item text may wrap in lvsIcon view).
    lvoNoScroll,      // obvious
    lvoNoSortHeader,  // click on header button does not lead to sort items
    lvoHideSel,       // hide selection when not in focus
    lvoMultiselect,   // allow to select multiple items
    lvoSortAscending,
    lvoSortDescending,
      // extended styles (not documented in my Win32.hlp :( , got from VCL source:
    lvoGridLines,
    lvoSubItemImages,
    lvoCheckBoxes,
    lvoTrackSelect,
    lvoHeaderDragDrop,
    lvoRowSelect,
    lvoOneClickActivate,
    lvoTwoClickActivate,
    lvoFlatsb,
    lvoRegional,
    lvoInfoTip,
    lvoUnderlineHot,
    lvoMultiWorkares,
      // virtual list view style:
    lvoOwnerData,
      // custom draw style:
    lvoOwnerDrawFixed
     );
  TListViewOptions = Set of TListViewOption;

  TOnEditLVItem = function( Sender: PControl; Idx, Col: Integer; NewText: PChar ): Boolean
                  of object;
  {* Event type for OnEndEditLVItem. Return True in handler to accept new text value. }
  TOnDeleteLVItem = procedure( Sender: PControl; Idx: Integer ) of object;
  {* Event type for OnDeleteLVItem event. }
  TOnLVData = procedure( Sender: PControl; Idx, SubItem: Integer;
              var Txt: String; var ImgIdx: Integer; var State: DWORD;
              var Store: Boolean ) of object;
  {* Event type for OnLVData event. Used to provide virtual list view control
     (i.e. having lvoOwnerData style) with actual data on request. Use parameter
     Store as a flag if control should store obtained data by itself or not. }
  {$IFNDEF _D2}
  {$IFNDEF _FPC}
  TOnLVDataW = procedure( Sender: PControl; Idx, SubItem: Integer;
              var Txt: WideString; var ImgIdx: Integer; var State: DWORD;
              var Store: Boolean ) of object;
  {* Event type for OnLVDataW event (the same as OnLVData, but for unicode verion
     of the control OnLVDataW allows to return WideString text in the event
     handler). Used to provide virtual list view control
     (i.e. having lvoOwnerData style) with actual data on request. Use parameter
     Store as a flag if control should store obtained data by itself or not. }
  {$ENDIF _FPC}
  {$ENDIF _D2}
  TOnCompareLVItems = function( Sender: PControl; Idx1, Idx2: Integer ): Integer
                    of object;
  {* Event type to compare two items of the list view (while sorting it). }
  TOnLVColumnClick = procedure( Sender: PControl; Idx: Integer ) of object;
  {* Event type for OnColumnClick event. }
  TOnLVStateChange = procedure( Sender: PControl; IdxFrom, IdxTo: Integer; OldState, NewState: DWORD )
                   of object;
  {* Event type for OnLVStateChange event, called in responce to select/unselect
     a single item or items range in list view control). }
  TOnLVDelete = procedure( Sender: PControl; Idx: Integer ) of object;
  {* Event type for OnLVDelete event, called when an item is been deleting. }

  TDrawActions = ( odaEntire, odaFocus, odaSelect );
  TDrawAction = Set of TDrawActions;
  TDrawStates = ( odsSelected, odsGrayed, odsDisabled, odsChecked, odsFocused,
                  odsDefault, odsHotlist, odsInactive,
                  odsNoAccel, odsNoFocusRect,
                  ods400reserved, ods800reserved,
                  odsComboboxEdit,
                  // specific for common controls:
                  odsMarked, odsIndeterminate );
  {* Possible draw states.
     |<br>odsSelected - The menu item's status is selected.
     |<br>odsGrayed - The item is to be grayed. This bit is used only in a menu.
     |<br>odsDisabled - The item is to be drawn as disabled.
     |<br>odsChecked - The menu item is to be checked. This bit is used only in
                     a menu.
     |<br>odsFocused - The item has the keyboard focus.
     |<br>odsDefault - The item is the default item.
     |<br>odsHotList - <b>Windows 98, Windows 2000:</b> The item is being
                     hot-tracked, that is, the item will be highlighted when
                     the mouse is on the item.
     |<br>odsInactive - <b>Windows 98, Windows 2000:</b> The item is inactive
                      and the window associated with the menu is inactive.
     |<br>odsNoAccel - <b>Windows 2000:</b> The control is drawn without the
                     keyboard accelerator cues.
     |<br>odsNoFocusRect - <b>Windows 2000:</b> The control is drawn without
                         focus indicator cues.
     |<br>odsComboboxEdit - The drawing takes place in the selection field
                          (edit control) of an owner-drawn combo box.
     |<br>odsMarked - for Common controls only. The item is marked. The meaning
                    of this is up to the implementation.
     |<br>odsIndeterminate - for Common Controls only. The item is in an
                           indeterminate state. }
  TDrawState = Set of TDrawStates;
  {* Set of possible draw states. }
  TOnDrawItem = function( Sender: PObj; DC: HDC; const Rect: TRect; ItemIdx: Integer;
                           DrawAction: TDrawAction; ItemState: TDrawState ): Boolean of object;
  {* Event type for OnDrawItem event (applied to list box, combo box, list view). }
  TOnMeasureItem = function( Sender: PObj; Idx: Integer ): Integer of object;
  {* Event type for OnMeasureItem event. The event handler must return height of list box
     item as a result. }
  TGetLVItemPart = ( lvipBounds, lvipIcon, lvipLabel, lvupIconAndLabel );
  {* }
  TWherePosLVItem = ( lvwpOnIcon, lvwpOnLabel, lvwpOnStateIcon, lvwpOnColumn,
                  lvwpOnItem );
  {* }

  TOnLVCustomDraw = function( Sender: PControl; DC: HDC; Stage: DWORD;
                  ItemIdx, SubItemIdx: Integer; const Rect: TRect;
                  ItemState: TDrawState; var TextColor, BackColor: TColor )
                  : DWORD of object;
  {* Event type for OnLVCustomDraw event. }

//[Paint TYPES]
  TOnPaint = procedure( Sender: PControl; DC: HDC ) of object;

  TGradientStyle = ( gsVertical, gsHorizontal, gsRectangle, gsElliptic, gsRombic );
  {* Gradient fill styles. See also TGradientLayout. }
  TGradientLayout = ( glTopLeft, glTop, glTopRight,
                      glLeft, glCenter, glRight,
                      glBottomLeft, glBottom, glBottomRight );
  {* Position of starting line / point for gradient filling. Depending on
     TGradientStyle, means either position of first line of first rectangle
     (ellipse) to be expanded in a loop to fit entire gradient panel area. }

//[Edit TYPES]
  TEditOption = ( eoNoHScroll, eoNoVScroll, eoLowercase, eoMultiline,
                  eoNoHideSel, eoOemConvert, eoPassword, eoReadonly,
                  eoUpperCase, eoWantReturn, eoWantTab, eoNumber );
  {* Available edit options.
  |<br> Please note, that eoWantTab option just removes TAB key from a list
  of keys available to tabulate from the edit control. To provide insertion
  of tabulating key, do so in TControl.OnChar event handler. Sorry for
  inconvenience, but this is because such behaviour is not must in all cases.
  See also TControl.EditTabChar property.  }
  TEditOptions = Set of TEditOption;
  {* Set of available edit options. }

  TRichFmtArea = ( raSelection, raWord, raAll );
  {* Characters formatting area for RichEdit. }
  TRETextFormat = ( reRTF, reText, rePlainRTF, reRTFNoObjs, rePlainRTFNoObjs,
                    reTextized );
  {* Available formats for transfer RichEdit text using property
     TControl.RE_Text.
     |<pre>
     reRTF - normal rich text (no transformations)
     reText - plain text only (without OLE objects)
     reTextized - plain text with text representation of OLE objects
     rePlainRTF - reRTF without language-specific keywords
     reRTFNoObjs - reRTF without OLE objects
     rePlainRTFNoObjs - rePlainRTF without OLE objects
     |</pre> }
  TRichUnderline = ( ruSingle, ruWord, ruDouble, ruDotted,
                 //all other - only for RichEditv3.0:
                 ruDash, ruDashDot, ruDashDotDot, ruWave, ruThick, ruHairLine );
  {* Rich text exteded underline styles (available only for RichEdit v2.0,
     and even for RichEdit v2.0 additional styles can not displayed - but
     ruDotted under Windows2000 is working). }
  TRichTextSizes = ( rtsNoUseCRLF, rtsNoPrecise, rtsClose, rtsBytes );
  {* Options to calculate size of rich text. Available only for RichEdit2.0
     or higher. }
  TRichTextSize = set of TRichTextSizes;
  {* Set of all available optioins to calculate rich text size using
     property TControl.RE_TextSize[ options ]. }
  TRichNumbering = ( rnNone, rnBullets, rnArabic, rnLLetter, rnULetter,
                rnLRoman, rnURoman );
  {* Advanced numbering styles for paragraph (RichEdit).
     |<pre>
     rnNone     - no numbering
     rnBullets  - bullets only
     rnArabic   - 1, 2, 3, 4, ...
     rnLLetter  - a, b, c, d, ...
     rnULetter  - A, B, C, D, ...
     rnLRoman   - i, ii, iii, iv, ...
     rnURoman   - I, II, III, IV, ...
     rnNoNumber - do not show any numbers (but numbering is taking place).
     |</pre> }
  TRichNumBrackets = ( rnbRight, rnbBoth, rnbPeriod, rnbPlain, rnbNoNumber );
  {* Brackets around number:
     |<pre>
     rnbRight   - 1) 2) 3)     - this is default !
     rnbBoth    - (1) (2) (3)
     rnbPeriod  - 1. 2. 3.
     rnbPlain   - 1 2 3
     |</pre> }
  TBorderEdge = (beLeft, beTop, beRight, beBottom);
  {* Borders of rectangle. }

  TCharFormat = TCharFormat2;
  TParaFormat = TParaFormat2;

  TOnTestMouseOver = function( Sender: PControl ): Boolean of object;
  {* Event type for TControl.OnTestMouseOver event. The handler should
     return True, if it dectects, that mouse is over control. }

  TEdgeStyle = ( esRaised, esLowered, esNone );
  {* Edge styles (for panel - see NewPanel). }

//[List TYPES]
  TListOption = ( loNoHideScroll, loNoExtendSel, loMultiColumn, loMultiSelect,
                  loNoIntegralHeight, loNoSel, loSort, loTabstops,
                  loNoStrings, loNoData, loOwnerDrawFixed, loOwnerDrawVariable );
  {* Options for ListBox (see NewListbox). }
  TListOptions = Set of TListOption;
  {* Set of available options for Listbox. }

  TComboOption = ( coReadOnly, coNoHScroll, coAlwaysVScroll, coLowerCase,
                   coNoIntegralHeight, coOemConvert, coSort, coUpperCase,
                   coOwnerDrawFixed, coOwnerDrawVariable, coSimple );
  {* Options for combobox. }
  TComboOptions = Set of TComboOption;
  {* Set of options available for combobox. }

//[Progress TYPES]
  TProgressbarOption = ( pboVertical, pboSmooth );
  {* Options for progress bar. }
  TProgressbarOptions = set of TProgressbarOption;
  {* Set of options available for progress bar. }

//[TreeView TYPES]
  TTreeViewOption = ( tvoNoLines, tvoLinesRoot, tvoNoButtons, tvoEditLabels, tvoHideSel,
                  tvoDragDrop, tvoNoTooltips, tvoCheckBoxes, tvoTrackSelect,
                  tvoSingleExpand, tvoInfoTip, tvoFullRowSelect, tvoNoScroll,
                  tvoNonEvenHeight );
  {* Tree view options. }
  TTreeViewOptions = set of TTreeViewOption;
  {* Set of tree view options. }

//[TabControl TYPES]
  TTabControlOption = ( tcoButtons, tcoFixedWidth, tcoFocusTabs,
                        tcoIconLeft, tcoLabelLeft,
                        tcoMultiline, tcoMultiselect, tcoFitRows, tcoScrollOpposite,
                        tcoBottom, tcoVertical, tcoFlat, tcoHotTrack, tcoBorder,
                        tcoOwnerDrawFixed );
  {* Options, available for TabControl. }
  TTabControlOptions = set of TTabControlOption;
  {* Set of options, available for TAbControl during its creation (by
     NewTabControl function). }

//[Toolbar TYPES]
  TToolbarOption = ( tboTextRight, tboTextBottom, tboFlat, tboTransparent,
                 tboWrapable, tboNoDivider, tbo3DBorder );
  {* Toolbar options. When tboFlat is set and toolbar is placed onto panel,
     set its property Transparent to TRUE to provide its correct view. }
  TToolbarOptions = Set of TToolbarOption;
  {* Set of toolbar options. }
  TOnToolbarButtonClick = procedure( Sender: PControl; BtnID: Integer ) of object;
  {* Special event type to handle separate toolbar buttons click events. }

//[TOnDropFiles TYPE]
  TOnDropFiles = procedure( Sender: PControl; const FileList: String; const Pt: TPoint ) of object;
  {* An event type for OnDropFiles event. When the event is occur, FileList
     parameter contains a list of files dropped. File names in a list are
     separated with #13 character. This allows You to assign it to TStrList
     object using its property Text (for example):
     ! procedure TSomeObject.DropFiles( Sender: PControl; const FileList: String;
     !           const Pt: TPoint ); )
     ! var FList: PStrList;
     !     I: Integer;
     ! begin
     !   FList := NewStrList;
     !   FList.Text := FileList;
     !   for I := 0 to FList.Count-1 do
     !   begin
     !     // do something with FList.Items[ I ]
     !   end;
     !   FList.Free;
     ! end; }

//[Scroll TYPES]
  TScrollerBar = ( sbHorizontal, sbVertical );
  TScrollerBars = set of TScrollerBar;

  TOnScroll = procedure( Sender: PControl; Bar: TScrollerBar; ScrollCmd: DWORD;
            ThumbPos: DWORD ) of object;

//[TOnHelp EVENT TYPE]
  TOnHelp = procedure( var Sender: PControl; var Context: Integer; var Popup: Boolean )
            of object;

  {$IFDEF USE_MHTOOLTIP}
  {$DEFINE pre_interface}
  {$I KOLMHToolTip}
  {$UNDEF pre_interface}
  {$ENDIF}

{ ----------------------------------------------------------------------

             TControl - object to implement any visual control

----------------------------------------------------------------------- }
//[TControl DEFINITION]
  TControl = class( TObj )
  {*! TControl is the basic visual object of KOL. And now, all visual
     objects have the same type PControl, differing only in "constructor",
     which during creating of object adjusts it so it can play role of
     desired control. Idea of incapsulating of all visual objects having
     the most common set of properties, is belonging to Vladimir Kladov,
     (C) 2000.
     |<br>&nbsp;&nbsp;&nbsp;<b> Since all visual objects are represented
     in KOL by this single object type, not all methods, properties and
     events defined in TControl, are applicable to different visual objects.
     See also notes about certain control kinds, located together with its
     |<a href="kol_pas.htm#visual_objects_constructors">
     |constructing functions definitions</a></b>. }
  protected
    function GetHelpPath: String;
    procedure SetHelpPath(const Value: String);
    procedure SetOnQueryEndSession(const Value: TOnEventAccept);
    procedure SetOnMinMaxRestore(const Index: Integer; const Value: TOnEvent);
    procedure SetConstraint(const Index, Value: Integer);
    {$IFDEF F_P}
    function GetOnMinMaxRestore(const Index: Integer): TOnEvent;
    function GetConstraint(const Index: Integer): Integer;
    {$ENDIF F_P}
    procedure SetOnScroll(const Value: TOnScroll);
    function GetLVColalign(Idx: Integer): TTextAlign;
    procedure SetLVColalign(Idx: Integer; const Value: TTextAlign);

    procedure SetParent( Value: PControl );
    function GetLeft: Integer;
    procedure SetLeft( Value: Integer );
    function GetTop: Integer;
    procedure SetTop( Value: Integer );
    function GetWidth: Integer;
    procedure SetWidth( Value: Integer );
    function GetHeight: Integer;
    procedure SetHeight( Value: Integer );

    function GetPosition: TPoint;
    procedure Set_Position( Value: TPoint );

    function GetMembers(Idx: Integer): PControl;
    function GetFont: PGraphicTool;
    procedure FontChanged( Sender: PGraphicTool );
    function GetBrush: PGraphicTool;
    procedure BrushChanged( Sender: PGraphicTool );
    function GetClientHeight: Integer;
    function GetClientWidth: Integer;
    procedure SetClientHeight(const Value: Integer);
    procedure SetClientWidth(const Value: Integer);
    function GetHasBorder: Boolean;
    procedure SetHasBorder(const Value: Boolean);

    function GetHasCaption: Boolean;
    procedure SetHasCaption(const Value: Boolean);

    function GetCanResize: Boolean;
    procedure SetCanResize( const Value: Boolean );

    function GetStayOnTop: Boolean;
    procedure SetStayOnTop(const Value: Boolean);
    function GetChecked: Boolean;
    procedure Set_Checked(const Value: Boolean);

    function GetSelStart: Integer;
    procedure SetSelStart(const Value: Integer);
    function GetSelLength: Integer;
    procedure SetSelLength(const Value: Integer);

    function GetItems(Idx: Integer): String;
    procedure SetItems(Idx: Integer; const Value: String);

    function GetItemsCount: Integer;
    function GetItemSelected(ItemIdx: Integer): Boolean;
    procedure SetItemSelected(ItemIdx: Integer; const Value: Boolean);

    procedure SetCtl3D(const Value: Boolean);
    function GetCurIndex: Integer;
    procedure SetCurIndex(const Value: Integer);
    function GetTextAlign: TTextAlign;
    function GetVerticalAlign: TVerticalAlign;
    procedure SetTextAlign(const Value: TTextAlign);
    procedure SetVerticalAlign(const Value: TVerticalAlign);

    function GetCanvas: PCanvas;
    function Dc2Canvas( Sender: PCanvas ): HDC;
    procedure SetShadowDeep(const Value: Integer);
    procedure SetDoubleBuffered(const Value: Boolean);

    procedure SetStatusText(Index: Integer; Value: PChar);
    function GetStatusText( Index: Integer ): PChar;
    function GetStatusPanelX(Idx: Integer): Integer;
    procedure SetStatusPanelX(Idx: Integer; const Value: Integer);

    procedure SetTransparent(const Value: Boolean);
    function GetImgListIdx(const Index: Integer): PImageList;

    procedure SetImgListIdx(const Index: Integer; const Value: PImageList);
    function GetLVColText(Idx: Integer): String;
    procedure SetLVColText(Idx: Integer; const Value: String);
    {$IFNDEF _FPC}
    {$IFNDEF _D2}
    function GetLVColTextW(Idx: Integer): WideString;
    procedure SetLVColTextW(Idx: Integer; const Value: WideString);
    {$ENDIF _D2}
    {$ENDIF _FPC}
    function LVGetItemText(Idx, Col: Integer): String;
    procedure LVSetItemText(Idx, Col: Integer; const Value: String);
    {$IFNDEF _FPC}
    {$IFNDEF _D2}
    function LVGetItemTextW(Idx, Col: Integer): WideString;
    procedure LVSetItemTextW(Idx, Col: Integer; const Value: WideString);
    {$ENDIF _D2}
    {$ENDIF _FPC}
    procedure SetLVOptions(const Value: TListViewOptions);
    procedure SetLVStyle(const Value: TListViewStyle);
    function GetLVColEx(Idx: Integer; const Index: Integer): Integer;
    procedure SetLVColEx(Idx: Integer; const Index: Integer;
      const Value: Integer);

    function GetChildCount: Integer;

    function LVGetItemPos(Idx: Integer): TPoint;
    procedure LVSetItemPos(Idx: Integer; const Value: TPoint);
    procedure LVSetColorByIdx(const Index: Integer; const Value: TColor);
    {$IFDEF F_P}
    function LVGetColorByIdx(const Index: Integer): TColor;
    {$ENDIF F_P}
    function GetIntVal(const Index: Integer): Integer;
    procedure SetIntVal(const Index, Value: Integer);
    function GetItemVal(Item: Integer; const Index: Integer): Integer;
    procedure SetItemVal(Item: Integer; const Index, Value: Integer);
    function TBGetButtonVisible(BtnID: Integer): Boolean;
    procedure TBSetButtonVisible(BtnID: Integer; const Value: Boolean);

    function TBGetBtnStt(BtnID: Integer; const Index: Integer): Boolean;
    procedure TBSetBtnStt(BtnID: Integer; const Index: Integer; const Value: Boolean);
    function TBGetButtonText(BtnID: Integer): String;
    function TBGetButtonRect(BtnID: Integer): TRect;

    function TBGetRows: Integer;
    procedure TBSetRows(const Value: Integer);
    procedure SetProgressColor(const Value: TColor);
    function TBGetBtnImgIdx(BtnID: Integer): Integer;
    procedure TBSetBtnImgIdx(BtnID: Integer; const Value: Integer);

    procedure TBSetButtonText(BtnID: Integer; const Value: String);

    function TBGetBtnWidth(BtnID: Integer): Integer;
    procedure TBSetBtnWidth(BtnID: Integer; const Value: Integer);
    procedure TBSetBtMinMaxWidth(const Idx: Integer; const Value: Integer);
    {$IFDEF F_P}
    function TBGetBtMinMaxWidth(const Idx: Integer): Integer;
    {$ENDIF F_P}
    procedure TBFreeTBevents;
    procedure Set_Align(const Value: TControlAlign);
    function GetSelection: String;
    procedure SetSelection(const Value: String);
    procedure SetTabOrder(const Value: Integer);
    function GetFocused: Boolean;
    procedure SetFocused(const Value: Boolean);
    function REGetFont: PGraphicTool;
    procedure RESetFont(Value: PGraphicTool);
    procedure RESetFontEx(const Index: Integer);
    function REGetFontEffects(const Index: Integer): Boolean;
    function REGetFontMask(const Index: Integer): Boolean;
    procedure RESetFontEffect(const Index: Integer; const Value: Boolean);
    function REGetFontAttr(const Index: Integer): Integer;
    procedure RESetFontAttr(const Index, Value: Integer);
    procedure RESetFontAttr1(const Index, Value: Integer);
    function REGetFontSizeValid: Boolean;
    function REGetCharformat: TCharFormat;
    procedure RESetCharFormat(const Value: TCharFormat);
    function REReadText(Format: TRETextFormat;
      SelectionOnly: Boolean): String;
    procedure REWriteText(Format: TRETextFormat; SelectionOnly: Boolean;
      const Value: String);
    function REGetFontName: String;
    procedure RESetFontName(const Value: String);
    function REGetParaFmt: TParaFormat;
    procedure RESetParaFmt(const Value: TParaFormat);
    function REGetNumbering: Boolean;
    function REGetParaAttr( const Index: Integer ): Integer;
    function REGetParaAttrValid( const Index: Integer ): Boolean;
    function REGetTabCount: Integer;
    function REGetTabs(Idx: Integer): Integer;
    function REGetTextAlign: TRichTextAlign;
    procedure RESetNumbering(const Value: Boolean);
    procedure RESetParaAttr(const Index, Value: Integer);
    procedure RESetTabCount(const Value: Integer);
    procedure RESetTabs(Idx: Integer; const Value: Integer);
    procedure RESetTextAlign(const Value: TRichTextAlign);
    function REGetStartIndentValid: Boolean;
    function REGetAutoURLDetect: Boolean;
    procedure RESetAutoURLDetect(const Value: Boolean);

    function GetMaxTextSize: DWORD;
    procedure SetMaxTextSize(const Value: DWORD);
    procedure SetOnResize(const Value: TOnEvent);

    procedure DoSelChange;

    function REGetUnderlineEx: TRichUnderline;
    procedure RESetUnderlineEx(const Value: TRichUnderline);

    function GetTextSize: Integer;
    function REGetTextSize(Units: TRichTextSize): Integer;

    function REGetNumStyle: TRichNumbering;
    procedure RESetNumStyle(const Value: TRichNumbering);
    function REGetNumBrackets: TRichNumBrackets;
    procedure RESetNumBrackets(const Value: TRichNumBrackets);
    function REGetNumTab: Integer;
    procedure RESetNumTab(const Value: Integer);
    function REGetNumStart: Integer;
    procedure RESetNumStart(const Value: Integer);
    function REGetSpacing(const Index: Integer): Integer;
    procedure RESetSpacing(const Index, Value: Integer);
    function REGetSpacingRule: Integer;
    procedure RESetSpacingRule(const Value: Integer);
    function REGetLevel: Integer;
    function REGetBorder(Side: TBorderEdge; const Index: Integer): Integer;
    procedure RESetBorder(Side: TBorderEdge; const Index: Integer;
      const Value: Integer);
    function REGetParaEffect(const Index: Integer): Boolean;
    procedure RESetParaEffect(const Index: Integer; const Value: Boolean);
    function REGetOverwite: Boolean;
    procedure RESetOverwrite(const Value: Boolean);
    procedure RESetOvrDisable(const Value: Boolean);
    function REGetTransparent: Boolean;
    procedure RESetTransparent(const Value: Boolean);
    procedure RESetOnURL(const Index: Integer; const Value: TOnEvent);
    {$IFDEF F_P}
    function REGetOnURL(const Index: Integer): TOnEvent;
    {$ENDIF F_P}
    function REGetLangOptions(const Index: Integer): Boolean;
    procedure RESetLangOptions(const Index: Integer; const Value: Boolean);
    function LVGetItemImgIdx(Idx: Integer): Integer;
    procedure LVSetItemImgIdx(Idx: Integer; const Value: Integer);
    procedure SetFlat(const Value: Boolean);
    procedure SetOnMouseEnter(const Value: TOnEvent);
    procedure SetOnMouseLeave(const Value: TOnEvent);
    procedure EdSetTransparent(const Value: Boolean);
    procedure SetOnTestMouseOver(const Value: TOnTestMouseOver);
    function GetPages(Idx: Integer): PControl;
    function TCGetItemText(Idx: Integer): String;
    procedure TCSetItemText(Idx: Integer; const Value: String);
    function TCGetItemImgIDx(Idx: Integer): Integer;
    procedure TCSetItemImgIdx(Idx: Integer; const Value: Integer);
    function TCGetItemRect(Idx: Integer): TRect;
    function TVGetItemIdx(const Index: Integer): THandle;
    procedure TVSetItemIdx(const Index: Integer; const Value: THandle);
    function TVGetItemNext(Item: THandle; const Index: Integer): THandle;
    function TVGetItemRect(Item: THandle; TextOnly: Boolean): TRect;
    function TVGetItemVisible(Item: THandle): Boolean;
    procedure TVSetITemVisible(Item: THandle; const Value: Boolean);
    function TVGetItemStateFlg(Item: THandle; const Index: Integer): Boolean;
    procedure TVSetItemStateFlg(Item: THandle; const Index: Integer;
      const Value: Boolean);
    function TVGetItemImage(Item: THandle; const Index: Integer): Integer;
    procedure TVSetItemImage(Item: THandle; const Index: Integer;
      const Value: Integer);
    function TVGetItemText(Item: THandle): String;
    procedure TVSetItemText(Item: THandle; const Value: String);
    {$IFNDEF _FPC}
    {$IFNDEF _D2}
    function TVGetItemTextW(Item: THandle): WideString;
    procedure TVSetItemTextW(Item: THandle; const Value: WideString);
    {$ENDIF _D2}
    {$ENDIF _FPC}
    function TV_GetItemHasChildren(Item: THandle): Boolean;
    procedure TV_SetItemHasChildren(Item: THandle; const Value: Boolean);
    function TVGetItemData(Item: THandle): Pointer;
    procedure TVSetItemData(Item: THandle; const Value: Pointer);

    function GetToBeVisible: Boolean;

    procedure SetAlphaBlend(const Value: Integer);
    procedure SetMaxProgress(const Index, Value: Integer);
    procedure SetDroppedWidth(const Value: Integer);
    function LVGetItemState(Idx: Integer): TListViewItemState;
    procedure LVSetItemState(Idx: Integer; const Value: TListViewItemState);
    function LVGetSttImgIdx(Idx: Integer): Integer;
    procedure LVSetSttImgIdx(Idx: Integer; const Value: Integer);
    function LVGetOvlImgIdx(Idx: Integer): Integer;
    procedure LVSetOvlImgIdx(Idx: Integer; const Value: Integer);
    function LVGetItemData(Idx: Integer): DWORD;
    procedure LVSetItemData(Idx: Integer; const Value: DWORD);
    function LVGetItemIndent(Idx: Integer): Integer;
    procedure LVSetItemIndent(Idx: Integer; const Value: Integer);
    procedure SetOnDeleteAllLVItems(const Value: TOnEvent);
    procedure SetOnDeleteLVItem(const Value: TOnDeleteLVItem);
    procedure SetOnEditLVItem(const Value: TOnEditLVItem);
    procedure SetOnLVData(const Value: TOnLVData);
    {$IFNDEF _FPC}
    {$IFNDEF _D2}
    procedure SetOnLVDataW(const Value: TOnLVDataW);
    {$ENDIF _D2}
    {$ENDIF _FPC}
    procedure SetOnColumnClick(const Value: TOnLVColumnClick);
    procedure SetOnDrawItem(const Value: TOnDrawItem);
    procedure SetOnMeasureItem(const Value: TOnMeasureItem);

    procedure SetItemsCount(const Value: Integer);

    function GetItemData(Idx: Integer): DWORD;
    procedure SetItemData(Idx: Integer; const Value: DWORD);
    function GetLVCurItem: Integer;
    procedure SetLVCurItem(const Value: Integer);
    procedure SetOnDropFiles(const Value: TOnDropFiles);
    procedure SetOnHide(const Value: TOnEvent);
    procedure SetOnShow(const Value: TOnEvent);
    procedure SetClientMargin(const Index, Value: Integer);
    {$IFDEF F_P}
    function GetClientMargin(const Index: Integer): Integer;
    {$ENDIF F_P}
    procedure SetOnPaint(const Value: TOnPaint);
    procedure SetOnEraseBkgnd(const Value: TOnPaint);
    procedure SetTVRightClickSelect(const Value: Boolean);
    procedure SetOnLVStateChange(const Value: TOnLVStateChange);
    procedure SetOnLVDelete(const Value: TOnLVDelete);
    procedure SetOnMove(const Value: TOnEvent);
    procedure SetColor1(const Value: TColor);
    procedure SetColor2(const Value: TColor);
    procedure SetGradientLayout(const Value: TGradientLayout);
    procedure SetGradientStyle(const Value: TGradientStyle);
    procedure SetDroppedDown(const Value: Boolean);
    function get_ClassName: String;
    procedure set_ClassName(const Value: String);
    procedure SetClsStyle( Value: DWord );

    procedure SetStyle( Value: DWord );
    procedure SetExStyle( Value: DWord );

    procedure SetCursor( Value: HCursor );

    procedure SetIcon( Value: HIcon );
    procedure SetMenu( Value: HMenu );
    function GetCaption: String;
    procedure SetCaption( const Value: String );

    procedure SetWindowState( Value: TWindowState );
    function GetWindowState: TWindowState;

    procedure ApplyFont2Wnd;
    procedure DoClick;

    function TBAddInsButtons( Idx: Integer; const Buttons: array of PChar; const BtnImgIdxArray: array
              of Integer ): Integer; stdcall;
    procedure SetBitBtnDrawMnemonic(const Value: Boolean);
    function GetBitBtnImgIdx: Integer;
    procedure SetBitBtnImgIdx(const Value: Integer);
    function GetBitBtnImageList: THandle;
    procedure SetBitBtnImageList(const Value: THandle);

    function GetModal: Boolean;
    {$IFDEF NEW_MODAL}
    procedure SetModalResult( const Value: Integer );
    {$ENDIF}

  protected
    fHandle: HWnd;
    fFocusHandle: HWnd;
    fClsStyle: DWord;
    fStyle: DWord;
    fExStyle: DWord;
    fCursor: HCursor;
    fCursorShared: Boolean;
    fIcon: HIcon;
    fIconShared: Boolean;
    fCaption: PChar; // it is now preferred to store Caption as PChar (null-
                     // terminated string), dynamically allocated in memory.
    fIgnoreWndCaption: Boolean;

    fWindowState: TWindowState;
    fShowAction: Integer;
    fCanvas: PCanvas;
    fDefWndProc: Pointer;
    fNCDestroyed: Boolean;

    FParent: PControl;
    //FTag: Integer;
    fEnabled: Boolean; // Caution!!! fVisible must follow fEnabled! ___
    fVisible: Boolean; //____________________________________________//
    fTabstop: Boolean;
    fTabOrder: Integer;
    fTextAlign: TTextAlign;
    fVerticalAlign: TVerticalAlign;
    fWordWrap: Boolean;
    fPreventResize: Boolean;
    fAlphaBlend: Integer;
    FDroppedWidth: Integer;

    fChildren: PList;
    {* List of children. }
    fMDIClient: PControl;
    {* MDI client window control }
    fPass2DefProc: function( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
    {* MDI children list }
    fMDIChildren: PList;
    {* List of MDI children. It is filled for MDI client window. }
    fWndFunc: Pointer;
    {* Initially pointer to WndFunc. For MDI child window, points to DefMDIChildProc. }
    fExMsgProc: function( Applet: PControl; var Msg: TMsg ): Boolean;
    {* Additional message handler called directly from Applet.ProcessMessage.
       Used to call TranslateMDISysAccel API function for MDI application. }
    fMDIDestroying: Boolean;
    {* }

    fTmpBrush: HBrush;
    {* Brush handle to return in response to some color set messages.
       Intended for internal use instead of Brush.Color if possible
       to avoid using it. }
    fTmpBrushColorRGB: TColor;
    { }
    fMembersCount: Integer;
    {* Memebers count is first used in XCustomControl to separate
       some internal child controls from common XControl.Children
       and make it invisible among Children[]. }
    fDrawCtrl1st: PControl;
    {* Child control to draw it first, i.e. foreground of others. }
    FCreating: Boolean;
    {* True, when creating of object is in progress. }
    fDestroying: Boolean;
    {* True, when destroying of the window is started. Made protected to
       be accessible in descending classes. }
    fMenu: HMenu;
    {* Usually used to store handle of attached main menu, but sometimes
       is used to store control ID (for standard GUI controls only). }
    fMenuObj: PObj;
    {* PMenu pointer to TMenu object. Freed automatically with entire
       chain of menu objects attached to a control (or form). }
    fAccelTable: HAccel;
    {* Handle of accelerator table created by menu(s). }
    fImageList: PImageList;
    {* Pointer to first private image list. Control can own several image,
       lists, linked to a chain of image list objects. All these image lists
       are released automatically, when control is destroyed. }
    fCtlImageListSml: PImageList;
    {* ImageList object (with small icons 16x16) to use with a control (e.g.,
       with ListView control).
       If not set, but control has a list of image list objects, last added
       image list with small icons is used automatically. }
    fCtlImageListNormal: PImageList;
    {* ImageList object (with big icons 32x32) to use with a control.
       If not set, last added image list with big icons is used. }
    fCtlImgListState: PImageList;
    {* ImageList object to use as a state image list (for ListView control). }
    fIsApplet: Boolean;
    {* True, if the object represent application taskbar button. }
    fIsForm: Boolean;
    {* True, if the object is form. }
    fIsMDIChild: Boolean;
    {* TRUE, if the object is MDI child form. }
    fIsControl: Boolean;
    {* True, if it is a control on form. }
    fIsStaticControl: Boolean;
    {* True, if it is static control with a caption. (To prevent flickering
       it in DoubleBuffered mode. }
    fIsCommonControl: Boolean;
    {* True, if it is common control. }
    fChangedPosSz: Byte;
    {* Flags of changing left (1), top (2), width (4) or height (8) }
    fCannotDoubleBuf: Boolean;
    {* True, if cannot set DoubleBuffered to True (RichEdit). }
    fUpdRgn: HRgn;
    fCollectUpdRgn: HRGN;
    fEraseUpdRgn: Boolean;
    fPaintDC: HDC;
    fDblBufBmp: HBitmap;
    {* Memory bitmap, used for DoubleBuffered painting. }
    fDblBufW, fDblBufH: Integer;
    {* Dimensions of fDblBufBmp. }
    fDblBufPainting: Boolean;
    fLookTabKeys: TTabKeys;
    fNotUpdate: Boolean;
    fDynHandlers: PList;
    fColumn: Integer;
    FSupressTab: Boolean;
    fUpdateCount: Integer;
    fPaintLater: Boolean;
    fOnLeave: TOnEvent;
    fEditing: Boolean;
    fAutoPopupMenu: PObj;
    fHelpContext: Integer;

    // Order of following fields is important:
    //_______________________________________________________________________________________________
    fOnDynHandlers: TWindowFunc;                                                                   //
    fWndProcKeybd: function( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;         //
    fControlClick: procedure( Sender : PObj );                                                     //
    fControlClassName: PChar;                                                                      //
    fWindowed: Boolean;                                                                            //
    {* True, if control is windowed (or is a form). Now always True,                               //
       because KOL does not yet contain Graphic controls. }                                        //
    //                                                                                             //
    fCtlClsNameChg: Boolean;                                                                       //
    {* True, if control class name changed and memory is allocated to store it. }                  //
    fWndProcResizeFlicks: function( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;  //
    fGotoControl: function( Self_: PControl; Key: DWORD; CheckOnly: Boolean ): Boolean;            //
    fCtl3Dchild: Boolean;                                                                          //
    fCtl3D: Boolean;                                                                               //
    fTextColor: TColor;                                                                            //
    {* Color of text. Used instead of fFont.Color internally to                                    //
       avoid usage of Font object if user is not accessing and changing it. }                      //
    fFont: PGraphicTool;                                                                           //
    fColor: TColor;                                                                                //
    {* Color of control background. }                                                              //
    fBrush: PGraphicTool;                                                                          //
    fMargin: Integer;                                                                              //
    fBoundsRect: TRect;                                                                            //
    fClientTop, fClientBottom, fClientLeft, fClientRight: Integer;                                 //
    {* Store adjustment factor of ClientRect for some 'idiosincrasies' windows,                    //
       such as Groupbox or Tabcontrol. }                                                           //
    //_____________________________________________________________________________________________//
    // this is the end of fiels set, which order is important

    fDoubleBuffered: Boolean;                                                                      //
    fTransparent: Boolean;                                                                         //

    fOnMessage: TOnMessage;
    fOldOnMessage: TOnMessage;

    fOnClick: TOnEvent;
    fRightClick: Boolean;
    fCurrentControl: PControl;
    fCreateVisible, fCreateHidden: Boolean;
    fRadio1st, fRadioLast : THandle;
    fDropDownProc: procedure( Sender : PObj );
    fDropped: Boolean;
    fCurIdxAtDrop: Integer;
    fPrevWndProc: Pointer;
    fClickDisabled: Byte;
    fCurItem, fCurIndex: Integer;
    FOnScroll: TOnScroll;
    FScrollLineDist: array[ 0..1 ] of Integer;

    fDefaultBtn: Boolean;
    fCancelBtn: Boolean;
    fDefaultBtnCtl: PControl;
    fCancelBtnCtl: PControl;
    fAllBtnReturnClick: Boolean;
    fIgnoreDefault: Boolean;

    fOnMouseDown: TOnMouse; // CAUTION!!! Order of mouse event handlers is important. ____
    fOnMouseUp: TOnMouse;                                                               //
    fOnMouseMove: TOnMouse;                                                             //
    fOnMouseDblClk: TOnMouse;                                                           //
    fOnMouseWheel: TOnMouse;     //_____________________________________________________//

    fOldDefWndProc: Pointer;

    fOnChange: TOnEvent;
    fOnEnter: TOnEvent;

    FOnLVCustomDraw: TOnLVCustomDraw;
  protected
    procedure SetOnLVCustomDraw(const Value: TOnLVCustomDraw);
  public
    fCommandActions: TCommandActions;
  protected
    fOnChar: TOnChar;
    fOnKeyUp: TOnKey;
    fOnKeyDown: TOnKey;

    fOnPaint: TOnPaint;

    FMaxWidth: Integer;
    FMinWidth: Integer;
    FMaxHeight: Integer;
    FMinHeight: Integer;
    fShadowDeep: Integer;
    fStatusCtl: PControl;
    fStatusWnd: HWnd;
    fStatusTxt: PChar;
    fColor1: TColor;
    fColor2: TColor;
    fLVColCount: Integer;
    fLVOptions: TListViewOptions;
    fLVStyle: TListViewStyle;
    fOnEditLVITem: TOnEditLVItem;
    fLVTextBkColor: TColor;

    fOnDropDown: TOnEvent;
    fOnCloseUp: TOnEvent;

    fModalResult: Integer;

    fModal: Integer;
    fModalForm: PControl;

    FAlign: TControlAlign;
    fNotUseAlign: Boolean;
    fDragCallback: TOnDrag;
    fDragging: Boolean;
    fDragStartPos: TPoint;
    fMouseStartPos: TPoint;
    fSplitStartPos: TPoint;
    fSplitStartPos2: TPoint;
    fSplitStartSize: Integer;
    fSplitMinSize1, fSplitMinSize2: Integer;
    fOnSplit: TOnSplit;
    fSecondControl: PControl;
    fOnSelChange: TOnEvent;
    fTmpFont: PGraphicTool;

    fRECharFormatRec: TCharFormat2;
    fREError: Integer;
    fREStream: PStream;
    fREStrLoadLen: DWORD;
    fREParaFmtRec: TParaFormat2;
    FOnResize: TOnEvent;
    fOnProgress: TOnEvent;
    fCharFmtDeltaSz: Integer;
    fParaFmtDeltaSz: Integer;
    fREOvr: Boolean;
    fReOvrDisable: Boolean;
    fOnREInsModeChg: TOnEvent;
    fREScrolling: Boolean;
    fUpdCount: Integer;
    fOnREOverURL: TOnEvent;
    fOnREURLClick: TOnEvent;
    fRECharArea: TRichFmtArea;
    fBitBtnOptions : TBitBtnOptions;
    fGlyphLayout : TGlyphLayout;
    fGlyphBitmap : HBitmap;
    fGlyphCount : Integer;
    fGlyphWidth, fGlyphHeight: Integer;
    fOnBitBtnDraw: TOnBitBtnDraw;
    fFlat: Boolean;
    fSizeRedraw: Boolean; {YS}

    fOnMouseLeave: TOnEvent;
    fOnMouseEnter: TOnEvent;
    fOnTestMouseOver: TOnTestMouseOver;

    fMouseInControl: Boolean;
    fRepeatInterval: Integer;
    fChecked: Boolean;
    fPrevFocusWnd: HWnd;

    fOnTVBeginDrag: TOnTVBeginDrag;
    fOnTVBeginEdit: TOnTVBeginEdit;
    fOnTVEndEdit: TOnTVEndEdit;
    fOnTVExpanded: TOnTVExpanded;
    fOnTVExpanding: TOnTVExpanding;
    fOnTVDelete: TOnTVDelete;

    fOnDeleteLVItem: TOnDeleteLVItem;
    fOnDeleteAllLVItems: TOnEvent;
    fOnLVData: TOnLVData;
    {$IFNDEF _FPC}
    {$IFNDEF _D2}
    fOnLVDataW: TOnLVDataW;
    {$ENDIF _D2}
    {$ENDIF _FPC}
    fOnCompareLVItems: TOnCompareLVItems;
    fOnColumnClick: TOnLVColumnClick;
    fOnDrawItem: TOnDrawItem;
    fOnMeasureItem: TOnMeasureItem;
    fREUrl: String;
    FMinimizeWnd: PControl;
    FFixWidth: Integer;
    FFixHeight: Integer;
    FOnDropFiles: TOnDropFiles;
    FOnHide: TOnEvent;
    FOnShow: TOnEvent;
    fOnEraseBkgnd: TOnPaint;
    fCustomData: Pointer;
    fCustomObj: PObj;
    fOnTVSelChanging: TOnTVSelChanging;

    fOnClose: TOnEventAccept;
    fOnQueryEndSession: TOnEventAccept;
    fCloseQueryReason: TCloseQueryReason;

    //----- order of following 3 events important: //
    fOnMinimize: TOnEvent;                         //
    fOnMaximize: TOnEvent;                         //
    fOnRestore: TOnEvent;                          //
    //---------------------------------------------//

    //fCreateParamsExt: procedure( Self_: PControl; var Params: TCreateParams );
    fCreateWndExt: procedure( Sender: PControl );

    fTBttCmd: PList;
    fTBttTxt: PStrList;
    fTBevents: PList; // events for TBAssignEvents
    fTBBtnImgWidth: Integer; // custom toolbar bitmap width
    FTBBtMinWidth: Integer;
    FTBBtMaxWidth: Integer;
    fGradientStyle: TGradientStyle;
    fGradientLayout: TGradientLayout;
    fVisibleWoParent: Boolean;


    fTVRightClickSelect: Boolean;
    FOnMove: TOnEvent;
    FOnLVStateChange: TOnLVStateChange;
    FOnLVDelete: TOnLVDelete;
    fAutoSize: procedure( Self_: PControl );
    fIsButton: Boolean;
    fSizeGrip: Boolean;
    fNotAvailable: Boolean;
    FPressedMnemonic: DWORD;
    FBitBtnDrawMnemonic: Boolean;
    FBitBtnGetCaption: function( Self_: PControl; const S: String ): String;
    FBitBtnExtDraw: procedure( Self_: PControl; DC: HDC; X, Y: Integer; const R: TRect;
                    const CapText, CapTxtOrig: String; Color: TColor );
    FTextShiftX, FTextShiftY: Integer;
    fNotifyChild: procedure( Self_, Child: PControl );
    fScrollChildren: procedure( Self_: PControl );
    fOnHelp: TOnHelp;

    {$IFDEF USE_MHTOOLTIP}
    {$DEFINE var}
    {$I KOLMHToolTip}
    {$UNDEF var}

    {$DEFINE function}
    {$I KOLMHToolTip}
    {$UNDEF function}
    {$ENDIF}

    procedure Init; override;
    {* }
    procedure InitParented( AParent: PControl ); virtual;
    {* Initialization of visual object. }
    procedure DestroyChildren;
    {* Destroys children. Is called in destructor, and can be
       called in descending classes as earlier as needed to
       prevent problems of too late destroying of visuals. }

    function GetParentWnd( NeedHandle: Boolean ): HWnd;
    {* Returns handle of parent window. }
    function GetParentWindow: HWnd;
    {* }
    procedure SetEnabled( Value: Boolean );
    {* Changes Enabled property value. Overriden here to change enabling
       status of a window. }
    function GetEnabled: Boolean;
    {* Returns True, if Enabled. Overriden here to obtain real window
       state. }
    procedure SetVisible( Value: Boolean );
    {* Sets Visible property value. Overriden here to change visibility
       of correspondent window. }
    procedure Set_Visible( Value: Boolean );
    {* }
    function GetVisible: Boolean;
    {* Returns True, if correspondent window is Visible. Overriden
       to get visibility of real window, not just value stored in object. }
    function Get_Visible: Boolean;
    {* Returns True, if correspondent window is Visible, for forms and applet,
       or if fVisible flag is set, for controls. }
    procedure SetCtlColor( Value: TColor );
    {* Sets TControl's Color property value. }
    procedure SetBoundsRect( const Value: TRect );
    {* Sets BoudsRect property value. }
    function GetBoundsRect: TRect;
    {* Returns bounding rectangle. }
    function GetIcon: HIcon;
    {* Returns Icon property. By default, if it is not set,
       returns Icon property of an Applet. }

    procedure CreateSubclass( var Params: TCreateParams; ControlClassName: PChar );
    {* Can be used in descending classes to subclass window with given
       standard Windows ControlClassName - must be called after
       creating Params but before CreateWindow. Usually it is called
       in overriden method CreateParams after calling of the inherited one. }

    function UpdateWndStyles: PControl;
    {* Updates fStyle, fExStyle, fClsStyle from window handle }
    procedure SetOnChar(const Value: TOnChar);
    {* }
    procedure SetOnKeyDown(const Value: TOnKey);

    {* }
    procedure SetOnKeyUp(const Value: TOnKey);
    {* }
    procedure SetMouseDown(const Value: TOnMouse);
    {* }
    procedure SetMouseMove(const Value: TOnMouse);
    {* }
    procedure SetMouseUp(const Value: TOnMouse);
    {* }
    procedure SetMouseWheel(const Value: TOnMouse);
    {* }
    procedure SetMouseDblClk(const Value: TOnMouse);
    {* }
    procedure SetHelpContext( Value: Integer );
    {* }
    procedure SetOnTVDelete( const Value: TOnTVDelete );
    {* }
    procedure SetDefaultBtn(const Index: Integer; const Value: Boolean);
    {$IFDEF F_P}
    function GetDefaultBtn(const Index: Integer): Boolean;
    {$ENDIF F_P}
    function DefaultBtnProc( var Msg: TMsg; var Rslt: Integer ): Boolean;
    {* }

  public
    constructor CreateParented( AParent: PControl );
    {* Creates new instance of TControl object, calling InitParented }
    //FormPointer_DoNotUseItPlease_ItIsUsedByMCK: Pointer;
    { ^ no more needed }
    destructor Destroy; override;
    {* Destroyes object. First of all, destructors for all children
       are called. }

    function GetWindowHandle: HWnd;
    {* Returns window handle. If window is not yet created,
       method CreateWindow is called. }
    procedure CreateChildWindows;
    {* Enumerates all children recursively and calls CreateWindow for all
       of these. }
    property Parent: PControl read fParent write SetParent;
    {* Parent of TParent object. Also must be of TParent type or derived from TParent. }
    //property Tag: Integer read FTag write FTag; //--------- moved to TObj --------
    {* User-defined pointer, which can contain any data or reference to
       anywhere in memory (when used as a pointer).
    }
    function ChildIndex( Child: PControl ): Integer;
    {* Returns index of given child. }
    procedure MoveChild( Child: PControl; NewIdx: Integer );
    {* Moves given Child into new position. }

    property Enabled: Boolean read GetEnabled write SetEnabled;
    {* Enabled usually used to decide if control can get keyboard focus
       or been clicked by mouse. }
    procedure EnableChildren( Enable, Recursive: Boolean );
    {* Enables (Enable = TRUE) or disables (Enable = FALSE) all the children
       of the control. If Recursive = TRUE then all the children of all the
       children are enabled or disabled recursively. }
    property Visible: Boolean read Get_Visible write SetVisible;
    {* Obvious. }
    property ToBeVisible: Boolean read GetToBeVisible;
    {* Returns True, if a control is supposed to be visible when its
       form is showing. Thus is, True is returned if either control
       is Visible or hidden, but marked with flag fCreateHidden. }
    property CreateVisible: Boolean read fCreateVisible write fCreateVisible;
    {* False by default. If You want your form to be created visible and
       flick due creation, set it to True. This does not affect size of
       executable anyway. }
    property Align: TControlAlign read FAlign write Set_Align;
    {* Align style of a control. If this property is not used in your
       application, there are no additional code added. Aligning of
       controls is made in KOL like in VCL. To align controls when
       initially create ones, use "transparent" function SetAlign
       ("transparent" means that it returns Self as a result).
       |<br>
       Note, that it is better not to align combobox caClient, caLeft or
       caRight (better way is to place a panel with Border = 0 and
       EdgeStyle = esNone, align it as desired and to place a combobox on it
       aligning caTop or caBottom). Otherwise, big problems could be under
       Win9x/Me, and some delay could occur under any other systems.
       |<br> Do not attempt to align some kinds of controls (like combobox or
       toolbar) caLeft or caRight, this can cause infinite recursion in the
       application. }
    property BoundsRect: TRect read GetBoundsRect write SetBoundsRect;
    {* Bounding rectangle of the visual. Coordinates are relative
       to top left corner of parent's ClientRect, or to top left corner
       of screen (for TForm). }
    property Left: Integer read GetLeft write SetLeft;
    {* Left horizontal position. }
    property Top: Integer read GetTop write SetTop;
    {* Top vertical position. }
    property Width: Integer read GetWidth write SetWidth;
    {* Width of TVisual object. }
    property Height: Integer read GetHeight write SetHeight;
    {* Height of TVisual object. }

    property Position: TPoint read GetPosition write Set_Position;
    {* Represents top left position of the object. See also BoundsRect. }
    property MinWidth: Integer index 0
             {$IFDEF F_P}   read GetConstraint
             {$ELSE DELPHI} read FMinWidth
             {$ENDIF F_P/DELPHI} write SetConstraint;
    {* Minimal width constraint. }
    property MinHeight: Integer index 1
             {$IFDEF F_P}   read GetConstraint
             {$ELSE DELPHI} read FMinHeight
             {$ENDIF F_P/DELPHI} write SetConstraint;
    {* Minimal height constraint. }
    property MaxWidth: Integer index 2
             {$IFDEF F_P}   read GetConstraint
             {$ELSE DELPHI} read FMaxWidth
             {$ENDIF F_P/DELPHI} write SetConstraint;
    {* Maximal width constraint. }
    property MaxHeight: Integer index 3
             {$IFDEF F_P}   read GetConstraint
             {$ELSE DELPHI} read FMaxHeight
             {$ENDIF F_P/DELPHI} write SetConstraint;
    {* Maximal height constraint. }

    function ClientRect: TRect;
    {* Client rectangle of TVisual. Contrary to VCL, for some
       classes (e.g., derived from XCustomControl, can be relative
       not to itself, but to top left corner of the BoundsRect
       rectangle. }
    property ClientWidth: Integer read GetClientWidth write SetClientWidth;
    {* Obvious. Accessing this property, program forces window latent creation. }
    property ClientHeight: Integer read GetClientHeight write SetClientHeight;
    {* Obvious. Accessing this property, program forces window latent creation. }

    function ControlRect: TRect;
    {* Absolute bounding rectangle relatively to nearest
       Windowed parent client rectangle (at least to a form, but usually to
       a Parent).
       Useful while drawing on device context, provided by such
       Windowed parent. For form itself is the same as BoundsRect. }
    function ControlAtPos( X, Y: Integer; IgnoreDisabled: Boolean ): PControl;
    {* Searches TVisual at the given position (relatively to top left
       corner of the ClientRect). }

    procedure Invalidate;
    {* Invalidates rectangle, occupied by the visual (but only if Showing =
       True). }

    procedure InvalidateEx;
    {* Invalidates the window and all its children. }
    procedure InvalidateNC( Recursive: Boolean );
    {* Invalidates the window and all its children including non-client area. }
    procedure Update;
    {* Updates control's window and calls Update for all child controls. }
    procedure BeginUpdate;
    {* |<#treeview>
       |<#listview>
       |<#richedit>
       |<#memo>
       |<#listbox>
       Call this method to stop visual updates of the control until correspondent
       EndUpdate called (pairs BeginUpdate - EndUpdate can be nested). }
    procedure EndUpdate;
    {* See BeginUpdate. }

    property Windowed: Boolean read fWindowed;
    {* Constantly returns True, if object is windowed (i.e. owns
        correspondent window handle). Otherwise, returns False.
        |<br>
        By now, all the controls are windowed (there are no controls in KOL, which are
        emulating window, acually belonging to Parent - like TGraphicControl
        in VCL). }

    function HandleAllocated: Boolean;
    {* Returns True, if window handle is allocated. Has no sense for
       non-Windowed objects (but now, the KOL has no non-Windowed controls). }
    property MDIClient: PControl read fMDIClient;
    {* For MDI forms only: returns MDI client window control, containng all MDI
       children. Use this window to send specific messages to rule MDI children. }

    property ChildCount: Integer read GetChildCount;//GetChildCountWOMembers;
    {* Returns number of commonly accessed child objects (without
       MembersCount). }
    property Children[ Idx: Integer ]: PControl read GetMembers;
    {* Child items of TVisual object. Property is reintroduced here
       to separate access to always visible Children[] from restricted
       a bit Members[]. }
    property MembersCount: Integer read FMembersCount;
    {* Returns number of "internal" child objects, which are
       not accessible through common Children[] property. }
    property Members[ Idx: Integer ]: PControl read GetMembers;
    {* Members and children array of the object (first from 0 to
       MembersCount-1 are Members[], and Children[] are followed by
       them. Usually You do not need to use this list. Use instead
       Children[0..ChildCount] property, Members[] is intended for
       internal needs of XCL (and in KOL by now Members and Children
       actually are the same properties). }

    procedure PaintBackground( DC: HDC; Rect: PRect );
    {* Is called to paint background in given rectangle. This
       method is filling clipped area of the Rect rectangle with
       Color, but only if global event Global_OnPaintBkgnd is
       not assigned. If assigned, this one is called instead here.
       |<br>&nbsp;&nbsp;&nbsp;
       This method made public, so it can be called directly to
       fill some device context's rectangle. But remember, that
       independantly of Rect, top left corner of background piece
       will be located so, if drawing is occure into ControlRect
       rectangle. }
    property WindowedParent: PControl read fParent;
    {* Returns nearest windowed parent, the same as Parent. }

    function ParentForm: PControl;
    {* |<#form>
       Returns parent form for a control (of Self for form itself. }
    property ActiveControl: PControl read fCurrentControl write fCurrentControl;
    {* }
    function Client2Screen( const P: TPoint ): TPoint;
    {* Converts the client coordinates of a specified point to screen coordinates. }
    function Screen2Client( const P: TPoint ): TPoint;
    {* Converts screen coordinates of a specified point to client coordinates. }
    function CreateWindow: Boolean; virtual;
    {* |<#form>
       Creates correspondent window object. Returns True if success (if
       window is already created, False is returned). If applied to a form,
       all child controls also allocates handles that time.
       |<br>&nbsp;&nbsp;&nbsp;
       Call this method to ensure, that a hanle is allocated for a form,
       an application button or a control. (It is not necessary to do so in
       the most cases, even if You plan to work with control's handle directly.
       But immediately after creating the object, if You want to pass its
       handle to API function, this can be helpful). }
    procedure Close;
    {* |<#appbutton>
       |<#form>
       Closes window. If a window is the main form, this closes application,
       terminating it. Also it is possible to call Close method for Applet
       window to stop application. }

    {$IFDEF USE_MHTOOLTIP}
    {$DEFINE public}
    {$I KOLMHToolTip}
    {$UNDEF public}
    {$ENDIF}

    property Handle: HWnd read fHandle; //GetHandle;
    {* Returns descriptor of system window object. If window is not yet
       created, 0 is returned. To allocate handle, call CreateWindow method. }

    property ParentWindow: HWnd read GetParentWindow;
    {* Returns handle of parent window (not TControl object, but system
       window object handle). }
    property ClsStyle: DWord read fClsStyle write SetClsStyle;
    {* Window class style. Available styles are:
       |<table border=0>
       |&L=<tr><td valign=top><font face=Fixedsys>%1</font></td><td>
       |&E=</td></tr>
       |&N=<br>&nbsp;&nbsp;&nbsp;
       <L CS_BYTEALIGNCLIENT> - Aligns the window's client area on the byte boundary
          (in the x direction) to enhance performance during
       drawing operations. <E>
       <L CS_BYTEALIGNWINDOW> - Aligns a window on a byte boundary (in the x
          direction). <E>
       <L CS_CLASSDC> - Allocates one device context to be shared by all
          windows in the class. <E>
       <L CS_DBLCLKS> - Sends double-click messages to the window
          procedure when the user double-clicks the mouse while the
          cursor is within a window belonging to the class. <E>
       <L CS_GLOBALCLASS> - Allows an application to create a window of
          the class regardless of the value of the hInstance parameter.
       <N> You can create a global class by creating
          the window class in a dynamic-link library (DLL) and listing the
          name of the DLL in the registry under specific keys. <E>
       <L CS_HREDRAW> - Redraws the entire window if a movement or
          size adjustment changes the width of the client area. <E>
       <L CS_NOCLOSE>  - Disables the Close command on the System menu. <E>
       <L CS_OWNDC> - Allocates a unique device context for each window
          in the class. <E>
       <L CS_PARENTDC> - Sets the clipping region of the child window to
          that of the parent window so that the child can draw on the parent. <E>
       <L CS_SAVEBITS> - Saves, as a bitmap, the portion of the screen
          image obscured by a window. Windows uses the saved bitmap to re-create
          the screen image when the window is removed. <E>
       <L CS_VREDRAW> - Redraws the entire window if a movement or size
          adjustment changes the height of the client area. <E>
       |</table> For more info, see Win32.hlp (keyword 'WndClass');
    }

    property Style: DWord read fStyle write SetStyle;
    {* Window styles. Available styles are:
       |<table border=0>
       <L WS_BORDER>	Creates a window that has a thin-line border. <E>
       <L WS_CAPTION>	Creates a window that has a title bar (includes the
          WS_BORDER style). <E>
       <L WS_CHILD>	Creates a child window. This style cannot be used with
          the WS_POPUP style. <E>
       <L WS_CHILDWINDOW>	Same as the WS_CHILD style. <E>
       <L WS_CLIPCHILDREN>	Excludes the area occupied by child windows
          when drawing occurs within the parent window. This style is used
          when creating the parent window. <E>
       <L WS_CLIPSIBLINGS>	Clips child windows relative to each other;
          that is, when a particular child window receives a WM_PAINT message,
          the WS_CLIPSIBLINGS style clips all other overlapping child windows
          out of the region of the child window to be updated. If
          WS_CLIPSIBLINGS is not specified and child windows overlap, it is
          possible, when drawing within the client area of a child window,
          to draw within the client area of a neighboring child window. <E>
       <L WS_DISABLED>	Creates a window that is initially disabled. A
          disabled window cannot receive input from the user. <E>
       <L WS_DLGFRAME>	Creates a window that has a border of a style
          typically used with dialog boxes. A window with this style cannot
          have a title bar. <E>
       <L WS_GROUP>	Specifies the first control of a group of controls.
          The group consists of this first control and all  controls defined
          after it, up to the next control with the WS_GROUP style.
          The first control in each group usually has the WS_TABSTOP
          style so that the user can move from group to group. The user
          can subsequently change the keyboard focus from one control in
          the group to the next control in the group by using the direction
          keys. <E>
       <L WS_HSCROLL>	Creates a window that has a horizontal scroll bar. <E>
       <L WS_ICONIC>	Creates a window that is initially minimized. Same as
          the WS_MINIMIZE style. <E>
       <L WS_MAXIMIZE>	Creates a window that is initially maximized. <E>
       <L WS_MAXIMIZEBOX>	Creates a window that has a Maximize button.
          Cannot be combined with the WS_EX_CONTEXTHELP style. The WS_SYSMENU
          style must also be specified. <E>
       <L WS_MINIMIZE>	Creates a window that is initially minimized.
          Same as the WS_ICONIC style. <E>
       <L WS_MINIMIZEBOX>	Creates a window that has a Minimize button.
          Cannot be combined with the WS_EX_CONTEXTHELP style. The WS_SYSMENU
          style must also be specified. <E>
       <L WS_OVERLAPPED>	Creates an overlapped window. An overlapped
          window has a title bar and a border. Same as the WS_TILED style. <E>
       <L WS_OVERLAPPEDWINDOW>	Creates an overlapped window with the
          WS_OVERLAPPED, WS_CAPTION, WS_SYSMENU, WS_THICKFRAME, WS_MINIMIZEBOX,
          and WS_MAXIMIZEBOX styles. Same as the WS_TILEDWINDOW style. <E>
       <L WS_POPUP>	Creates a pop-up window. This style cannot be used with
          the WS_CHILD style. <E>
       <L WS_POPUPWINDOW>	Creates a pop-up window with WS_BORDER,
          WS_POPUP, and WS_SYSMENU styles. The WS_CAPTION and WS_POPUPWINDOW
          styles must be combined to make the window menu visible. <E>
       <L WS_SIZEBOX>	Creates a window that has a sizing border. Same as the
          WS_THICKFRAME style. <E>
       <L WS_SYSMENU>	Creates a window that has a window-menu on its title
          bar. The WS_CAPTION style must also be specified. <E>
       <L WS_TABSTOP>	Specifies a control that can receive the keyboard focus
          when the user presses the TAB key. Pressing the TAB key changes
          the keyboard focus to the next control with the WS_TABSTOP style. <E>
       <L WS_THICKFRAME>	Creates a window that has a sizing border.
          Same as the WS_SIZEBOX style. <E>
       <L WS_TILED>	Creates an overlapped window. An overlapped window has
          a title bar and a border. Same as the WS_OVERLAPPED style. <E>
       <L WS_TILEDWINDOW>	Creates an overlapped window with the
          WS_OVERLAPPED, WS_CAPTION, WS_SYSMENU, WS_THICKFRAME,
          WS_MINIMIZEBOX, and WS_MAXIMIZEBOX styles. Same as the
          WS_OVERLAPPEDWINDOW style. <E>
       <L WS_VISIBLE>	Creates a window that is initially visible. <E>
       <L WS_VSCROLL>	Creates a window that has a vertical scroll bar. <E>
       |</table>
       See also Win32.hlp (topic CreateWindow).
    }
    property ExStyle: DWord read fExStyle write SetExStyle;
    {* Extra window styles. Available flags are following:
       |<table border=0>
       <L WS_EX_ACCEPTFILES>	Specifies that a window created with this style
          accepts drag-drop files. <E>
       <L WS_EX_APPWINDOW>	Forces a top-level window onto the taskbar
          when the window is minimized. <E>
       <L WS_EX_CLIENTEDGE>	Specifies that a window has a border with a
          sunken edge. <E>
       <L WS_EX_CONTEXTHELP>	Includes a question mark in the title bar of
          the window. When the user clicks the question mark, the cursor
          changes to a question mark with a pointer. If the user then clicks
          a child window, the child receives a WM_HELP message. The child
          window should pass the message to the parent window procedure,
          which should call the WinHelp function using the HELP_WM_HELP
          command. The Help application displays a pop-up window that
          typically contains help for the child window.WS_EX_CONTEXTHELP
          cannot be used with the WS_MAXIMIZEBOX or WS_MINIMIZEBOX styles. <E>
       <L WS_EX_CONTROLPARENT> Allows the user to navigate among the child
          windows of the window by using the TAB key. <E>
       <L WS_EX_DLGMODALFRAME> Creates a window that has a double border;
          the window can, optionally, be created with a title bar by
          specifying the WS_CAPTION style in the dwStyle parameter. <E>
       <L WS_EX_LEFT>	Window has generic "left-aligned" properties. This
          is the default. <E>
       <L WS_EX_LEFTSCROLLBAR> If the shell language is Hebrew, Arabic, or
          another language that supports reading order alignment, the
          vertical scroll bar (if present) is to the left of the client
          area. For other languages, the style is ignored and not treated
          as an error. <E>
       <L WS_EX_LTRREADING>	The window text is displayed using Left to
          Right reading-order properties. This is the default. <E>
       <L WS_EX_MDICHILD>	Creates an MDI child window. <E>
       <L WS_EX_NOPARENTNOTIFY>	Specifies that a child window created
          with this style does not send the WM_PARENTNOTIFY message to its
          parent window when it is created or destroyed. <E>
       <L WS_EX_OVERLAPPEDWINDOW>	Combines the WS_EX_CLIENTEDGE and
          WS_EX_WINDOWEDGE styles. <E>
       <L WS_EX_PALETTEWINDOW> Combines the WS_EX_WINDOWEDGE,
          WS_EX_TOOLWINDOW, and WS_EX_TOPMOST styles. <E>
       <L WS_EX_RIGHT> Window has generic "right-aligned" properties.
          This depends on the window class. This style has an effect only
          if the shell language is Hebrew, Arabic, or another language that
          supports reading order alignment; otherwise, the style is
          ignored and not treated as an error. <E>
       <L WS_EX_RIGHTSCROLLBAR> Vertical scroll bar (if present) is to the
          right of the client area. This is the default. <E>
       <L WS_EX_RTLREADING>	If the shell language is Hebrew, Arabic, or
          another language that supports reading order alignment, the
          window text is displayed using Right to Left reading-order
          properties. For other languages, the style is ignored and not
          treated as an error. <E>
       <L WS_EX_STATICEDGE>	Creates a window with a three-dimensional
          border style intended to be used for items that do not accept
          user input. <E>
       <L WS_EX_TOOLWINDOW>	Creates a tool window; that is, a window
          intended to be used as a floating toolbar. A tool window has
          a title bar that is shorter than a normal title bar, and the
          window title is drawn using a smaller font. A tool window does
          not appear in the taskbar or in the dialog that appears when
          the user presses ALT+TAB. <E>
       <L WS_EX_TOPMOST> Specifies that a window created with this style
          should be placed above all non-topmost windows and should stay
          above them, even when the window is deactivated. To add or remove
          this style, use the SetWindowPos function. <E>
       <L WS_EX_TRANSPARENT>	Specifies that a window created with this
          style is to be transparent. That is, any windows that are
          beneath the window are not obscured by the window. A window
          created with this style receives WM_PAINT messages only after
          all sibling windows beneath it have been updated. <E>
       <L WS_EX_WINDOWEDGE>	Specifies that a window has a border with
          a raised edge. <E>
       |</table>
       See also Win32.hlp (topic CreateWindowEx).
    }

    property Cursor: HCursor read fCursor write SetCursor;
    {* Current cursor. For most of controls, sets initially to IDC_ARROW. See
       also ScreenCursor. }
    procedure CursorLoad( Inst: Integer; ResName: PChar );
    {* Loads Cursor from the resource. See also comments for Icon property. }

    property Icon: HIcon read GetIcon write SetIcon;
    {* |<#appbutton>
       |<#form>
       Icon. By default, icon of the Applet is used. To load icon from the
       resource, use IconLoad or IconLoadCursor method - this is more correct, because
       in such case a special flag is set to prevent attempts to destroy
       shared icon object in the destructor of the control. }

    procedure IconLoad( Inst: Integer; ResName: PChar );
    {* |<#appbutton>
       |<#form>
       See Icon property. }
    procedure IconLoadCursor( Inst: Integer; ResName: PChar );
    {* |<#appbutton>
       |<#form>
       Loads Icon from the cursor resource. See also Icon property. }


    property Menu: HMenu read fMenu write SetMenu;

    {* Menu (or ID of control - for standard GUI controls). }
    property HelpContext: Integer read fHelpContext write SetHelpContext;
    {* Help context. }
    function AssignHelpContext( Context: Integer ): PControl;
    {* Assigns HelpContext and returns Self (can be used in initialization
       of a control in a chain of "transparent" calls). }

    procedure CallHelp( Context: Integer; CtxCtl: PControl {; CtlID: Integer} );
    {* Method of a form or Applet. Call it to show help with the given context
       ID. If the Context = 0, help contents is displayed. By default,
       WinHelp is used. To allow using HtmlHelp, call AssignHtmlHelp global
       function. When WinHelp used, HelpPath variable can be assigned directly.
       If HelpPath variable is not assigned, application name
       (and path) is used, with extension replaced to '.hlp'. }

    property HelpPath: String read GetHelpPath write SetHelpPath;
    {* Property of a form or an Applet. Change it to provide custom path to
       WinHelp format help file. If HtmlHelp used, call global procedure
       AssignHtmlHelp instead. }

    property OnHelp: TOnHelp read fOnHelp write fOnHelp;
    {* An event of a form, it is called when F1 pressed or help topic requested
       by any other way. To prevent showing help, nullify Sender. Set Popup to
       TRUE to provide showing help in a pop-up window. It is also possible to
       change Context dynamically. }

    property Caption: String read GetCaption write SetCaption;
    {* |<#appbutton>
       |<#form>
       |<#button>
       |<#bitbtn>
       |<#label>
       |<#wwlabel>
       |<#3dlabel>
       Caption of a window. For standard Windows buttons, labels and so on
       not a caption of a window, but text of the window. }
    property Text: String read GetCaption write SetCaption;
    {* |<#edit>
       |<#memo>
       The same as Caption. To make more convenient with Edit controls. For
       Rich Edit control, use property RE_Text. }
    property SelStart: Integer read GetSelStart write SetSelStart;
    {* |<#edit>
       |<#memo>
       |<#richedit>
       |<#listbox>
       |<#combo>
       Start of selection (editbox - character position, listbox and combobox -
       index of [the first] selected item). }
    property SelLength: Integer read GetSelLength write SetSelLength;
    {* |<#edit>
       |<#memo>
       |<#richedit>
       |<#listbox>
       |<#listview>
       Length of selection (editbox - number of characters selected, multiline
       listbox - number of items selected). }

    property Selection: String read GetSelection write SetSelection;
    {* |<#edit>
       |<#memo>
       |<#richedit>
       Selected text (editbox, richedit) as string. Can be useful to replace
       selection. For rich edit, use RE_Text[ reText, TRUE ], if you want to
       read correctly characters from another locale then ANSI only. }
    procedure SelectAll;
    {* |<#edit>
       |<#memo>
       |<#richedit>
       Makes all the text in editbox or RichEdit, or all items in listbox
       selected. }

    procedure ReplaceSelection( const Value: String; aCanUndo: Boolean );
    {* |<#edit>
       |<#memo>
       |<#richedit>
       Replaces selection (in edit, RichEdit). Unlike assigning new value
       to Selection property, it is possible to specify, if operation can
       be undone. }

    procedure DeleteLines( FromLine, ToLine: Integer );
    {* |<#edit>
       |<#memo>
       |<#richedit>
       Deletes lines from FromLine to ToLine (inclusively, i.e. 0 to 0 deletes
       one line with index 0). Current selection is restored as possible. }
    property CurIndex: Integer read GetCurIndex write SetCurIndex;
    {* |<#listbox>
       |<#combo>
       |<#toolbar>
       Index of current item (for listbox, combobox) or button index pressed
       or dropped down (for toolbar button, and only in appropriate event
       handler call).
       |<br>
       You cannot use it to set or remove a selection in a multiple-selection
       list box, so you should set option loNoExtendSel to true.
       |<br>
       In OnClick event handler, CurIndex has not yet changed. Use OnSelChange
       to respond to selection changes. }

    property Count: Integer read GetItemsCount write SetItemsCount;
    {* |<#listbox>
       |<#combo>
       |<#listview>
       |<#treeview>
       |<#edit>
       |<#memo>
       |<#richedit>
       |<#toolbar>
       Number of items (listbox, combobox, listview) or lines (multiline
       editbox, richedit control) or buttons (toolbar). It is possible to
       assign a value to this property only for listbox control with loNoData
       style and for list view control with lvoOwnerData style (virtual list
       box and list view). }

    property Items[ Idx: Integer ]: String read GetItems write SetItems;
    {* |<#edit>
       |<#listbox>
       |<#combo>
       |<#memo>
       |<#richedit>
       Obvious. Used with editboxes, listbox, combobox. With list view, use
       property LVItems instead. }

    function Item2Pos( ItemIdx: Integer ): Integer;
    {* |<#edit>
       |<#memo>
       Only for edit controls: converts line index to character position. }
    function Pos2Item( Pos: Integer ): Integer;
    {* |<#edit>
       |<#memo>
       Only for edit controls: converts character position to line index. }

    function EditTabChar: PControl;
    {* |<#edit>
       |<#memo>
       Call this method (once) to provide insertion of tab character (code #9)
       when tab key is pressed on keyboard. }

    function IndexOf( const S: String ): Integer;
    {* |<#listbox>
       |<#combobox>
       |<#tabcontrol>
       Works for the most of control types, though some of those
       have its own methods to search given item. If a control is not
       list box or combobox, item is finding by enumerating all
       the Items one by one. See also SearchFor method. }
    function SearchFor( const S: String; StartAfter: Integer; Partial: Boolean ): Integer;
    {* |<#listbox>
       |<#combobox>
       |<#tabcontrol>
       Works for the most of control types, though some of those
       have its own methods to search given item. If a control is not
       list box or combobox, item is finding by enumerating all
       the Items one by one. See also IndexOf method. }


    property ItemSelected[ ItemIdx: Integer ]: Boolean read GetItemSelected write SetItemSelected;
    {* |<#edit>
       |<#memo>
       |<#listbox>
       |<#combo>
       Returns True, if a line (in editbox) or an item (in listbox, combobox) is
       selected.
       Can be set only for listboxes. For listboxes, which are not multiselect, and
       for combo lists, it is possible only to set to True, to change selection. }

    property ItemData[ Idx: Integer ]: DWORD read GetItemData write SetItemData;
    {* |<#listbox>
       |<#combo>
       Access to user-defined data, associated with the item of a list box and
       combo box. }
    property OnDropDown: TOnEvent read fOnDropDown write fOnDropDown;
    {* |<#combo>
       |<#toolbar>
       Is called when combobox is dropped down (or drop-down button of
       toolbar is pressed - see also OnTBDropDown). }
    property OnCloseUp: TOnEvent read fOnCloseUp write fOnCloseUp;
    {* |<#combo>
       Is called when combobox is closed up. When drop down list is closed
       because user pressed "Escape" key, previous selection is restored.
       To test if it is so, call GetKeyState( VK_ESCAPE ) and check, if
       negative value is returned (i.e. Escape key is pressed when event
       handler is calling). }
    property DroppedWidth: Integer read FDroppedWidth write SetDroppedWidth;
    {* |<#combo>
       Allows to change width of dropped down items list for combobox (only!)
       control. }
    property DroppedDown: Boolean read fDropped write SetDroppedDown;
    {* |<#combo>
       Dropped down state for combo box. Set it to TRUE or FALSE to change
       dropped down state. }
    procedure AddDirList( const Filemask: String; Attrs: DWORD );
    {* |<#listbox>
       |<#combo>
       Can be used only with listbox and combobox - to add directory list items,
       filtered by given Filemask (can contain wildcards) and Attrs. Following
       flags can be combined in Attrs:
       |<table border=0>
       |&L=<tr><td>%1</td><td>
       <L DDL_ARCHIVE> Include archived files. <E>
       <L DDL_DIRECTORY> Includes subdirectories. Subdirectory names are
          enclosed in square brackets ([ ]). <E>
       <L DDL_DRIVES> Includes drives. Drives are listed in the form [-x-],
          where x is the drive letter. <E>
       <L DDL_EXCLUSIVE> Includes only files with the specified attributes.
          By default, read-write files are listed even if DDL_READWRITE is
          not specified. Also, this flag needed to list directories only,
          etc. <E>
       <L DDL_HIDDEN> Includes hidden files. <E>
       <L DDL_READONLY> Includes read-only files. <E>
       <L DDL_READWRITE> Includes read-write files with no additional
          attributes. <E>
       <L DDL_SYSTEM> Includes system files. <E>
       </table>
       If the listbox is sorted, directory items will be sorted (alpabetically). }
    property OnBitBtnDraw: TOnBitBtnDraw read fOnBitBtnDraw write fOnBitBtnDraw;
    {* |<#bitbtn>
       Special event for BitBtn. Using it, it is possible to provide
       additional effects, such as highlighting button text (by changing
       its Font and other properties). If the handler returns True, it is
       supposed that it made all drawing and there are no further drawing
       occure. }
    property BitBtnDrawMnemonic: Boolean read FBitBtnDrawMnemonic write SetBitBtnDrawMnemonic;
    {* |<#bitbtn>
       Set this property to TRUE to provide correct drawing of bit btn control
       caption with '&' characters (to remove such characters, and underline
       follow ones). }
    property TextShiftX: Integer read fTextShiftX write fTextShiftX;
    {* |<#bitbtn>
       Horizontal shift for bitbtn text when the bitbtn is pressed. }
    property TextShiftY: Integer read fTextShiftY write fTextShiftY;
    {* |<#bitbtn>
       Vertical shift for bitbtn text when the bitbtn is pressed. }
    property BitBtnImgIdx: Integer read GetBitBtnImgIdx write SetBitBtnImgIdx;
    {* |<#bitbtn>
       BitBtn image index for the first image in list view, used as bitbtn
       image. It is used only in case when BitBtn is created with bboImageList
       option. }
    property BitBtnImgList: THandle read GetBitBtnImageList write SetBitBtnImageList;
    {* |<#bitbtn>
       BitBtn Image list. Assign image list handle to change it. }

    function SetButtonIcon( aIcon: HIcon ): PControl;
    {* |<#button>
       Sets up button icon image and changes its styles. Returns button itself. }
    function SetButtonBitmap( aBmp: HBitmap ): PControl;
    {* |<#button>
       Sets up button icon image and changes its styles. Returns button itself. }

    property OnMeasureItem: TOnMeasureItem read fOnMeasureItem write SetOnMeasureItem;
    {* |<#combo>
       |<#listbox>
       |<#listview>
       This event is called for owner-drawn controls, such as list box, combo box,
       list view with appropriate owner-drawn style. For fixed item height controls
       (list box with loOwnerDrawFixed style, combobox with coOwnerDrawFixed and
       list view with lvoOwnerDrawFixed option) this event is called once. For
       list box with loOwnerDrawVariable style and for combobox with coOwnerDrawVariable
       style this event is called for every item. }

    property DefaultBtn: Boolean index 13
             {$IFDEF F_P}   read GetDefaultBtn
             {$ELSE DELPHI} read fDefaultBtn
             {$ENDIF F_P/DELPHI} write SetDefaultBtn;
    {* |<#button>
       |<#bitbtn>
       Set this property to true to make control clicked when ENTER key is pressed.
       This property uses OnMessage event of the parent form, storing it into
       fOldOnMessage field and calling in chain. So, assign default button
       after setting OnMessage event for the form. }
    property CancelBtn: Boolean index 27
             {$IFDEF F_P}   read GetDefaultBtn
             {$ELSE DELPHI} read fCancelBtn
             {$ENDIF F_P/DELPHI} write SetDefaultBtn;
    {* |<#button>
       |<#bitbtn>
       Set this property to true to make control clicked when escape key is pressed.
       This property uses OnMessage event of the parent form, storing it into
       fOldOnMessage field and calling in chain. So, assign cancel button
       after setting OnMessage event for the form. }
    function AllBtnReturnClick: PControl;
    {* Call this method for a form or any its control to provide clicking
       a focused button when ENTER pressed. By default, a button can be clicked
       only by SPACE key from the keyboard, or by mouse. }
    property IgnoreDefault: Boolean read fIgnoreDefault write fIgnoreDefault;
    {* Change this property to TRUE to ignore default button reaction on
       press ENTER key when a focus is grabbed of the control. Default
       value is different for different controls. By default, DefaultBtn
       ignored in memo, richedit (even if read-only). }


    property Color: TColor read fColor write SetCtlColor;
    {* Property Color is one of the most common for all visual
       elements (like form, control etc.) Please note, that standard GUI button
       can not change its color and the most characteristics of the Font. Also,
       standard button can not become Transparent. Use bitbtn for such purposes.
       Also, changing Color property for some kinds of control has no effect (rich edit,
       list view, tree view, etc.). To solve this, use native (for such controls)
       color property, or call Perform method with appropriate message to set the
       background color. }
    property Font: PGraphicTool read GetFont;
    {* If the Font property is not accessed, correspondent TGraphicTool object
       is not created and its methods are not included into executable. Leaving
       properties Font and Brush untouched can economy executable size a lot. }
    property Brush: PGraphicTool read GetBrush;
    {* If not accessed, correspondent TGraphicTool object is not created
       and its methods are not referenced. See also note on Font property. }

    property Ctl3D: Boolean read fCtl3D write SetCtl3D;
    {* Inheritable from parent controls to child ones. }

    procedure Show;
    {* |<#appbutton>
       |<#form>
       Makes control visible and activates it. }
    function ShowModal: Integer;
    {* |<#form>
       Can be used only with a forms to show it modal. See also global function
       ShowMsgModal.
       |<br>
       To use a form as a modal, it is possible to make it either auto-created
       or dynamically created. For a first case, You (may be prefer to hide a
       form after showing it as a modal:
       !
       !  procedure TForm1.Button1Click( Sender: PObj );
       !  begin
       !    Form2.Form.ShowModal;
       !    Form2.Form.Hide;
       !  end;
       !
       Another way is to create modal form just before showing it (this economies
       system resources):
       !
       !  procedure TForm1.Button1Click( Sender: PObj );
       !  begin
       !    NewForm2( Form2, Applet );
       !    Form2.Form.ShowModal;
       !    Form2.Form.Free; // Never call Form2.Free or Form2.Form.Close
       !  end;               // but always Form2.Form.Free; (!)
       !
       In samples above, You certainly can place any wished code before and after
       calling ShowModal method.
       |<br>
       Do not forget that if You have more than a single form in your project,
       separate Applet object should be used.
       |<br>
       See also ShowModalEx.
       }
    function ShowModalParented( const AParent: PControl ): Integer;
    {* by Alexander Pravdin. The same as ShowModal, but with a certain
       form as a parent. }
    function ShowModalEx: Integer;
    {* The same as ShowModal, but all the windows of current thread are
       disabled while showing form modal. This is useful if KOL form from
       a DLL is used modally in non-KOL application. }
    property ModalResult: Integer read fModalResult write
      {$IFDEF NEW_MODAL}
      SetModalResult;
      {$ELSE}
      fModalResult;
      {$ENDIF}
    {* |<#form>
       Modal result. Set it to value<>0 to stop modal dialog. By agreement,
       value 1 corresponds 'OK', 2 - 'Cancel'. But it is totally by decision
       of yours how to interpret this value. }
    property Modal: Boolean read GetModal;
    {* |<#form>
       TRUE, if the form is shown modal. }
    property ModalForm: PControl read fModalForm write fModalForm;
    {* |<#form>
       |<#appbutton>
       Form currently shown modal from this form or from Applet. }

    procedure Hide;
    {* |<#appbutton>
       |<#form>
       Makes control hidden. }
    property OnShow: TOnEvent read FOnShow write SetOnShow;
    {* Is called when a control or form is to be shown. This event is not fired
       for a form, if its WindowState initially is set to wsMaximized or
       wsMinimized. This behaviour is by design (the window does not receive
       WM_SHOW message in such case). }
    property OnHide: TOnEvent read FOnHide write SetOnHide;
    {* Is called when a control or form becomes hidden. }
    property WindowState: TWindowState read GetWindowState write SetWindowState;
    {* |<#form>
       Window state. }

    property Canvas: PCanvas read GetCanvas;
    {* |<#paintbox>
       Placeholder for Canvas: PCanvas. But in KOL, it is possible to
       create applets without canvases at all. To do so, avoid using
       Canvas and use DC directly (which is passed in OnPaint event). }
    function CallDefWndProc( var Msg: TMsg ): Integer;
    {* Function to be called in WndProc method to redirect message handling
       to default window procedure. }
    function DoSetFocus: Boolean;
    {* Sets focus for Enabled window. Returns True, if success. }

    procedure MinimizeNormalAnimated;
    {* |<#form>
       Apply this method to a main form (not to another form or Applet,
       even when separate Applet control is not used and main form matches it!).
       This provides normal animated visual minimization for the application.
       It therefore has no effect, if animation during minimize/resore is
       turned off by user. }

    property OnMessage: TOnMessage read fOnMessage write fOnMessage;
    {* |<#appbutton>
       |<#form>
       Is called for every message processed by TControl object. And for
       Applet window, this event is called also for all messages, handled by
       all its child windows (forms). }

    function IsMainWindow: Boolean;
    {* |<#appbutton>
       |<#form>
       Returns True, if a window is the main in application (created first
       after the Applet, or matches the Applet). }
    property IsApplet: Boolean read FIsApplet;
    {* Returns true, if the control is created using NewApplet (or CreateApplet).
    }
    property IsForm: Boolean read fIsForm;
    {* Returns True, if the object is form window. }
    property IsMDIChild: Boolean read fIsMDIChild;
    {* Returns TRUE, if the object is MDI child form. In such case, IsForm also
       returns TRUE. }
    property IsControl: Boolean read fIsControl;
    {* Returns True, is the control is control (not form or applet). }
    property IsButton: Boolean read fIsButton;
    {* Returns True, if the control is button-like or containing buttons (button,
       bitbtn, checkbox, radiobox, toolbar). }

    function ProcessMessage: Boolean;
    {* |<#appbutton>
       Processes one message. See also ProcessMessages. }

    procedure ProcessMessages;
    {* |<#appbutton>
       Processes pending messages during long cycle of calculation,
       allowing to window to be repainted if needed and to respond to other
       messages. But if there are no such messages, your application can be
       stopped until such one appear in messages queue. To prevent such
       situation, use method ProcessPendingMessages instead. }

    procedure ProcessMessagesEx;
    {* Version of ProcessMessages, which works always correctly, even if
       the application is minimized or background. }

    procedure ProcessPendingMessages;
    {* |<#appbutton>
       Similar to ProcessMessages, but without waiting of
       message in messages queue. I.e., if there are no pending
       messages, this method immediately returns control to your
       code. This method is better to call during long cycle of
       calculation (then ProcessMessages). }
    procedure ProcessPaintMessages;
    {* }
    function WndProc( var Msg: TMsg ): Integer; virtual;
    {* Responds to all Windows messages, posted (sended) to the
       window, before all other proceeding. You can override it in
       derived controls, but in KOL there are several other ways
       to control message flow of existing controls without deriving
       another costom controls for only such purposes. See OnMessage,
       AttachProc.  }
    property HasBorder: Boolean read GetHasBorder write SetHasBorder;
    {* |<#form>
       Obvious. Form-aware. }

    property HasCaption: Boolean read GetHasCaption write SetHasCaption;
    {* |<#form>
       Obvious. Form-aware. }
    property CanResize: Boolean read GetCanResize write SetCanResize;
    {* |<#form>
       Obvious. Form-aware. }
    property StayOnTop: Boolean read GetStayOnTop write SetStayOnTop;
    {* |<#form>
       Obvious. Form-aware, but can be applied to controls. }
    property Border: Integer read fMargin write fMargin;
    {* |<#form>
       Distance between edges and child controls and between child
       controls by default (if methods PlaceRight, PlaceDown, PlaceUnder,
       ResizeParent, ResizeParentRight, ResizeParentBottom are called).
       |<br>
       Originally was named Margin, now I recommend to use the name 'Border' to
       avoid confusion with MarginTop, MarginBottom, MarginLeft and
       MarginRight properties.
       |<br>
       Initial value is always 2. Border property is used in realigning
       child controls (when its Align property is not caNone), and value
       of this property determines size of borders between edges of children
       and its parent and between aligned controls too.
       |<br>
       See also properties MarginLeft, MarginRight, MarginTop, MarginBottom. }
    function SetBorder( Value: Integer ): PControl;
    {* Assigns new Border value, and returns Self. }

    property Margin: Integer read fMargin write fMargin;
    {* |<#form>
       Old name for property Border. }

    property MarginTop: Integer index 1
             {$IFDEF F_P}   read GetClientMargin
             {$ELSE DELPHI} read fClientTop
             {$ENDIF F_P/DELPHI} write SetClientMargin;
    {* Additional distance between true window client top and logical top of
       client rectangle. This value is added to Top of rectangle, returning
       by property ClientRect. Together with other margins and property Border,
       this property allows to change view of form for case, that Align property
       is used to align controls on parent (it is possible to provide some
       distance from child controls to its parent, and between child controls.
       |<br>
       Originally this property was introduced to compensate incorrect
       ClientRect property, calculated for some types of controls.
       |<br>
       See also properties Border, MarginBottom, MarginLeft, MarginRight. }
    property MarginBottom: Integer index 2
             {$IFDEF F_P}   read GetClientMargin
             {$ELSE DELPHI} read fClientBottom
             {$ENDIF F_P/DELPHI} write SetClientMargin;
    {* The same as MarginTop, but a distance between true window Bottom of
       client rectangle and logical bottom one. Take in attention, that this value
       should be POSITIVE to make logical bottom edge located above true edge.
       |<br>
       See also properties Border, MarginTop, MarginLeft, MarginRight. }
    property MarginLeft: Integer index 3
             {$IFDEF F_P}   read GetClientMargin
             {$ELSE DELPHI} read fClientLeft
             {$ENDIF F_P/DELPHI} write SetClientMargin;
    {* The same as MarginTop, but a distance between true window Left of
       client rectangle and logical left edge.
       |<br>
       See also properties Border, MarginTop, MarginRight, MarginBottom. }
    property MarginRight: Integer index 4
             {$IFDEF F_P}   read GetClientMargin
             {$ELSE DELPHI} read fClientRight
             {$ENDIF F_P/DELPHI} write SetClientMargin;
    {* The same as MarginLeft, but a distance between true window Right of
       client rectangle and logical bottom one. Take in attention, that this value
       should be POSITIVE to make logical right edge located left of true edge.
       |<br>
       See also properties Border, MarginTop, MarginLeft, MarginBottom. }

    property Tabstop: Boolean read fTabstop write fTabstop;
    {* True, if control can be focused using tabulating between controls.
       Set it to False to make control unavailable for keyboard, but only
       for mouse. }

    property TabOrder: Integer read fTabOrder write SetTabOrder;
    {* Order of tabulating of controls. Initially, TabOrder is equal to
       creation order of controls. If TabOrder changed, TabOrder of
       all controls with not less value of one is shifted up. To place
       control before another, assign TabOrder of one to another.
       For example:
       !             Button1.TabOrder := EditBox1.TabOrder;
       In code above, Button1 is placed just before EditBox1 in tabulating
       order (value of TabOrder of EditBox1 is incremented, as well as
       for all follow controls). }

    property Focused: Boolean read GetFocused write SetFocused;
    {* True, if the control is current on form (but check also, what form
       itself is focused). For form it is True, if the form is active (i.e.
       it is foreground and capture keyboard). Set this value to True to make
       control current and focused (if applicable). }

    function BringToFront: PControl;
    {* Changes z-order of the control, bringing it to the topmost level. }
    function SendToBack: PControl;
    {* Changes z-order of the control, sending it to the back of siblings. }
    property TextAlign: TTextAlign read GetTextAlign write SetTextAlign;
    {* |<#label>
       |<#panel>
       |<#button>
       |<#bitbtn>
       |<#edit>
       |<#memo>
       Text horizontal alignment. Applicable to labels, buttons,
       multi-line edit boxes, panels. }
    property VerticalAlign: TVerticalAlign read GetVerticalAlign write SetVerticalAlign;
    {* |<#button>
       |<#label>
       Text vertical alignment. Applicable to buttons and labels. }
    property WordWrap: Boolean read fWordWrap;
    {* TRUE, if this is a label, created using NewWordWrapLabel. }
    property ShadowDeep: Integer read FShadowDeep write SetShadowDeep;
    {* |<#3dlabel>
       Deep of a shadow (for label effect only, created calling NewLabelEffect). }

    property CannotDoubleBuf: Boolean read fCannotDoubleBuf write fCannotDoubleBuf;
    {* }
    property DoubleBuffered: Boolean read fDoubleBuffered write SetDoubleBuffered;
    {* Set it to true for some controls, which are flickering in repainting
       (like label effect). Slow, and requires additional code. This property
       is inherited by all child controls.
       |<br>&nbsp;&nbsp;&nbsp;
       Note: RichEdit control can not become DoubleBuffered. }
    //function IsSelfOrParentDblBuf: Boolean;
    {* Returns true, if DoubleBuffered or one of parents is DoubleBuffered. }
    function DblBufTopParent: PControl;
    {* Returns the topmost DoubleBuffered Parent control. }
    property Transparent: Boolean read fTransparent write SetTransparent;
    {* Set it to true to get special effects. Transparency also uses
       DoubleBuffered and inherited by child controls.
       |<br>&nbsp;&nbsp;&nbsp;
       Please note, that some controls can not be shown properly, when
       Transparent is set to True for it. If You want to make edit control
       transparent (e.g., over gradient filled panel), handle its OnChanged
       property and call there Invalidate to provide repainting of edit
       control content. Note also, that for RichEdit control property
       Transparent has no effect (as well as DoubleBuffered). But special
       property RE_Transparent is designed especially for RichEdit control
       (it works fine, but with great number of flicks while resizing
       of a control). Another note is about Edit control. To allow editing
       of transparent edit box, it is necessary to invalidate it for
       every pressed character. Or, use Ed_Transparent property instead. }

    property Ed_Transparent: Boolean read fTransparent write EdSetTransparent;
    {* |<#edit>
       |<#memo>
       Use this property for editbox to make it really Transparent. Remember,
       that though Transparent property is inherited by child controls from
       its parent, this is not so for Ed_Transparent. So, it is necessary to
       set Ed_Transparent to True for every edit control explicitly. }
    property AlphaBlend: Integer read fAlphaBlend write SetAlphaBlend;
    {* |<#form>
       If assigned to 0..254, makes window (form or control) semi-transparent
       (Win2K only).
       |<br>
       Depending on value assigned, it is possible to adjust transparency
       level ( 0 - totally transparent, 255 - totally opaque).  }

    property LookTabKeys: TTabKeys read fLookTabKeys write fLookTabKeys;
    {* Set of keys which can be used as tabulation keys in a control. }
    procedure GotoControl( Key: DWORD );
    {* |<#form>
       Emulates tabulation key press w/o sending message to current control.
       Can be applied to a form or to any its control. If VK_TAB is used,
       state of shift kay is checked in: if it is pressed, tabulate is in
       backward direction. }
    property SubClassName: String read get_ClassName write set_ClassName;
    {* Name of window class - unique for every window class
       in every run session of a program. }

    property OnClose: TOnEventAccept read fOnClose write fOnClose;
    {* |<#form>
       |<#applet>
       Called before closing the window. It is possible to set Accept
       parameter to False to prevent closing the window. This event events
       is not called when windows session is finishing (to handle this
       event, handle WM_QUERYENDSESSION message, or assign OnQueryEndSession
       event to another or the same event handler). }

    property OnQueryEndSession: TOnEventAccept read fOnQueryEndSession write SetOnQueryEndSession;
    {* |<#form>
       |<#applet>
       Called when WM_QUERYENDSESSION message come in. It is possible to set Accept
       parameter to False to prevent closing the window (in such case session ending
       is halted). It is possible to check CloseQueryReason property to find out,
       why event occur. }
    property CloseQueryReason: TCloseQueryReason read fCloseQueryReason;
    {* Reason why OnClose or OnQueryEndSession called. }
    property OnMinimize: TOnEvent index 0
             {$IFDEF F_P}   read GetOnMinMaxRestore
             {$ELSE DELPHI} read fOnMinimize
             {$ENDIF F_P/DELPHI} write SetOnMinMaxRestore;
    {* |<#form>
       Called when window is minimized. }
    property OnMaximize: TOnEvent index 8
             {$IFDEF F_P}   read GetOnMinMaxRestore
             {$ELSE DELPHI} read fOnMaximize
             {$ENDIF F_P/DELPHI} write SetOnMinMaxRestore;
    {* |<#form>
       Called when window is maximized. }
    property OnRestore: TOnEvent index 16
             {$IFDEF F_P}   read GetOnMinMaxRestore
             {$ELSE DELPHI} read fOnRestore
             {$ENDIF F_P/DELPHI} write SetOnMinMaxRestore;
    {* |<#form>
       Called when window is restored from minimized or maximized state. }

    property UpdateRgn: HRgn read fUpdRgn;
    {* A handle of update region. Valid only in OnPaint method. You
       can use it to improve painting (for speed), if necessary. When
       UpdateRgn is obtained in response to WM_PAINT message, value
       of the property EraseBackground is used to pass it to the API
       function GetUpdateRgn. If UpdateRgn = 0, this means that entire
       window should be repainted. Otherwise, You (e.g.) can check
       if the rectangle is in clipping region using API function
       RectInRegion. }

    property EraseBackground: Boolean read fEraseUpdRgn write fEraseUpdRgn;
    {* This value is used to pass it to the API function GetUpdateRgn,
       when UpadateRgn property is obtained first in responce to WM_PAINT
       message. If EraseBackground is set to True, system is responsible
       for erasing background of update region before painting. If not
       (default), the entire region invalidated should be painted by your
       event handler. }

    property OnPaint: TOnPaint read fOnPaint write SetOnPaint;
    {* Event to set to override standard control painting. Can be applied
       to any control (though originally was designed only for paintbox
       control). When an event handler is called, it is possible to use
       UpdateRgn to examine what parts of window require painting to
       improve performance of the painting operation. }


    property OnEraseBkgnd: TOnPaint read fOnEraseBkgnd write SetOnEraseBkgnd;
    {* This event allows to override erasing window background in response
       to WM_ERASEBKGND message. This allows to add some decorations to
       standard controls without overriding its painting in total.
       Note: When erase background, remember, that property ClientRect can
       return not true client rectangle of the window - use GetClientRect
       API function instead. For example:
    !
    !var BkBmp: HBitmap;
    !
    !procedure TForm1.KOLForm1FormCreate(Sender: PObj);
    !begin
    !  Toolbar1.OnEraseBkgnd := DecorateToolbar;
    !  BkBmp := LoadBitmap( hInstance, 'BK1' );
    !end;
    !
    !procedure TForm1.DecorateToolbar(Sender: PControl; DC: HDC);
    !var CR: TRect;
    !begin
    !  GetClientRect( Sender.Handle, CR );
    !  Sender.Canvas.Brush.BrushBitmap := BkBmp;
    !  Sender.Canvas.FillRect( CR );
    !end;
    !
     }


    property OnClick: TOnEvent read fOnClick write fOnClick;
    {* |<#button>
       |<#checkbox>
       |<#radiobox>
       |<#toolbar>
       Called on click at control. For buttons, checkboxes and radioboxes
       is called regadless if control clicked by mouse or keyboard. For toolbar,
       the same event is used for all toolbar buttons and toolbar itself.
       To determine which toolbar button is clicked, check CurIndex property.
       And note, that all the buttons including separator buttons are enumerated
       starting from 0. Though images are stored (and prepared) only for
       non-separator buttons. And to determine, if toolbar button was clicked
       with right mouse button, check RightClick property. }
    property RightClick: Boolean read fRightClick;
    {* |<#toolbar>
       |<#listview>
       Use this property to determine which mouse button was clicked
       (applicable to toolbar in the OnClick event handler). }
    property OnEnter: TOnEvent read fOnEnter write fOnEnter;
    {* Called when control receives focus. }
    property OnLeave: TOnEvent read fOnLeave write fOnLeave;
    {* Called when control looses focus. }
    property OnChange: TOnEvent read fOnChange write fOnChange;
    {* |<#edit>
       |<#memo>
       |<#listbox>
       |<#combo>
       |<#tabcontrol>
       Called when edit control is changed, or selection in listbox or
       current index in combobox is changed (but if OnSelChanged assigned,
       the last is called for change selection). To respond to check/uncheck
       checkbox or radiobox events, use OnClick instead. }
    property OnSelChange: TOnEvent read fOnSelChange write fOnSelChange;
    {* |<#richedit>
       |<#listbox>
       |<#combo>
       |<#treeview>
       Called for rich edit control, listbox, combobox or treeview when current selection
       (range, or current item) is changed. If not assigned, but OnChange is
       assigned, OnChange is called instead. }
    property OnResize: TOnEvent read FOnResize write SetOnResize;
    {* Called whenever control receives message WM_SIZE (thus is, if
       control is resized. }
    property OnMove: TOnEvent read FOnMove write SetOnMove;
    {* Called whenever control receives message WM_MOVE (i.e. when control is
       moved over its parent). }

    property MinSizePrev: Integer read fSplitMinSize1 write fSplitMinSize1;
    {* |<#splitter>
       Minimal allowed (while dragging splitter) size of previous control
       for splitter (see NewSplitter). }
    property SplitMinSize1: Integer read fSplitMinSize1 write fSplitMinSize1;
    {* The same as MinSizePrev. }
    property MinSizeNext: Integer read fSplitMinSize2 write fSplitMinSize2;
    {* |<#splitter>
       Minimal allowed (while dragging splitter) size of the rest of parent
       of splitter or of SecondControl (see NewSplitter). }
    property SplitMinSize2: Integer read fSplitMinSize2 write fSplitMinSize2;
    {* The same as MinSizeNext. }
    property SecondControl: PControl read fSecondControl write fSecondControl;
    {* |<#splitter>
       Second control to check (while dragging splitter) if its size not less
       than SplitMinSize2 (see NewSplitter). By default, second control is
       not necessary, and needed only in rare case when SecondControl can not
       be determined automatically to restrict splitter right (bottom) position. }
    property OnSplit: TOnSplit read fOnSplit write fOnSplit;
    {* |<#splitter>
       Called when splitter control is dragging - to allow for
       your event handler to decide if to accept new size of
       left (top) control, and new size of the rest area of parent. }
    property Dragging: Boolean read FDragging;
    {* |<#splitter>
       True, if splitter control is dragging now by user with left
       mouse button. Also, this property can be used to detect if the control
       is dragging with mouse (after calling DragStartEx method). }
    procedure DragStart;
    {* Call this method for a form or control to drag it with left mouse button,
       when mouse left button is already down. Dragging is stopped when left mouse
       button is released. See also DragStartEx, DragStopEx. }
    procedure DragStartEx;
    {* Call this method to start dragging the form by mouse. To stop
       dragging, call DragStopEx method. (Tip: to detect mouse up event,
       use OnMouseUp event of the dragging control). This method can be used
       to move any control with the mouse, not only entire form. State of
       mouse button is not significant. Determine dragging state of the control
       checking its Dragging property. }
    procedure DragStopEx;
    {* Call this method to stop dragging the form (started by DragStopEx). }
    procedure DragItem( OnDrag: TOnDrag );
    {* Starts dragging something with mouse. During the process,
       callback function OnDrag is called, which allows to control
       drop target, change cursor shape, etc. }

    property OnKeyDown: TOnKey read fOnKeyDown write SetOnKeyDown;
    {* Obvious. }
    property OnKeyUp: TOnKey read fOnKeyUp write SetOnKeyUp;
    {* Obvious. }
    property OnChar: TOnChar read fOnChar write SetOnChar;
    {* Obvious. }

    property OnMouseDown: TOnMouse read fOnMouseDown write SetMouseDown;
    {* Obvious. }
    property OnMouseUp: TOnMouse read fOnMouseUp write SetMouseUp;
    {* Obvious. }
    property OnMouseMove: TOnMouse read fOnMouseMove write SetMouseMove;
    {* Obvious. }
    property OnMouseDblClk: TOnMouse read fOnMouseDblClk write SetMouseDblClk;
    {* Obvious. }
    property OnMouseWheel: TOnMouse read fOnMouseWheel write SetMouseWheel;
    {* Obvious. }

    property OnMouseEnter: TOnEvent read fOnMouseEnter write SetOnMouseEnter;
    {* Is called when mouse is entered into control. See also OnMouseLeave. }
    property OnMouseLeave: TOnEvent read fOnMouseLeave write SetOnMouseLeave;
    {* Is called when mouse is leaved control. If this event is assigned,
       then mouse is captured on mouse enter event to handle all other
       mouse events until mouse cursor leaves the control. }
    property OnTestMouseOver: TOnTestMouseOver read fOnTestMouseOver write SetOnTestMouseOver;
    {* |<#bitbtn>
       Special event, which allows to extend OnMouseEnter / OnMouseLeave
       (and also Flat property for BitBtn control). If a handler is assigned
       to this event, actual testing whether mouse is in control or not,
       is occuring in the handler. So, it is possible to simulate more
       careful hot tracking for controls with non-rectangular shape (such
       as glyphed BitBtn control). }

    property MouseInControl: Boolean read fMouseInControl;
    {* |<#bitbtn>
       This property can return True only if OnMouseEnter / OnMouseLeave
       event handlers are set for a control (or, for BitBtn, property Flat
       is set to True. Otherwise, False is returned always. }

    property Flat: Boolean read fFlat write SetFlat;
    {* |<#bitbtn>
       Set it to True for BitBtn, to provide either flat border for a button
       or availability of "highlighting" (correspondent to glyph index 4).
       |<br>
       Note: this can work incorrectly a bit under win95 without comctl32.dll
       updated. Therefore, application will launch. To enforce correct working
       even under Win95, use your own timer, which event handler checks for
       mouse over bitbtn control, e.g.:
       !    procedure TForm1.Timer1Timer(Sender: PObj);
       !    var P: TPoint;
       !    begin
       !      if not BitBtn1.MouseInControl then Exit;
       !      GetCursorPos( P );
       !      P := BitBtn1.Screen2Client( P );
       !      if not PtInRect( BitBtn1.ClientRect, P ) then
       !      begin
       !        BitBtn1.Flat := FALSE;
       !        BitBtn1.Flat := TRUE;
       !      end;
       !    end;
    }
    property RepeatInterval: Integer read fRepeatInterval write fRepeatInterval;
    {* |<#bitbtn>
       If this property is set to non-zero, it is interpreted (for BitBtn
       only) as an interval in milliseconds between repeat button down events,
       which are generated after first mouse or button click and until
       button is released. Though, if the button is pressed with keyboard (with
       space key), RepeatInterval value is ignored and frequency of repeatitive
       clicking is determined by user keyboard settings only. }
    function LikeSpeedButton: PControl;
    {* |<#button>
       |<#bitbtn>
       Transparent method (returns control itself). Makes button not focusable. }

    function Add( const S: String ): Integer;
    {* |<#listbox>
       |<#combo>
       Only for listbox and combobox. }

    function Insert( Idx: Integer; const S: String ): Integer;
    {* |<#listbox>
       |<#combo>
       Only for listbox and combobox. }
    procedure Delete( Idx: Integer );
    {* |<#listbox>
       |<#combo>
       Only for listbox and combobox. }
    procedure Clear;
    {* Clears object content. Has different sense for different controls.
       E.g., for label, editbox, button and other simple controls it
       assigns empty string to Caption property. For listbox, combobox,
       listview it deletes all items. For toolbar, it deletes all buttons.
       Et so on. }

    property Progress: Integer index ((PBM_SETPOS or $8000) shl 16) or PBM_GETPOS
                               read GetIntVal write SetIntVal;
    {* |<#progressbar>
       Only for ProgressBar. }
    property MaxProgress: Integer index ((PBM_SETRANGE32 or $8000) shl 16) or PBM_GETRANGE
                               read GetIntVal write SetMaxProgress;
    {* |<#progressbar>
       Only for ProgressBar. 100 is the default value. }
    property ProgressColor: TColor read fTextColor write SetProgressColor;
    {* |<#progressbar>
       Only for ProgressBar. }
    property ProgressBkColor: TColor read fColor write SetCtlColor; //SetProgressBkColor;
    {* |<#progressbar>
       Obsolete. Now the same as Color. }

    property StatusText[ Idx: Integer ]: PChar read GetStatusText write SetStatusText;
    {* |<#form>
       Only for forms to set/retrieve status text to/from given status panel.
       Panels are enumerated from 0 to 254, 255 is to indicate simple
       status bar. Size grip in right bottom corner of status window is
       displayed only if form still CanResize.
       |<br>
       When a status text is set first time, status bar window is created
       (always aligned to bottom), and form is resizing to preset client height.
       While status bar is showing, client height value is returned without
       height of status bar. To remove status bar, call RemoveStatus method for
       a form.
       |<br>
       By default, text is left-aligned within the specified part of a status
       window. You can embed tab characters (#9) in the text to center or
       right-align it. Text to the right of a single tab character is centered,
       and text to the right of a second tab character is right-aligned.
       |<br>
       If You use separate status bar onto several panels, these automatically
       align its widths to the same value (width divided to number of panels).
       To adjust status panel widths for every panel, use property StatusPanelRightX.
    }
    property SimpleStatusText: PChar index 255 read GetStatusText write SetStatusText;
    {* |<#form>
       Only for forms to set/retrive status text to/from simple status bar.
       Size grip in right bottom corner of status window is displayed only
       if form CanResize.
       |<br>
       When status text set first time, (simple) status bar window is created
       (always aligned to bottom), and form is resizing to preset client height.
       While status bar is showing, client height value is returned without
       height of status bar. To remove status bar, call RemoveStatus method for
       a form.
       |<br>
       By default, text is left-aligned within the specified part of a status
       window. You can embed tab characters (#9) in the text to center or
       right-align it. Text to the right of a single tab character is centered,
       and text to the right of a second tab character is right-aligned.
    }
    property StatusCtl: PControl read fStatusCtl;
    {* Pointer to Status bar control. Can be used to create child controls on
       the status bar. }
    property SizeGrip: Boolean read fSizeGrip write fSizeGrip;
    {* Size grip for status bar. Has effect only before creating window. }

    procedure RemoveStatus;
    {* |<#form>
       Call it to remove status bar from a form (created in result of assigning
       value(s) to StatusText[], SimpleStatusText properties). When status bar is
       removed, form is resized to preset client height. }
    function StatusPanelCount: Integer;
    {* |<#form>
       Returns number of status panels defined in status bar. }
    property StatusPanelRightX[ Idx: Integer ]: Integer read GetStatusPanelX write SetStatusPanelX;
    {* |<#form>
       Use this property to adjust status panel right edges (if the status bar is
       divided onto several subpanels). If the right edge for the last panel is
       set to -1 (by default) it is expanded to the right edge of a form window.
       Otherwise, status bar can be shorter then form width. }
    property StatusWindow: HWND read fStatusWnd;
    {* |<#form>
       Provided for case if You want to use API direct message sending to
       status bar. }

    property Color1: TColor read fColor1 write SetColor1;
    {* |<#gradient>
       Top line color for GradientPanel. }
    property Color2: TColor read fColor2 write SetColor2;
    {* |<#gradient>
       |<#3Dlabel>
       Bottom line color for GradientPanel, or shadow color for LabelEffect.
       (If clNone, shadow color for LabelEffect is calculated as a mix bitween
       TextColor and clBlack). }
    property GradientStyle: TGradientStyle read FGradientStyle write SetGradientStyle;
    {* |<#gradient>
       Styles other then gsVertical and gsHorizontal has effect only for
       gradient panel, created by NewGradientPanelEx. }
    property GradientLayout: TGradientLayout read FGradientLayout write SetGradientLayout;
    {* |<#gradient>
       Has only effect for gradient panel, created by NewGradientPanelEx.
       Ignored for styles gsVertical and gsHorizontal. }

    //======== Image lists (for ListView, TreeView, ToolBar and TabControl):
    property ImageListSmall: PImageList index 16 read GetImgListIdx write SetImgListIdx;
    {* |<#listview>
       Image list with small icons used with List View control. If not set,
       last added (i.e. created with a control as an owner) image list with
       small icons is used. }
    property ImageListNormal: PImageList index 32 read GetImgListIdx write SetImgListIdx;
    {* |<#listview>
       |<#treeview>
       |<#tabcontrol>
       |<#bitbtn>
       Image list with normal size icons used with List View control (or with
       icons for BitBtn, TreeView, ToolBar or TabControl). If not set,
       last added (i.e. created with a control as an owner) image list is used.
       }
    property ImageListState: PImageList index 0 read GetImgListIdx write SetImgListIdx;
    {* |<#listview>
       |<#treeview>
       Image list used as a state images list for ListView or TreeView control. }

    //========
    function SetUnicode( Unicode: Boolean ): PControl;
    {* |<#listview>
       |<#treeview>
       |<#tabcontrol>
       Sets control as Unicode or not. The control itself is returned as for
       other "transparent" functions. A conditional define UNICODE_CTRLS must
       be added to a project to provide handling unicode messages. }

    //======== TabControl-specific properties and methods:
    property Pages[ Idx: Integer ]: PControl read GetPages;
    {* |<#tabcontrol>
       Returns controls, which can be used as parent for controls, placed on
       different pages of a tab control. Use it like in follows example:
       | Label1 := NewLabel( TabControl1.Pages[ 0 ], 'Label1' );
       To find number of pages available, check out Count property of the tab
       control. Pages are enumerated from 0 to Count - 1, as usual. }
    property TC_Pages[ Idx: Integer ]: PControl read GetPages;
    {* |<#tabcontrol>
       The same as above. }
    function TC_Insert( Idx: Integer; const TabText: String; TabImgIdx: Integer ): PControl;
    {* |<#tabcontrol>
       Inserts new tab before given, returns correspondent page control
       (which can be used as a parent for controls to place on the page). }
    procedure TC_Delete( Idx: Integer );
    {* |<#tabcontrol>
       Removes tab from tab control, destroying all its child controls. }
    property TC_Items[ Idx: Integer ]: String read TCGetItemText write TCSetItemText;
    {* |<#tabcontrol>
       Text, displayed on tab control tabs. }
    property TC_Images[ Idx: Integer ]: Integer read TCGetItemImgIDx write TCSetItemImgIdx;
    {* |<#tabcontrol>
       Image index for a tab in tab control. }
    property TC_ItemRect[ Idx: Integer ]: TRect read TCGetItemRect;
    {* |<#tabcontrol>
       Item rectangle for a tab in tab control. }
    procedure TC_SetPadding( cx, cy: Integer );
    {* |<#tabcontrol>
       Sets space padding around tab text in a tab of tab control. }
    function TC_TabAtPos( x, y: Integer ): Integer;
    {* |<#tabcontrol>
       Returns index of tab, found at the given position (relative to
       a client rectangle of tab control). If no tabs found at the
       position, -1 is returned. }
    function TC_DisplayRect: TRect;
    {* |<#tabcontrol>
       Returns rectangle, occupied by a page rather then tab. }
    function TC_IndexOf(const S: String): Integer;
    {* |<#tabcontrol>
       By Mr Brdo. Index of page by its Caption. }
    function TC_SearchFor(const S: String; StartAfter: Integer; Partial: Boolean): Integer;
    {* |<#tabcontrol>
       By Mr Brdo. Index of page by its Caption. }

    //======== ListView style and options:
    property LVStyle: TListViewStyle read fLVStyle write SetLVStyle;
    {* |<#listview>
       ListView style of view. Can be changed at run time. }

    property LVOptions: TListViewOptions read fLVOptions write SetLVOptions;
    {* |<#listview>
       ListView options. Can be changed at run time. }

    property LVTextColor: TColor index LVM_GETTEXTCOLOR
             {$IFDEF F_P}   read LVGetColorByIdx
             {$ELSE DELPHI} read fTextColor
             {$ENDIF F_P/DELPHI} write LVSetColorByIdx;
    {* |<#listview>
       ListView text color. Use it instead of TextColor. }
    property LVTextBkColor: TColor index LVM_GETTEXTBKCOLOR
             {$IFDEF F_P}   read LVGetColorByIdx
             {$ELSE DELPHI} read fLVTextBkColor
             {$ENDIF F_P/DELPHI} write LVSetColorByIdx;
    {* |<#listview>
       ListView background color for text. }
    property LVBkColor: TColor read fColor write SetCtlColor; //LVSetBkColor;
    {* |<#listview>
       ListView background color.  Use it instead of Color. }

    //======== List View columns handling:
    property LVColCount: Integer read fLVColCount;
    {* |<#listview>
       ListView (additional) column count. Value 0 means that there are
       no columns (single item text / icon is used). If You want
       to provide several columns, first call LVColAdd to "insert" column 0,
       i.e. to provide header text for first column (with index 0).
       If there are no column, nothing will be shown in lvsDetail /
       lvsDetailNoHeader view style. }
    procedure LVColAdd( const aText: String; aalign: TTextAlign; aWidth: Integer );
    {* |<#listview>
       Adds new column. Pass 'width' <= 0 to provide default column width.
       'text' is a column header text. }
    {$IFNDEF _FPC}
    {$IFNDEF _D2}
    procedure LVColAddW( const aText: WideString; aalign: TTextAlign; aWidth: Integer );
    {* |<#listview>
       Adds new column (unicode version). }
    {$ENDIF _D2}
    {$ENDIF _FPC}
    procedure LVColInsert( ColIdx: Integer; const aText: String; aAlign: TTextAlign; aWidth: Integer );
    {* |<#listview>
       Inserts new column at the Idx position (1-based column index). }
    {$IFNDEF _FPC}
    {$IFNDEF _D2}
    procedure LVColInsertW( ColIdx: Integer; const aText: WideString; aAlign: TTextAlign; aWidth: Integer );
    {* |<#listview>
       Inserts new column at the Idx position (1-based column index). }
    {$ENDIF _D2}
    {$ENDIF _FPC}
    procedure LVColDelete( ColIdx: Integer );
    {* |<#listview>
       Deletes column from List View }
    property LVColWidth[ Item: Integer ]: Integer index LVM_GETCOLUMNWIDTH
             read GetItemVal write SetItemVal;
    {* |<#listview>
       Retrieves or changes column width. For lvsList view style, the same width
       is returned for all columns (ColIdx is ignored). It is possible to use
       special values to assign to a property:
       |<br> LVSCW_AUTOSIZE - Automatically sizes the column
       |<br> LVSCW_AUTOSIZE_USEHEADER - Automatically sizes the column to fit
       the header text
       |<br>
       To set coumn width in lvsList view mode, column index must be -1
       (and Width to set must be in range 0..32767 always). }
    property LVColText[ Idx: Integer ]: String read GetLVColText write SetLVColText;
    {* |<#listview>
       Allows to get/change column header text at run time. }
    {$IFNDEF _FPC}
    {$IFNDEF _D2}
    property LVColTextW[ Idx: Integer ]: WideString read GetLVColTextW write SetLVColTextW;
    {* |<#listview>
       Allows to get/change column header text at run time. }
    {$ENDIF _D2}
    {$ENDIF _FPC}
    property LVColAlign[ Idx: Integer ]: TTextAlign read GetLVColalign write SetLVColalign;
    {* |<#listview>
       Column text aligning. }
    property LVColImage[ Idx: Integer ]: Integer index LVCF_IMAGE or (24 shl 16) read GetLVColEx write SetLVColEx;
    {* |<#listview>
       Only starting from comctrl32.dll of version 4.70 (IE4+). Allows to
       set an image for list view column itself from the ImageListSmall.
    }
    property LVColOrder[ Idx: Integer ]: Integer index LVCF_ORDER or (28 shl 16) read GetLVColEx write SetLVColEx;
    {* |<#listview>
       Only starting from comctrl32.dll of version 4.70 (IE4+). Allows to
       set visual order of the list view column from the ImageListSmall.
       This value does not affect the index, by which the column is still
       accessible in the column array.
    }

    //======== List View items handling:
    property LVCount: Integer read GetItemsCount write SetItemsCount;
    {* |<#listview>
       Returns item count for ListView control. It is possible to use Count
       property instead when obtaining of item count is needed only. But this this
       property allows also to set actual count of list view items when a list
       view is virtual. }

    property LVCurItem: Integer read GetLVCurItem write SetLVCurItem;
    {* |<#listview>
       Returns first selected item index in a list view. See also LVNextSelected
       and LVNextItem functions. }

    function LVNextItem( IdxPrev: Integer; Attrs: DWORD ): Integer;
    {* |<#listview>
       Returns an index of the next after IdxPrev item with given attributes in
       the list view. }
    function LVNextSelected( IdxPrev: Integer ): Integer;
    {* |<#listview>
       Returns an index of next (after IdxPrev) selected item in a list view. }

    function LVAdd( const aText: String; ImgIdx: Integer; State: TListViewItemState;
                     StateImgIdx, OverlayImgIdx: Integer; Data: DWORD ): Integer;
    {* |<#listview>
       Adds new line to the end of ListView control. Only content of item itself
       is set (aText, ImgIdx). To change other column text and attributes of
       item added, use appropriate properties / methods ().
       |<br>
       Returns an index of added item.
       |<br>
       There is no Unicode version defined, use LVItemAddW instead. }
    function LVItemAdd( const aText: String ): Integer;
    {* |<#listview>
       Adds an item to the end of list view. Returns an index of the item added. }
    {$IFNDEF _FPC}
    {$IFNDEF _D2}
    function LVItemAddW( const aText: WideString ): Integer;
    {* |<#listview>
       Adds an item to the end of list view. Returns an index of the item added. }
    {$ENDIF _D2}
    {$ENDIF _FPC}
    function LVInsert( Idx: Integer; const aText: String; ImgIdx: Integer;
              State: TListViewItemState;  StateImgIdx, OverlayImgIdx: Integer; Data: DWORD ): Integer;
    {* |<#listview>
       Inserts new line before line with index Idx in ListView control. Only
       content of item itself is set (aText, ImgIdx). To change other column
       text and attributes of item added, use appropriate properties / methods ().
       if ImgIdx = I_IMAGECALLBACK, event handler OnGetLVItemImgIdx is responsible
       for returning image index for an item ( /// not implemented yet /// )
       Pass StateImgIdx and OverlayImgIdx = 0 (ignored in that case) or 1..15 to
       use correspondent icon from ImageListState image list.
       |<br> Returns an index of item inserted.
       |<br> There is no unicode version of this method, use LVItemInsertW. }
    function LVItemInsert( Idx: Integer; const aText: String ): Integer;
    {* |<#listview>
       Inserts an item to Idx position. }
    {$IFNDEF _FPC}
    {$IFNDEF _D2}
    function LVItemInsertW( Idx: Integer; const aText: WideString ): Integer;
    {* |<#listview>
       Inserts an item to Idx position. }
    {$ENDIF _D2}
    {$ENDIF _FPC}

    procedure LVDelete( Idx: Integer );
    {* |<#listview>
       Deletes item of ListView with subitems (full row - in lvsDetail view style. }
    procedure LVSetItem( Idx, Col: Integer; const aText: String; ImgIdx: Integer;
              State: TListViewItemState; StateImgIdx, OverlayImgIdx: Integer; Data: DWORD );
    {* |<#listview>
       Use this method to set item data and item columns data for ListView control.
       It is possible to pass I_SKIP as ImgIdx, StateImgIdx, OverlayImgIdx values to
       skip setting this fields. But all other are set always. Like in LVInsert /
       LVAdd, ImgIdx can be I_IMAGECALLBACK to determine that image will be
       retrieved in OnGetItemImgIdx event handler when needed.
       |<br>
       If this method is called to set data for column > 0, parameters ImgIdx and
       Data are ignored anyway.
       |<br> There is no unicode version of this method, use other methods
       to set up listed properties separately using correspondent W-functions. }

    property LVItemState[ Idx: Integer ]: TListViewItemState read LVGetItemState write LVSetItemState;
    {* |<#listview>
       Access to list view item states set [lvisBlend, lvisHighlight, lvisFocus,
       lvisSelect]. When assign new value to the property, it is possible to use
       special index value -1 to change state for all items for a list view
       (but only when lvoMultiselect style is applied to the list view, otherwise
       index -1 is referring to the last item of the list view). }

    property LVItemIndent[ Idx: Integer ]: Integer read LVGetItemIndent write LVSetItemIndent;
    {* Item indentation. Indentation is calculated as this value multiplied to
       image list ImgWidth value (Image list must be applied to list view).
       Note: indentation supported only if IE3.0 or higher installed. }
    property LVItemStateImgIdx[ Idx: Integer ]: Integer read LVGetSttImgIdx write LVSetSttImgIdx;
    {* |<#listview>
       Access to state image of the item. Use index -1 to assign the same state
       image index to all items of the list view at once (fast).
       Option lvoCheckBoxes just means, that control itself creates special inner
       image list for two state images. Later it is possible to examine checked
       state for items or set checked state programmatically by changing
       LVItemStateImgIdx[ ] property. Value 1 corresponds to unchecked state,
       2 to checked. Value 0 allows to remove checkbox at all. So, to check all
       added items by default (e.g.), do following:
       ! ListView1.LVItemStateImgIdx[ -1 ] := 2; }
    property LVItemOverlayImgIdx[ Idx: Integer ]: Integer read LVGetOvlImgIdx write LVSetOvlImgIdx;
    {* |<#listview>
       Access to overlay image of the item. Use index -1 to assign the same
       overlay image to all items of the list view at once (fast). }
    property LVItemData[ Idx: Integer ]: DWORD read LVGetItemData write LVSetItemData;
    {* |<#listview>
       Access to user defined data, assiciated with the item of the list view. }
    procedure LVSelectAll;
    {* |<#listview>
       Call this method to select all the items of the list view control. }
    property LVSelCount: Integer read GetSelLength write SetSelLength;
    {* |<#listview>
       Returns number of items selected in listview. }
    property LVItemImageIndex[ Idx: Integer ]: Integer read LVGetItemImgIdx write LVSetItemImgIdx;
    {* |<#listview>
       Image index of items in listview. }
    property LVItems[ Idx, Col: Integer ]: String read LVGetItemText write LVSetItemText;
    {* |<#listview>
       Access to List View item text. }
    {$IFNDEF _FPC}
    {$IFNDEF _D2}
    property LVItemsW[ Idx, Col: Integer ]: WideString read LVGetItemTextW write LVSetItemTextW;
    {* |<#listview>
       Access to List View item text. }
    {$ENDIF _D2}
    {$ENDIF _FPC}
    function LVItemRect( Idx: Integer; Part: TGetLVItemPart ): TRect;
    {* |<#listview>
       Returns rectangle occupied by given item part(s) in ListView window.
       Empty rectangle is returned, if the item is not viewing currently. }
    function LVSubItemRect( Idx, ColIdx: Integer ): TRect;
    {* |<#listview>
       Returns rectangle occupied by given item's subitem in ListView window,
       in lvsDetail or lvsDetailNoHeader style. Empty rectangle (0,0,0,0) is
       returned if the item is not viewing currently. Left or/and right bounds
       of the rectangle returned can be outbound item rectangle if only a part
       of the subitem is visible or the subitem is not visible in the item,
       which is visible itself. }
    property LVItemPos[ Idx: Integer ]: TPoint read LVGetItemPos write LVSetItemPos;
    {* |<#listview>
       Position of List View item (can be changed in icon or small icon view). }
    function LVItemAtPos( X, Y: Integer ): Integer;
    {* |<#listview>
       Return index of item at the given position. }
    function LVItemAtPosEx( X, Y: Integer; var Where: TWherePosLVItem ): Integer;
    {* |<#listview>
       Retrieves index of item and sets in Where, what part of item is under
       given coordinates. If there are no items at the specified position,
       -1 is returned. }
    procedure LVMakeVisible( Item: Integer; PartiallyOK: Boolean );
    {* |<#listview>
       Makes listview item visible. Ignred when Item passed < 0. }
    procedure LVEditItemLabel( Idx: Integer );
    {* |<#listview>
       Begins in-place editing of item label (first column text). }
    procedure LVSort;
    {* |<#listview>
       Initiates sorting of list view items. This sorting procedure is available only
       for Win2K, WinNT4 with IE5, Win98 or Win95 with IE5. See also LVSortData. }
    procedure LVSortData;
    {* |<#listview>
       Initiates sorting of list view items. This sorting procedure is always available
       in Windows95/98, NT/2000. But OnCompareLVItems procedure receives not indexes of
       items compared but its Data field associated instead. }
    procedure LVSortColumn( Idx: Integer );
    {* |<#listview>
       This is a method to simplify sort by column. Just call it in your OnColumnClick
       event passing column index and enjoy with your list view sorted automatically
       when column header is clicked. Requieres Windows2000 or Winows98, not supported
       under WinNT 4.0 and below and under Windows95.
       |<br>
       Either lvoSortAscending or lvoSortDescending option must be set in
       LVOptions, otherwise no sorting is performed. }
    function LVIndexOf( const S: String ): Integer;
    {* Returns first list view item index with caption matching S.
       The same as LVSearchFor( S, -1, FALSE ). }
    {$IFNDEF _FPC}
    {$IFNDEF _D2}
    function LVIndexOfW( const S: WideString ): Integer;
    {* Returns first list view item index with caption matching S.
       The same as LVSearchForW( S, -1, FALSE ). }
    {$ENDIF _D2}
    {$ENDIF _FPC}
    function LVSearchFor( const S: String; StartAfter: Integer; Partial: Boolean ): Integer;
    {* Searches an item with Caption equal to S (or starting from S, if Partial = TRUE).
       Searching is started after an item specified by StartAfter parameter. }
    {$IFNDEF _FPC}
    {$IFNDEF _D2}
    function LVSearchForW( const S: WideString; StartAfter: Integer; Partial: Boolean ): Integer;
    {* Searches an item with Caption equal to S (or starting from S, if Partial = TRUE).
       Searching is started after an item specified by StartAfter parameter. }
    {$ENDIF _D2}
    {$ENDIF _FPC}

    //======== List view page:
    property LVTopItem: Integer index LVM_GETTOPINDEX read GetIntVal; //LVGetTopItem;
    {* |<#listview>
       Returns index of topmost visible item of ListView in lvsList view style. }
    property LVPerPage: Integer index LVM_GETCOUNTPERPAGE read GetIntVal; //LVGetPerPage;
    {* |<#listview>
       Returns the number of fully-visible items if successful. If the current
       view is icon or small icon view, the return value is the total number
       of items in the list view control. }

    //======== List View specific events:
    property OnEndEditLVItem: TOnEditLVItem read fOnEditLVITem write SetOnEditLVItem;
    {* |<#listview>
       Called when edit of an item label in ListView control finished. Return
       True to accept new label text, or false - to not accept it (item label
       will not be changed). If handler not set to an event, all changes are
       accepted. }

    property OnDeleteLVItem: TOnDeleteLVItem read fOnDeleteLVItem write SetOnDeleteLVItem;
    {* |<#listview>
       Called for every deleted list view item. }
    property OnDeleteAllLVItems: TOnEvent read fOnDeleteAllLVItems write SetOnDeleteAllLVItems;
    {* |<#listview>
       Called when all the items of the list view control are to be deleted. If after
       returning from this event handler event OnDeleteLVItem is yet assigned,
       an event OnDeleteLVItem will be called for every deleted item. }
    property OnLVData: TOnLVData read fOnLVData write SetOnLVData;
    {* |<#listview>
       Called to provide virtual list view with actual data. To use list view as
       virtaul list view, define also lvsOwnerData style and set Count property
       to actual row count of the list view. This manner of working with list view
       control can greatly improve performance of an application when working with
       huge data sets represented in listview control. }
    {$IFNDEF _FPC}
    {$IFNDEF _D2}
    property OnLVDataW: TOnLVDataW read fOnLVDataW write SetOnLVDataW;
    {* |<#listview>
       The same as OnLVData, but for unicode version of the list view allows
       to return WideString text in the event handler. Though for unicode list
       view it is still possible to use ordinary event OnLVData, it is
       very recommended to use this event istead. }
    {$ENDIF _D2}
    {$ENDIF _FPC}

    property OnCompareLVItems: TOnCompareLVItems read fOnCompareLVItems write fOnCompareLVItems;
    {* |<#listview>
       Event to compare two list view items during sort operation (initiated by
       LVSort method call). Do not send any messages to the list view control
       while it is sorting - results can be unpredictable! }
    property OnColumnClick: TOnLVColumnClick read fOnColumnClick write SetOnColumnClick;
    {* |<#listview>
       This event handler is called when column of the list view control is clicked.
       You can use this event to initiate sorting of list view items by this column. }
    property OnLVStateChange: TOnLVStateChange read FOnLVStateChange write SetOnLVStateChange;
    {* |<#listview>
       This event occure when an item or items range in list view control are
       changing its state (e.g. selected or unselected). }
    property OnLVDelete: TOnLVDelete read FOnLVDelete write SetOnLVDelete;
    {* |<#listview>
       This event is called when an item is deleted in the listview.
       Do not add, delete, or rearrange items in the list view while processing
       this notification. }
    property OnDrawItem: TOnDrawItem read fOnDrawItem write SetOnDrawItem;
    {* |<#listview>
       |<#listbox>
       |<#combo>
       This event can be used to implemet custom drawing for list view, list box, dropped
       list of a combobox. For a list view, custom drawing using this event is possible
       only in lvsDetail and lvsDetailNoHeader styles, and OnDrawItem is called to draw
       entire row at once only. See also OnLVCustomDraw event. }

    property OnLVCustomDraw: TOnLVCustomDraw read FOnLVCustomDraw write SetOnLVCustomDraw;
    {* |<#listview>
       Custom draw event for listview. For every item to be drawn, this event
       can be called several times during a single drawing cycle - depending on
       a result, returned by an event handler. Stage can have one of following
       values:
       |<pre>
       CDDS_PREERASE
       CDDS_POSTERASE
       CDDS_ITEMPREERASE
       CDDS_PREPAINT
       CDDS_ITEMPREPAINT
       CDDS_ITEM
       CDDS_SUBITEM + CDDS_ITEMPREPAINT
       CDDS_SUBITEM + CDDS_ITEMPOSTPAINT
       CDDS_ITEMPOSTPAINT
       CDDS_POSTPAINT
       </pre>
       When called, see on Stage to get know, on what stage the event is
       activated. And depend on the stage and on what you want to paint,
       return a value as a result, which instructs the system, if to use
       default drawing on this (and follows) stae(s) for the item, and if
       to notify further about different stages of drawing the item during
       this drawing cycle. Possible values to return are:
       |<pre>
       CDRF_DODEFAULT - perform default drawing. Do not notify further for this
                      item (subitem) (or for entire listview, if called with
                      flag CDDS_ITEM reset - ?);
       CDRF_NOTIFYITEMDRAW - return this value, when the event is called the
                      first time in a cycle of drawing, with ItemIdx = -1 and
                      flag CDDS_ITEM reset in Stage parameter;
       CDRF_NOTIFYPOSTERASE - usually can be used to provide default erasing,
                      if you want to perform drawing immediately after that;
       CDRF_NOTIFYPOSTPAINT - return this value to provide calling the event
                      after performing default drawing. Useful when you wish
                      redraw only a part of the (sub)item;
       CDRF_SKIPDEFAULT - return this value to inform the system that all
                      drawing is done and system should not peform any more
                      drawing for the (sub)item during this drawing cycle.
       CDRF_NEWFONT - informs the system, that font is changed and default
                      drawing should be performed with changed font;
       |</pre>
       See also NM_CUSTOMDRAW in API Help.
    }


    //======== TreeView specific properties and methods:
    function TVInsert( nParent, nAfter: THandle; const Txt: String ): THandle;
    {* |<#treeview>
       Inserts item to a tree view. If nParent is 0 or TVI_ROOT, the item is
       inserted at the root of tree view. It is possible to pass following special
       values as nAfter parameter:
       |<pre>
       TVI_FIRST        Inserts the item at the beginning of the list.
       TVI_LAST	        Inserts the item at the end of the list.
       TVI_SORT	        Inserts the item into the list in alphabetical order.
       |</pre> }
    {$IFNDEF _FPC}
    {$IFNDEF _D2}
    function TVInsertW( nParent, nAfter: THandle; const Txt: WideString ): THandle;
    {* |<#treeview>
       Inserts item to a tree view. If nParent is 0 or TVI_ROOT, the item is
       inserted at the root of tree view. It is possible to pass following special
       values as nAfter parameter:
       |<pre>
       TVI_FIRST        Inserts the item at the beginning of the list.
       TVI_LAST	        Inserts the item at the end of the list.
       TVI_SORT	        Inserts the item into the list in alphabetical order.
       |</pre><br>
       This version of the method is Unicode. The tree view control should be
       set up as unicode control calling Perform( TVM_SETUNICODEFORMAT, 1, 0 ),
       and conditional symbol UNICODE_CTRLS must be defined to provide event
       handling for such kind of tree view (and other Unicode) controls. }
    {$ENDIF _D2}
    {$ENDIF _FPC}
    procedure TVDelete( Item: THandle );
    {* |<#treeview>
       Removes an item from the tree view. If value TVI_ROOT is passed, all items
       are removed. }

    property TVSelected: THandle index TVGN_CARET read TVGetItemIdx write TVSetItemIdx;
    {* |<#treeview>
       Returns or sets currently selected item handle in tree view. }

    property TVDropHilighted: THandle index TVGN_DROPHILITE read TVGetItemIdx write TVSetItemIdx;
    {* |<#treeview>
       Returns or sets item, which is currently highlighted as a drop target. }
    property TVDropHilited: THandle index TVGN_DROPHILITE read TVGetItemIdx write TVSetItemIdx;
    {* The same as TVDropHilighted. }
    property TVFirstVisible: THandle index TVGN_FIRSTVISIBLE read TVGetItemIdx write TVSetItemIdx;
    {* |<#treeview>
       Returns or sets given item to top of tree view. }

    property TVIndent: Integer index TVM_GETINDENT read GetIntVal write SetIntVal;
    {* |<#treeview>
       The amount, in pixels, that child items are indented relative to their
       parent items. }
    property TVVisibleCount: Integer index TVM_GETVISIBLECOUNT read GetIntVal;
    {* |<#treeview>
       Returns number of fully (not partially) visible items in tree view. }

    property TVRoot: THandle index TVGN_ROOT read TVGetItemIdx;
    {* |<#treeview>
       Returns handle of root item in tree view (or 0, if tree is empty). }
    property TVItemChild[ Item: THandle ]: THandle index TVGN_CHILD read TVGetItemNext;
    {* |<#treeview>
       Returns first child item for given one. }
    property TVItemHasChildren[ Item: THandle ]: Boolean read TV_GetItemHasChildren write TV_SetItemHasChildren;
    {* |<#treeview>
       TRUE, if an Item has children. Set this value to true if you want to
       force [+] sign appearing left from the node, even if there are no
       subnodes added to the node yet. }
    property TVItemNext[ Item: THandle ]: THandle index TVGN_NEXT read TVGetItemNext;
    {* |<#treeview>
       Returns next sibling item handle for given one (or 0, if passed item is
       the last child for its parent node). }
    property TVItemPrevious[ Item: THandle ]: THandle index TVGN_PREVIOUS read TVGetItemNext;
    {* |<#treeview>
       Returns previous sibling item (or 0, if the is no such item). }
    property TVItemNextVisible[ Item: THandle ]: THandle index TVGN_NEXTVISIBLE read TVGetItemNext;
    {* |<#treeview>
       Returns next visible item (passed item must be visible too, to determine,
       if it is really visible, use property TVItemRect or TVItemVisible. }
    property TVItemPreviousVisible[ Item: THandle ]: THandle index TVGN_PREVIOUSVISIBLE read TVGetItemNext;
    {* |<#treeview>
       Returns previous visible item. }
    property TVItemParent[ Item: THandle ]: THandle index TVGN_PARENT read TVGetItemNext;
    {* |<#treeview>
       Returns parent item for given one (or 0 for root item). }

    property TVItemText[ Item: THandle ]: String read TVGetItemText write TVSetItemText;
    {* |<#treeview>
       Text of tree view item. }
    {$IFNDEF _FPC}
    {$IFNDEF _D2}
    property TVItemTextW[ Item: THandle ]: WideString read TVGetItemTextW write TVSetItemTextW;
    {* |<#treeview>
       Text of tree view item. }
    {$ENDIF _D2}
    {$ENDIF _FPC}
    function TVItemPath( Item: THandle; Delimiter: Char ): String;
    {* |<#treeview>
       Returns full path from the root item to given item. Path is calculated
       as a concatenation of all parent nodes text strings, separated by
       given delimiter character.
       |<br>Please note, that returned path has no trailing delimiter, this
       character is only separating different parts of the path.
       |<br>If Item is not specified ( =0 ), path is returned
       for Selected item. }
    {$IFNDEF _FPC}
    {$IFNDEF _D2}
    function TVItemPathW( Item: THandle; Delimiter: WideChar ): WideString;
    {* |<#treeview>
       Returns full path from the root item to given item. Path is calculated
       as a concatenation of all parent nodes text strings, separated by
       given delimiter character. If Item is not specified ( =0 ), path is returned
       for Selected item. }
    {$ENDIF _D2}
    {$ENDIF _FPC}

    property TVItemRect[ Item: THandle; TextOnly: Boolean ]: TRect read TVGetItemRect;
    {* |<#treeview>
       Returns rectangle, occupied by an item in tree view. }

    property TVItemVisible[ Item: THandle ]: Boolean read TVGetItemVisible write TVSetITemVisible;
    {* |<#treeview>
       Returs True, if item is visible in tree view. It is also possible to
       assign True to this property to ensure that a tree view item is visible
       (if False is assigned, this does nothing). }
    function TVItemAtPos( x, y: Integer; var Where: DWORD ): THandle;
    {* |<#treeview>
       Returns handle of item found at specified position (relative to upper left
       corener of client area of the tree view). If no item found, 0 is returned.
       Variable Where receives additional flags combination, describing more
       detailed, on which part of item or tree view given point is located,
       such as:
       |<pre>
       TVHT_ABOVE              Above the client area
       TVHT_BELOW              Below the client area
       TVHT_NOWHERE            In the client area, but below the last item
       TVHT_ONITEM	       On the bitmap or label associated with an item
       TVHT_ONITEMBUTTON       On the button associated with an item
       TVHT_ONITEMICON	       On the bitmap associated with an item
       TVHT_ONITEMINDENT       In the indentation associated with an item
       TVHT_ONITEMLABEL	       On the label (string) associated with an item
       TVHT_ONITEMRIGHT	       In the area to the right of an item
       TVHT_ONITEMSTATEICON    On the state icon for a tree-view item that is in a user-defined state
       TVHT_TOLEFT	       To the right of the client area
       TVHT_TORIGHT	       To the left of the client area
       |</pre> }

    property TVRightClickSelect: Boolean read fTVRightClickSelect write SetTVRightClickSelect;
    {* |<#treeview>
       Set this property to True to allow change selection to an item, clicked with right mouse button. }
    property TVEditing: Boolean read fEditing;
    {* |<#treeview>
       Returns True, if tree view control is editing its item label. }

    property TVItemBold[ Item: THandle ]: Boolean index TVIS_BOLD read TVGetItemStateFlg write TVSetItemStateFlg;
    {* |<#treeview>
       True, if item is bold. }
    property TVItemCut[ Item: THandle ]: Boolean index TVIS_CUT read TVGetITemStateFlg write TVSetItemStateFlg;
    {* |<#treeview>
       True, if item is selected as part of "cut and paste" operation. }
    property TVItemDropHighlighted[ Item: THandle ]: Boolean index TVIS_DROPHILITED read TVGetITemStateFlg write TVSetItemStateFlg;
    {* |<#treeview>
       True, if item is selected as drop target. }
    property TVItemDropHilited[ Item: THandle ]: Boolean index TVIS_DROPHILITED read TVGetITemStateFlg write TVSetItemStateFlg;
    {* The same as TVItemDropHighlighted. }
    property TVItemExpanded[ Item: THandle ]: Boolean index TVIS_EXPANDED read TVGetITemStateFlg; // write TVSetItemStateFlg;
    {* |<#treeview>
       True, if item's list of child items is currently expanded. To change
       expanded state, use method TVExpand. }
    property TVItemExpandedOnce[ Item: THandle ]: Boolean index TVIS_EXPANDEDONCE read TVGetITemStateFlg; // write TVSetItemStateFlg;
    {* |<#treeview>
       True, if item's list of child items has been expanded at least once. }
    property TVItemSelected[ Item: THandle ]: Boolean index TVIS_SELECTED read TVGetITemStateFlg write TVSetItemStateFlg;
    {* |<#treeview>
       True, if item is selected. }

    procedure TVExpand( Item: THandle; Flags: DWORD );
    {* |<#treeview>
       Call it to expand/collapse item's child nodes. Possible values for Flags
       parameter are:
       <pre>
       TVE_COLLAPSE         Collapses the list.
       TVE_COLLAPSERESET    Collapses the list and removes the child items. Note
                            that TVE_COLLAPSE must also be specified.
       TVE_EXPAND	    Expands the list.
       TVE_TOGGLE	    Collapses the list if it is currently expanded or
                            expands it if it is currently collapsed.
       </pre>
       }
    procedure TVSort( N: THandle );
    {* |<#treeview>
       By Alex Mokrov. Sorts treeview. If N = 0, entire treeview is sorted.
       Otherwise, children of the given node only.
    }

    property TVItemImage[ Item: THandle ]: Integer index TVIF_IMAGE read TVGetItemImage write TVSetItemImage;
    {* |<#treeview>
       Image index for an item of tree view. To tell that there are no image
       set, use index -2 (value -1 is reserved for callback image). }
    property TVItemSelImg[ Item: THandle ]: Integer index TVIF_SELECTEDIMAGE read TVGetItemImage write TVSetItemImage;
    {* |<#treeview>
       Image index for an item of tree view in selected state. Use value -2 to
       provide no image, -1 used for callback image. }
    property TVItemOverlay[ Item: THandle ]: Integer index TVIS_OVERLAYMASK or $80000
                             read TVGetItemImage write TVSetItemImage;
    {* |<#treeview>
       Overlay image index for an item in tree view. }
    property TVItemStateImg[ Item: THandle ]: Integer index TVIS_STATEIMAGEMASK or $C0000
                              read TVGetItemImage write TVSetItemImage;
    {* |<#treeview>
       State image index for an item in tree view. }

    property TVItemData[ Item: THandle ]: Pointer read TVGetItemData write TVSetItemData;
    {* |<#treeview>
       Stores any program-defined pointer with the item. }
    procedure TVEditItem( Item: THandle );
    {* |<#treeview>
       Begins editing given item label in tree view. }
    procedure TVStopEdit( Cancel: Boolean );
    {* |<#treeview>
       Ends editing item label, started by user or explicitly by TVEditItem method. }

    property OnTVBeginDrag: TOnTVBeginDrag read fOnTVBeginDrag write fOnTVBeginDrag;
    {* |<#treeview>
       Is called for tree view, when its item is to be dragging. }
    property OnTVBeginEdit: TOnTVBeginEdit read fOnTVBeginEdit write fOnTVBeginEdit;
    {* |<#treeview>
       Is called for tree view, when its item label is to be editing. }
    property OnTVEndEdit: TOnTVEndEdit read fOnTVEndEdit write fOnTVEndEdit;
    {* |<#treeview>
       Is called when item label is edited. It is possible to cancel
       edit, returning False as a result. }
    property OnTVExpanding: TOnTVExpanding read fOnTVExpanding write fOnTVExpanding;
    {* |<#treeview>
       Is called just before expanding/collapsing item. It is possible to
       return False to prevent expanding item. }
    property OnTVExpanded: TOnTVExpanded read fOnTVExpanded write fOnTVExpanded;
    {* |<#treeview>
       Is called after expanding/collapsing item children. }
    property OnTVDelete: TOnTVDelete read fOnTVDelete write SetOnTVDelete;
    {* |<#treeview>
       Is called just before deleting item. You may use this event to free
       resources, associated with an item (see TVItemData property). }
    //----------------- by Sergey Shisminzev:
    property OnTVSelChanging: TOnTVSelChanging read fOnTVSelChanging write fOnTVSelChanging;
    {* |<#treeview>
       Is called before changing the selection. The handler can return FALSE
       to prevent changing the selection. }
    //--------------------------------------

    //======== Toolbar specific methods:
    procedure TBAddBitmap( Bitmap: HBitmap );
    {* |<#toolbar>
       Adds bitmaps to a toolbar. You can pass special values as Bitmap to
       add one of predefined system button images bitmaps:
       |<br> THandle(-1) to add standard small icons,
       |<br> THandle(-2) to add standard large icons,
       |<br> THandle(-5) to add standard small view icons,
       |<br> THandle(-6) to add standard large view icons,
       |<br> THandle(-9) to add standard small view icons,
       |<br> THandle(-10) to add standard large view icons,
       (in that case use following values as indexes to the standard and view
       bitmaps:
       |<br>
       STD_COPY, STD_CUT, STD_DELETE, STD_FILENEW, STD_FILEOPEN, STD_FILESAVE,
       STD_FIND, STD_HELP, STD_PASTE, STD_PRINT, STD_PRINTPRE, STD_PROPERTIES,
       STD_REDO, STD_REPLACE, STD_UNDO,
       |<br>
       VIEW_LARGEICONS, VIEW_SMALLICONS,
       VIEW_LIST, VIEW_DETAILS, VIEW_SORTNAME, VIEW_SORTSIZE, VIEW_SORTDATE,
       VIEW_SORTTYPE (use it as parameters BtnImgIdxArray in TBAddButtons or
       TBInsertButtons methods, and in assigning value to TBButtonImage[ ]
       property).
       Added bitmaps have indeces starting from previous count of images
       (as these are appended to existing - if any).
       |<br>
       Note, that if You add your own (custom) bitmap, it is not transparent.
       Do not assume that clSilver is always equal to clBtnFace. Use API
       function CreateMappedBitmap to load bitmap from resource and map
       desired colors as you wish (e.g., convert clTeal to clBtnFace). Or,
       call defined in KOL function LoadMappedBitmap to do the same more easy.
       Unfortunately, resource identifier for bitmap to pass it to LoadMappedBitmap
       or to CreateMappedBitmap seems must be integer, so it is necessary to
       create rc-file manually and compile using Borland Resource Compiler to
       figure it out. }


    function TBAddButtons( const Buttons: array of PChar; const BtnImgIdxArray: array
              of Integer ): Integer;
    {* |<#toolbar>
       Adds buttons to toolbar. Last string in Buttons array *must* be empty
       ('' or nil), so to add buttons without text, pass ' ' string (one space
       char). It is not necessary to provide image indexes for all
       buttons (it is sufficient to assign index for first button only).
       But in place, correspondent to separator button (defined by string '-'),
       any integer must be passed to assign follow image indexes correctly.
       See example.
       |*Toolbar adding buttons sample.
       Code below shows how to call TBAddButtons method to add two buttons with
       a separator between these buttons. idxNew and idxOld are integer
       expressions assigning image indexes to buttons 'New' and 'Old'. This
       indexes are zero-based and refer to bitmap images, added earlier (either
       in creating toolbar by call of NewToolbar or later in call of TBAddBitmap).
       !
       !     TBAddButtons( [ '&New', '-', '&Old', '' ], [ idxNew, 0, idxOld ] );
       !
       |*
       To add check buttons, use prefix '+' or '-' in button definition
       string. If next character is '!', such buttons are grouped to a
       radio-group. Also, it is possible to use '^' prefix (must be first) to
       define button with small drop-down section (use also OnTBDropDown event
       to respond to clicking drop down section of such buttons).
       |<br>
       This function returns command id for first added button (other
       id's can be calculated incrementing the result by one for each
       button, except separators, which have no command id).
       |<br>
       Note: for static toolbar (single in application and created
       once) ids are started from value 100. }

    function TBInsertButtons( BeforeIdx: Integer; Buttons: array of PChar;
             BtnImgIdxArray: array of Integer ): Integer;
    {* |<#toolbar>
       Inserts buttons before button with given index on toolbar. Returns
       command identifier for first button inserted (other can be calculated
       incrementing returned value needed times. See also TBAddButtons. }

    procedure TBDeleteButton( BtnID: Integer );
    {* |<#toolbar>
       Deletes single button given by its command id. To delete separator,
       use TBDeleteBtnByIdx instead. }

    procedure TBDeleteBtnByIdx( Idx: Integer );
    {* |<#toolbar>
       Deletes single button given by its index in toolbar (not by command ID). }

    procedure TBAssignEvents( BtnID: Integer; Events: array of TOnToolbarButtonClick );
    {* |<#toolbar>
       Allows to assign separate OnClick events for every toolbar button.
       BtnID should be toolbar button ID or index of the first button to
       assign event. If it is an ID, events are assigned to buttons in
       creation order. Otherwise, events are assigned in placement order.
       Anyway, separator buttons are not skipped, so pass at least nil for such
       button as an event.
       |<br>
       Please note, that though not all buttons should exist before
       assigning events to it, therefore at least the first button
       (specified by BtnID) must be already added before calling TBAssignEvents. }

    procedure TBResetImgIdx( BtnID, BtnCount: Integer );
    {* |<#toolbar>
       Resets image index for BtnCount buttons starting from BtnID. }

    property CurItem: Integer read fCurItem;
    {* |<#toolbar>
       For toolbar, in OnClick event this property can be used to determine
       which button was clicked (100-based button id in toolbar). It is also
       possible to use CurIndex property (zero-based) for this purpose as
       well, but do not assume, that CurItem always equal to CurIndex+100.
       At least, it is possible to call TBItem2Index function to convert
       button ID to its index in toolbar.
       |<br>
       In case, when button (or toolbar itself) is clicked using right
       mouse button, CurItem and CurIndex are always set to -1. To further
       determine which button was clicked, get mouse coordinates on screen,
       apply Screen2Client method of toolbar control to it and then use
       TBButtonAtPos function to determine which button was under cursor.
    }

    property TBButtonCount: Integer read GetItemsCount; //TBGetButtonCount;
    {* |<#toolbar>
       Returns count of buttons on toolbar. The same as Count. }

    property TBBtnImgWidth: Integer read fTBBtnImgWidth write fTBBtnImgWidth;
    {* |<#toolbar>
       Custom toolbar buttons width. Set it before assigning buttons bitmap.
       Changing this property after assigning the bitmap has no effect. }

    function TBItem2Index( BtnID: Integer ): Integer;
    {* |<#toolbar>
       Converts button command id to button index for tool bar. }

    function TBIndex2Item( Idx: Integer ): Integer;
    {* |<#toolbar>
       Converts toolbar button index to its command ID. }

    property TBButtonEnabled[ BtnID: Integer ]: Boolean index TB_ENABLEBUTTON
             read TBGetBtnStt write TBSetBtnStt;
    {* |<#toolbar>
       Obvious. }

    property TBButtonVisible[ BtnID: Integer ]: Boolean read TBGetButtonVisible
                              write TBSetButtonVisible;
    {* |<#toolbar>
       Allows to hide/show some of toolbar buttons. }

    property TBButtonChecked[ BtnID: Integer ]: Boolean index TB_CHECKBUTTON
             read TBGetBtnStt write TBSetBtnStt;
    {* |<#toolbar>
       Allows to determine 'checked' state of a button (e.g., radio-button),
       and to check it programmatically. }

    property TBButtonMarked[ BtnID: Integer ]: Boolean index TB_MARKBUTTON
             read TBGetBtnStt write TBSetBtnStt;
    {* |<#toolbar>
       Returns True if toolbar button is marked (highlighted). Allows to
       highlight buttons assigning True to this value. }

    property TBButtonPressed[ BtnID: Integer ]: Boolean index TB_PRESSBUTTON
             read TBGetBtnStt write TBSetBtnStt;
    {* |<#toolbar>
       Allows to detrmine if toolbar button (given by its command ID) pressed,
       and press/unpress it programmatically. }

    property TBButtonText[ BtnID: Integer ]: String read TBGetButtonText write TBSetButtonText;
    {* |<#toolbar>
       Obtains toolbar button text and allows to change it. Be sure that text
       is not empty for all buttons, if You want for it to be shown (if at least
       one button has empty text, no text labels will be shown at all). At
       least set it to ' ' for buttons, which You do not want to show labels,
       if You want from other ones to have it. }

    property TBButtonImage[ BtnID: Integer ]: Integer read TBGetBtnImgIdx write TBSetBtnImgIdx;
    {* |<#toolbar>
       Allows to access/change button image. }

    property TBButtonRect[ BtnID: Integer ]: TRect read TBGetButtonRect;
    {* |<#toolbar>
       Obtains rectangle occupied by toolbar button in toolbar window.
       (It is not possible to obtain rectangle for buttons, currently
       not visible). }

    property TBButtonWidth[ BtnID: Integer ]: Integer read TBGetBtnWidth write TBSetBtnWidth;
    {* |<#toolbar>
       Allows to obtain / change toolbar button width. }

    property TBButtonsMinWidth: Integer index 0
             {$IFDEF F_P}   read TBGetBtMinMaxWidth
             {$ELSE DELPHI} read FTBBtMinWidth
             {$ENDIF F_P/DELPHI} write TBSetBtMinMaxWidth;
    {* |<#toolbar>
       Allows to set minimal width for all toolbar buttons. }
    property TBButtonsMaxWidth: Integer index 1
             {$IFDEF F_P}   read TBGetBtMinMaxWidth
             {$ELSE DELPHI} read FTBBtMaxWidth
             {$ENDIF F_P/DELPHI} write TBSetBtMinMaxWidth;
    {* |<#toolbar>
       Allows to set maximal width for all toolbar buttons. }

    function TBButtonAtPos( X, Y: Integer ): Integer;
    {* |<#toolbar>
       Returns command ID of button at the given position on toolbar,
       or -1, if there are no button at the position. Value 0 is returned
       for separators. }

    function TBBtnIdxAtPos( X, Y: Integer ): Integer;
    {* |<#toolbar>
       Returns index of button at the given position on toolbar.
       This also can be index of separator button. -1 is returned if
       there are no buttons found at the position. }

    property TBRows: Integer read TBGetRows write TBSetRows;
    {* |<#toolbar>
       Returns number of rows for toolbar and allows to try to set
       desired number of rows (but system can set another number of
       rows in some cases). This property has no effect if tboWrapable
       style not present in Options when toolbar is created. }

    procedure TBSetTooltips( BtnID1st: Integer; Tooltips: array of PChar );
    {* |<#toolbar>
       Allows to assign tooltips to several buttons. Until this procedure
       is not called, tooltips list is not created and no code is added
       to executable. This method of tooltips maintainance for toolbar buttons
       is useful both for static and dynamic toolbars (meaning "dynamic" -
       toolbars with buttons, deleted and inserted at run-time). }

    property OnTBDropDown: TOnEvent read fOnDropDown write fOnDropDown;
    {* |<#toolbar>
       This event is called for drop down buttons, when user click drop part
       of drop down button. To determine for which button event is called,
       look at CurItem or CurIndex property. It is also possible to use
       common (with combobox) property OnDropDown. }

    property OnTBClick: TOnEvent read fOnClick write fOnClick;
    {* |<#toolbar>
       The same as OnClick. }

    //================== RichEdit specific: ==================

    property MaxTextSize: DWORD read GetMaxTextSize write SetMaxTextSize;
    {* |<#richedit>
       This property valid also for simple edit control, not only for RichEdit.
       But for usual edit control, maximum text size available is 32K. For
       RichEdit, limit is 4Gb. By default, RichEdit is limited to
       32767 bytes (to set maximum size available to 2Gb, assign MaxInt value
       to a property). Also, to get current text size of RichEdit, use property
       TextSize or RE_TextSize[ ]. }
    property TextSize: Integer read GetTextSize;
    {* |<#richedit>
       Common for edit and rich edit controls property, which returns size of
       text in edit control. Also, for any other control (or form, or applet
       window) returns size (in characters) of Caption or Text (what is, the
       same property actually). }
    property RE_TextSize[ Units: TRichTextSize ]: Integer read REGetTextSize;
    {* |<#richedit>
       For RichEdit control, it returns text size, measured in desired units
       (rtsChars - characters, including OLE objects, counted as a single
       character; rtsBytes - presize length of text image (if it would be stored
       in file or stream). Please note, that for RichEdit1.0, only size in
       characters can be obtained. }
    function RE_TextSizePrecise: Integer;
    {* |<#richedit>
       By Savva. Returns length of rich edit text. }

    property RE_CharFmtArea: TRichFmtArea read fRECharArea write fRECharArea;
    {* |<#richedit>
       By default, this property is raSelection. Changing it, You determine in
       for which area characters format is applyed, when changing
       character formatting properties below (not paragraph formatting).
       |&A=<a href=#RE_CharFmtArea target=main>%0</a>
    }
    property RE_CharFormat: TCharFormat read REGetCharformat write RESetCharFormat;
    {* |<#richedit>
       In differ to follow properties, which allow to control certain formatting
       attributes, this property provides low level access for formatting current
       character area (see RE_CharFmtArea). It returns TCharFormat structure,
       filled in with formatting attributes, and by assigning another value to
       this property You can change desired attributes as You wish. Even if
       RichEdit1.0 is used, TCharFormat2 is returned (but extended fields are
       ignored for RichEdit1.0). }
    property RE_Font: PGraphicTool read REGetFont write RESetFont;
    {* |<#richedit>
       Font of the first character in current selection (when retrieve).
       When set (or subproperties of RE_Font are set), all font attributes are
       applied to entire <A area>. To apply only needed attributes, use another
       properties: RE_FmtBold, RE_FmtItalic, RE_FmtStrikeout, RE_FmtUnderline,
       RE_FmtName, etc.
       |<br>
       Note, that font size is measured in twips, which is about 1/10 of pixel. }
    property RE_FmtBold: Boolean index CFM_BOLD read REGetFontEffects write RESetFontEffect;
    {* |<#richedit>
       Formatting flag. When retrieve, returns True, if fsBold style RE_Font.FontStyle
       is valid for a first character in the selection. When set, changes fsBold
       style (True - set, False - reset) for all characters in <A area>. }
    property RE_FmtBoldValid: Boolean index CFM_BOLD read REGetFontMask;
    {* }
    property RE_FmtItalic: Boolean index CFM_ITALIC read REGetFontEffects write RESetFontEffect;
    {* |<#richedit>
       Formatting flag. Like RE_FmtBold, when retrieving, shows, is fsItalic
       style valid for the first character of the selection, and when set, changes
       only fsItalic style for an <A area>. }
    property RE_FmtItalicValid: Boolean index CFM_ITALIC read REGetFontMask;
    {* }
    property RE_FmtStrikeout: Boolean index CFM_STRIKEOUT read REGetFontEffects write RESetFontEffect;
    {* |<#richedit>
       Formatting flag. Like RE_FmtBold, when retrieving, shows, is fsStrikeout
       style valid for the first selected character, and when set, changes only
       fsStrikeout style for an <A area>. }
    property RE_FmtStrikeoutValid: Boolean index CFM_STRIKEOUT read REGetFontMask;
    {* }
    property RE_FmtUnderline: Boolean index CFM_UNDERLINE read REGetFontEffects write RESetFontEffect;
    {* |<#richedit>
       Formatting flag. Like RE_FmtBold, when retrieving, shows, is fsUnderline
       style valid for the first selected character, and when set, changes
       fsUnderline style for an <A area>. }
    property RE_FmtUnderlineValid: Boolean index CFM_UNDERLINE read REGetFontMask;
    {* }
    property RE_FmtUnderlineStyle: TRichUnderline
             read REGetUnderlineEx write RESetUnderlineEx;
    {* |<#richedit>
       Extended underline style. To check, if this property is valid for
       entire selection, examine RE_FmtUnderlineValid value. }
    property RE_FmtProtected: Boolean index CFM_PROTECTED read REGetFontEffects write RESetFontEffect;
    {* |<#richedit>
       Formatting flag. When retrieving, shows, is the first character of the selection
       is protected from changing it by user (True) or not (False). To get know,
       if retrived value is valid for entire selection, check the property
       RE_FmtProtectedValid. When set, makes all characters in <A area> protected (
       True) or not (False). }
    property RE_FmtProtectedValid: Boolean index CFM_PROTECTED read REGetFontMask;
    {* |<#richedit>
       True, if property RE_FmtProtected is valid for entire selection, when
       retrieving it. }
    property RE_FmtHidden: Boolean index CFM_HIDDEN read REGetFontEffects write RESetFontEffect;
    {* |<#richedit>
       For RichEdit3.0, makes text hidden (not displayed). }
    property RE_FmtHiddenValid: Boolean index CFM_HIDDEN read REGetFontMask;
    {* |<#richedit>
       Returns True, if RE_FmtHidden style is valid for entire selection. }

    property RE_FmtLink: Boolean index $20 {CFM_LINK} read REGetFontEffects write RESetFontEffect;
    {* |<#richedit>
       Returns True, if the first selected character is a part of link (URL). }
       // by Sergey Shisminzev

    property RE_FmtLinkValid: Boolean index $20 {CFM_LINK} read REGetFontMask;
    {* }
    property RE_FmtFontSize: Integer index (12 shl 16) or CFM_SIZE read REGetFontAttr write RESetFontAttr;
    {* |<#richedit>
       Formatting value: font size, in twips (1/1440 of an inch, or 1/20 of a
       printer's point, or about 1/10 of pixel). When retrieving, returns
       RE_Font.FontHeight.
       When set, changes font size for entire <A area> (but does not change
       other font attributes). }
    property RE_FmtFontSizeValid: Boolean read REGetFontSizeValid;
    {* |<#richedit>
       Returns True, if property RE_FmtFontSize is valid for entire selection,
       when retrieving it. }
    //property RE_FmtBackColor: Integer index (62 shl 16) or CFM_BACKCOLOR read REGetFontAttr write RESetFontAttr1;
    {* |<#richedit>
       Background color for an <A area>. }
    //property RE_FmtBackColorValid: Boolean index CFM_BACKCOLOR read REGetFontEffect;
    {* |<#richedit>
       True, if RE_FmtBackColor valid for entire <A area>. }
    property RE_FmtAutoBackColor: Boolean index CFM_BACKCOLOR read REGetFontEffects write RESetFontEffect;
    {* |<#richedit>
       True, when automatic back color is used. }
    property RE_FmtAutoBackColorValid: Boolean index CFM_BACKCOLOR read REGetFontMask;
    {* }
    property RE_FmtFontColor: Integer index (20 shl 16) or CFM_COLOR read REGetFontAttr write RESetFontAttr1;
    {* |<#richedit>
       Formatting value (font color). When retrieving, returns RE_Font.Color.
       When set, changes font color for entire <A area> (but does not change
       other font attributes). }
    property RE_FmtFontColorValid: Boolean index CFM_COLOR read REGetFontMask;
    {* |<#richedit>
       Returns True, if property RE_FmtFontColor valid for entire selection,
       when retrieving it. }
    property RE_FmtAutoColor: Boolean index CFM_COLOR read REGetFontEffects write RESetFontEffect;
    {* |<#richedit>
       True, when automatic text color is used (in such case, RE_FmtFontColor
       assignment is ignored for current area). }
    property RE_FmtAutoColorValid: Boolean index CFM_COLOR read REGetFontMask;
    {* }
    property RE_FmtBackColor: Integer index (64 shl 16) or CFM_BACKCOLOR read REGetFontAttr write RESetFontAttr1;
    {* |<#richedit>
       Formatting value (back color). Only available for Rich Edit 2.0 and higher.
       When set, changes background color for entire <A area> (but does not change
       other font attributes). }
    property RE_FmtBackColorValid: Boolean index CFM_BACKCOLOR read REGetFontMask;
    {* }
    property RE_FmtFontOffset: Integer index (16 shl 16) or CFM_OFFSET read REGetFontAttr write RESetFontAttr;
    {* |<#richedit>
       Formatting value (font vertical offset from baseline, positive values
       correspond to subscript). When retrieving, returns offset for first
       character in the selection. When set, changes font offset for entire
       <A area>. To get know, is retrieved value valid for entire selction,
       check RE_FmtFontOffsetValid property. }
    property RE_FmtFontOffsetValid: Boolean index CFM_OFFSET read REGetFontMask;
    {* |<#richedit>
       Returns True, if property RE_FmtFontOffset is valid for entire selection,
       when retrieving it. }
    property RE_FmtFontCharset: Integer index (25 shl 16) or CFM_CHARSET read REGetFontAttr write RESetFontAttr;
    {* |<#richedit>
       Returns charset for first character in current selection, when retrieved
       (and to get know, if this value is valid for entire selection, check
       property RE_FmtFontCharsetValid). When set, changes charset for all
       characters in <A area>, but does not alter other formatting attributes. }
    property RE_FmtFontCharsetValid: Boolean index CFM_CHARSET read REGetFontMask;
    {* |<#richedit>
       Returns True, only if rerieved property RE_FmtFontCharset is valid for
       entire selection. }
    property RE_FmtFontName: String read REGetFontName write RESetFontName;
    {* |<#richedit>
       Returns font face name for first character in the selection, when retrieved,
       and sets font name for entire <A area>, wnen assigned to (without
       changing of other formatting attributes). To get know, if retrived
       font name valid for entire selection, examine property RE_FmtFontNameValid. }
    property RE_FmtFontNameValid: Boolean index CFM_FACE read REGetFontMask;
    {* |<#richedit>
       Returns True, only if the font name is the same for entire selection,
       thus is, if rerieved property value RE_FmtFontName is valid for entire
       selection. }

    property RE_ParaFmt: TParaFormat read REGetParaFmt write RESetParaFmt;
    {* |<#richedit>
       Allows to retrieve or set paragraph formatting attributes for currently
       selected paragraph(s) in RichEdit control. See also following properties,
       which allow to do the same for certain paragraph format attributes
       separately. }
    property RE_TextAlign: TRichTextAlign read REGetTextAlign write RESetTextAlign;
    {* |<#richedit>
       Returns text alignment for current selection and allows to change it
       (without changing other formatting attributes). }
    property RE_TextAlignValid: Boolean index PFM_ALIGNMENT read REGetParaAttrValid;
    {* |<#richedit>
       Returns True, if property RE_TextAlign is valid for entire selection. If
       False, it is concerning only start of selection. }
    property RE_Numbering: Boolean read REGetNumbering write RESetNumbering;
    {* |<#richedit>
       Returns True, if selected text is numbered (or has style of list with
       bullets). To get / change numbering style, see properties
       RE_NumStyle and RE_NumBrackets. }
    property RE_NumStyle: TRichNumbering read REGetNumStyle write RESetNumStyle;
    {* |<#richedit>
       Advanced numbering style, such as rnArabic etc. If You use it, do not
       change RE_Numbering property simultaneously - this can cause changing
       style to rnBullets only. }
    property RE_NumStart: Integer read REGetNumStart write RESetNumStart;
    {* |<#richedit>
       Starting number for advanced numbering style. If this property is not
       set, numbering is starting by default from 0. For rnLRoman and rnURoman
       this cause, that first item has no number to be shown (ancient Roman
       people did not invent '0'). }
    property RE_NumBrackets: TRichNumBrackets read REGetNumBrackets write RESetNumBrackets;
    {* |<#richedit>
       Brackets style for advanced numbering. rnbPlain is default
       brackets style, and every time, when RE_NumStyle is changed,
       RE_NumBrackets is reset to rnbPlain. }
    property RE_NumTab: Integer read REGetNumTab write RESetNumTab;
    {* |<#richedit>
       Tab between start of number and start of paragraph text. If too small too
       view number, number is not displayed. (Default value seems to be sufficient
       though). }
    property RE_NumberingValid: Boolean index PFM_NUMBERING read REGetParaAttrValid;
    {* |<#richedit>
       Returns True, if RE_Numbering, RE_NumStyle, RE_NumBrackets, RE_NumTab,
       RE_NumStart properties are valid for entire selection. }
    property RE_Level: Integer read REGetLevel;
    {* |<#richedit>
       Outline level (for numbering paragraphs?). Read only. }
    property RE_SpaceBefore: Integer index 0 or PFM_SPACEBEFORE read REGetSpacing write RESetSpacing;
    {* |<#richedit>
       Spacing before paragraph. }
    property RE_SpaceBeforeValid: Boolean index PFM_SPACEBEFORE read REGetParaAttrValid;
    {* |<#richedit>
       True, if RE_SpaceBefore value is valid for all selected paragraph (if
       False, this value is valid only for first paragraph. }
    property RE_SpaceAfter: Integer index 4 or PFM_SPACEAFTER read REGetSpacing write RESetSpacing;
    {* |<#richedit>
       Spacing after paragraph. }
    property RE_SpaceAfterValid: Boolean index PFM_SPACEAFTER read REGetParaAttrValid;
    {* |<#richedit>
       True, only if RE_SpaceAfter value is valid for all selected paragraphs. }
    property RE_LineSpacing: Integer index 8 or PFM_LINESPACING read REGetSpacing write RESetSpacing;
    {* |<#richedit>
       Linespacing in paragraph (this value is based on RE_SpacingRule property). }
    property RE_SpacingRule: Integer read REGetSpacingRule write RESetSpacingRule;
    {* |<#richedit>
       Linespacing rule. Do not know what is it. }
    property RE_LineSpacingValid: Boolean index PFM_LINESPACING read REGetParaAttrValid;
    {* |<#richedit>
       True, only if RE_LineSpacing and RE_SpacingRule values are valid for
       entire selection. }
    property RE_Indent: Integer index (20 shl 16) or PFM_OFFSET read REGetParaAttr write RESetParaAttr;
    {* |<#richedit>
       Returns left indentation for paragraph in current selection and allows
       to change it (without changing other formatting attributes). }
    property RE_IndentValid: Boolean index PFM_OFFSET read REGetParaAttrValid;
    {* |<#richedit>
       Returns True, if RE_Indent property is valid for entire selection. }
    property RE_StartIndent: Integer index (12 shl 16) or PFM_OFFSETINDENT read REGetParaAttr write RESetParaAttr;
    {* |<#richedit>
       Returns left indentation for first line in paragraph for current
       selection, and allows to change it (without changing other formatting
       attributes). }
    property RE_StartIndentValid: Boolean read REGetStartIndentValid;
    {* |<#richedit>
       Returns True, if property RE_StartIndent is valid for entire selection. }
    property RE_RightIndent: Integer index (16 shl 16) or PFM_RIGHTINDENT read REGetParaAttr write RESetParaAttr;
    {* |<#richedit>
       Returns right indent for paragraph in current selection, and allow to
       change it (without changing other formatting attributes). }
    property RE_RightIndentValid: Boolean index PFM_RIGHTINDENT read REGetParaAttrValid;
    {* |<#richedit>
       Returns True, if property RE_RightIndent is valid for entire selection only. }
    property RE_TabCount: Integer read REGetTabCount write RESetTabCount;
    {* |<#richedit>
       Number of tab stops in current selection. This value can not be set greater
       then MAX_TAB_COUNT (32). }
    property RE_Tabs[ Idx: Integer ]: Integer read REGetTabs write RESetTabs;
    {* |<#richedit>
       Tab stops for RichEdit control. }
    property RE_TabsValid: Boolean index PFM_TABSTOPS read REGetParaAttrValid;
    {* |<#richedit>
       Returns True, if properties RE_Tabs[ ] and RE_TabCount are valid for
       entire selection. }


    // following does not work now :
    property RE_BorderWidth[ Side: TBorderEdge ]: Integer index 2 read REGetBorder write RESetBorder;
    { * |<#richedit>
       Border width. }
    property RE_BorderSpace[ Side: TBorderEdge ]: Integer index 0 read REGetBorder write RESetBorder;
    { * |<#richedit>
       Border space. }
    property RE_BorderStyle[ Side: TBorderEdge ]: Integer index 4 read REGetBorder write RESetBorder;
    { * |<#richedit>
       Border style. }
    property RE_BorderValid: Boolean index PFM_BORDER read REGetParaAttrValid;
    { * |<#richedit>
       Returns True, if border style, space and width are the same for all
       paragraphs in selection. }
    property RE_Table: Boolean index $C000 read REGetParaEffect write RESetParaEffect;
    { * |<#richedit>
       True, if current paragraph is a part of table (row, cell or cell end).
       seems working as read only property. }
    // end of experiment section

    function RE_FmtStandard: PControl;
    {* |<#richedit>
       "Transparent" method (returns Self as a result), which (when called)
       provides "standard" keyboard interface for formatting Rich text (just
       call this method, for example:
       !    RichEd1 := NewRichEdit( Panel1, [ ] ).SetAlign( caClient ).RE_FmtStandard;
       Following keys will be maintained additionally:
       |<pre>
       CTRL+I - switch "Italic",
       CTRL+B - switch "Bold",
       CTRL+U - switch "Underline",
       CTRL+SHIFT+U - swith underline type
                    and turn underline on (note, that some of underline styles
                    can not be shown properly in RichEdit v2.0 and lower,
                    though RichEdit2.0 stores data successfully).
       CTRL+O - switch "StrikeOut",
       CTRL+'gray+' - increase font size,
       CTRL+'gray-' - decrease font size,
       CTRL+SHIFT+'gray+' - superscript,
       CTRL+SHIFT+'gray-' - subscript.
       CTRL+SHIFT+Z - ReDo
       |</pre>
       And, though following standard formatting keys are provided by RichEdit
       control itself in Windows2000, some of these are not functioning
       automatically in earlier Windows versions, even for RichEdit2.0. So,
       functionality of some of these (marked with (*) ) are added here too:
       |<pre>
       CTRL+L - align paragraph left,           (*)
       CTRL+R - align paragraph right,          (*)
       CTRL+E - align paragraph center,         (*)
       CTRL+A - select all,                     (*)
       double-click on word - select word,
       CTRL+Right - to next word,
       CTRL+Left - to previous word,
       CTRL+Home - to the beginning of text,
       CTRL+End - to the end of text.
       CTRL+Z - UnDo
       |</pre>
       If You originally assign some (plain) text to Text property, switching "underline"
       can also change other font attributes, e.g., "bold" - if fsBold style is
       in default Font. To prevent such behavior, select entire text first (see
       SelectAll) and make assignment to RE_Font property, e.g.:
       !        RichEd1.SelectAll;
       !        RichEd1.RE_Font := RichEd1.RE_Font;
       !        RichEd1.SelLength := 0;
       |<br>
       And, some other notices about formatting. Please remember, that only True
       Type fonts can be succefully scaled and transformed to get desired effects
       (e.g., bold). By default, RichEdit uses System font face name, which can
       even have problems with fsBold style. Please remember also, that assigning
       RE_Font to RE_Font just initializying formatting attributes, making all
       those valid in entire text, but does not change font attributes. To use
       True Type font, directly assign face name You wish, e.g.:
       !        RichEd1.SelectAll;
       !        RichEd1.RE_Font := RichEd1.RE_Font;
       !        RichEd1.RE_Font.FontName := 'Arial';
       !        RichEd1.SelLength := 0;
    }
    property RE_AutoKeyboard: Boolean index 1 read REGetLangOptions write RESetLangOptions;
    {* |<#richedit>
       True if autokeyboard on (lovely "feature" of automatic switching keyboard
       language when caret is over another language text). For older RichEdit,
       is 'on' always, for newest - 'off' by default. }

    property RE_OverwriteMode: Boolean read REGetOverwite write RESetOverwrite;
    {* |<#richedit>
       This property allows to control insert/overwrite mode. First, to examine, if
       insert or overwrite mode is current (but it is necessary either to
       access this property, at least once, immediately after creating RichEdit
       control, or to assign event OnRE_InsOvrMode_Change to your handler).
       Second, to set desired mode programmatically - by assigning value to
       this property (You also have to initialize monitoring procedure by either
       reading RE_OverwriteMode property or assigning handler to event
       OnRE_InsOvrMode_Change immediately following RichEdit control creation). }
    property OnRE_InsOvrMode_Change: TOnEvent read fOnREInsModeChg write fOnREInsModeChg;
    {* |<#richedit>
       This event is called, whenever key INSERT is pressed in control (and for
       RichEdit, this means, that insert mode is changed). }
    property RE_DisableOverwriteChange: Boolean read fReOvrDisable write RESetOvrDisable;
    {* |<#richedit>
       It is possible to disable switching between "insert" and "overwrite" mode
       by user (therefore, event OnRE_InsOvrMode_Change continue works, but it
       just called when key INSERT is pressed, though RE_OverwriteMode property
       is not actually changed if switching is disabled). }

    function RE_LoadFromStream( Stream: PStream; Length: Integer;
                                Format: TRETextFormat; SelectionOnly: Boolean ): Boolean;
    {* |<#richedit>
       Use this method rather then assignment to RE_Text property, if
       source is stored in file or stream (to minimize resources during
       loading of RichEdit content). Data is loading starting from current
       position in stream and no more then Length bytes are loaded (use -1
       value to load to the end of stream). Loaded data replaces entire
       content of RichEdit control, or selection only, depending on SelectionOnly
       flag.
       |<br>&nbsp;&nbsp;&nbsp;
       If You want to provide progress (e.g. in form of progress bar), assign
       OnProgress event to your handler - and to examine current position of
       loading, read TSream.Position property of soiurce stream). }
    function RE_SaveToStream( Stream: PStream; Format: TRETextFormat; SelectionOnly: Boolean ): Boolean;
    {* |<#richedit>
       Use this method rather then RE_TextProperty to store data to file
       or stream (to minimize resources during saving of RichEdit content).
       Data is saving starting from current position in a stream (until
       end of RichEdit data). If SelectionOnly flag is True, only selected
       part of RichEdit text is saved.
       |<br>&nbsp;&nbsp;&nbsp;
       Like for RE_LoadFromStream, it is possible to assign your method to
       OnProgress event (but to calculate progress of save-to-stream operation,
       compare current stream position with RE_Size[ rsBytes ] property
       value). }

    property OnProgress: TOnEvent read fOnProgress write fOnProgress;
    {* |<#richedit>
       This event is called during RE_SaveToStream, RE_LoadFromStream (and also
       during RE_SaveToFile, RE_LoadFromFile and while accessing or changing
       RE_Text property). To calculate relative progress, it is possible to
       examine current position in stream/file with its total size while reading,
       or with rich edit text size, while writing (property RE_TextSize[ rsBytes ]).
    }
    function RE_LoadFromFile( const Filename: String; Format: TRETextFormat;
             SelectionOnly: Boolean ): Boolean;
    {* |<#richedit>
       Use this method rather then other assignments to RE_Text property,
       if a source for RichEdit is the file. See also RE_LoadFromStream. }
    function RE_SaveToFile( const Filename: String; Format: TRETextFormat;
             SelectionOnly: Boolean ): Boolean;
    {* |<#richedit>
       Use this method rather then other similar, if You want to store
       entire content of RichEdit or selection only of RichEdit to a file. }

    property RE_Text[ Format: TRETextFormat; SelectionOnly: Boolean ]: String read REReadText write REWriteText;
    {* |<#richedit>
       This property allows to get / replace content of RichEdit control
       (entire text or selection only). Using different formats, it is
       possible to exclude or replace undesired formatting information
       (see TRETextFormat specification). To get or replace entire text
       in reText mode (plain text only), it is possible to use habitual
       for edit controls Text property.
       |<br>&nbsp;&nbsp;&nbsp;
       Note: it is possible to append text to the end of RichEdit control
       using method Add, but only if property RE_Text is accessed at least
       once:
       !               RichEdit1.RE_Text[ reText, True ];
       (This line can be written immediatelly after creating RichEdit control). }

    procedure RE_Append( const S: String; ACanUndo: Boolean );
    {* }
    procedure RE_InsertRTF( const S: String );
    {* }
    property RE_Error: Integer read fREError;
    {* |<#richedit>
       Contains error code, if access to RE_Text failed. }

    procedure RE_HideSelection( aHide: Boolean );
    {* |<#richedit>
       Allows to hide / show selection in RichEdit. }

    function RE_SearchText( const Value: String; MatchCase, WholeWord, ScanForward: Boolean;
                            SearchFrom, SearchTo: Integer ): Integer;
    {* |<#richedit>
       Searches given string starting from SearchFrom position up to SearchTo
       position (to the end of text, if SearchTo is -1). Returns zero-based
       character position of the next match, or -1 if there are no more matches.
       To search in bacward direction, set ScanForward to False, and pass
       SearchFrom > SearchTo (or even SearchFrom = -1 and SearchTo = 0). }

    property RE_AutoURLDetect: Boolean read REGetAutoURLDetect write RESetAutoURLDetect;
    {* |<#richedit>
       If set to True, automatically detects URLs (and highlights it with
       blue color, applying fsItalic and fsUnderline font styles (while
       typing and loading). Default value is False. Note: if event OnRE_URLClick
       or event OnRE_OverURL are set, property RE_AutoURLDetect is set to True
       automatically. }

    property RE_URL: String read fREUrl;
    {* |<#richedit>
       Detected URL (valid in OnRE_OverURL and OnRE_URLClick event handlers). }
    property OnRE_OverURL: TOnEvent index 0
             {$IFDEF F_P}   read REGetOnURL
             {$ELSE DELPHI} read fOnREOverURL
             {$ENDIF F_P/DELPHI} write RESetOnURL;
    {* |<#richedit>
       Is called when mouse is moving over URL. This can be used to set
       cursor, for example, depending on type of URL (to determine URL type
       read property RE_URL). }
    property OnRE_URLClick: TOnEvent index 8
             {$IFDEF F_P}   read REGetOnURL
             {$ELSE DELPHI} read fOnREURLClick
             {$ENDIF F_P/DELPHI} write RESetOnURL;
    {* |<#richedit>
       Is called when click on URL detected. }

    //property RE_SelectionBar: Boolean read REGetSelectionBar write RESetSelectionBar;
    //{* ??? - don't know that is this... }
    function RE_NoOLEDragDrop: PControl;
    {* |<#richedit>
       Just prevents drop OLE objects to the rich edit control. Seems not
       working for some cases. }

    //function RE_Wyswig: PControl;

    function RE_Bottomless: PControl;
    // not finished

    property RE_Transparent: Boolean read REGetTransparent write RESetTransparent;
    {* |<#richedit>
       Use this property to make richedit control transparent, instead of
       Ed_Transparent or Transparent. But do not place such transparent
       richedit control directly on form - it can be draw incorrectly when
       form is activated and rich editr control is not current active control.
       Use at least panel as a parent instead.
       }

    //========== both for Edit and RichEdit: =====================
    function CanUndo: Boolean;
    {* |<#richedit>
       |<#edit>
       |<#memo>
       Returns True, if the edit (or RichEdit) control can correctly process
       the EM_UNDO message. }
    procedure EmptyUndoBuffer;
    {* |<#richedit>
       |<#edit>
       |<#memo>
       Reset the undo flag of an edit control, preventing undoing all previous
       changes. }
    function Undo: Boolean;
    {* |<#richedit>
       |<#edit>
       |<#memo>
       For a single-line edit control, the return value is always TRUE. For a
       multiline edit control and RichEdit control, the return value is TRUE if
       the undo operation is successful, or FALSE if the undo operation fails. }

    function RE_Redo: Boolean;
    {* |<#richedit>
       Only for RichEdit control: Returns True if successful. }




    //----------------------------------------------------------------------

    // "Through", or "transparent" methods to simplify initial
    // adjustment of controls and make non-visual designing of
    // forms more easy. All these functions return Self as a
    // result, so, it is possible to use such methods immediately
    // in constructing statement, concatenating it with dots, e.g.:
    //
    // NewButton( MyForm, 'Click here' ).PlaceUnder.ResizeParentBottom;
    //
    function PlaceRight: PControl;
    {* Places control right (to previously created on the same parent). }
    function PlaceDown: PControl;
    {* Places control below (to previously created on the same parent).
       Left position is not changed (thus is, kept equal to Parent.Margin). }
    function PlaceUnder: PControl;
    {* Places control below (to previously created one, aligning its
       Left position to Left position of previous control). }
    function SetSize( W, H: Integer ): PControl;

    {* Changes size of a control. If W or H less or equal to 0,
       correspondent size is not changed. }
    function Size( W, H: Integer ): PControl;
    {* Like SetSize, but provides automatic resizing of parent control
       (recursively). Especially useful for aligned controls. }
    function SetClientSize( W, H: Integer ): PControl;
    {* Like SetSize, but works setting W = ClientWidth, H = ClientHeight.
       Use this method for forms, which can not be resized (dialogs). }

    function AutoSize( AutoSzOn: Boolean ): PControl;

    {* Determines if to autosize control (like label, button, etc.) }
    function IsAutoSize: Boolean;
    {* TRUE, if a control is autosizing. }
    function AlignLeft( P: PControl ): PControl;
    {* assigns Left := P.Left }
    function AlignTop( P: PControl ): PControl;
    {* assigns Top := P.Top }
    function ResizeParent: PControl;
    {* Resizes parent, calling ResizeParentRight and ResizeParentBottom. }
    function ResizeParentRight: PControl;
    {* Resizes parent right edge (Margin of parent is added to right
       coordinate of a control). If called second time (for the same
       parent), resizes only for increasing of right edge of parent. }

    function ResizeParentBottom: PControl;
    {* Resizes parent bottom edge (Margin of parent is added to
       bottom coordinate of a control). }
    function CenterOnParent: PControl;
    {* Centers control on parent, or if applied to a form, centers
       form on screen. }

    function Shift( dX, dY : Integer ): PControl;
    {* Moves control respectively to current position (Left := Left + dX,
       Top := Top + dY). }
    function SetPosition( X, Y: Integer ): PControl;
    {* Moves control directly to the specified position. }

    function Tabulate: PControl;
    {* Call it once for form/applet to provide tabulation between controls on
       form/on all forms using TAB / SHIFT+TAB and arrow keys. }
    function TabulateEx: PControl;
    {* Call it once for form/applet to provide tabulation between controls on
       form/on all forms using TAB / SHIFT+TAB and arrow keys. Arrow keys are
       used more smart, allowing go to nearest control in certain direction. }

    function SetAlign( AAlign: TControlAlign ): PControl;
    {* Assigns passed value to property Align, aligning control on parent,
       and returns Self (so it is "transparent" function, which can be
       used to adjust control at the creation, e.g.:
       ! MyLabel := NewLabel( MyForm, 'Label1' ).SetAlign( caBottom );
       See also property Align. }
    function PreventResizeFlicks: PControl;
    {* If called, prevents resizing flicks for child controls, aligned to
       right and bottom (but with a lot of code added to executable - about 3,5K).
       There is sensible to set DoubleBuffered to True also to eliminate the
       most of flicks.
       |<br>&nbsp;&nbsp;&nbsp;
       This method been applied to a form, prevents, resizing flicks for
       form and all controls on the form. If it is called for applet window,
       all forms are affected. And if You want, You can apply it for certain
       control only - in such case only given control and its children will
       be resizing without flicks (e.g., using splitter control). }

    property Checked: Boolean read GetChecked write Set_Checked;
    {* |<#checkbox>
       |<#radiobox>
       For checkbox and radiobox - if it is checked. Do not assign
       value for radiobox - use SetRadioChecked instead. }
    function SetChecked(const Value: Boolean): PControl;
    {* |<#checkbox>
       Use it to check/uncheck check box control or push button.
       Do not apply it to check radio buttons - use SetRadioChecked
       method below. }
    function SetRadioChecked : PControl;
    {* |<#radiobox>
       Use it to check radio button item correctly (unchecking all
       alternative ones). Actually, method Click is called, and control
       itself is returned. }
    function SetRadioCheckedOld: PControl;
    {* |<#radiobox>
       Old version of SetRadioChecked (implemented using recommended API
       call. It does not work properly, if control is not visible
       (together with its form). }
    procedure Click;
    {* |<#button>
       |<#checkbox>
       |<#radiobox>
       Emulates click on control programmatically, sending WM_COMMAND
       message with BN_CLICKED code. This method is sensible only for
       buttons, checkboxes and radioboxes. }

    function Perform( msgcode: DWORD; wParam, lParam: Integer): Integer; stdcall;
    {* Sends message to control's window (created if needed). }
    procedure AttachProc( Proc: TWindowFunc );
    {* It is possible to attach dynamically any message handler to window
       procedure using this method. Last attached procedure is called first.
       If procedure returns True, further processing of a message is stopped.
       Attached procedure can be detached using DetachProc (but do not
       attach/detach procedures during handling of attached procedure -
       this can hang application). }
    procedure AttachProcEx( Proc: TWindowFunc; ExecuteAfterAppletTerminated: Boolean );
    {* The same as AttachProc, but a handler is executed even after terminating
       the main message loop processing (i.e. after assigning true to
       AppletTerminated global variable. }
    function IsProcAttached( Proc: TWindowFunc ): Boolean;
    {* Returns True, if given procedure is already in chain of attached
       ones for given control window proc. }
    procedure DetachProc( Proc: TWindowFunc );
    {* Detaches procedure attached earlier using AttachProc. }

    property OnDropFiles: TOnDropFiles read FOnDropFiles write SetOnDropFiles;
    {* Assign this event to your handler, if You want to accept drag and drop
       files from other applications such as explorer onto your control. When
       this event is assigned to a control or form, this has effect also for
       all its child controls too. }

    property CustomData: Pointer read fCustomData write fCustomData;
    {* Can be used to exend the object when new type of control added. Memory,
       pointed by this pointer, released automatically in the destructor. }
    property CustomObj: PObj read fCustomObj write fCustomObj;
    {* Can be used to exend the object when new type of control added. Object,
       pointed by this pointer, released automatically in the destructor. }
    procedure SetAutoPopupMenu( PopupMenu: PObj );
    {* To assign a popup menu to the control, call SetAutoPopupMenu method of
       the control with popup menu object as a parameter. }

    function SupportMnemonics: PControl;
    {* This method provides supporting mnemonic keys in menus, buttons, checkboxes,
       toolbar buttons. }
    property OnScroll: TOnScroll read FOnScroll write SetOnScroll;
    {* }

    {$IFDEF USE_CONSTRUCTORS}
    //------------------------------------------------------------
    // constructors here:
    constructor CreateWindowed( AParent: PControl; AClassName: PChar; ACtl3D: Boolean );
    constructor CreateApplet( const ACaption: String );
    constructor CreateForm( AParent: PControl; const ACaption: String );
    constructor CreateControl( AParent: PControl; AClassName: PChar; AStyle: DWORD;
                               ACtl3D: Boolean; Actions: PCommandActions );
    constructor CreateButton( AParent: PControl; const ACaption: String );
    constructor CreateBitBtn( AParent: PControl; const ACaption: String;
         AOptions: TBitBtnOptions; ALayout: TGlyphLayout; AGlyphBitmap: HBitmap;
         AGlyphCount: Integer);
    constructor CreateLabel( AParent: PControl; const ACaption: String );
    constructor CreateWordWrapLabel( AParent: PControl; const ACaption: String );
    constructor CreateLabelEffect( AParent: PControl; ACaption: String; AShadowDeep: Integer );
    constructor CreatePaintBox( AParent: PControl );
    constructor CreateGradientPanel( AParent: PControl; AColor1, AColor2: TColor );
    constructor CreateGradientPanelEx( AParent: PControl; AColor1, AColor2: TColor;
                             AStyle: TGradientStyle; ALayout: TGradientLayout );
    constructor CreateGroupbox( AParent: PControl; const ACaption: String );
    constructor CreateCheckbox( AParent: PControl; const ACaption: String );
    constructor CreateRadiobox( AParent: PControl; const ACaption: String );
    constructor CreateEditbox( AParent: PControl; AOptions: TEditOptions );
    constructor CreatePanel( AParent: PControl; AStyle: TEdgeStyle );
    constructor CreateSplitter( AParent: PControl; AMinSizePrev, AMinSizeNext: Integer;
                EdgeStyle: TEdgeStyle );
    constructor CreateListbox( AParent: PControl; AOptions: TListOptions );
    constructor CreateCombobox( AParent: PControl; AOptions: TComboOptions );
    constructor CreateCommonControl( AParent: PControl; AClassName: PChar; AStyle: DWORD;
                            ACtl3D: Boolean; Actions: PCommandActions );
    constructor CreateRichEdit( AParent: PControl; AOptions: TEditOptions );
    constructor CreateRichEdit1( AParent: PControl; AOptions: TEditOptions );
    constructor CreateProgressbar( AParent: PControl );
    constructor CreateProgressbarEx( AParent: PControl; AOptions: TProgressbarOptions );
    constructor CreateListView( AParent: PControl; AStyle: TListViewStyle; AOptions: TListViewOptions;
                      AImageListSmall, AImageListNormal, AImageListState: PImageList );
    constructor CreateTreeView( AParent: PControl; AOptions: TTreeViewOptions;
                      AImgListNormal, AImgListState: PImageList );
    constructor CreateTabControl( AParent: PControl; ATabs: array of String;
         AOptions: TTabControlOptions; AImgList: PImageList; AImgList1stIdx: Integer );
    constructor CreateToolbar( AParent: PControl; AAlign: TControlAlign; AOptions: TToolbarOptions;
                     ABitmap: HBitmap; AButtons: array of PChar;
                     ABtnImgIdxArray: array of Integer );
    {$ENDIF USE_CONSTRUCTORS}

    {$IFDEF USE_CUSTOMEXTENSIONS}
      {$I CUSTOM_TCONTROL_EXTENSION.inc}
    {$ENDIF}
    // If an option USE_CUSTOMEXTENSIONS is enabled (at the beginning of this
    // unit), You can freely extend TControl definition by your own fields,
    // methods and properties. This provides You with capability to extend
    // TControl implementing another kinds of visual controls without deriving
    // new descendant objects from TControl. This way is provided to avoid too
    // large grow of executable size. You also can derive your own controls
    // from TControl using standard OOP capabilities. In such case an option
    // USE_CONSTRUCTORS should be turned on (see it at the start of this unit).
    //   If You choose this "flat" model of extending the TControl with your
    // own properties, fieds, methods, events, etc. You should provide three
    // inc-files: CUSTOM_TCONTROL_EXTENSION.inc, containing such definitions
    // for TControl, CUSTOM_KOL_EXTENSION.inc, containing needed global
    // declarations, and CUSTOM_CODE_EXTENSION.inc, the implementation of those
    // two.
    //   Because KOL is always grow and constantly is extending by me, I also can
    // add my own complements for TControl. To avoid naming conflicts, I suggest
    // to use the same naming rule for all of You. Name your fields, properies, etc.
    // using a form idx_SomeName, where idx is a prefix, containing several
    // (at least one) letters and digits. E.g. ZK65_OnSomething.

  end;
//[END OF TControl DEFINITION]

  {$IFDEF USE_MHTOOLTIP}
  {$DEFINE interface}
  {$I KOLMHToolTip}
  {$UNDEF interface}
  {$ENDIF}

//[Paint Background PROCEDURE]
type
  TOnPaintBkgnd = procedure( Sender: PControl; DC: HDC; Rect: PRect );
  {* Global event definition. Used to define Global_OnPaintBackground
     event placeholder. }

procedure DefaultPaintBackground( Sender: PControl; DC: HDC; Rect: PRect );

var
  Global_OnPaintBkgnd: TOnPaintBkgnd = DefaultPaintBackground;
  {* Global event. It is assigned in XBackgounds.pas add-on to replace
     PaintBackground method for all TVisual objects, allowing great
     visualization effect: transparent controls over [animated] bitmap
     background. Idea:
     | <a href=mailto:"bw@sunv.com">Wei&nbsp;Bao</a>. Implementation:
     | <a href=mailto:"bonanzas@xcl.cjb.net">Kladov&nbsp;Vladimir</a>. }

procedure DummyPaintProc( Sender: PControl; DC: HDC );

//[WndProcXXX DECLARATIONS]
function WndProcMouse( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
function WndProcKeybd( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
function WndProcDummy( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
function WndProcBufferedDraw( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
{$IFDEF ALL_BUTTONS_RESPOND_TO_ENTER}
function WndProcBtnReturnClick( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
{$ENDIF}

//[InitCommonXXXX DECLARATIONS]
procedure InitCommonControlSizeNotify( Ctrl: PControl );
procedure InitCommonControlCommonNotify( Ctrl: PControl );

//[Buffered Draw DECLARATIONS]
var
  Global_OnBufferedDraw: function( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean
                         = WndProcDummy;
  Global_DblBufCreateWnd: procedure( Sender: PObj ) = DummyObjProc;
  Global_Invalidate: procedure( Sender: PObj ) = DummyObjProc;
  {* Is called in TControl.Invalidate to extend it in case when DoubleBuffered
     painting used. }

  Global_TranspDrawBkgnd: procedure( DC: HDC; Sender: PControl );

  //Global_OnCreateWindow: procedure( Sender: PObj ) = DummyObjProc;
  //{* Is called when TControl object is created. }
  //Global_OnDestroyWindow: procedure( Sender: PObj ) = DummyObjProc;
  //{* Is called before destroying TControl object (after accepting it,
  //   if event OnClose is defined). }
  Global_OnBeginPaint: procedure( Sender: PControl; DC: HDC ) = DummyPaintProc;
  {* Is called before painting a window. }
  Global_OnEndPaint: procedure( Sender: PControl; DC: HDC ) = DummyPaintProc;
  {* Is called after painting a window. }
  HelpFilePath: PChar;
  {* Path to application help file. If not assigned, application path with
     extension replaced to '.hlp' used. To use '.chm' file (HtmlHelp),
     call AssignHtmlHelp with a path to a html help file (or a name). }

//[Html Help DECLARATIONS]
procedure AssignHtmlHelp( const HtmlHelpPath: String );
procedure HtmlHelpCommand( Wnd: HWnd; const HelpFilePath: String; Cmd, Data: Integer );
{* Use this wrapper procedure to call HtmlHelp API function. }
//+++++++++++ HTML HELP DEFINITIONS SECTION:
// this section is from
//   HTML Help API Interface Unit
//   Copyright (c) 1999 The Helpware Group
// provided for KOL by Alexey Babenko
const
  HH_DISPLAY_TOPIC        = $0000;  {**}
  HH_HELP_FINDER          = $0000;  // WinHelp equivalent
  HH_DISPLAY_TOC          = $0001;  // not currently implemented
  HH_DISPLAY_INDEX        = $0002;  // not currently implemented
  HH_DISPLAY_SEARCH       = $0003;  // not currently implemented
  HH_SET_WIN_TYPE         = $0004;
  HH_GET_WIN_TYPE         = $0005;
  HH_GET_WIN_HANDLE       = $0006;
  HH_ENUM_INFO_TYPE       = $0007;  // Get Info type name, call repeatedly to enumerate, -1 at end
  HH_SET_INFO_TYPE        = $0008;  // Add Info type to filter.
  HH_SYNC                 = $0009;
  HH_RESERVED1            = $000A;
  HH_RESERVED2            = $000B;
  HH_RESERVED3            = $000C;
  HH_KEYWORD_LOOKUP       = $000D;
  HH_DISPLAY_TEXT_POPUP   = $000E;  // display string resource id or text in a popup window
  HH_HELP_CONTEXT         = $000F;  {**}// display mapped numeric value in dwData
  HH_TP_HELP_CONTEXTMENU  = $0010;  // text popup help, same as WinHelp HELP_CONTEXTMENU
  HH_TP_HELP_WM_HELP      = $0011;  // text popup help, same as WinHelp HELP_WM_HELP
  HH_CLOSE_ALL            = $0012;  // close all windows opened directly or indirectly by the caller
  HH_ALINK_LOOKUP         = $0013;  // ALink version of HH_KEYWORD_LOOKUP
  HH_GET_LAST_ERROR       = $0014;  // not currently implemented // See HHERROR.h
  HH_ENUM_CATEGORY        = $0015;	// Get category name, call repeatedly to enumerate, -1 at end
  HH_ENUM_CATEGORY_IT     = $0016;  // Get category info type members, call repeatedly to enumerate, -1 at end
  HH_RESET_IT_FILTER      = $0017;  // Clear the info type filter of all info types.
  HH_SET_INCLUSIVE_FILTER = $0018;  // set inclusive filtering method for untyped topics to be included in display
  HH_SET_EXCLUSIVE_FILTER = $0019;  // set exclusive filtering method for untyped topics to be excluded from display
  HH_INITIALIZE           = $001C;  // Initializes the help system.
  HH_UNINITIALIZE         = $001D;  // Uninitializes the help system.
  HH_PRETRANSLATEMESSAGE  = $00fd;  // Pumps messages. (NULL, NULL, MSG*).
  HH_SET_GLOBAL_PROPERTY  = $00fc;  // Set a global property. (NULL, NULL, HH_GPROP)

  { window properties }

const
  HHWIN_PROP_TAB_AUTOHIDESHOW = $00000001;  // (1 << 0)  Automatically hide/show tri-pane window
  HHWIN_PROP_ONTOP            = $00000002;  // (1 << 1)  Top-most window
  HHWIN_PROP_NOTITLEBAR       = $00000004;  // (1 << 2)  no title bar
  HHWIN_PROP_NODEF_STYLES     = $00000008;  // (1 << 3)  no default window styles (only HH_WINTYPE.dwStyles)
  HHWIN_PROP_NODEF_EXSTYLES   = $00000010;  // (1 << 4)  no default extended window styles (only HH_WINTYPE.dwExStyles)
  HHWIN_PROP_TRI_PANE         = $00000020;  // (1 << 5)  use a tri-pane window
  HHWIN_PROP_NOTB_TEXT        = $00000040;  // (1 << 6)  no text on toolbar buttons
  HHWIN_PROP_POST_QUIT        = $00000080;  // (1 << 7)  post WM_QUIT message when window closes
  HHWIN_PROP_AUTO_SYNC        = $00000100;  // (1 << 8)  automatically ssync contents and index
  HHWIN_PROP_TRACKING         = $00000200;  // (1 << 9)  send tracking notification messages
  HHWIN_PROP_TAB_SEARCH       = $00000400;  // (1 << 10) include search tab in navigation pane
  HHWIN_PROP_TAB_HISTORY      = $00000800;  // (1 << 11) include history tab in navigation pane
  HHWIN_PROP_TAB_FAVORITES    = $00001000;  // (1 << 12) include favorites tab in navigation pane
  HHWIN_PROP_CHANGE_TITLE     = $00002000;  // (1 << 13) Put current HTML title in title bar
  HHWIN_PROP_NAV_ONLY_WIN     = $00004000;  // (1 << 14) Only display the navigation window
  HHWIN_PROP_NO_TOOLBAR       = $00008000;  // (1 << 15) Don't display a toolbar
  HHWIN_PROP_MENU             = $00010000;  // (1 << 16) Menu
  HHWIN_PROP_TAB_ADVSEARCH    = $00020000;  // (1 << 17) Advanced FTS UI.
  HHWIN_PROP_USER_POS         = $00040000;  // (1 << 18) After initial creation, user controls window size/position
  HHWIN_PROP_TAB_CUSTOM1      = $00080000;  // (1 << 19) Use custom tab #1
  HHWIN_PROP_TAB_CUSTOM2      = $00100000;  // (1 << 20) Use custom tab #2
  HHWIN_PROP_TAB_CUSTOM3      = $00200000;  // (1 << 21) Use custom tab #3
  HHWIN_PROP_TAB_CUSTOM4      = $00400000;  // (1 << 22) Use custom tab #4
  HHWIN_PROP_TAB_CUSTOM5      = $00800000;  // (1 << 23) Use custom tab #5
  HHWIN_PROP_TAB_CUSTOM6      = $01000000;  // (1 << 24) Use custom tab #6
  HHWIN_PROP_TAB_CUSTOM7      = $02000000;  // (1 << 25) Use custom tab #7
  HHWIN_PROP_TAB_CUSTOM8      = $04000000;  // (1 << 26) Use custom tab #8
  HHWIN_PROP_TAB_CUSTOM9      = $08000000;  // (1 << 27) Use custom tab #9
  HHWIN_TB_MARGIN             = $10000000;  // (1 << 28) the window type has a margin

  { window parameters }

const
  HHWIN_PARAM_PROPERTIES      = $00000002;  // (1 << 1)  valid fsWinProperties
  HHWIN_PARAM_STYLES          = $00000004;  // (1 << 2)  valid dwStyles
  HHWIN_PARAM_EXSTYLES        = $00000008;  // (1 << 3)  valid dwExStyles
  HHWIN_PARAM_RECT            = $00000010;  // (1 << 4)  valid rcWindowPos
  HHWIN_PARAM_NAV_WIDTH       = $00000020;  // (1 << 5)  valid iNavWidth
  HHWIN_PARAM_SHOWSTATE       = $00000040;  // (1 << 6)  valid nShowState
  HHWIN_PARAM_INFOTYPES       = $00000080;  // (1 << 7)  valid apInfoTypes
  HHWIN_PARAM_TB_FLAGS        = $00000100;  // (1 << 8)  valid fsToolBarFlags
  HHWIN_PARAM_EXPANSION       = $00000200;  // (1 << 9)  valid fNotExpanded
  HHWIN_PARAM_TABPOS          = $00000400;  // (1 << 10) valid tabpos
  HHWIN_PARAM_TABORDER        = $00000800;  // (1 << 11) valid taborder
  HHWIN_PARAM_HISTORY_COUNT   = $00001000;  // (1 << 12) valid cHistory
  HHWIN_PARAM_CUR_TAB         = $00002000;  // (1 << 13) valid curNavType

  { button constants }

const
  HHWIN_BUTTON_EXPAND         = $00000002;  // (1 << 1)  Expand/contract button
  HHWIN_BUTTON_BACK           = $00000004;  // (1 << 2)  Back button
  HHWIN_BUTTON_FORWARD        = $00000008;  // (1 << 3)  Forward button
  HHWIN_BUTTON_STOP           = $00000010;  // (1 << 4)  Stop button
  HHWIN_BUTTON_REFRESH        = $00000020;  // (1 << 5)  Refresh button
  HHWIN_BUTTON_HOME           = $00000040;  // (1 << 6)  Home button
  HHWIN_BUTTON_BROWSE_FWD     = $00000080;  // (1 << 7)  not implemented
  HHWIN_BUTTON_BROWSE_BCK     = $00000100;  // (1 << 8)  not implemented
  HHWIN_BUTTON_NOTES          = $00000200;  // (1 << 9)  not implemented
  HHWIN_BUTTON_CONTENTS       = $00000400;  // (1 << 10) not implemented
  HHWIN_BUTTON_SYNC           = $00000800;  // (1 << 11) Sync button
  HHWIN_BUTTON_OPTIONS        = $00001000;  // (1 << 12) Options button
  HHWIN_BUTTON_PRINT          = $00002000;  // (1 << 13) Print button
  HHWIN_BUTTON_INDEX          = $00004000;  // (1 << 14) not implemented
  HHWIN_BUTTON_SEARCH         = $00008000;  // (1 << 15) not implemented
  HHWIN_BUTTON_HISTORY        = $00010000;  // (1 << 16) not implemented
  HHWIN_BUTTON_FAVORITES      = $00020000;  // (1 << 17) not implemented
  HHWIN_BUTTON_JUMP1          = $00040000;  // (1 << 18)
  HHWIN_BUTTON_JUMP2          = $00080000;  // (1 << 19)
  HHWIN_BUTTON_ZOOM           = $00100000;  // (1 << 20)
  HHWIN_BUTTON_TOC_NEXT       = $00200000;  // (1 << 21)
  HHWIN_BUTTON_TOC_PREV       = $00400000;  // (1 << 22)

  HHWIN_DEF_BUTTONS           = (HHWIN_BUTTON_EXPAND
                                 OR HHWIN_BUTTON_BACK
                                 OR HHWIN_BUTTON_OPTIONS
                                 OR HHWIN_BUTTON_PRINT);


  { Button IDs }

const
  IDTB_EXPAND             = 200;
  IDTB_CONTRACT           = 201;
  IDTB_STOP               = 202;
  IDTB_REFRESH            = 203;
  IDTB_BACK               = 204;
  IDTB_HOME               = 205;
  IDTB_SYNC               = 206;
  IDTB_PRINT              = 207;
  IDTB_OPTIONS            = 208;
  IDTB_FORWARD            = 209;
  IDTB_NOTES              = 210; // not implemented
  IDTB_BROWSE_FWD         = 211;
  IDTB_BROWSE_BACK        = 212;
  IDTB_CONTENTS           = 213; // not implemented
  IDTB_INDEX              = 214; // not implemented
  IDTB_SEARCH             = 215; // not implemented
  IDTB_HISTORY            = 216; // not implemented
  IDTB_FAVORITES          = 217; // not implemented
  IDTB_JUMP1              = 218;
  IDTB_JUMP2              = 219;
  IDTB_CUSTOMIZE          = 221;
  IDTB_ZOOM               = 222;
  IDTB_TOC_NEXT           = 223;
  IDTB_TOC_PREV           = 224;


  { Notification codes }

const
  HHN_FIRST       = (0-860);
  HHN_LAST        = (0-879);

  HHN_NAVCOMPLETE   = (HHN_FIRST-0);
  HHN_TRACK         = (HHN_FIRST-1);
  HHN_WINDOW_CREATE = (HHN_FIRST-2);


type
  {*** Used by command HH_GET_LAST_ERROR
   NOTE: Not part of the htmlhelp.h but documented in HH Workshop help
         You must call SysFreeString(xx.description) to free BSTR
  }
  tagHH_LAST_ERROR = packed record
    cbStruct:      Integer;     // sizeof this structure
    hr:            Integer;     // Specifies the last error code.
    description:   PWideChar;   // (BSTR) Specifies a Unicode string containing a description of the error.
  end;
  HH_LAST_ERROR = tagHH_LAST_ERROR;
  THHLastError = tagHH_LAST_ERROR;


type
  {*** Notify event info for HHN_NAVCOMPLETE, HHN_WINDOW_CREATE }
  PHHNNotify = ^THHNNotify;
  tagHHN_NOTIFY = packed record
    hdr:    TNMHdr;
    pszUrl: PChar;              //PCSTR: Multi-byte, null-terminated string
  end;
  HHN_NOTIFY = tagHHN_NOTIFY;
  THHNNotify = tagHHN_NOTIFY;

  {** Use by command HH_DISPLAY_TEXT_POPUP}
  PHHPopup = ^THHPopup;
  tagHH_POPUP = packed record
    cbStruct:      Integer;     // sizeof this structure
    hinst:         HINST;       // instance handle for string resource
    idString:      cardinal;    // string resource id, or text id if pszFile is specified in HtmlHelp call
    pszText:       PChar;       // used if idString is zero
    pt:            TPOINT;      // top center of popup window
    clrForeground: COLORREF;    // use -1 for default
    clrBackground: COLORREF;    // use -1 for default
    rcMargins:     TRect;       // amount of space between edges of window and text, -1 for each member to ignore
    pszFont:       PChar;       // facename, point size, char set, BOLD ITALIC UNDERLINE
  end;
  HH_POPUP = tagHH_POPUP;
  THHPopup = tagHH_POPUP;

  {** Use by commands - HH_ALINK_LOOKUP, HH_KEYWORD_LOOKUP}
  PHHAKLink = ^THHAKLink;
  tagHH_AKLINK = packed record
    cbStruct:      integer;     // sizeof this structure
    fReserved:     BOOL;        // must be FALSE (really!)
    pszKeywords:   PChar;       // semi-colon separated keywords
    pszUrl:        PChar;       // URL to jump to if no keywords found (may be NULL)
    pszMsgText:    PChar;       // Message text to display in MessageBox if pszUrl is NULL and no keyword match
    pszMsgTitle:   PChar;       // Message text to display in MessageBox if pszUrl is NULL and no keyword match
    pszWindow:     PChar;       // Window to display URL in
    fIndexOnFail:  BOOL;        // Displays index if keyword lookup fails.
  end;
  HH_AKLINK = tagHH_AKLINK;
  THHAKLink = tagHH_AKLINK;


const
  HHWIN_NAVTYPE_TOC          = 0;
  HHWIN_NAVTYPE_INDEX        = 1;
  HHWIN_NAVTYPE_SEARCH       = 2;
  HHWIN_NAVTYPE_FAVORITES    = 3;
  HHWIN_NAVTYPE_HISTORY      = 4;   // not implemented
  HHWIN_NAVTYPE_AUTHOR       = 5;
  HHWIN_NAVTYPE_CUSTOM_FIRST = 11;


const
  IT_INCLUSIVE = 0;
  IT_EXCLUSIVE = 1;
  IT_HIDDEN    = 2;

type
  PHHEnumIT = ^THHEnumIT;
  tagHH_ENUM_IT = packed record                  //tagHH_ENUM_IT, HH_ENUM_IT, *PHH_ENUM_IT
    cbStruct:           Integer;     // size of this structure
    iType:              Integer;     // the type of the information type ie. Inclusive, Exclusive, or Hidden
    pszCatName:         PAnsiChar;   // Set to the name of the Category to enumerate the info types in a category; else NULL
    pszITName:          PAnsiChar;   // volitile pointer to the name of the infotype. Allocated by call. Caller responsible for freeing
    pszITDescription:   PAnsiChar;   // volitile pointer to the description of the infotype.
  end;
  THHEnumIT = tagHH_ENUM_IT;


type
  PHHEnumCat = ^THHEnumCat;
  tagHH_ENUM_CAT = packed record                 //tagHH_ENUM_CAT, HH_ENUM_CAT, *PHH_ENUM_CAT
    cbStruct:           Integer;     // size of this structure
    pszCatName:         PAnsiChar;   // volitile pointer to the category name
    pszCatDescription:  PAnsiChar;   // volitile pointer to the category description
  end;
  THHEnumCat = tagHH_ENUM_CAT;


type
  PHHSetInfoType = ^THHSetInfoType;
  tagHH_SET_INFOTYPE = packed record             //tagHH_SET_INFOTYPE, HH_SET_INFOTYPE, *PHH_SET_INFOTYPE
    cbStruct:           Integer;     // the size of this structure
    pszCatName:         PAnsiChar;   // the name of the category, if any, the InfoType is a member of.
    pszInfoTypeName:    PAnsiChar;   // the name of the info type to add to the filter
  end;
  THHSetInfoType = tagHH_SET_INFOTYPE;


type
  HH_INFOTYPE = DWORD;
  THHInfoType = HH_INFOTYPE;
  PHHInfoType = ^THHInfoType;        //PHH_INFOTYPE


const
  HHWIN_NAVTAB_TOP    = 0;
  HHWIN_NAVTAB_LEFT   = 1;
  HHWIN_NAVTAB_BOTTOM = 2;

const
  HH_MAX_TABS  = 19;                 // maximum number of tabs
const
  HH_TAB_CONTENTS     = 0;
  HH_TAB_INDEX        = 1;
  HH_TAB_SEARCH       = 2;
  HH_TAB_FAVORITES    = 3;
  HH_TAB_HISTORY      = 4;
  HH_TAB_AUTHOR       = 5;
  HH_TAB_CUSTOM_FIRST = 11;
  HH_TAB_CUSTOM_LAST  = HH_MAX_TABS;

  HH_MAX_TABS_CUSTOM = (HH_TAB_CUSTOM_LAST - HH_TAB_CUSTOM_FIRST + 1);



  { HH_DISPLAY_SEARCH Command Related Structures and Constants }

const
  HH_FTS_DEFAULT_PROXIMITY = (-1);

type
  {** Used by command HH_DISPLAY_SEARCH}
  PHHFtsQuery = ^THHFtsQuery;
  tagHH_FTS_QUERY = packed record          //tagHH_FTS_QUERY, HH_FTS_QUERY
    cbStruct:          integer;      // Sizeof structure in bytes.
    fUniCodeStrings:   BOOL;         // TRUE if all strings are unicode.
    pszSearchQuery:    PChar;        // String containing the search query.
    iProximity:        LongInt;      // Word proximity.
    fStemmedSearch:    Bool;         // TRUE for StemmedSearch only.
    fTitleOnly:        Bool;         // TRUE for Title search only.
    fExecute:          Bool;         // TRUE to initiate the search.
    pszWindow:         PChar;        // Window to display in
  end;
  THHFtsQuery = tagHH_FTS_QUERY;


  { HH_WINTYPE Structure }

type
  {** Used by commands HH_GET_WIN_TYPE, HH_SET_WIN_TYPE}
  PHHWinType = ^THHWinType;
  tagHH_WINTYPE = packed record             //tagHH_WINTYPE, HH_WINTYPE, *PHH_WINTYPE;
    cbStruct:          Integer;      // IN: size of this structure including all Information Types
    fUniCodeStrings:   BOOL;         // IN/OUT: TRUE if all strings are in UNICODE
    pszType:           PChar;        // IN/OUT: Name of a type of window
    fsValidMembers:    DWORD;        // IN: Bit flag of valid members (HHWIN_PARAM_)
    fsWinProperties:   DWORD;        // IN/OUT: Properties/attributes of the window (HHWIN_)

    pszCaption:        PChar;        // IN/OUT: Window title
    dwStyles:          DWORD;        // IN/OUT: Window styles
    dwExStyles:        DWORD;        // IN/OUT: Extended Window styles
    rcWindowPos:       TRect;        // IN: Starting position, OUT: current position
    nShowState:        Integer;      // IN: show state (e.g., SW_SHOW)

    hwndHelp:          HWND;         // OUT: window handle
    hwndCaller:        HWND;         // OUT: who called this window

    paInfoTypes:       PHHInfoType;  // IN: Pointer to an array of Information Types

    { The following members are only valid if HHWIN_PROP_TRI_PANE is set }

    hwndToolBar:       HWND;         // OUT: toolbar window in tri-pane window
    hwndNavigation:    HWND;         // OUT: navigation window in tri-pane window
    hwndHTML:          HWND;         // OUT: window displaying HTML in tri-pane window
    iNavWidth:         Integer;      // IN/OUT: width of navigation window
    rcHTML:            TRect;        // OUT: HTML window coordinates

    pszToc:            PChar;        // IN: Location of the table of contents file
    pszIndex:          PChar;        // IN: Location of the index file
    pszFile:           PChar;        // IN: Default location of the html file
    pszHome:           PChar;        // IN/OUT: html file to display when Home button is clicked
    fsToolBarFlags:    DWORD;        // IN: flags controling the appearance of the toolbar (HHWIN_BUTTON_)
    fNotExpanded:      BOOL;         // IN: TRUE/FALSE to contract or expand, OUT: current state
    curNavType:        Integer;      // IN/OUT: UI to display in the navigational pane
    tabpos:            Integer;      // IN/OUT: HHWIN_NAVTAB_TOP, HHWIN_NAVTAB_LEFT, or HHWIN_NAVTAB_BOTTOM
    idNotify:          Integer;      // IN: ID to use for WM_NOTIFY messages
    tabOrder: packed array[0..HH_MAX_TABS] of Byte;  // IN/OUT: tab order: Contents, Index, Search, History, Favorites, Reserved 1-5, Custom tabs
    cHistory:          Integer;       // IN/OUT: number of history items to keep (default is 30)
    pszJump1:          PChar;         // Text for HHWIN_BUTTON_JUMP1
    pszJump2:          PChar;         // Text for HHWIN_BUTTON_JUMP2
    pszUrlJump1:       PChar;         // URL for HHWIN_BUTTON_JUMP1
    pszUrlJump2:       PChar;         // URL for HHWIN_BUTTON_JUMP2
    rcMinSize:         TRect;         // Minimum size for window (ignored in version 1)

    cbInfoTypes:       Integer;       // size of paInfoTypes;
    pszCustomTabs:     PChar;         // multiple zero-terminated strings
  end;
  HH_WINTYPE = tagHH_WINTYPE;
  THHWinType = tagHH_WINTYPE;

const
  HHACT_TAB_CONTENTS   = 0;
  HHACT_TAB_INDEX      = 1;
  HHACT_TAB_SEARCH     = 2;
  HHACT_TAB_HISTORY    = 3;
  HHACT_TAB_FAVORITES  = 4;

  HHACT_EXPAND         = 5;
  HHACT_CONTRACT       = 6;
  HHACT_BACK           = 7;
  HHACT_FORWARD        = 8;
  HHACT_STOP           = 9;
  HHACT_REFRESH        = 10;
  HHACT_HOME           = 11;
  HHACT_SYNC           = 12;
  HHACT_OPTIONS        = 13;
  HHACT_PRINT          = 14;
  HHACT_HIGHLIGHT      = 15;
  HHACT_CUSTOMIZE      = 16;
  HHACT_JUMP1          = 17;
  HHACT_JUMP2          = 18;
  HHACT_ZOOM           = 19;
  HHACT_TOC_NEXT       = 20;
  HHACT_TOC_PREV       = 21;
  HHACT_NOTES          = 22;

  HHACT_LAST_ENUM      = 23;


type
  {*** Notify event info for HHN_TRACK }
  PHHNTrack = ^THHNTrack;
  tagHHNTRACK = packed record                  //tagHHNTRACK, HHNTRACK;
    hdr:               TNMHdr;
    pszCurUrl:         PChar;                  // Multi-byte, null-terminated string
    idAction:          Integer;                // HHACT_ value
    phhWinType:        PHHWinType;             // Current window type structure
  end;
  HHNTRACK = tagHHNTRACK;
  THHNTrack = tagHHNTRACK;


///////////////////////////////////////////////////////////////////////////////
//
// Global Control Properties.
//
const
  HH_GPROPID_SINGLETHREAD     = 1;      // VARIANT_BOOL: True for single thread
  HH_GPROPID_TOOLBAR_MARGIN   = 2;      // long: Provides a left/right margin around the toolbar.
  HH_GPROPID_UI_LANGUAGE      = 3;      // long: LangId of the UI.
  HH_GPROPID_CURRENT_SUBSET   = 4;      // BSTR: Current subset.
  HH_GPROPID_CONTENT_LANGUAGE = 5;      // long: LandId for desired content.

type
  tagHH_GPROPID = HH_GPROPID_SINGLETHREAD..HH_GPROPID_CONTENT_LANGUAGE;                //tagHH_GPROPID, HH_GPROPID
  HH_GPROPID = tagHH_GPROPID;
  THHGPropID = HH_GPROPID;

///////////////////////////////////////////////////////////////////////////////
//
// Global Property structure
//
{type
  PHHGlobalProperty = ^THHGlobalProperty;
  tagHH_GLOBAL_PROPERTY = record                  //tagHH_GLOBAL_PROPERTY, HH_GLOBAL_PROPERTY
    id:                THHGPropID;
    Dummy:             Integer;                  // Added to enforce 8-byte packing
    var_:              VARIANT;
  end;
  HH_GLOBAL_PROPERTY = tagHH_GLOBAL_PROPERTY;
  THHGlobalProperty = tagHH_GLOBAL_PROPERTY;}
//[END OF HTMLHELP DECLARATIONS]

//[GetCtlBrush DECLARATIONS]
function SimpleGetCtlBrushHandle( Sender: PControl ): HBrush; //forward;

var
  Global_GetCtlBrushHandle: function( Sender: PControl ): HBrush = SimpleGetCtlBrushHandle;
  {* Is called to obtain brush handle. }

  Global_Align: procedure( Sender: PObj ) = DummyObjProc;
  {* Is set to perform aligning of control, and only if property Align
     is changed for TControl, or SetAlign method is called for it. }

//[WndFunc DECLARATION]
function WndFunc( W: HWnd; Msg: Cardinal; wParam, lParam: Integer )
                                   : Integer; stdcall;
{* Global message handler for window. Redirects all messages to
   destination windows, obtaining target TControl object address from
   window itself, using GetProp API call. }

//[Applet VARIABLES]
var AppletRunning: Boolean;
    {* Is set to True while message loop is processing (in Run procedure). }
    AppletTerminated: Boolean;
    {* Is set to True when message loop is terminated. }
    Applet: PControl;
    {* Applet window object. Actually, can be set to main form if program
       not needed in special applet button window (useful to make applet
       button invisible on taskbar, or to have several forms with single
       applet button - crete it in that case using NewApplet). }
    AppButtonUsed: Boolean;
    {* True if special window to represent applet button (may be invisible)
       is used. If no, every form is represented with its own taskbar button
       (always visible). }

//[Screen DECLARATIONS]
    ScreenCursor: HCursor;
    {* Set this global variable to override any cursor settings of current
       form or control. }

function ScreenWidth: Integer;
{* Returns screen width in pixels. }
function ScreenHeight: Integer;
{* Returns screen height in pixels. }

//[Status DECLARATIONS]
type
  TStatusOption = ( soNoSizeGrip, soTop );
  {* Options available for status bars. }
  TStatusOptions = Set of TStatusOption;
  {* Status bar options. }





//[Run DECLARATION]
procedure Run( var AppletWnd: PControl );
{* |<#appbutton>
   Call this procedure to process messages loop of your program.
   Pass here pointer to applet button object (if You have created it
   - see NewApplet) or your main form object of type PControl (created
   using NewForm).
     |<br><br>
     |<h1 align=center><font color=#FF8040><a name="visual_objects_constructors"></a>
       Visual objects constructing functions
     |</font></h2>
   Following constructing functions for visual controls are available:
   |#control
}

//[Applet FUNCTIONS DECLARATIONS]
procedure AppletMinimize;
{* Minimizes the application (Applet should be assigned to have effect). }
procedure AppletHide;
{* Minimizes and hides application. }
procedure AppletRestore;
{* Restores Applet when minimized. }

//[Idle handler DECALRATIONS]
{YS+}
procedure RegisterIdleHandler( const OnIdle: TOnEvent );
{* Registers new Idle handler. Idle handler is called each time when
   message queue becomes empty. }
procedure UnRegisterIdleHandler( const OnIdle: TOnEvent );
{* Unregisters Idle handler. }
{YS-}



//[InitCommonXXXX ANOTHER DECLARATIONS]

{* ComCtrl32 controls initialization. }
procedure InitCommonControls; stdcall;
procedure DoInitCommonControls( dwICC: DWORD );
{* Calls extended initialization for Common Controls (from ComCtrl32).
   Pass one of following constants:
   |<pre>
  ICC_LISTVIEW_CLASSES   = $00000001; // listview, header
  ICC_TREEVIEW_CLASSES   = $00000002; // treeview, tooltips
  ICC_BAR_CLASSES        = $00000004; // toolbar, statusbar, trackbar, tooltips
  ICC_TAB_CLASSES        = $00000008; // tab, tooltips
  ICC_UPDOWN_CLASS       = $00000010; // updown
  ICC_PROGRESS_CLASS     = $00000020; // progress
  ICC_HOTKEY_CLASS       = $00000040; // hotkey
  ICC_ANIMATE_CLASS      = $00000080; // animate
  ICC_WIN95_CLASSES      = $000000FF;
  ICC_DATE_CLASSES       = $00000100; // month picker, date picker, time picker, updown
  ICC_USEREX_CLASSES     = $00000200; // comboex
  ICC_COOL_CLASSES       = $00000400; // rebar (coolbar) control
  ICC_INTERNET_CLASSES   = $00000800;
  ICC_PAGESCROLLER_CLASS = $00001000; // page scroller
  ICC_NATIVEFNTCTL_CLASS = $00002000; // native font control
   |</pre>
    }

const
  ICC_LISTVIEW_CLASSES   = $00000001; // listview, header
  ICC_TREEVIEW_CLASSES   = $00000002; // treeview, tooltips
  ICC_BAR_CLASSES        = $00000004; // toolbar, statusbar, trackbar, tooltips
  ICC_TAB_CLASSES        = $00000008; // tab, tooltips
  ICC_UPDOWN_CLASS       = $00000010; // updown
  ICC_PROGRESS_CLASS     = $00000020; // progress
  ICC_HOTKEY_CLASS       = $00000040; // hotkey
  ICC_ANIMATE_CLASS      = $00000080; // animate
  ICC_WIN95_CLASSES      = $000000FF;
  ICC_DATE_CLASSES       = $00000100; // month picker, date picker, time picker, updown
  ICC_USEREX_CLASSES     = $00000200; // comboex
  ICC_COOL_CLASSES       = $00000400; // rebar (coolbar) control
  ICC_INTERNET_CLASSES   = $00000800;
  ICC_PAGESCROLLER_CLASS = $00001000; // page scroller
  ICC_NATIVEFNTCTL_CLASS = $00002000; // native font control

//[Ole DECLARATIONS]
function OleInit: Boolean;
{* Calls OleInitialize (once - all other calls are simulated by incrementing
   call counter. Every OleInit shoud be complemented with correspondent OleUninit.
   (Though, it is possible to call API function OleUnInitialize once to
   cancel all OleInit calls). }
procedure OleUnInit;
{* Decrements counter and calls OleUnInitialize when it is zeroed. }
var OleInitCount: Integer;

function SysAllocStringLen(psz: PWideChar; len: Integer): PWideChar; stdcall;
procedure SysFreeString( psz: PWideChar ); stdcall;










{ -- Contructors for visual controls -- }
//[NewXXXX DECLARATIONS]

//[_NewWindowed DECLARATION]
function _NewWindowed( AParent: PControl; ControlClassName: PChar; Ctl3D: Boolean ): PControl;

//[NewApplet DECLARATION]
function NewApplet( const Caption: String ): PControl;
{* |<#control>
   Creates applet button window, which has to be parent of all other forms
   in your project (but this is *not must*). See also comments about NewForm.
   |<br>
   Following methods, properties and events are useful to work with applet
   control:
   |#appbutton }

//[NewForm DECLARATION]
function NewForm( AParent: PControl; const Caption: String ): PControl;
{* |<#control>
   Creates form window object and returns pointer to it. If You use only one form,
   and You are not going to do applet button on task bar invisible, it is not
   necessary to create also special applet button window - just pass
   your (main) form object to Run procedure. In that case, it is a good
   idea to assign pointer to your main form object to Applet variable
   immediately following creating it - because some objects (e.g. TTimer)
   want to have Applet assigned to something.
   |<br>
   |&D=<a href="tcontrol.htm#%1" target=_top> %0 </a>
   Following methods, properties and events are useful to work with forms
   (ones common for all visual objects, such as <D Left>, <D Top>, <D Width>,
   <D Height>, etc. are not listed here - look TControl for it):
   |#form }

//[_NewControl DECLARATION]
function _NewControl( AParent: PControl; ControlClassName: PChar;
         Style: DWORD; Ctl3D: Boolean; Actions: PCommandActions ): PControl;

//[NewButton DECLARATION]
function NewButton( AParent: PControl; const Caption: String ): PControl;
{* |<#control>
   Creates button on given parent control or form.
   Please note, that in Windows, buttons can not change its <D Font> color
   and to be <D Transparent>.
   |<br> Following methods, properies and events are (especially) useful with
   a button:
   |#button }

//[NewBitBtn DECLARATION]
function NewBitBtn( AParent: PControl; const Caption: String;
         Options: TBitBtnOptions; Layout: TGlyphLayout; GlyphBitmap: HBitmap; GlyphCount: Integer ): PControl;
{* |<#control>
   Creates image button (actually implemented as owner-drawn). In Options,
   it is possible to determine, whether bitmap or image list used to contain
   one or more (up to 5) images, correspondent to certain BitBtn state.
   |<br>&nbsp;&nbsp;&nbsp;
   For case of imagelist (option bboImageList), it is possible to use a
   number of glyphs from the image list, starting from image index given
   by GlyphCount parameter. Number of used glyphs is passed in that case
   in high word of GlyphCount parameter (if 0, one image is used therefore).
   For bboImageList, BitBtn can be Transparent (and in that case bboNoBorder
   style can be useful to draw custom buttons of non-rectangular shape).
   |<br>&nbsp;&nbsp;&nbsp;
   For case of bitmap BitBtn, image is stretched down (if too big), but can
   not be transparent. It is not necessary for bitmap BitBtn to pass correct
   GlyphCount - it is calculated on base of bitmap size, if 0 is passed.
   |<br>&nbsp;&nbsp;&nbsp;
   And, certainly, BitBtn can be without glyph image (text only). For that
   case, it is therefore is more flexible and power than usual Button (but
   requires more code). E.g., BitBtn can change its <D Font>, <D Color>,
   and to be totally <D Transparent>.
   Moreover, BitBtn can be <D Flat>, bboFixed, <D SpeedButton> and
   have property <D RepeatInterval>.
   |<br>&nbsp;&nbsp;&nbsp;
   Note: if You use bboFixed Style, use OnChange event instead of OnClick,
   because <D Checked> state is changed immediately however OnClick occure
   only when mouse or space key released (and can be not called at all if
   mouse button is released out of BitBtn bounds). Also, bboFixed defines
   only which glyph to show (the border if it is not turned off behaves as
   usual for a button, i.e. it becomes lowered and then raised again at any click).
   Here You can find references to other properties, events and methods
   applicable to BitBtn:
   |#bitbtn }

//[NewLabel DECLARATION]
function NewLabel( AParent: PControl; const Caption: String ): PControl;
{* |<#control>
   Creates static text control (native Windows STATIC control).
   Use property <D Caption> at run time to change label text. Also
   it is possible to adjust label <D Font>, <D Brush> or <D Color>.
   Label can be <D Transparent>. If You want to have rotated text
   label, call NewLabelEffect instead and change its <D Font>.FontOrientation.
   Other references certain for a label:
   |#label }

//[NewWordWrapLabel DECLARATION]
function NewWordWrapLabel( AParent: PControl; const Caption: String ): PControl;
{* |<#control>
   Creates multiline static text control (native Windows STATIC control),
   which can wrap long text onto several lines. See also NewLabel.
   See also:
   |#wwlabel
   |#label }

//[NewLabelEffect DECLARATION]
function NewLabelEffect( AParent: PControl; const Caption: String; ShadowDeep: Integer ): PControl;
{* |<#control>
   Creates 3D-label with capability to rotate its text <D Caption>, which
   is controlled by changing <D Font>.FontOrientation property. If You want
   to get flat effect label (e.g. to rotate it only), pass <D ShadowDeep> = 0.
   Please note, that drawing procedure uses <D Canvas> property, so using of
   LabelEffect leads to increase size of executable.
   See also:
   |#3dlabel
   |#label }

//[NewPaintbox DECLARATION]
function NewPaintbox( AParent: PControl ): PControl;
{* |<#control>
   Creates owner-drawn STATIC control. Set its <D OnPaint> event to
   perform custom painting.
   |#paintbox }

//[NewImageShow DECLARATION]
function NewImageShow( AParent: PControl; AImgList: PImageList; ImgIdx: Integer ): PControl;
{* |<#control>
   Creates an image show control, implemented as a paintbox which is used to
   draw an image from the imagelist. At run-time, use property CurIndex to
   select another image from the imagelist, and a property ImageListNormal to
   use another image list. When the control is created, its size becomes
   equal to dimensions of imagelist (if any). }

//[NewScrollBar DECLARATION]
function NewScrollBar( AParent: PControl; BarSide: TScrollerBar ): PControl;
{ * not yet finished... }

//[NewScrollBox DECLARATION]
function NewScrollBox( AParent: PControl; EdgeStyle: TEdgeStyle;
         Bars: TScrollerBars ): PControl;
{* |<#control>
   Creates simple scrolling box, which can be used any way you wish, e.g. to scroll
   certain large image. To provide automatic scrolling of a set of child controls,
   use advanced scroll box, created with NewScrollBoxEx. }

procedure NotifyScrollBox( Self_, Child: PControl );


function NewScrollBoxEx( AParent: PControl; EdgeStyle: TEdgeStyle ): PControl;
{* |<#control>
   Creates extended scrolling box control, which automatically scrolls child
   controls (if any). }

//[NewGradientPanel DECLARATION]
function NewGradientPanel( AParent: PControl; Color1, Color2: TColor ): PControl;
{* |<#control>
   Creates gradient-filled STATIC control. To adjust colors at the
   run time, change <D Color1> and <D Color2> properties (which initially are
   assigned from Color1, Color2 parameters), and call <D Invalidate> method
   to repaint control. }

function NewGradientPanelEx( AParent: PControl; Color1, Color2: TColor;
                             Style: TGradientStyle; Layout: TGradientLayout ): PControl;
{* |<#control>
   Creates gradient-filled STATIC control. To adjust colors at the
   run time, change <D Color1> and <D Color2> properties (which initially are
   assigned from Color1, Color2 parameters), and call <D Invalidate> method
   to repaint control. Depending on style and first line/point layout, can
   looking different. Idea: Vladimir Stojiljkovic. }

//[NewPanel DECLARATION]
function NewPanel( AParent: PControl; EdgeStyle: TEdgeStyle ): PControl;
{* |<#control>
   Creates panel, which can be parent for other controls (though, any
   control can be used as a parent for other ones, but panel is specially
   designed for such purpose). }

//[NewMDIxxx DECLARATIONS]
function NewMDIClient( AParent: PControl; WindowMenu: THandle ): PControl;
{* |<#control>
   Creates MDI client window, which is a special type of child window,
   containing all MDI child windows, created calling NewMDIChild function.
   On a form, MDI client behaves like a panel, so it can be placed and sized
   (or aligned) like any other controls. To minimize flick during resizing
   main form having another aligned controls, place MDI client window on
   a panel and align it caClient in the panel.
   |<br>Note:
   MDI client must be a single on the form. }

function NewMDIChild( AParent: PControl; const ACaption: String ): PControl;
{* |<#control>
   Creates MDI client window. AParent should be a MDI client window,
   created with NewMDIClient function. }

//[NewSplitter DECLARATIONS]
function NewSplitter( AParent: PControl; MinSizePrev, MinSizeNext: Integer ): PControl;
{* |<#control>
   Creates splitter control, which will separate previous one (i.e. last
   created one before splitter on the same parent) from created
   next, allowing to user to adjust size of separated controls by dragging
   the splitter in desired direction. Created splitter becomes vertical
   or horizontal depending on Align style of previous control on the same
   parent (if caLeft/caRight then vertical, if caTop/caBottom then horizontal).
   |<br>&nbsp;&nbsp;&nbsp;
   Please note, what if previous control has no Align equal to caLeft/caRight
   or caTop/caBottom, splitter will not be able to function normally. If
   previous control does not exist, it is yet possible to use splitter as
   a resizeable panel (but set its initial Align value first - otherwise it
   is not set by default. Also, change Cursor property as You wish in that
   case, since it is not set too in case, when previous control does not
   exist).
   |<br>&nbsp;&nbsp;&nbsp;
   Additional parameters determine, which minimal size (width or height -
   correspondently to split direction) is allowed for left (top) control
   and to rest of client area of parent, correspondently. (It is possible
   later to set second control for checking its size with MinSizeNext
   value - using TControl.SecondControl property). If -1 passed,
   correspondent control size is not checked during dragging of splitter.
   Usually 0 is more suitable value (with this value, it is garantee, that
   splitter will be always available even if mouse was released far from the
   edge of form).
   |<br>&nbsp;&nbsp;&nbsp;
   It is possible for user to press Escape any time while dragging splitter
   to abort all adjustments made starting from left mouse button push and
   begin of drag the splitter. But remember please, that such event is
   controlled using timer, and therefore correspondent keyboard events
   are received by currently focused control. Be sure, that pressing Escape
   will not affect to any control on form, which could be focused, otherwise
   filter keyboard messages (by yourself) to prevent undesired handling of
   Escape key by certain controls while splitting. (Use Dragging property
   to check if splitter is dragging by user with mouse).
   |<br>&nbsp;&nbsp;&nbsp;
   See also:
   NewSplitterEx
   |#splitter }

function NewSplitterEx( AParent: PControl; MinSizePrev, MinSizeNext: Integer;
         EdgeStyle: TEdgeStyle ): PControl;
{* |<#control>
   Creates splitter control. Difference from NewSplitter is what it is possible
   to determine if a splitter will be beveled or not. See also NewSplitter. }

//[NewGroupbox DECLARATION]
function NewGroupbox( AParent: PControl; const Caption: String ): PControl;
{* |<#control>
   Creates group box control. Note, that to group radio items, group
   box is not necessary - any parent can play role of group for radio items.
   See also NewPanel. }

//[NewCheckbox DECLARATION]
function NewCheckbox( AParent: PControl; const Caption: String ): PControl;
{* |<#control>
   Creates check box control. Special properties, methods, events:
   |#checkbox }

function NewCheckBox3State( AParent: PControl; const Caption: String ): PControl;
{* |<#control>
   Creates check box control with 3 states. Special properties, methods,
   events:
   |#checkbox }

//[NewRadiobox DECLARATION]
function NewRadiobox( AParent: PControl; const Caption: String ): PControl;
{* |<#control>
   Creates radio box control. Alternative radio items must have the
   same parent window (regardless of its kind, either groupbox (NewGroupbox),
   panel (NewPanel) or form itself). Following properties, methods and events
   are specially for radiobox controls:
   |#radiobox }

//[NewEditbox DECLARATION]
function NewEditbox( AParent: PControl; Options: TEditOptions ): PControl;
{* |<#control>
   Creates edit box control. To create multiline edit box, similar to
   TMemo in VCL, apply eoMultiline in Options. Following properties, methods,
   events are special for edit controls:
   |#edit }

//[NewRichEdit DECLARATION]
function NewRichEdit( AParent: PControl; Options: TEditOptions ): PControl;
{* |<#control>
   Creates rich text edit control. A rich edit control is a window in which
   the user can enter and edit text. The text can be assigned character and
   paragraph formatting, and can include embedded OLE objects. Rich edit
   controls provide a programming interface for formatting text. However, an
   application must implement any user interface components necessary to make
   formatting operations available to the user.
   |<br>&nbsp;&nbsp;&nbsp;
   Note: eoPassword, eoMultiline options have no effect for RichEdit control.
   Some operations are supersided with special versions of those, created
   especially for RichEdit, but in some cases it is necessary to use
   another properties and methods, specially designed for RichEdit (see
   methods and properties, which names are starting from RE_...).
   |<br>&nbsp;&nbsp;&nbsp;
   Following properties, methods, events are special for edit controls:
   |#richedit
   }

function NewRichEdit1( AParent: PControl; Options: TEditOptions ): PControl;
{* |<#control>
   Like NewRichEdit, but to work with older RichEdit control version 1.0
   (window class 'RichEdit' forced to use instead of 'RichEdit20A', even
   if library RICHED20.DLL found and loaded successfully). One more
   difference - OleInit is not called, so the most of OLE capabilities
   of RichEdit could not working. }

//[NewListbox DECLARATION]
function NewListbox( AParent: PControl; Options: TListOptions ): PControl;
{* |<#control>
   Creates list box control. Following properties, methods and events are
   special for Listbox:
   |#listbox }

//[NewCombobox DECLARATION]
function NewCombobox( AParent: PControl; Options: TComboOptions ): PControl;
{* |<#control>
   Creates new combo box control. Note, that it is not possible to align
   combobox caLeft or caRight: this can cause infinit recursion in the
   application.
   |<br>Following properties, methods and events are
   special for Combobox:
   |#combo }

//[_NewCommonControl DECLARATION]
function _NewCommonControl( AParent: PControl; ClassName: PChar; Style: DWORD;
                            Ctl3D: Boolean; Actions: PCommandActions ): PControl;

//[NewProgressbar DECLARATION]
function NewProgressbar( AParent: PControl ): PControl;
{* |<#control>
   Creates progress bar control. Following properties are special for
   progress bar:
   |#progressbar
   See also NewProgressEx. }

function NewProgressbarEx( AParent: PControl; Options: TProgressbarOptions ): PControl;
{* |<#control>
   Can create progress bar with smooth style (progress is not segmented
   onto bricks) or/and vertical progress bar - using additional parameter.
   For list of properties, suitable for progress bars, see NewProgressbar. }

//[NewListVew DECLARATION]
function NewListView( AParent: PControl; Style: TListViewStyle; Options: TListViewOptions;
  ImageListSmall, ImageListNormal, ImageListState: PImageList ): PControl;
{* |<#control>
   Creates list view control. It is very powerful control, which can partially
   compensate absence of grid controls (in lvsDetail view mode). Properties,
   methods and events, special for list view control are:
   |#listview }

//[NewTreeView DECLARATION]
function NewTreeView( AParent: PControl; Options: TTreeViewOptions;
                      ImgListNormal, ImgListState: PImageList ): PControl;
{* |<#control>
   Creates tree view control. See tree view methods and properties:
   |#treeview }

//[NewTabControl DECLARATION]
function NewTabControl( AParent: PControl; Tabs: array of String; Options: TTabControlOptions;
         ImgList: PImageList; ImgList1stIdx: Integer ): PControl;
{* |<#control>
   Creates new tab control (like notebook). To place child control on a certain
   page of TabControl, use property Pages[ Idx ], for example:
   ! Label1 := NewLabel( TabControl1.Pages[ 0 ], 'Label1' );
   | &nbsp;&nbsp;&nbsp;
   To determine number of pages at run time, use property <D Count>;
   |<br> to determine which page is currently selected (or to change
   selection), use property <D CurrentIndex>;
   |<br> to feedback to switch between tabs assign your handler to OnSelChange
   event;
   |<br>Note, that by default, tab control is created with a border lowered to
   tab control's parent. To remove it, you can apply WS_EX_TRANSPARENT extended
   style (see TControl.ExStyle property), but painting of some child controls
   can be strange a bit in this case (no border drawing for edit controls was
   found, but not always...). You can also apply style WS_THICKFRAME (TControl.Style
   property) to make the border raised.
   |<br> Other methods and properties, suitable for tab control, are:
   |#tabcontrol }

//[NewToolbar DECLARATION]
function NewToolbar( AParent: PControl; Align: TControlAlign; Options: TToolbarOptions;
                     Bitmap: HBitmap; Buttons: array of PChar;
                     BtnImgIdxArray: array of Integer ) : PControl;
{* |<#control>
   Creates toolbar control. Bitmap must contain images for all buttons
   excluding separators (defined by string '-' in Buttons array), otherwise
   last buttons will no have images at all. Image width for every button
   is assumed to be equal to Bitmap height (if last of "squares" has
   insufficient width, it will not be used). To define fixed buttons, use
   characters '+' or '-' as a prefix for button string (even empty). To
   create groups of (radio-)buttons, use also '!' follow '+' or '-'. (These rules
   are similar used in menu creation). To define drop down button, use (as
   first) prefix '^'. (Do not forget to set <D OnTBDropDown> event for this
   case). If You want to assign images to buttons not in the same order
   how these are placed in Bitmap (or You use system bitmap), define for every
   button (in BtnImgIdxArray array) indexes for every button (excluding
   separator buttons). Otherwise, it is possible to define index only for first
   button (e.g., [0]). It is also possible to change TBImages[ ] property
   for such purpose, or do the same in method TBSetBtnImgIdx).
   |<br>
   Following properties, methods and event are specially designed to work with
   toolbar control:
   |#toolbar
   |<br>&nbsp;&nbsp;&nbsp;
   If your project uses Align property to align controls, this can conflict with
   toolbar native aligning. To solve such problem, place toolbar to parent panel,
   which has its own Align property assigned to desired value.
   |<br>
   To create toolbar with buttons, drawn from top to bottom, instead from left
   to right, combine caLeft / caRight in Align parameter and style tboWrapable
   when create toolbar. To adjust width of vertically aligned toolbar, it is
   possible to call ResizeParentLeft for it. E.g.:

   ! P0 := NewPanel( W, esRaised ) .SetSize( 30, 0 ) .SetAlign( caLeft );
   ! //                            ^^^^^^^^^^^^^^^^^            //////
   !TB := NewToolbar( P0, caLeft, [ tboNoDivider, tboWrapable ], DWORD(-1),
   ! //                   //////                  ///////////
   !                  [ ' ', ' ', ' ', '-', ' ', ' ' ],
   !      [ STD_FILEOPEN ] ).ResizeParentRight;
   !//Note, that caLeft is *must*, and tboWrapable style too. SetSize for
   !//parent panel is not necessary, but only if ResizeParentRight is called
   !//than for Toolbar.
   |<br><br>
   One more note: if You create toolbar without text labels (passing ' ' for
   each button You add), include also option tboTextRight to fix incorrect
   sizing of buttons under Windows9x.
   }



{ -- Constructor for Image List objet -- }

//[NewImageList DECLARATION]
function NewImageList( AOwner: PControl ): PImageList;
{* Constructor of TImageList object. Unlike other non-visual objects, image list
   can be parented by TControl object (but this does not *must*), and in that
   case it is destroyed automatically when its parent control is destroyed.
   Every control can have several TImageList objects, linked to a simple list.
   But if any TImageList object is destroyed, all following ones are destroyed
   too (at least, now I implemented it so). }
































//[TIMER]
type
  TTimer = class;
  PTimer = TTimer;
{ ----------------------------------------------------------------------

                            TTimer object

----------------------------------------------------------------------- }
//[TTimer DEFINITION]
  TTimer = class( TObj )
  {* Easy timer incapsulation object. Uses applet window to
     receive timer events. So, either assign your main form
     to Applet variable or create applet button object (and
     assign it to Applet) before enabling timer. }
  protected
    fHandle : Integer;
    fEnabled: Boolean;
    fInterval: Integer;
    fOnTimer: TOnEvent;
    procedure SetEnabled(const Value: Boolean); virtual;
    procedure SetInterval(const Value: Integer);
  protected
  public
    destructor Destroy; override;
    {* Destructor. }
  public
    property Handle : Integer read fHandle;
    {* Windows timer object handle. }
    property Enabled : Boolean read fEnabled write SetEnabled;
    {* True, is timer is on. Initially, always False. Before assigning True,
       make sure, that Applet global variable is assigned to applet object
       (NewApplet) or to form (NewForm). }
    property Interval : Integer read fInterval write SetInterval;
    {* Interval in milliseconds (1000 is default and means 1 second). }
    property OnTimer : TOnEvent read fOnTimer write fOnTimer;
    {* Event, which is called when time interval is over. }
  end;
//[END OF TTimer DEFINITION]

//[NewTimer DECLARATION]
function NewTimer( Interval: Integer ): PTimer;
{* Constructs initially disabled timer with interval 1000 (1 second). }


//[MULTIMEDIA TIMER]
type
  TMMTimer = class;
  PMMTimer = TMMTimer;

//[TMMTimer DEFINITION]
  TMMTimer = class( TTimer )
  {* Multimedia timer incapsulation object. Does not require Applet or special
     window to handle it. System creates a thread for each high resolution
     timer, so using many such objects can degrade total PC performance. }
  protected
    FResolution: Integer;
    FPeriodic: Boolean;
    procedure SetEnabled(const Value: Boolean); override;
  public
    destructor Destroy; override;
    {* }
    property Resolution: Integer read FResolution write FResolution;
    {* Minimum timer resolution. The less the more accuracy (0 is exactly
       Interval milliseconds between timer shots). It is recommended to set
       this property greater to prevent entire system from reducing overhead.
       If you change this value, reset and then set Enabled again to apply
       changes. }
    property Periodic: Boolean read FPeriodic write FPeriodic;
    {* TRUE, if timer is periodic (default). Otherwise, timer is one-shot
       (set it Enabled every time in such case for each shot). If you change
       this property, reset and set Enabled property again to get effect. }
  end;
//[END OF TMMTimer DEFINITION]

//[NewMMTimer DECLARATION]
function NewMMTimer( Interval: Integer ): PMMTimer;
{* Creates multimedia timer object. Initially, it has Resolution = 0,
   Periodic = TRUE and Enabled = FALSE. Do not forget also to assign your
   event handler to OnTimer to do something on timer shot. }













//[DIRCHANGE]
type
  TDirChange = class;
  PDirChange = TDirChange;
  {* }

  TOnDirChange = procedure (Sender: PDirChange; const Path: string) of object;
  {* Event type to define OnChange event for folder monitoring objects. }

  TFileChangeFilters = (fncFileName, fncDirName, fncAttributes, fncSize,
      fncLastWrite, fncLastAccess, fncCreation, fncSecurity);
  {* Possible change monitor filters. }
  TFileChangeFilter = set of TFileChangeFilters;
  {* Set of filters to pass to a constructor of TDirChange object. }

{ ----------------------------------------------------------------------

                          TDirChange object

----------------------------------------------------------------------- }
//[TDirChange DEFINITION]
  TDirChange = class(TObj)
  {* Object type to monitor changes in certain folder. }
  protected
    FOnChange: TOnDirChange;
    FHandle: THandle;
    FPath: string;
    FMonitor: PThread;
    function Execute( Sender: PThread ): Integer;
    procedure Changed;
  protected
  public
    destructor Destroy; override;
    {*}
  public
    property Handle: THandle read FHandle;
    {* Handle of file change notification object. *}
    property Path: String read FPath; //write SetPath;
    {* Path to monitored folder (to a root, if tree of folders
       is under monitoring). }
  end;
//[END OF TDirChange DEFINITION]

//[NewDirChangeNotifier DECLARATION]
function NewDirChangeNotifier( const Path: String; Filter: TFileChangeFilter;
                               WatchSubtree: Boolean; ChangeProc: TOnDirChange ): PDirChange;
{* Creates notification object TDirChangeNotifier. If something wrong (e.g.,
   passed directory does not exist), nil is returned as a result. When change
   is notified, ChangeProc is called always in main thread context.
   (Please note, that ChangeProc can not be nil).
   If empty filter is passed, default filter is used:
   [fncFileName..fncLastWrite]. }








{ -- TTrayIcon object -- }
//[TRAYICON]

type
  TOnTrayIconMouse = procedure( Sender: PObj; Message : Word ) of object;
  {* Event type to be called when Applet receives a message from an icon,
     added to the taskbar tray. }

  TTrayIcon = class;
  PTrayIcon = TTrayIcon;
{ ----------------------------------------------------------------------

                TTrayIcon - icon in tray area of taskbar

----------------------------------------------------------------------- }
//[TTrayIcon DEFINITION]
  TTrayIcon = class(TObj)
  {* Object to place (and change) a single icon onto taskbar tray. }
  protected
    FIcon: HIcon;
    FActive: Boolean;
    FTooltip: String;
    FOnMouse: TOnTrayIconMouse;
    FControl: PControl;
    fAutoRecreate: Boolean;
    FNoAutoDeactivate: Boolean;
    FWnd: HWnd;
    procedure SetIcon(const Value: HIcon);
    procedure SetActive(const Value: Boolean);
    procedure SetTrayIcon( const Value : DWORD );
    procedure SetTooltip(const Value: String);
    procedure SetAutoRecreate(const Value: Boolean);
  protected
  public
    destructor Destroy; override;
    {* Destructor. Use Free method instead (as usual). }
  public
    property Icon : HIcon read FIcon write SetIcon;
    {* Icon to be shown on taskbar tray. If not set, value of Active
       property has no effect. It is also possible to assign a value
       to Icon property after assigning True to Active to install
       icon first time or to replace icon with another one (e.g. to
       get animation effect).
       |<br>&nbsp;&nbsp;&nbsp;
       Previously allocated icon (if any) is not deleted using
       DeleteObject. This is normal for icons, loaded from resource
       (e.g., by LoadIcon API call). But if icon was created (e.g.) by
       CreateIconIndirect, your code is responsible for destroying
       of it). }
    property Active : Boolean read FActive write SetActive;
    {* Set it to True to show assigned Icon on taskbar tray. Default
       is False. Has no effect if Icon property is not assigned.
       TrayIcon is deactivated automatically when Applet is finishing
       (but only if Applet window is used as a "parent" for tray
       icon object). }
    property Tooltip : String read FTooltip write SetTooltip;
    {* Tooltip string, showing automatically when mouse is moving
       over installed icon. Though "huge string" type is used, only
       first 63 characters are considered. Also note, that only in
       most recent versions of Windows multiline tooltips are supported. }
    property OnMouse : TOnTrayIconMouse read FOnMouse write FOnMouse;
    {* Is called then mouse message is taking place concerning installed
       icon. Only type of message can be obtained (e.g. WM_MOUSEMOVE,
       WM_LBUTTONDOWN etc.) }
    property AutoRecreate: Boolean read fAutoRecreate write SetAutoRecreate;
    {* If set to TRUE, auto-recreating of tray icon is proveded in case,
       when Explorer is restarted for some (unpredictable) reasons. Otherwise,
       your tray icon is disappeared forever, and if this is the single way
       to communicate with your application, the user nomore can achieve it. }
    property NoAutoDeactivate: Boolean read FNoAutoDeactivate write FNoAutoDeactivate;
    {* If set to true, tray icon is not removed from tray automatically on
       WM_CLOSE message receive by owner control. Set Active := FALSE in
       your code for such case before accepting closing the form. }
    property Wnd: HWnd read FWnd write FWnd;
    {* A window to use as a base window for tray icon messages. Overrides
       parent Control handle is assigned. Note, that if Wnd property used,
       message handling is not done automatically, and you should do this in
       your code, or at least for one tray icon object, call AttachProc2Wnd. }
    procedure AttachProc2Wnd;
    {* Call this method for a tray icon object in case if Wnd used rather then
       control. It is enough to call this method once for each Wnd used, even
       if several other tray icons are also based on the same Wnd. See also
       DetachProc2Wnd method. }
    procedure DetachProc2Wnd;
    {* Call this method to detach window procedure attached via AttachProc2Wnd.
       Do it once for a Wnd, used as a base to handle tray icon messages.
       Caution! If you do not call this method before destroying Wnd, the
       application will not functioning normally. }
  end;
  {* When You create invisible application, which should be represented by
     only the tray icon, prepare a handle for the window, resposible for
     messages handling. Remember, that window handle is created automatically
     only when a window is showing first time. If window's property Visible is
     set to False, You should to call CreateWindow manually.
     <br>
     There is a known bug exist with similar invisible tray-iconized applications.
     When a menu is activated in response to tray mouse event, if there was
     not active window, belonging to the application, the menu is not disappeared
     when mouse is clicked anywhere else. This bug is occure in Windows9x/ME.
     To avoid it, activate first your form window. This last window shoud have
     status visible (but, certainly, there are no needs to place it on visible
     part of screen - change its position, so it will not be visible for user,
     if You wish).
     <br>
     Also, to make your application "invisible" but until special event is occure,
     use Applet separate from the main form, and make for both Visible := False.
     This allows for You to make your form visible any time You wish, and without
     making application button visible if You do not wish.
  }
  {= Когда Вы делаете невидимое приложение, которое должно быть представлено
     только иконкой в трее, обеспечьте ненулевой Handle для окна, отвечающего
     за обработку сообщений. Помните, что Handle окна создается автоматически
     только в тот момент, когда оно должно появиться в первый раз. Если свойство
     окна Visible установлено в FALSE, необходимо вызвать CreateWindow самостоятельно.
     <br>
     Существует известный BUG с подобными невидимыми минимизированными в трей
     приложениями. Когда в ответ на событие мыши активизирвано выпадающее меню,
     оно не исчезает по щелчку мыши вне этого меню. Происходит это в Windows9x/ME.
     чтобы решить эту проблему, сначала активизируйте свое окно (форму). Это окно
     должно быть видимым (но, конечно, его можно разместить вне пределов видимой
     части экрана, так что пользователю его видно не будет).
     <br>
     Так же, чтобы сделать приложение невидимым, по крайней мере, пока это не
     потребуется, используйте отдельный представитель класса TControl - глобальную
     переменную Applet, и присвойте FALSE ее свойству Visible.
  }
//[END OF TTrayIcon DEFINITION]

//[NewTrayIcon DECLARATION]
function NewTrayIcon( Wnd: PControl; Icon: HIcon ): PTrayIcon;
{* Constructor of TTrayIcon object. Pass main form or applet as Wnd
   parameter. }












//[JUST ONE]
{ -- JustOne -- }

type
  TOnAnotherInstance = procedure( const CmdLine: String ) of object;
  {* Event type to use in JustOneNotify function. }

function JustOne( Wnd: PControl; const Identifier : String ) : Boolean;
{* Returns True, if this is a first instance. For all other instances
   (application is already running), False is returned. }

function JustOneNotify( Wnd: PControl; const Identifier : String;
                        const aOnAnotherInstance: TOnAnotherInstance ) : Boolean;
{* Returns True, if this is a first instance. For all other instances
   (application is already running), False is returned. If handler
   aOnAnotherInstance passed, it is called (in first instance) every time
   when another instance of an application is started, receiving command
   line used to run it. }

















{ -- string (mainly) utility procedures and functions. -- }

//[Message Box DECLARATIONS]
function MsgBox( const S: String; Flags: DWORD ): DWORD;
{* Displays message box with the same title as Applet.Caption. If applet
   is not running, and Applet global variable is not assigned, caption
   'Error' is displayed (but actually this is not an error - the system
   does so, if nil is passed as a title).
   |<br>&nbsp;&nbsp;&nbsp;
   Returns ID_... result (correspondently to flags passed (MB_OK, MBYESNO,
   etc. -> ID_OK, ID_YES, ID_NO, etc.) }
procedure MsgOK( const S: String );
{* Displays message box with the same title as Applet.Caption (or 'Error',
   if Applet is not running). }
function ShowMsg( const S: String; Flags: DWORD ): DWORD;
{* Displays message box like MsgBox, but uses Applet.Handle as a parent
   (so the message has no button on a task bar). }
procedure ShowMessage( const S: String );
{* Like ShowMsg, but has only styles MB_OK and MB_SETFOREGROUND. }
procedure ShowMsgModal( const S: String );
{* This message function can be used out of a message loop (e.g., after
   finishing the application). It is always modal.
      Actually, a form with word-wrap label (decorated as borderless edit
   box with btnFace color) and with OK button is created and shown modal.
   When a dialog is called from outside message loop, caption 'Information'
   is always displayed.
   Dialog form is automatically resized vertically to fit message text
   (but until screen height is achieved) and shown always centered on
   screen. The width is fixed (400 pixels).
   |<br>
   Do not use this function outside the message loop for case, when the
   Applet variable is not used in an application. }
function ShowQuestion( const S: String; Answers: String ): Integer;
{* Modal dialog like ShowMsgModal. It is based on KOL form, so it can
   be called also out of message loop, e.g. after finishing the
   application. Also, this function *must* be used in MDI applications
   in place of any dialog functions, based on MessageBox.
   |<br>
   The second parameter should be empty string or several possible
   answers separated by '/', e.g.: 'Yes/No/Cancel'. Result is
   a number answered, starting from 1. For example, if  'Cancel'
   was pressed, 3 will be returned.
   |<br>
   User can also press ESCAPE key, or close modal dialog. In such case
   -1 is returned. }
function ShowQuestionEx( const S: String; Answers: String; CallBack: TOnEvent ): Integer;
{* Like ShowQuestion, but with CallBack function, called just before showing
   the dialog. }
procedure SpeakerBeep( Freq: Word; Duration: DWORD );
{* On Windows NT, calls Windows.Beep. On Windows 9x, produces beep on speaker
   of desired frequency during given duration time (in milliseconds). }


function FormatMessage(dwFlags: DWORD; lpSource: Pointer; dwMessageId: DWORD; dwLanguageId: DWORD;
  lpBuffer: PChar; nSize: DWORD; Arguments: Pointer): DWORD; stdcall;

function SysErrorMessage(ErrorCode: Integer): string;
{* Creates and returns a string containing formatted system error message.
   It is possible then to display this message or write it to a log
   file, e.g.:
   !  ShowMsg( SysErrorMessage( GetLastError ) );



   |&R=<a name="%0"></a><font color=#FF8040><h1>%0</h1></font>
   <R 64-bit integer numbers>
}
//[I64 TYPE]
type
  I64 = record
  {* 64 bit integer record. Use it and correspondent functions below in KOL
     projects to avoid dependancy from Delphi version (earlier versions of
     Delphi had no Int64 type). }
    Lo, Hi: DWORD;
  end;
  PI64 = ^I64;
  {* }



function IntPower(Base: Extended; Exponent: Integer): Extended;
{* Result := Base ^ Exponent; }

//[String<->Double DECLARATIONS]
function Str2Double( const S: String ): Double;
{* }

function Double2Str( D: Double ): String;
{* }
function Extended2Str( E: Extended ): String;
{* }

function Double2StrEx( D: Double ): String;
{* experimental, do not use }

function TruncD( D: Double ): Double;
{* Result := trunc( D ) as Double;
|<hr>















  <R Small bit arrays (max 32 bits in array)>
  See also TBits object.
}

//[SMALL BIT ARRAYS DECLARATIONS]
function GetBits( N: DWORD; first, last: Byte ): DWord;
{* Retuns bits straing from <first> and to <last> inclusively. }
function GetBitsL( N: DWORD; from, len: Byte ): DWord;
{* Retuns len bits starting from index <from>.
|<hr>











  <R Arithmetics, geometry and other utility functions>

  See also units KolMath.pas, CplxMath.pas and Err.pas.
}
//[MulDiv DECLARATION]
{$IFNDEF FPC}
function MulDiv( A, B, C: Integer ): Integer;
{* Returns A * B div C. Small and fast. }
{$ENDIF}

//[TMethod TYPE]
type
///////////////////////////////////////////
{$ifndef _D6orHigher}                    //
///////////////////////////////////////////
   TMethod = packed record
   {* Is defined here because using of VCL classes.pas unit is
      not recommended in XCL. This record type is used often
      to set/access event handlers, referring to a procedure
      of object (usually to set such event to an ordinal
      procedure setting Data field to nil. }
    Code: Pointer; // Pointer to method code.
    {* If used to fake assigning to event handler of type 'procedure
       of object' with ordinal procedure pointer, use symbol '@'
       before method:
       |<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face="Courier"><b>
       |    Method.Code := @MyProcedure;
       |</b></font> }
    Data: Pointer; // Pointer to object, owning the method.
    {* To fake event of type 'procedure of object' with setting it to
       ordinal procedure assign here NIL; }
   end;
   {* When assigning TMethod record to event handler, typecast it with
      desired event type, e.g.:
      |<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face="Courier"><b>
      |     SomeObject.OnSomeEvent := TOnSomeEvent( Method );
      |</b></font><br> }
///////////////////////////////////////////
{$endif}                                 //
///////////////////////////////////////////
   PMethod = ^TMethod;
   {* }

   function MakeMethod( Data, Code: Pointer ): TMethod;
   {* Help function to construct TMethod record. Can be useful to
      assign regular type procedure/function as event handler for
      event, defined as object method (do not forget, that in that
      case it must have first dummy parameter to replace Self,
      passed in EAX to methods of object). }

//[Rectangles&Points DECLARATIONS]
   function MakeRect( Left, Top, Right, Bottom: Integer ): TRect; stdcall;
   {* Use it instead of VCL Rect function }
   function RectsEqual( const R1, R2: TRect ): Boolean;
   {* Returns True if rectangles R1 and R2 have the same bounds }
   function RectsIntersected( const R1, R2: TRect ): Boolean;
   {* Returns TRUE if rectangles R1 and R2 have at least one common point.
      Note, that right and bottom bounds of rectangles are not their part,
      so, if such points are lying on that bounds, FALSE is returned. }
   function PointInRect( const P: TPoint; const R: TRect ): Boolean;
   {* Returns True if point P is located in rectangle R (including
      left and top bounds but without right and bottom bounds of the
      rectangle). }
   function MakePoint( X, Y: Integer ): TPoint;
   {* Use instead of VCL function Point }
//[MakeFlags DECLARATION]
   function MakeFlags( FlgSet: PDWORD; FlgArray: array of Integer): Integer;
   {* }
//[Integer FUNCTIONS DECLARATIONS]
   procedure Swap( var X, Y: Integer );
   {* exchanging values }
   function Min( X, Y: Integer ): Integer;
   {* minimum of two integers }
   function Max( X, Y: Integer ): Integer;
   {* maximum of two integers }
   function Abs( X: Integer ): Integer;
   {* absolute value
   |<hr>




  <R String to number and number to string conversions>
}
//[Integer<->String DECLARATIONS]
function Int2Hex( Value : DWord; Digits : Integer ) : String;
{* Converts integer Value into string with hex number. Digits parameter
   determines minimal number of digits (will be completed by adding
   necessary number of leading zeroes). }
function Int2Str( Value : Integer ) : String;
{* Obvious. }
function UInt2Str( Value: DWORD ): String;
{* The same as Int2Str, but for unsigned integer value. }
function Int2StrEx( Value, MinWidth: Integer ): String;
{* Like Int2Str, but resulting string filled with leading spaces to provide
   at least MinWidth characters. }
function Int2Rome( Value: Integer ): String;
{* Represents number 1..8999 to Rome numer. }
function Int2Ths( I : Integer ) : String;
{* Converts integer into string, separating every three digits from each
   other by ',' character. (Convert to thousands). }
function Int2Digs( Value, Digits : Integer ) : String;
{* Converts integer to string, inserting necessary number of leading zeroes
   to provide desired length of string, given by Digits parameter. If
   resulting string is greater then Digits, string is not truncated anyway. }
function Num2Bytes( Value : Double ) : String;
{* Converts double float to string, considering it as a bytes count.
   If Value is sufficiently large, number is represented in kilobytes (with
   following letter K), or in megabytes (M), gigabytes (G) or terabytes (T).
   Resulting string number is truncated to two decimals (.XX) or to one (.X),
   if the second is 0. }
function S2Int( S: PChar ): Integer;
{* Converts null-terminated string to Integer. Scanning stopped when any
   non-digit character found. Even empty string or string not containing
   valid integer number silently converted to 0. }
function Str2Int(const Value : String) : Integer;
{* Converts string to integer. First character, which can not be
   recognized as a part of number, regards as a separator. Even
   empty string or string without number silently converted to 0. }
function Hex2Int( const Value : String) : Integer;
{* Converts hexadecimal number to integer. Scanning is stopped
   when first non-hexadicimal character is found. Leading dollar ('$')
   character is skept (if present). Minus ('-') is not concerning as
   a sign of number and also stops scanning.}
function cHex2Int( const Value : String) : Integer;
{* As Hex2Int, but also checks for leading '0x' and skips it. }
{$IFNDEF _FPC}
function Format( const fmt: string; params: array of const ): String;
{* Uses API call to wvsprintf, so does not understand extra formats,
   such as floating point, date/time, currency conversions. See list of
   available formats in win32.hlp (topic wsprintf).
|<hr>



   <R Working with null-terminated and ansi strings>
}
{$ENDIF _FPC}
//[String FUNCTIONS DECLARATIONS]
function StrComp(const Str1, Str2: PChar): Integer;
{* Compares two strings fast. -1: Str1<Str2; 0: Str1=Str2; +1: Str1>Str2 }
function StrLComp(const Str1, Str2: PChar; MaxLen: Cardinal): Integer;
{* Compare two strings (fast). Terminating 0 is not considered, so if
   strings are equal, comparing is continued up to MaxLen bytes.
   Since this, pass minimum of lengths as MaxLen. }
function StrCopy( Dest, Source: PChar ): PChar;
{* Copy source string to destination (fast). Pointer to Dest is returned. }
function StrLen(const Str: PChar): Cardinal;
{* StrLen returns the number of characters in Str, not counting the null
  terminator. }
function StrScanLen(Str: PChar; Chr: Char; Len: Integer): PChar;
{* Fast scans string Str of length Len searching character Chr.
   Pointer to found character or to Str[Len] is returned. }
function StrScan(Str: PChar; Chr: Char): PChar;
{* Fast search of given character in a string. Pointer to found character
   (or nil) is returned. }
function StrRScan(const Str: PChar; Chr: Char): PChar;
{* StrRScan returns a pointer to the last occurrence of Chr in Str. If Chr
  does not occur in Str, StrRScan returns NIL. The null terminator is
  considered to be part of the string. }
function StrIsStartingFrom( Str, Pattern: PChar ): Boolean;
{* Returns True, if string Str is starting from Pattern, i.e. if
   Copy( Str, 1, StrLen( Pattern ) ) = Pattern }
function TrimLeft(const S: string): string;
{* Removes spaces, tabulations and control characters from the starting
   of string S. }
function TrimRight(const S: string): string;
{* Removes spaces, tabulates and other control characters from the
   end of string S. }
function Trim( const S : string): string;
{* Makes TrimLeft and TrimRight for given string. }
function RemoveSpaces( const S: String ): String;
{* Removes all characters less or equal to ' ' in S and returns it. }
procedure Str2LowerCase( S: PChar );
{* Converts null-terminated string to lowercase (inplace). }
function LowerCase(const S: string): string;
{* Obvious. }
function UpperCase(const S: string): string;
{* Obvious. }
function AnsiUpperCase(const S: string): string;
{* Obvious. }
function AnsiLowerCase(const S: string): string;
{* Obvious. }
{$IFNDEF _D2}
{$IFNDEF _FPC}
function WAnsiUpperCase(const S: WideString): WideString;
{* Obvious. }
function WAnsiLowerCase(const S: WideString): WideString;
{* Obvious. }
{$ENDIF _FPC}
{$ENDIF _D2}
function AnsiCompareStr(const S1, S2: string): Integer;
{* AnsiCompareStr compares S1 to S2, with case-sensitivity. The compare
  operation is controlled by the current Windows locale. The return value
  is the same as for CompareStr. }
function _AnsiCompareStr(S1, S2: PChar): Integer;
{* The same, but for PChar ANSI strings }
function AnsiCompareStrNoCase(const S1, S2: string): Integer;
{* AnsiCompareStr compares S1 to S2, with case-sensitivity. The compare
  operation is controlled by the current Windows locale. The return value
  is the same as for CompareStr. }
function _AnsiCompareStrNoCase(S1, S2: PChar): Integer;
{* The same, but for PChar ANSI strings }
function AnsiCompareText( const S1, S2: String ): Integer;
{* }

{$IFNDEF _FPC}
function LStrFromPWCharLen(Source: PWideChar; Length: Integer): String;
{* from Delphi5 - because D2 does not contain it. }
function LStrFromPWChar(Source: PWideChar): String;
{* from Delphi5 - because D2 does not contain it. }
{$ENDIF _FPC}

function CopyEnd( const S : String; Idx : Integer ) : String;
{* Returns copy of source string S starting from Idx up to the end of
   string S. Works correctly for case, when Idx > Length( S ) (returns
   empty string for such case). }
function CopyTail( const S : String; Len : Integer ) : String;
{* Returns last Len characters of the source string. If Len > Length( S ),
   entire string S is returned. }
procedure DeleteTail( var S : String; Len : Integer );
{* Deletes last Len characters from string. }
function IndexOfChar( const S : String; Chr : Char ) : Integer;
{* Returns index of given character (1..Length(S)), or
   -1 if a character not found. }
function IndexOfCharsMin( const S, Chars : String ) : Integer;
{* Returns index (in string S) of those character, what is taking place
   in Chars string and located nearest to start of S. If no such
   characters in string S found, -1 is returned. }
{$IFNDEF _D2}
{$IFNDEF _FPC}
function IndexOfWideCharsMin( const S, Chars : WideString ) : Integer;
{* Returns index (in wide string S) of those wide character, what
   is taking place in Chars wide string and located nearest to start of S.
   If no such characters in string S found, -1 is returned. }
{$ENDIF _FPC}
{$ENDIF _D2}

function IndexOfStr( const S, Sub : String ) : Integer;
{* Returns index of given substring in source string S. If found,
   1..Length(S)-Length(Sub), if not found, -1. }
function Parse( var S : String; const Separators : String ) : String;
{* Returns first characters of string S, separated from others by
   one of characters, taking place in Separators string, assigning
   a tail of string (after found separator) to source string. If
   no separator characters found, source string S is returned, and
   source string itself becomes empty. }
{$IFNDEF _FPC}
{$IFNDEF _D2}
function WParse( var S : WideString; const Separators : WideString ) : WideString;
{* Returns first wide characters of wide string S, separated from others
   by one of wide characters, taking place in Separators wide string,
   assigning a tail of wide string (following found separator) to the
   source one. If there are no separator characters found, source wide
   string S is returned, and source wide string itself becomes empty. }
{$ENDIF _D2}
{$ENDIF _FPC}
function ParsePascalString( var S : String; const Separators : String ) : String;
{* Returns first characters of string S, separated from others by
   one of characters, taking place in Separators string, assigning
   a tail of string (after the found separator) to source string. If
   there are no separator characters found, the source string S is returned,
   and the source string itself becomes empty. Additionally: if the first (after
   a blank space) is the quote "'" or '#', pascal string is assumung first
   and is converted to usual string (without quotas) before analizing
   of other separators. }
function String2PascalStrExpr( const S : String ) : String;
{* Converts string to Pascal-like string expression (concatenation of
   strings with quotas and characters with leading '#'). }
function StrEq( const S1, S2 : String ) : Boolean;
{* Returns True, if LowerCase(S1) = LowerCase(S2). I.e., if strings
   are equal to each other without caring of characters case sensitivity
   (ASCII only). }
function AnsiEq( const S1, S2 : String ) : Boolean;
{* Returns True, if AnsiLowerCase(S1) = AnsiLowerCase(S2). I.e., if ANSI
   stringsare equal to each other without caring of characters case
   sensitivity. }
{$IFNDEF _D2}
{$IFNDEF _FPC}
function WAnsiEq( const S1, S2 : WideString ) : Boolean;
{* Returns True, if AnsiLowerCase(S1) = AnsiLowerCase(S2). I.e., if ANSI
   stringsare equal to each other without caring of characters case
   sensitivity. }
{$ENDIF _FPC}
{$ENDIF _D2}

function StrIn( const S : String; const A : array of String ) : Boolean;
{* Returns True, if S is "equal" to one of strings, taking place
   in A array. To check equality, StrEq function is used, i.e.
   comaprison is taking place without case sensitivity. }
{$IFNDEF _FPC}
{$IFNDEF _D2}
function WStrIn( const S : WideString; const A : array of WideString ) : Boolean;
{* Returns True, if S is "equal" to one of strings, taking place
   in A array. To check equality, WAnsiEq function is used, i.e.
   comaprison is taking place without case sensitivity. }
{$ENDIF _D2}
{$ENDIF _FPC}
function StrIs( const S : String; const A : array of String; var Idx: Integer ) : Boolean;
{* Returns True, if S is "equal" to one of strings, taking place
   in A array, and in such Case Idx also is assigned to an index of A element
   equal to S. To check equality, StrEq function is used, i.e.
   comaprison is taking place without case sensitivity. }
function IntIn( Value: Integer; const List: array of Integer ): Boolean;
{* Returns TRUE, if Value is found in a List. }
function _StrSatisfy( S, Mask : PChar ) : Boolean;
{* }
function _2StrSatisfy( S, Mask: PChar ): Boolean;
{* }
function StrSatisfy( const S, Mask : String ) : Boolean;
{* Returns True, if S is satisfying to a given Mask (which can contain
   wildcard symbols '*' and '?' interpeted correspondently as 'any
   set of characters' and 'single any character'. If there are no
   such wildcard symbols in a Mask, result is True only if S is maching
   to Mask string.) }
function StrReplace( var S: String; const From, ReplTo: String ): Boolean;
{* Replaces first occurance of From to ReplTo in S, returns True,
   if pattern From was found and replaced. }
{$IFNDEF _FPC}
{$IFNDEF _D2}
function WStrReplace( var S: WideString; const From, ReplTo: WideString ): Boolean;
{* Replaces first occurance of From to ReplTo in S, returns True,
   if pattern From was found and replaced. See also function StrReplace.
   This function is not available in Delphi2 (this version of Delphi
   does not support WideString type). }
{$ENDIF _D2}
{$ENDIF _FPC}

function StrRepeat( const S: String; Count: Integer ): String;
{* Repeats given string Count times. E.g., StrRepeat( 'A', 5 ) gives 'AAAAA'. }
{$IFNDEF _FPC}
{$IFNDEF _D2}
function WStrRepeat( const S: WideString; Count: Integer ): WideString;
{* Repeats given wide string Count times. E.g., StrRepeat( 'A', 5 ) gives 'AAAAA'. }
{$ENDIF _D2}
{$ENDIF _FPC}

procedure NormalizeUnixText( var S: String );
{* In the string S, replaces all occurances of character #10 (without leading #13)
   to the character #13. }

{$IFNDEF _FPC}
function WStrLen( W: PWideChar ): Integer;
{* Returns Length of null-terminated Unicode string. }
procedure WStrCopy( Dest, Src: PWideChar );
{* Copies null-terminated Unicode string (terminated null also copied). }
function WStrCmp( W1, W2: PWideChar ): Integer;
{* Compares two null-terminated Unicode strings. }
{$ENDIF _FPC}

function StrPCopy(Dest: PChar; const Source: string): PChar;
{* Copyes Pascal-style string into null-terminaed one. }
function StrLCopy(Dest: PChar; const Source: PChar; MaxLen: Cardinal): PChar;
{* Copyes first MaxLen characters of Pascal-style string into
   null-terminated one. }

function DelimiterLast( const Str, Delimiters: String ): Integer;
{* Returns index of the last of delimiters given by same named parameter
   among characters of Str. If there are no delimiters found, length of
   Str is returned. This function is intended mainly to use in filename
   parsing functions. }
function __DelimiterLast( Str, Delimiters: PChar ): PChar;
{* Returns address of the last of delimiters given by Delimiters parameter
   among characters of Str. If there are no delimeters found, position of
   the null terminator in Str is returned. This function is intended
   mainly to use in filename parsing functions. }
function SkipSpaces( P: PChar ): PChar;
{* Skips all characters #1..' ' in a string.
}
{$IFDEF F_P}
function DummyStrFun( const S: String ): String;
{$ENDIF}


//[Memory FUNCTIONS DECLARATIONS]
function CompareMem(P1, P2: Pointer; Length: Integer): Boolean;
{* Fast compare of two memory blocks. }
function AllocMem( Size : Integer ) : Pointer;
{* Allocates global memory and unlocks it. }
procedure DisposeMem( var Addr : Pointer );
{* Locks global memory block given by pointer, and frees it.
   Does nothing, if the pointer is nil.
   |<hr>

  <R Text in clipboard operations>
}

//[clipboard FUNCTIONS DECLARATIONS]
function Clipboard2Text: String;
{* If clipboard contains text, this function returns it for You. }
{$IFNDEF _FPC}
{$IFNDEF _D2}
function Clipboard2WText: WideString;
{* If clipboard contains text, this function returns it for You (as Unicode string). }
{$ENDIF _D2}
{$ENDIF _FPC}
function Text2Clipboard( const S: String ): Boolean;
{* Puts given string to a clipboard. }
{$IFNDEF _FPC}
{$IFNDEF _D2}
function WText2Clipboard( const WS: WideString ): Boolean;
{* Puts given Unicode string to a clipboard.
|<hr>
}
{$ENDIF _D2}
{$ENDIF _FPC}



//[Mnemonics FUNCTIONS DECLARATIONS]
var SearchMnemonics: function ( const S: String ): String
    = {$IFDEF F_P} DummyStrFun {$ELSE} UpperCase {$ENDIF};
    MnemonicsLocale: Integer;

procedure SupportAnsiMnemonics( LocaleID: Integer );
{* Provides encoding to work with given locale. Call this global function to
   extend TControl.SupportMnemonics capability (also should be called for a form
   or for Applet variable).





   <R Date and time handling>
}
//[TDateTime TYPE DEFINITION]
type
  TDateTime = Double;
  {* Basic date and time type. Integer part represents year and days (as is,
     i.e. 1-Jan-2000 is representing by value 730141, which is a number of
     days from 1-Jan-0001 to 1-Jan-2000 inclusively). Fractional part is
     representing hours, minutes, seconds and milliseconds of a day
     proportionally (like in VCL TDateTime type, e.g. 0.5 = 12:00, 0.25 = 6:00,
     etc.). }

  PDayTable = ^TDayTable;
  TDayTable = array[1..12] of Word;

  TDateFormat = ( dfShortDate, dfLongDate );
  {* Date formats available to use in formatting date/time to string. }
  TTimeFormatFlag = ( tffNoMinutes, tffNoSeconds, tffNoMarker, tffForce24 );
  {* Additional flags, used for formatting time. }
  TTimeFormatFlags = Set of TTimeFormatFlag;
  {* Set of flags, used for formatting time. }

const
  MonthDays: array [Boolean] of TDayTable =
    ((31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31),
     (31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31));
  {* The MonthDays array can be used to quickly find the number of
    days in a month:  MonthDays[IsLeapYear(Y), M].      }

  SecsPerDay = 24 * 60 * 60;
  {* Seconds per day. }
  MSecsPerDay = SecsPerDay * 1000;
  {* Milliseconds per day. }

  VCLDate0 = 693594;
  {* Value to convert VCL "date 0" to KOL "date 0" and back.
     This value corresponds to 30-Dec-1899, 0:00:00. So,
     to convert VCL date to KOL date, just subtract this
     value from VCL date. And to convert back from KOL date
     to VCL date, add this value to KOL date.}


procedure GetLocalTime(var lpSystemTime: TSystemTime); stdcall;
procedure GetSystemTime(var lpSystemTime: TSystemTime); stdcall;


//[Date&Time FUNCTIONS DECLARATIONS]
function Now : TDateTime;
{* Returns local date and time on running PC. }
function Date: TDateTime;
{* Returns todaylocal date. }
procedure DecodeDateFully( DateTime: TDateTime; var Year, Month, Day, DayOfWeek: WORD );
{* Decodes date. }
procedure DecodeDate( DateTime: TDateTime; var Year, Month, Day: WORD );
{* Decodes date. }
function EncodeDate( Year, Month, Day: WORD; var DateTime: TDateTime ): Boolean;
{* Encodes date. }
function CompareSystemTime(const D1, D2 : TSystemTime) : Integer;
{* Compares to TSystemTime records. Returns -1, 0, or 1 if, correspondantly,
   D1 < D2, D1 = D2 and D1 > D2. }
procedure IncDays( var SystemTime : TSystemTime; DaysNum : Integer );
{* Increases/decreases day in TSystemTime record onto given days count
   (can be negative). }
procedure IncMonths( var SystemTime : TSystemTime; MonthsNum : Integer );
{* Increases/decreases month number in TSystemTime record onto given
   months count (can be negative). Correct result is not garantee if
   day number is incorrect for newly obtained month. }
function IsLeapYear(Year: Word): Boolean;
{* Returns True, if given year is "leap" (i.e. has 29 days in the February). }
function DayOfWeek(Date: TDateTime): Integer;
{* Returns day of week (0..6) for given date. }
function SystemTime2DateTime(const SystemTime : TSystemTime; var DateTime : TDateTime ) : Boolean;
{* Converts TSystemTime record to XDateTime variable. }
function DateTime2SystemTime(const DateTime : TDateTime; var SystemTime : TSystemTime ) : Boolean;
{* Converts TDateTime variable to TSystemTime record. }
function CatholicEaster( nYear: Integer ): TDateTime;
{* Returns date of catholic easter for given year. }

procedure DivMod(Dividend: Integer; Divisor: Word; var Result, Remainder: Word);
{* Dividing of integer onto divisor with obtaining both result of division
   and remainder. }

function SystemDate2Str( const SystemTime : TSystemTime; const LocaleID : DWORD;
                         const DfltDateFormat : TDateFormat; const DateFormat : PChar ) : String;
{* Formats date, stored in TSystemTime record into string, using given locale
   and date/time formatting flags. }
function SystemTime2Str( const SystemTime : TSystemTime; const LocaleID : DWORD;
                         const Flags : TTimeFormatFlags; const TimeFormat : PChar ) : String;
{* Formats time, stored in TSystemTime record into string, using given locale
   and date/time formatting flags. }

function Date2StrFmt( const Fmt: String; D: TDateTime ): String;
{* Represents date as a string correspondently to Fmt formatting string.
   See possible pictures in definition of the function Str2DateTimeFmt
   (the first part). If Fmt string is empty, default system date format
   for short date string used. }
function Time2StrFmt( const Fmt: String; D: TDateTime ): String;
{* Represents time as a string correspondently to Fmt formatting string.
   See possible pictures in definition of the function Str2DateTimeFmt
   (the second part). If Fmt string is empty, default system time format
   for short date string used. }
function DateTime2StrShort( D: TDateTime ): String;
{* Formats date and time to string in short date format using current user
   locale. }
function Str2DateTimeFmt( const sFmtStr, sS: String ): TDateTime;
{* Restores date or/and time from string correspondently to a format string.
   Date and time formatting string can contain following pictures (case
   sensitive):
   |<pre>
        DATE PICTURES
   d    Day of the month as digits without leading zeros for single digit days.
   dd   Day of the month as digits with leading zeros for single digit days
   ddd  Day of the week as a 3-letter abbreviation as specified by a
        LOCALE_SABBREVDAYNAME value.
   dddd Day of the week as specified by a LOCALE_SDAYNAME value.
   M    Month as digits without leading zeros for single digit months.
   MM   Month as digits with leading zeros for single digit months
   MMM  Month as a three letter abbreviation as specified by a LOCALE_SABBREVMONTHNAME value.
   MMMM Month as specified by a LOCALE_SMONTHNAME value.
   y    Year represented only be the last digit.
   yy   Year represented only be the last two digits.
   yyyy Year represented by the full 4 digits.
   gg   Period/era string as specified by the CAL_SERASTRING value. The gg
        format picture in a date string is ignored if there is no associated era
        string. In Enlish locales, usual values are BC or AD.

        TIME PICTURES
   h    Hours without leading zeros for single-digit hours (12-hour clock).
   hh   Hours with leading zeros for single-digit hours (12-hour clock).
   H    Hours without leading zeros for single-digit hours (24-hour clock).
   HH   Hours with leading zeros for single-digit hours (24-hour clock).
   m    Minutes without leading zeros for single-digit minutes.
   mm   Minutes with leading zeros for single-digit minutes.
   s    Seconds without leading zeros for single-digit seconds.
   ss   Seconds with leading zeros for single-digit seconds.
   t    One character–time marker string (usually P or A, in English locales).
   tt   Multicharacter–time marker string (usually PM or AM, in English locales).
   |
   E.g., 'D, yyyy/MM/dd h:mm:ss'.
   See also Str2DateTimeShort function.
  }
function Str2DateTimeShort( const S: String ): TDateTime;
{* Restores date and time from string correspondently to current user locale.
|<hr>


  <R File and directory routines>
}

//[OpenFile CONSTANTS]
const
  ofOpenRead          = $80000000;
  {* Use this flag (in combination with others) to open file for "read" only. }
  ofOpenWrite         = $40000000;
  {* Use this flag (in combination with others) to open file for "write" only. }
  ofOpenReadWrite     = $C0000000;
  {* Use this flag (in combination with others) to open file for "read" and "write". }
  ofShareExclusive    = $00;
  {* Use this flag (in combination with others) to open file for exclusive use. }
  ofShareDenyWrite    = $01;
  {* Use this flag (in combination with others) to open file in share mode, when
     only attempts to open it in other process for "write" will be impossible.
     I.e., other processes could open this file simultaneously for read only
     access. }
  ofShareDenyRead     = $02;
  {* Use this flag (in combination with others) to open file in share mode, when
     only attempts to open it for "read" in other processes will be disabled.
     I.e., other processes could open it for "write" only access. }
  ofShareDenyNone     = $03;
  {* Use this flag (in combination with others) to open file in full sharing mode.
     I.e. any process will be able open this file using the same share flag. }
  ofCreateNew         = $100;
  {* Default creation disposition. Use this flag for creating new file (usually
     for write access. }
  ofCreateAlways      = $200;
  {* Use this flag (in combination with others) to open existing or creating new
     file. If existing file is opened, it is truncated to size 0. }
  ofOpenExisting      = $300;
  {* Use this flag (in combination with others) to open existing file only. }
  ofOpenAlways        = $400;
  {* Use this flag (in combination with others) to open existing or create new
     (if such file is not yet exists). }
  ofTruncateExisting  = $500;
  {* Use this flag (in combination with others) to open existing file and truncate
     it to size 0. }

  ofAttrReadOnly = $10000;
  {* Use this flag to create Read-Only file (?). }
  ofAttrHidden   = $20000;
  {* Use this flag to create hidden file. }
  ofAttrSystem   = $40000;
  {* Use this flag to create system file. }
  ofAttrTemp       = $1000000;
  {* Use this flag to create temp file. }
  ofAttrArchive  = $200000;
  {* Use this flag to create archive file. }
  ofAttrCompressed = $8000000;
  {* Use this flag to create compressed file. Has effect only on NTFS, and
     only if ofAttrCompressed is not specified also. }
  ofAttrOffline    = $10000000;
  {* Use this flag to create offline file. }
//[END OF OpenFileConstants]

//[File FUNCTIONS DECLARATIONS]
function FileCreate(const FileName: string; OpenFlags: DWord): THandle;
{* Call this function to open existing or create new file. OpenFlags
   parameter can be a combination of up to three flags (by one from
   each group:
   |<table border=0>
   |&L=<tr><td valign=top>%0</td><td valign=top>
   |&E=</td></tr>
   <L ofOpenRead, ofOpenWrite, ofOpenReadWrite> - 1st group. Here You decide
      wish You open file for read, write or read-and-write operations; <E>
   <L ofShareExclusive, ofShareDenyWrite, ofShareDenyRead, ofShareDenyNone> -2nd
      group - sharing. Here You can mark out sharing mode, which is used to
      open file. <E>
   <L ofCreateNew, ofCreateAlways, ofOpenExisting, ofOpenAlways, ofTruncateExisting>
      - 3rd group - creation disposition. Here You determine, either to create new
      or open existing file and if to truncate existing or not.
   |</table> }
function FileClose(Handle: THandle): Boolean;
{* Call it to close opened earlier file. }
function FileExists( const FileName: String ) : Boolean;
{* Returns True, if given file exists.
   |<br>Note (by Dod):
   It is not documented in a help for GetFileAttributes, but it seems that
   under NT-based Windows systems, FALSE is always returned for files
   opened for excluseve use like pagefile.sys. }
function FileRead(Handle: THandle; var Buffer; Count: DWord): DWord;
{* Reads bytes from current position in file to buffer. Returns number of
   read bytes. }
function File2Str(Handle: THandle): String;
{* Reads file from current position to the end and returns result as ansi string. }

function FileSeek(Handle: THandle; MoveTo: integer; MoveMethod: TMoveMethod): DWord;
{* Changes current position in file. }
function FileWrite(Handle: THandle; const Buffer; Count: DWord): DWord;
{* Writes bytes from buffer to file from current position, extending its
   size if needed. }
function FileEOF( Handle: THandle ) : Boolean;
{* Returns True, if EOF is achieved during read operations or last byte is
   overwritten or append made to extend file during last write operation. }
function FileFullPath( const FileName : String ) : String;
{* Returns full path name for given file. Validness of source FileName path
   is not checked at all. }
function FileShortPath( const FileName: String ): String;
{* Returns short path to the file or directory. }
function FileIconSystemIdx( const Path: String ): Integer;
{* Returns index of the index of the system icon correspondent to the file or
   directory in system icon image list. }
function FileIconSysIdxOffline( const Path: String ): Integer;
{* The same as FileIconSystemIdx, but an icon is calculated for the file
   as it were offline (it is possible to get an icon for file even if
   it is not existing, on base of its extension only). }
procedure LogFileOutput( const filepath, str: String );
{* Debug function. Use it to append given string to the end of the given file. }

function StrSaveToFile( const Filename, Str: String ): Boolean;
{* Saves a string to a file without any changes. If file does not exists, it is
   created. If it exists, it is overriden. If operation failed, FALSE is returned. }
function StrLoadFromFile( const Filename: String ): String;
{* Reads entire file and returns its content as a string. If operation failed,
   an empty strinng is returned. }

function FileSize( const Path: String ) : Integer;
{* Returns file size in bytes without opening it. If file too large
   to represent its size as Integer, -1 is returned. }
function GetUniqueFilename( PathName: string ) : String;
{* If file given by PathName exists, modifies it to create unique
   filename in target folder and returns it. Modification is performed
   by incrementing last number in name (if name part of file does not
   represent a number, such number is generated and concatenated to
   it). E.g., if file aaa.aaa is already exist, the function checks
   names aaa1.aaa, aaa2.aaa, ..., aaa10.aaa, etc. For name abc123.ext,
   names abc124.ext, abc125.ext, etc. will be checked. }

function FileTimeCompare( const FT1, FT2 : TFileTime ) : Integer;
{* Compares time of file (createing, writing, accessing. Returns
   -1, 0, 1 if correspondantly FT1<FT2, FT1=FT2, FT1>FT2. }

//[Directory FUNCTIONS DECLARATIONS]
function GetStartDir: String;
{* Returns path to directory where executable is located (regardless
   of current directory). }
function DirectoryExists(const Name: string): Boolean;
{* Returns True if given directory (folder) exists. }
function DirectoryEmpty(const Name: String): Boolean;
{* Returns True if given directory is not exists or empty. }
{
function DirectorySize( const Path: String ): I64;
-- moved after PDirList
}
function DirectoryHasSubdirs( const Path: String ): Boolean;
{* Returns TRUE if given directory exists and has subdirectories. }
function CheckDirectoryContent( const Name: String; SubDirsOnly: Boolean; const Mask: String ): Boolean;
{* Returns TRUE if directory does not contain files (or directories only)
   satisfying given mask. }

//---------------------------------------------------------
// Following functions/procedures are created by Edward Aretino:
// IncludeTrailingPathDelimiter, ExcludeTrailingPathDelimiter,
// ForceDirectories, CreateDir, ChangeFileExt
//---------------------------------------------------------
function IncludeTrailingPathDelimiter(const S: string): string;
{* by Edward Aretino. Adds '\' to the end if it is not present. }
function ExcludeTrailingPathDelimiter(const S: string): string;
{* by Edward Aretino. Removes '\' at the end if it is present. }
function ForceDirectories(Dir: String): Boolean;
{* by Edward Aretino. Creates given directory if not present. All needed
   subdirectories are created if necessary. }
function CreateDir(const Dir: string): Boolean;
{* by Edward Aretino. Creates given directory. }
function ChangeFileExt(FileName: String; const Extension: string): string;
{* by Edward Aretino. Changes file extention. }

function ExcludeTrailingChar( const S: String; C: Char ): String;
{* If S is finished with character C, it is excluded. }
function IncludeTrailingChar( const S: String; C: Char ): String;
{* If S is not finished with character C, it is added. }

function ExtractFilePath( const Path: String ) : String;
{* Returns only path part from exact path to file. }
function ExtractFileName( const Path: String ) : String;
{* Extracts file name from exact path to file. }
function ExtractFileNameWOext( const Path: String ) : String;
{* Extracts file name from path to file or from filename. }
function ExtractFileExt( const Path: String ) : String;
{* Extracts extention from file name (returns it with dot '.' first) }
function ReplaceFileExt( const Path, NewExt: String ): String;
{* Returns a path with extension replaced to a given one. }
function ExtractShortPathName( const Path: String ): String;
{* }
function FilePathShortened( const Path: String; MaxLen: Integer ): String;
{* Returns shortened file path to fit MaxLen characters. }
function FilePathShortenPixels( const Path: String; DC: HDC; MaxPixels: Integer ): String;
{* Returns shortened file path to fit MaxPixels for a given DC. If you pass
   Canvas.Handle of any control or bitmap object, ensure that font is valid
   for it (or call TCanvas.RequiredState( FontValid ) method before. If DC passed
   = 0, call is equivalent to call FilePathShortened, and MaxPixels means in such
   case maximum number of characters. }
function MinimizeName( const Path: String; DC: HDC; MaxPixels: Integer ): String;
{* Exactly the same as MinimizeName in FileCtrl.pas (VCL). }

function GetSystemDir: String;
{* Returns path to windows system directory. }
function GetWindowsDir : string;
{* Returns path to Windows directory. }
function GetWorkDir : string;
{* Returns path to application's working directory. }
function GetTempDir : string;
{* Returns path to default temp folder (directory to place temporary files). }
function CreateTempFile( const DirPath, Prefix: String ): String;
{* Returns path to just created temporary file. }
function  GetFileListStr(FPath{e.g.'c:\tmp\'}, FMask{e.g.'*.*'}: string): string;
{* List of files in string, separating each path from others with semicolon (';').
   E.g.: 'c:\tmp\unit1.dcu;c:\tmp\unit1.~pa' (for use with DeleteFile2Recycle())}
function DeleteFiles( const DirPath: String ): Boolean;
{* Deletes files by file mask (given with wildcards '*' and '?'). }
function DeleteFile2Recycle( const Filename : String ) : Boolean;
{* Deletes file to recycle bin. This operation can be very slow, when
   called for a single file. To delete group of files at once (fast),
   pass a list of paths to files to be deleted, separating each path
   from others with semicolon (';'). E.g.: 'unit1.dcu;unit1.~pa'
   |<br>
   FALSE is returned only in case when at least one file was not deleted
   successfully.
   |<br>
   Note, that files are deleted not to recycle bin, if wildcards are
   used or not fully qualified paths to files. }
function CopyMoveFiles( const FromList, ToList: String; Move: Boolean ): Boolean;
{* }

{* Returns disk free space in bytes. Pass a path to root directory,
   e.g. 'C:\'.
|<hr>










  <R Wrappers to registry API functions>

  These functions can be used independently to simplify access to Windows
  registry. }

//[Registry FUNCTIONS DECLARATIONS]

function RegSetValueEx(hKey: HKEY; lpValueName: PChar;
  Reserved: DWORD; dwType: DWORD; lpData: Pointer; cbData: DWORD): Longint; stdcall;

function RegKeyOpenRead( Key: HKey; const SubKey: String ): HKey;
{* Opens registry key for read operations (including enumerating of subkeys).
   Pass either handle of opened earlier key or one of constans
   HKEY_CLASSES_ROOT, HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_USERS
   as a first parameter. If not successful, 0 is returned. }
function RegKeyOpenWrite( Key: HKey; const SubKey: String ): HKey;
{* Opens registry key for write operations (including adding new values or
   subkeys), as well as for read operations too. See also RegKeyOpenRead. }
function RegKeyOpenCreate( Key: HKey; const SubKey: String ): HKey;
{* Creates and opens key. }
function RegKeyGetStr( Key: HKey; const ValueName: String ): String;
{* Reads key, which must have type REG_SZ (null-terminated string). If
   not successful, empty string is returned. This function as well as all
   other registry manipulation functions, does nothing, if Key passed is 0
   (without producing any error). }
function RegKeyGetStrEx( Key: HKey; const ValueName: String ): String;
{* Like RegKeyGetStr, but accepts REG_EXPAND_SZ type, expanding all
   environment variables in reulting string.
   |<br>
   Code provided by neuron, e-mailto:neuron@hollowtube.mine.nu }
function RegKeyGetDw( Key: HKey; const ValueName: String ): DWORD;
{* Reads key value, which must have type REG_DWORD. If ValueName passed
   is '' (empty string), unnamed (default) value is reading. If not
   successful, 0 is returned. }
function RegKeySetStr(Key: HKey; const ValueName: String; const Value: String ): Boolean;
{* Writes new key value as null-terminated string (type REG_SZ). If not
   successful, returns False. }
function RegKeySetStrEx( Key: HKey; const ValueName: string; const Value: string;
                         expand: boolean): Boolean;
{* Writes new key value as REG_SZ or REG_EXPAND_SZ. - by neuron, e-mailto:neuron@hollowtube.mine.nu }
function RegKeySetDw( Key: HKey; const ValueName: String; Value: DWORD ): Boolean;
{* Writes new key value as dword (with type REG_DWORD). Returns False,
   if not successful. }
procedure RegKeyClose( Key: HKey );
{* Closes key, opened using RegKeyOpenRead or RegKeyOpenWrite. (But does
   nothing, if Key passed is 0). }
function RegKeyDelete( Key: HKey; const SubKey: String ): Boolean;
{* Deletes key. Does nothing if key passed is 0 (returns FALSE). }
function RegKeyDeleteValue( Key: HKey; const SubKey: String ): Boolean;
{* Deletes value. - by neuron, e-mailto:neuron@hollowtube.mine.nu }
function RegKeyExists( Key: HKey; const SubKey: String ): Boolean;
{* Returns TRUE, if given subkey exists under given Key. }
function RegKeyValExists( Key: HKey; const ValueName: String ): Boolean;
{* Returns TRUE, if given value exists under the Key.
}
function RegKeyValueSize( Key: HKey; const ValueName: String ): Integer;
{* Returns a size of value. This is a size of buffer needed to store
   registry key value. For string value, size returned is equal to a
   length of string plus 1 for terminated null character. }
function RegKeyGetBinary( Key: HKey; const ValueName: String; var Buffer; Count: Integer ): Integer;
{* Reads binary data from a registry, writing it to the Buffer.
   It is supposed that size of Buffer provided is at least Count bytes.
   Returned value is actul count of bytes read from the registry and written
   to the Buffer.
   |<br>
   This function can be used to get data of any type from the registry, not
   only REG_BINARY. }
function RegKeySetBinary( Key: HKey; const ValueName: String; const Buffer; Count: Integer ): Boolean;
{* Stores binary data in the registry. }
function RegKeyGetDateTime(Key: HKey; const ValueName: String): TDateTime;
{* Returns datetime variable stored in registry in binary format. }
function RegKeySetDateTime(Key: HKey; const ValueName: String; DateTime: TDateTime): Boolean;
{* Stores DateTime variable in the registry. }


procedure FileTypeReg(FExt,Desc,Cmd,Exe: string; IconIndex: integer; Default,Run: boolean);
{* By Dimaxx. Registers file type association.
   |<pre>
   FExt - file extension                  расширение файла
   Desc - file type description           описание типа файла
   Cmd  - context menu command            команда для контекстного меню
   Exe  - path to executable              путь к исполняемому файлу
   Default - if command is default        назначается действием по умолчанию
   Run  - if reaction needed when clicked нужны ли действия при щелчке на файле с таким расширением
   |</pre>
   Example:
   ! FileTypeReg('.abc','ABC Data File','Open','d:\abc_edit.exe',True);
}


//-------------------------------------------------------
// registry functions by Valerian Luft <luft@valerian.de>
//-------------------------------------------------------
function RegKeyGetSubKeys( const Key: HKEY; List: PStrList): Boolean;
{* The function enumerates subkeys of the specified open registry key.
   True is returned, if successful.
}
function RegKeyGetValueNames(const Key: HKEY; List: PStrList): Boolean;
{* The function enumerates value names of the specified open registry key.
   True is returned, if successful.
}
function RegKeyGetValueTyp (const Key:HKEY; const ValueName: String) : DWORD;
{* The function receives the type of data stored in the specified value.
   |<br>
   If the function fails, the return value is the Key value.
   |<br>
   If the function succeeds, the return value return will be one of the following:
   |<br>
   REG_BINARY , REG_DWORD, REG_DWORD_LITTLE_ENDIAN,
   REG_DWORD_BIG_ENDIAN, REG_EXPAND_SZ, REG_LINK , REG_MULTI_SZ,
   REG_NONE, REG_RESOURCE_LIST, REG_SZ


|<hr>



















  <R Data sorting (quicksort implementation)>
  This part contains implementation of 'quick sort' algorithm,
   based on following code:

|<pre>
| TQSort by Mike Junkin 10/19/95.
| DoQSort routine adapted from Peter Szymiczek's QSort procedure which
| was presented in issue#8 of The Unofficial Delphi Newsletter.

| TQSort changed by Vladimir Kladov (Mr.Bonanzas) to allow 32-bit
| sorting (of big arrays with more than 64K elements).
|</pre>

  Finally, this sort procedure is adapted to XCL (and then to KOL)
  requirements (no references to SysUtils, Classes etc. TQSort object
  is transferred to a single procedure call and DoQSort method is
  renamed to SortData - which is a regular procedure now). }

//[Sorting TYPES]
type
  TCompareEvent = function (const Data: Pointer; const e1,e2 : Dword) : Integer;
  {* Event type to define comparison function between two elements of an array.
     This event handler must return -1 or +1 (correspondently for cases e1<e2
     and e2>e2). Items are enumerated from 0 to uNElem. }
  TSwapEvent = procedure (const Data : Pointer; const e1,e2 : Dword);
  {* Event type to define swap procedure which is swapping two elements of an
     array. }

//[SortData FUNCTIONS DECLARATIONS]
procedure SortData( const Data: Pointer; const uNElem: Dword;
                    const CompareFun: TCompareEvent;
                    const SwapProc: TSwapEvent );
{* Call it to sort any array of data of any kind, passing total
   number of items in an array and two defined (regular) function
   and procedure to perform custom compare and swap operations.
   First procedure parameter is to pass it to callback function
   CompareFun and procedure SwapProc. Items are enumerated from
   0 to uNElem-1. }

procedure SortIntegerArray( var A : array of Integer );
{* procedure to sort array of integers. }

procedure SortDwordArray( var A : array of DWORD );
{* Procedure to sort array of unsigned 32-bit integers.
|<hr>
}













{ -- directory list object -- }
//[DirList Object]

type
  TSortDirRules = ( sdrNone, sdrFoldersFirst, sdrCaseSensitive, sdrByName, sdrByExt,
                    sdrBySize, sdrBySizeDescending, sdrByDateCreate, sdrByDateChanged,
                    sdrByDateAccessed );
  {* List of rules (options) to sort directories. Rules are passed to Sort
     method in an array, and first placed rules are applied first. }

  TDirList = class;
  PDirList = TDirList;
{ ----------------------------------------------------------------------

                TDirList - Directory scanning

----------------------------------------------------------------------- }
//[TDirList DEFINITION]
  TDirList = class( TObj )
  {* Allows easy directory scanning. This is not visual object, but
     storage to simplify working with directory content. }
  protected
    FList : PList;
    FPath: string;
    fFilters: PStrList;
    function Get(Idx: Integer): PWin32FindData;
    function GetCount: Integer;
    function GetNames(Idx: Integer): string;
    function GetIsDirectory(Idx: Integer): Boolean;
  protected
    function SatisfyFilter( FileName : PChar; FileAttr, FindAttr : DWord ) : Boolean;
  public
    destructor Destroy; override;
    {* Destructor. As usual, call Free method to destroy an object. }
  public
    property Items[ Idx : Integer ] : PWin32FindData read Get; default;
    {* Full access to scanned items (files and subdirectories). }
    property IsDirectory[ Idx: Integer ]: Boolean read GetIsDirectory;
    {* Returns TRUE, if specified item represents a directory, not a file. }
    property Count : Integer read GetCount;
    {* Number of items. }
    property Names[ Idx : Integer ] : string read GetNames;
    {* Full long names of directory items. }
    property Path : string read FPath;
    {* Path of scanned directory. }
    procedure Clear;
    {* Call it to clear list of files. }
    procedure ScanDirectory( const DirPath, Filter : String; Attr : DWord );
    {* Call it to rescan directory or to scan another directory content
       (method Clear is called first). Pass path to directory, file filter
       and attributes to scan directory immediately.
       |<br>&nbsp;&nbsp;&nbsp;
       Note: Pass FILE_ATTRIBUTE_... constants or-combination as Attr
       parameter. If 0 passed, both files and directories are listed. }
    procedure ScanDirectoryEx( const DirPath, Filters : String; Attr : DWord );
    {* Call it to rescan directory or to scan another directory content
       (method Clear is called first). Pass path to directory, file filter
       and attributes to scan directory immediately.
       |<br>&nbsp;&nbsp;&nbsp;
       Note: Pass FILE_ATTRIBUTE_... constants or-combination as Attr
       parameter. }
    procedure Sort( Rules : array of TSortDirRules );
   {* Sorts directory entries. If empty rules array passed, default rules
      array DefSortDirRules is used. }
   function FileList( const Separator {e.g.: ';', or #13}: String;
            Dirs, FullPaths: Boolean ): String;
   {* Returns a string containing all names separated with Separator.
      If Dirs=FALSE, only files are returned. }
  end;
//[END OF TDirList DEFINITION]

//[NewDirList DECLARATIONS]
function NewDirList( const DirPath, Filter: String; Attr: DWORD ): PDirList;
{* Creates directory list object using easy one-string filter. If Attr = FILE_ATTRIBUTE_NORMAL,
   only files are scanned without directories. If Attr = 0, both files and
   directories are listed. }

function NewDirListEx( const DirPath, Filters: String; Attr: DWORD ): PDirList;
{* Creates directory list object using several filters, separated by ';'.
   Filters starting from '^' consider to be anti-filters, i.e. files,
   satisfying to those masks, are skept during scanning. }

const DefSortDirRules : array[ 0..3 ] of TSortDirRules = ( sdrFoldersFirst,
      sdrByName, sdrBySize, sdrByDateCreate );
{* Default rules to sort directory entries. }

//[DirectorySize DECLARATION]



//[OpenSaveDialog OPTIONS]
type
  TOpenSaveOption = ( OSCreatePrompt,
                      OSExtensionDiffent,
                      OSFileMustExist,
                      OSHideReadonly,
                      OSNoChangedir,
                      OSNoReferenceLinks,
                      OSAllowMultiSelect,
                      OSNoNetworkButton,
                      OSNoReadonlyReturn,
                      OSOverwritePrompt,
                      OSPathMustExist,
                      OSReadonly,
                      OSNoValidate
  //{$IFDEF OpenSaveDialog_Extended}
                      ,
                      OSTemplate,
                      OSHook
  //{$ENDIF}
                    );
  TOpenSaveOptions = set of TOpenSaveOption;
  {* Options available for TOpenSaveDialog. }

  TOpenSaveDialog = class;
  POpenSaveDialog = TOpenSaveDialog;
{ ----------------------------------------------------------------------

                              TOpenSaveDialog

----------------------------------------------------------------------- }
//[TOpenSaveDialog DEFINITION]
  TOpenSaveDialog = class( TObj )
  {* Object to show standard Open/Save dialog. Initially provided
     for XCL by Carlo Kok. }
  protected
    FFilter : String;
    fFilterIndex : Integer;
    fOpenDialog : Boolean;
    FInitialDir : String;
    FDefExtension : String;
    FFilename : string;
    FTitle : string;
    FOptions : TOpenSaveOptions;
    fWnd: THandle;
  public
    {$IFDEF OpenSaveDialog_Extended}
    TemplateName: String;
    HookProc: Pointer;
    {$ENDIF}
    destructor Destroy; override;
    {* destructor }
    Function Execute : Boolean;
    {* Call it after creating to perform selecting of file by user. }
    property Filename : String read FFilename write FFileName;
    {*
    Filename is seperated by #13 when multiselect is true and the first
    file, is the path of the files selected.
    |<pre>
    |  C:\Projects
    |  Test1.Dpr
    |  Test2.Dpr
    |</pre>
    If only one file is selected, it is saved as (e.g.)
    C:\Projects\Test1.dpr
    }
    property InitialDir : string read FInitialDir write FInitialDir;
    {* Initial directory path. If not set, current directory (usually
       directory when program is started) is used. }
    property Filter : String read FFilter write FFilter;
    {* A list of pairs of filter names and filter masks, separated with '|'.
       If a mask contains more than one mask, it should be separated with ';'.
       E.g.:
       ! 'All files|*.*|Text files|*.txt;*.1st;*.diz' }
    property FilterIndex : Integer read FFilterIndex write FFilterIndex;
    {* Index of default filter mask (0 by default, which means "first"). }
    property OpenDialog : Boolean read FOpenDialog write FOpenDialog;
    {* True, if "Open" dialog. False, if "Save" dialog. True is default. }
    property Title : String read Ftitle write Ftitle;
    {* Title for dialog. }
    property Options : TOpenSaveOptions read FOptions write FOptions;
    {* Options. }
    property DefExtension : String read FDefExtension write FDefExtension;
    {* Default extention. Set it to desired extension without leading period,
       e.g. 'txt', but not '.txt'. }
    property WndOwner: THandle read fWnd write fWnd;
    {* Owner window handle. If not assigned, Applet.Handle is used (whenever
       possible). Assign it, if your application has stay-on-top forms, and
       a separate Applet object is used. }
  end;
//[END OF TOpenSaveDialog DEFINITION]

//[Default OpenSaveDialog OPTIONS]
const DefOpenSaveDlgOptions: TOpenSaveOptions = [ OSHideReadonly,
  OSOverwritePrompt, OSFileMustExist, OSPathMustExist ];

//[NewOpenSaveDialog DECLARATION]
function NewOpenSaveDialog( const Title, StrtDir: String;
         Options: TOpenSaveOptions ): POpenSaveDialog;
{* Creates object, which can be used (several times) to open file(s)
   selecting dialog. }



//[OpenDirectory Object]
type
  TOpenDirDialog = class;
  POpenDirDialog = TOpenDirDialog;

  TOpenDirOption = ( odBrowseForComputer, odBrowseForPrinter, odDontGoBelowDomain,
                   odOnlyFileSystemAncestors, odOnlySystemDirs, odStatusText,
                   odBrowseIncludeFiles );
  {* Flags available for TOpenDirDialog object. }
                   // odfStatusText - do not support status callback
  TOpenDirOptions = set of TOpenDirOption;
  {* Set of all flags used to control ZOpenDirDialog class. }

  TOnODSelChange = procedure( Sender: POpenDirDialog; NewSelDir: PChar;
                              var EnableOK: Integer; var StatusText: String )
                              of object;
  {* Event type to be called when user select another directory in OpenDirDialog.
     Set EnableOK to -1 to disable OK button, or to +1 to enable it.
     It is also possible to set new StatusText string. }

{ ----------------------------------------------------------------------

                               TOpenDirDialog

----------------------------------------------------------------------- }
//[TOpenDirDialog DEFINITION]
  TOpenDirDialog = class( TObj )
  {* Dialog for open directories, uses SHBrowseForFolder. }
  protected
    FTitle: String;
    FOptions: TOpenDirOptions;
    FCallBack: Pointer;
    FCenterProc: procedure( Wnd: HWnd );
    FBuf : array[ 0..MAX_PATH ] of Char;
    FInitialPath: String;
    FCenterOnScreen: Boolean;
    FDoSelChanged: procedure( Wnd: HWnd; Msg: DWORD; lParam, lpData: LParam ); stdcall;
    FOnSelChanged: TOnODSelChange;
    FStatusText: String;
    FWnd: HWnd;
    function GetPath: String;
    procedure SetInitialPath(const Value: String);
    procedure SetCenterOnScreen(const Value: Boolean);
    procedure SetOnSelChanged(const Value: TOnODSelChange);
    function GetInitialPath: String;
  public
    destructor Destroy; override;
    {* destructor }
    function Execute : Boolean;
    {* Call it to select directory by user. Returns True, if operation was
       not cancelled by user. }
    property Title : String read FTitle write FTitle;
    {* Title for a dialog. }
    property Options : TOpenDirOptions read FOptions write FOptions;
    {* Option flags. }
    property Path : String read GetPath;
    {* Resulting (selected by user) path. }
    property InitialPath: String read GetInitialPath write SetInitialPath;
    {* Set this property to a path of directory to be selected initially
       in a dialog. }
    property CenterOnScreen: Boolean read FCenterOnScreen write SetCenterOnScreen;
    {* Set it to True to center dialog on screen. }
    property OnSelChanged: TOnODSelChange read FOnSelChanged write SetOnSelChanged;
    {* This event is called every time, when user selects another directory.
       It is possible to eneble/disable OK button in dialog and/or change
       dialog status text in responce to event. }
    property WndOwner: HWnd read FWnd write FWnd;
    {* Owner window. If you want to provide your dialog visible over stay-on-top
       form, fire it as a child of the form, assigning the handle of form window
       to this property first. }
  end;
//[END OF TOpenDirDialog DEFINITION]

//[NewOpenSaveDialog DECLARATION]
function NewOpenDirDialog( const Title: String; Options: TOpenDirOptions ):
         POpenDirDialog;
{* Creates object, which can be used (several times) to open directory
   selecting dialog (using SHBrowseForFolder API call). }









//[Color Dialog Object]
type
  TColorCustomOption = ( ccoFullOpen, ccoShortOpen, ccoPreventFullOpen );

  TColorDialog = class;
  PColorDialog = TColorDialog;
{ ----------------------------------------------------------------------

                               TColorDialog

----------------------------------------------------------------------- }
//[TColorDialog DEFINITION]
  TColorDialog = class( TObj )
  {* Color choosing dialog. }
  protected
  public
    OwnerWindow: HWnd;
    {* Owner window (can be 0). }
    CustomColors: array[ 1..16 ] of TColor;
    {* Array of stored custom colors. }
    ColorCustomOption: TColorCustomOption;
    {* Options (how to open a dialog). }
    Color: TColor;
    {* Returned color (if the result of Execute is True). }
    function Execute: Boolean;
    {* Call this method to open a dialog and wait its result. }
  end;
//[END OF TColorDialog DEFINITION]

//[NewColorDialog DECLARATION]
function NewColorDialog( FullOpen: TColorCustomOption ): PColorDialog;
{* Creates color choosing dialog object. }









//[Ini files]
type
  TIniFileMode = ( ifmRead, ifmWrite );
  {* ifmRead is default mode (means "read" data from ini-file.
     Set mode to ifmWrite to write data to ini-file, correspondent to
     TIniFile. }

  TIniFile = class;
  PIniFile = TIniFile;
{ ----------------------------------------------------------------------

                TIniFile - store/load data to ini-files

----------------------------------------------------------------------- }
//[TIniFile DEFINITION]
  TIniFile = class( TObj )
  {* Ini file incapsulation. The main feature is what the same block of
     read-write operations could be defined (difference must be only in
     Mode value).
     |*Ini file sample.
     This sample shows how the same Pascal operators can be used both
     for read and write for the same variables, when working with TIniFile:
     !    procedure ReadWriteIni( Write: Boolean );
     !    var Ini: PIniFile;
     !    begin
     !      Ini := OpenIniFile( 'MyIniFile.ini' );
     !      Ini.Section := 'Main';
     !      if Write then            // if Write, the same operators will save
     !         Ini.Mode := ifmWrite; // data rather then load.
     !      MyForm.Left := Ini.ValueInteger( 'Left', MyForm.Left );
     !      MyForm.Top  := Ini.ValueInteger( 'Top',  MyForm.Top );
     !      Ini.Free;
     !    end;
     !
     |*  }
  protected
    fMode: TIniFileMode;
    fFileName: String;
    fSection: String;
  protected
  public
    destructor Destroy; override;
    {* destructor }
    property Mode: TIniFileMode read fMode write fMode;
    {* ifmWrite, if write data to ini-file rather than read it. }
    property FileName: String read fFileName;
    {* Ini file name. }
    property Section: String read fSection write fSection;
    {* Current ini section. }
    function ValueInteger( const Key: String; Value: Integer ): Integer;
    {* Reads or writes integer data value. }
    function ValueString( const Key: String; const Value: String ): String;
    {* Reads or writes string data value. }
    function ValueBoolean( const Key: String; Value: Boolean ): Boolean;
    {* Reads or writes boolean data value. }
    function ValueData( const Key: String; Value: Pointer; Count: Integer ): Boolean;
    {* Reads or writes data from/to buffer. Returns True, if success. }
    procedure ClearAll;
    {* Clears all sections of ini-file. }
    procedure ClearSection;
    {* Clears current Section of ini-file. }
    procedure ClearKey( const Key: String );
    {* Clears given key in current section. }

    /////////////// + by Vyacheslav A. Gavrik:
    procedure GetSectionNames(Names:PStrList);
    {* Retrieves section names, storing it in string list passed as a parameter.
       String list does not cleared before processing. Section names are added
       to the end of the string list. }
    procedure SectionData(Names:PStrList);
    {* Read/write current section content to/from string list. (Depending on
       current Mode value). }
    ///////////////

  end;
//[END OF TIniFile DEFINITION]

//[OpenIniFile DECLARATION]
function OpenIniFile( const FileName: String ): PIniFile;
{* Opens ini file, creating TIniFile object instance to work with it. }





//[CABINET FILES OBJECT]
type
  TCabFile = class;
  PCABFile = TCABFile;

  TOnNextCAB = function( Sender: PCABFile ): String of object;
  TOnCABFile = function( Sender: PCABFile; var FileName: String ): Boolean of object;

{ ----------------------------------------------------------------------

                TCabFile - windows cabinet files

----------------------------------------------------------------------- }
//[TCabFile DEFINITION]
  TCABFile = class( TObj )
  {* An object to simplify extracting files from a cabinet (.CAB) files.
     The only what need to use this object, setupapi.dll. It is provided
     with all latest versions of Windows. }
  protected
    FPaths: PStrList;
    FNames: PStrList;
    FOnNextCAB: TOnNextCAB;
    FOnFile: TOnCABFile;
    FTargetPath: String;
    FSetupapi: THandle;
    function GetNames(Idx: Integer): String;
    function GetCount: Integer;
    function GetPaths(Idx: Integer): String;
    function GetTargetPath: String;
  protected
    FGettingNames: Boolean;
    FCurCAB: Integer;
  public
    destructor Destroy; override;
    {* }
    property Paths[ Idx: Integer ]: String read GetPaths;
    {* A list of CAB-files. It is stored, when constructing function
       OpenCABFile called. }
    property Names[ Idx: Integer ]: String read GetNames;
    {* A list of file names, stored in a sequence of CAB files. To get know,
       how many files are there, check Count property. }
    property Count: Integer read GetCount;
    {* Number of files stored in a sequence of CAB files. }
    function Execute: Boolean;
    {* Call this method to extract or enumerate files in CAB. For every
       file, found during executing, event OnFile is alled (if assigned).
       If the event handler (if any) does not provide full target path for
       a file to extract to, property TargetPath is applyed (also if it
       is assigned), or file is extracted to the default directory (usually
       the same directory there CAB file is located, or current directory
       - by a decision of the system).
       |<br>
       If a sequence of CAB files is used, and not all names for CAB files
       are provided (absent or represented by a string '?' ), an event
       OnNextCAB is called to obtain the name of the next CAB file.}
    property CurCAB: Integer read FCurCAB;
    {* Index of current CAB file in a sequence of CAB files. When OnNextCAB
       event is called (if any), CurCAB property is already set to the
       index of path, what should be provided. }
    property OnNextCAB: TOnNextCAB read FOnNextCAB write FOnNextCAB;
    {* This event is called, when a series of CAB files is needed and not
       all CAB file names are provided (absent or represented by '?' string).
       If this event is not assigned, the user is prompted to browse file. }
    property OnFile: TOnCABFile read FOnFile write FOnFile;
    {* This event is called for every file found during Execute method.
       In an event handler (if any assigned), it is possible to return
       False to skip file, or to provide another full target path for
       file to extract it to, then default. If the event is not assigned,
       all files are extracted either to default directory, or to the
       directory TargetPath, if it is provided. }
    property TargetPath: String read GetTargetPath write FTargetPath;
    {* Optional target directory to place there extracted files. }
  end;
//[END OF TCABFile DEFINITION]

//[OpenCABFile DECLARATION]
function OpenCABFile( const APaths: array of String ): PCABFile;
{* This function creates TCABFile object, passing a sequence of CAB file names
   (fully qualified). It is possible not to provide all names here, or pass '?'
   string in place of some of those. For such files, either an event OnNextCAB
   will be called, or (and) user will be prompted to browse file during
   executing (i.e. Extracting). }







//[MENU OBJECT]

type
  TMenuitemInfo = packed record
    cbSize: UINT;
    fMask: UINT;
    fType: UINT;             { used if MIIM_TYPE}
    fState: UINT;            { used if MIIM_STATE}
    wID: UINT;               { used if MIIM_ID}
    hSubMenu: HMENU;         { used if MIIM_SUBMENU}
    hbmpChecked: HBITMAP;    { used if MIIM_CHECKMARKS}
    hbmpUnchecked: HBITMAP;  { used if MIIM_CHECKMARKS}
    dwItemData: DWORD;       { used if MIIM_DATA}
    dwTypeData: PAnsiChar;   { used if MIIM_TYPE}
    cch: UINT;               { used if MIIM_TYPE}
    hbmpItem: HBITMAP;       { used if MIIM_BITMAP - not exists under Windows95 }
  end;

type
  TMenu = class;
  PMenu = TMenu;

  TOnMenuItem = procedure( Sender : PMenu; Item : Integer ) of object;
  {* Event type to define OnMenuItem event. }

  TMenuAccelerator = packed Record
  {* Menu accelerator record. Use MakeAccelerator function to combine desired
     attributes into a record, describing the accelerator. }
    fVirt: Byte; // or-combination of FSHIFT, FCONTROL, FALT, FVIRTKEY, FNOINVERT
    Key: Word;   // character or virtual key code (FVIRTKEY flag is present above)
    NotUsed: Byte; // not used
  end;

  // by Sergey Shisminzev:
  TMenuOption = (moDefault, moDisabled, moChecked,
          moCheckMark, moRadioMark, moSeparator, moBitmap, moSubMenu,
          moBreak, moBarBreak);
  {* Options to add menu items dynamically. }
  TMenuOptions = set of TMenuOption;
  {* Set of options for menu item to use it in TMenu.AddItem method. }

  TMenuBreak = ( mbrNone, mbrBreak, mbrBarBreak );
  {* Possible menu item break types. }

{ ----------------------------------------------------------------------

                TMenu - main, popup menu and menu item

----------------------------------------------------------------------- }
//[TMenu DEFINITION]
  TMenu = class( TObj )
  {* Dynamic menu incapsulation object. Can play role of form main menu or popup
     menu, depending on kind of parent window (form or control) and order of
     creation (created first (for a form) become main menu). Does not allow
     merging menus, but items can be hidden. Additionally checkmark bitmaps,
     shortcut key accelerators and other features are available. }
  protected
    FHandle: HMenu;
    FId: Integer;
    FParent: PMenu;
    FControl: PControl;
    fNextMenu : PMenu;
    FRadioGroup: Integer;
    FIsCheckItem: Boolean;
    FIsSeparator: Boolean;
    FMenuBreak: TMenuBreak;
    FItems: PList;
    FOnMenuItem : TOnMenuItem;
    FOnRadioOff : TOnMenuItem;
    fOnPopup: TOnEvent;
    fByAccel: Boolean;
    FPopupFlags: DWORD;
    //fAutoPopup: Boolean;
    FVisible: Boolean;
    FSavedState: DWORD;
    FData: Pointer;
    FOwnerDraw: Boolean;
    FCaption: String;
    FBitmap: HBitmap;
    FBmpChecked: HBitmap;
    FBmpItem: HBitmap;
    ClearBitmapsProc: procedure( Sender: PMenu );
    FClearBitmaps: Boolean;
    FAccelerator: TMenuAccelerator;
    FHelpContext: Integer;
    FOnMeasureItem: TOnMeasureItem;
    FOnDrawItem: TOnDrawItem;
    function GetItems( Id: HMenu ): PMenu;
    function GetCount: Integer;
    function GetTopParent: PMenu;
    function GetState( const Index: Integer ): Boolean;
    procedure SetState( const Index: Integer; Value: Boolean );
    procedure SetVisible( Value: Boolean );
    procedure SetData( Value: Pointer );
    procedure SetMenuItemCaption( const Value: String );
    function FillMenuItems(AHandle: HMenu; StartIdx: Integer;
      const Template: array of PChar): Integer;
    procedure SetMenuBreak( Value: TMenuBreak );
    function GetControl: PControl;
    function GetInfo( var MII: TMenuItemInfo ): Boolean;
    function SetInfo( var MII: TMenuItemInfo ): Boolean;
    function SetTypeInfo( var MII: TMenuItemInfo ): Boolean;
    procedure SetBitmap( Value: HBitmap );
    procedure SetBmpChecked( Value: HBitmap );
    procedure SetBmpItem( Value: HBitmap );
    procedure ClearBitmaps;
    procedure SetAccelerator( const Value: TMenuAccelerator );
    procedure SetHelpContext( Value: Integer );
    procedure SetSubmenu( Value: HMenu );
    procedure SetOnMeasureItem( const Value: TOnMeasureItem );
    procedure SetOnDrawItem( const Value: TOnDrawItem );
    procedure SetOwnerDraw( Value: Boolean );
    {$IFDEF USE_MENU_CURCTL}
    fCurCtl: PControl;
    {$ENDIF USE_MENU_CURCTL}
  protected
    function GetItemChecked( Item : Integer ) : Boolean;
    procedure SetItemChecked( Item : Integer; Value : Boolean );
    function GetItemBitmap(Idx: Integer): HBitmap;
    procedure SetItemBitmap(Idx: Integer; const Value: HBitmap);
    function GetItemText(Idx: Integer): String;
    procedure SetItemText(Idx: Integer; const Value: String);
    function GetItemEnabled(Idx: Integer): Boolean;
    procedure SetItemEnabled(Idx: Integer; const Value: Boolean);
    function GetItemVisible(Idx: Integer): Boolean;
    procedure SetItemVisible(Idx: Integer; const Value: Boolean);
    function GetItemAccelerator(Idx: Integer): TMenuAccelerator;
    procedure SetItemAccelerator(Idx: Integer; const Value: TMenuAccelerator);
    function GetItemSubMenu( Idx: Integer ): HMenu;
  public
    destructor Destroy; override;
    {* To release menu dynamically, call Free method instead. All (popup)
       menus created after this (for the same control) are destroyed in
       that case too.
       |<br>
       It is not necessary to release menu object manually: all menus,
       created with given form (or control), are automatically released,
       when owner form (or control) is destroyed.
    }
    property Handle : HMenu read FHandle;
    {* Handle of Windows menu object. }
    property MenuId: Integer read FId;
    {* Id of the menu item object. If menu item has subitems, it has
       also submenu Handle. Top parent menu object itself has no Id.
       Id-s areassigned automatically starting from 4096. Do not
       (re)create menu items instantly, because such values are not
       reused, and maximum possible Id value must not exceed 65535. }
    property Parent: PMenu read FParent;
    {* Parent menu item (or parent menu). }
    property TopParent: PMenu read GetTopParent;
    {* Top parent menu, owning all nested subitems. }
    property Owner: PControl read GetControl;
    {* Parent control or form. }
    property Caption: String read FCaption write SetMenuItemCaption;
    {* Menu item caption text (including '&' indicating mnemonic characters,
       and keyboard accelerator representation string, usually following
       tabulation character). }
    property Items[ Id: HMenu ]: PMenu read GetItems;
    {* Returns menu item object by its index or by menu id. Since menu id
       values are starting from 4096, values from 0 to 4095 are interpreted
       as absolute index of menu item. Be careful accessing menu items or
       submenus by index, if you dynamically insert or delete items or
       submenus. In this version, separators are enumerating too, like
       all other items. Use index -1 to access object itself. The first
       item of a menu (or the first subitem of submenu item) has index 0.
       Children are enumerating before all siblings. The maximum available
       index is (Count - 1), when accessing menu items by index. }
    property Count: Integer read GetCount;
    {* Count of items together with all its nested subitems. }
    function IndexOf( Item: PMenu ): Integer;
    {* Returns index of an item. This index can be used to access
       menu item. Value -2 is returned, if the Item is not a child for menu
       or menu item, and has no parents, which are children for it, etc.
       Menu object itself always has index -1. }
    property OnMenuItem : TOnMenuItem read FOnMenuItem write FOnMenuItem;
    {* Is called when menu item is clicked. Absolute index of menu item
       clicked is passed as the second parameter. TopParent always is
       passed as a Sender parameter. }
    property ByAccel: Boolean read fByAccel;
    {* True, when OnMenuItem is called not by mouse, but by accelerator key.
       Check this flag for entire menu (TopParent), not for item itself.
       (Note, that Sender in OnMenuItem always is TopParent menu object). )
    }
    property IsSeparator: Boolean read FIsSeparator;
    {* TRUE, if a separator menu item. }
    property MenuBreak: TMenuBreak read FMenuBreak write SetMenuBreak;
    {* Menu item break type. }
    property OnUncheckRadioItem : TOnMenuItem read FOnRadioOff write FOnRadioOff;
    {* Is called when radio item becomes unchecked in menu in result of
       checking another radio item of the same radio group. }
    property RadioGroup: Integer read FRadioGroup write FRadioGroup;
    {* Radio group index. Several neighbour items with the same radio group
       index form radio group. Only single item from the same group can be
       checked at a time. }
    property IsCheckItem: Boolean read FIsCheckItem;
    {* If menu item is defined as check item, it is checked automatically
       when clicked. }
    procedure RadioCheckItem;
    {* Call this method to check radio item. (Calling this method for
       an item, which is not belonging to a radio group, just sets its
       Checked state to TRUE). }
    property Checked: Boolean index MFS_CHECKED read GetState write SetState;
    {* Checked state of the item. }
    property Enabled: Boolean
             {$IFDEF F_P}
             index $80000000 or MFS_DISABLED
             {$ELSE DELPHI}
             index Integer( $80000000 or MFS_DISABLED )
             {$ENDIF F_P/DELPHI}
             read GetState write SetState;
    {* Enabled state of the item. Whaen assigned, Grayed state also is
       set to arbitrary value (i.e., when Enabled is set to true, Grayed
       is set to FALSE. }
    property DefaultItem: Boolean index MFS_DEFAULT read GetState write SetState;
    {* Set this property to TRUE to make menu item default. Default item
       is drawn with bold. }
    property Highlight: Boolean index MFS_HILITE read GetState write SetState;
    {* Highlight state of the item. }
    property Visible: Boolean read FVisible write SetVisible;
    {* Visibility of menu item. }
    property Data: Pointer read FData write SetData;
    {* Data pointer, associated with the menu item. }
    property Bitmap: HBitmap read FBitmap write SetBitmap;
    {* Bitmap used for unchecked state of the menu item. }
    property BitmapChecked: HBitmap read FBmpChecked write SetBmpChecked;
    {* Bitmap used for checked state of the menu item. }
    property BitmapItem: HBitmap read FBmpItem write SetBmpItem;
    {* Bitmap used for item itself. In addition, following special values
       are possible:
       HBMMENU_CALLBACK, HBMMENU_MBAR_CLOSE, HBMMENU_MBAR_CLOSE_D,
       HBMMENU_MBAR_MINIMIZE, HBMMENU_MBAR_MINIMIZE_D, HBMMENU_MBAR_RESTORE,
       HBMMENU_POPUP_CLOSE, HBMMENU_POPUP_MAXIMIZE, HBMMENU_POPUP_MINIMIZE,
       HBMMENU_POPUP_RESTORE, HBMMENU_SYSTEM. }
    property Accelerator: TMenuAccelerator read FAccelerator write SetAccelerator;
    {* Accelerator for menu item. }
    property HelpContext: Integer read FHelpContext write SetHelpContext;
    {* Help context for entire menu (help context can not be assigned to
       individual menu items). }

    procedure AssignEvents( StartIdx: Integer; Events: array of TOnMenuItem );
    {* It is possible to assign its own event handler to every menu item
       using this call. This procedure also is called automatically in
       a constructor NewMenuEx. }

    procedure Popup( X, Y : Integer );
    {* Only for popup menu - to popup it at the given position on screen. }
    procedure PopupEx( X, Y: Integer );
    {* This version of popup command is very useful, when popup menu is activated
       when its parent window is not visible (e.g., for a kind of applications,
       which always are invisible, and can be activated only using tray icon).
       PopupEx method provides correct tracking of menu disappearing when mouse
       is clicked anywhere else on screen, fixing strange menu behavior in some
       Windows versions (NT).
       |<br>
       Actually, when PopupEx used, parent form is shown but below of visible
       screen, and when menu is disappearing, previous state of the form (visibility
       and position) are restored. If such solvation is not satisfying You,
       You can do something else (e.g., use region clipping, etc.) }
    property OnPopup: TOnEvent read fOnPopup write fOnPopup;
    {* This event occurs before the popup menu is shown. }
    property Flags: DWORD read FPopupFlags write FPopupFlags;
    {* Pop-up flags, which are used to call TrackPopupMenuEx, when Popup or
       PopupEx method is called. Can be a combination of following values:
       |<br>
       TPM_CENTERALIGN or TPM_LEFTALIGN or TPM_RIGHTALIGN
       |<br>
       TPM_BOTTOMALIGN or TPM_TOPALIGN or TPM_VCENTERALIGN
       |<br>
       TPM_NONOTIFY or TPM_RETURNCMD
       |<br>
       TPM_LEFTBUTTON or TPM_RIGHTBUTTON
       |<br>
       TPM_HORNEGANIMATION or TPM_HORPOSANIMATION or TPM_NOANIMATION or
       TPM_VERNEGANIMATION or TPM_VERPOSANIMATION
       |<br>
       TPM_HORIZONTAL or TPM_VERTICAL.
       |<br>
       By default, a combination TPM_LEFTALIGN or TPM_LEFTBUTTON is used. }
    function Insert(InsertBefore: Integer; ACaption: PChar; Event: TOnMenuItem;
             Options: TMenuOptions): PMenu;
    {* Inserts new menu item before item, given by Id (>=4096) or index
       value InsertBefore. Pointer to an object created is returned. }
    property SubMenu: HMenu read FHandle; // write SetSubMenu;
    {* Submenu associated with the menu item. The same as Handle. It was possible
       in ealier versions to change this value, replacing (removing, assigning)
       entire popup menu as a submenu for menu item.
       But in modern version of TMenu, this is not possible.
       Instead, entire menu object should be added or removed using
       InsertSubmenu or RemoveSubmenu methods. }
    procedure InsertSubMenu( SubMenuToInsert: PMenu; InsertBefore: Integer );
    {* Inserts existing menu item (together with its subitems if any present)
       into given position. See also RemoveSubMenu. }
    function RemoveSubMenu( ItemToRemove: Integer ): PMenu;
    {* Removes menu item from the menu, returning TMenu object, representing it,
       if submenu item, having its own children, detached. If an individual menu
       item is removed, nil is returned.
       This function can be useful to add or remove dynamically entire submenus
       (created together with its subitems). }
    property OnMeasureItem: TOnMeasureItem read FOnMeasureItem write SetOnMeasureItem;
    {* This event is called for owner-drawn menu items. Event handler must return
       menu item height. }
    property OnDrawItem: TOnDrawItem read FOnDrawItem write SetOnDrawItem;
    {* This event is called for owner-drawn menu items. }
    property OwnerDraw: Boolean read FOwnerDraw write SetOwnerDraw;
    {* Set this property to true for some items to make it owner-draw. }

    // For compatibility with old code (be sure that item with given index
    // actually exists):
    function GetMenuItemHandle( Idx : Integer ): DWORD;
    {* Returns Id of menu item with given index. }
    property ItemHandle[ Idx: Integer ]: DWORD read GetMenuItemHandle;
    {* Returns handle for item given by index. }
    property ItemChecked[ Idx : Integer ] : Boolean read GetItemChecked write SetItemChecked;
    {* True, if correspondent menu item is checked. }
    procedure RadioCheck( Idx : Integer );
    {* Call this method to check radio item. For radio items, do not
       use assignment to ItemChecked or Checked properties. }
    property ItemBitmap[ Idx: Integer ]: HBitmap read GetItemBitmap write SetItemBitmap;
    {* This property allows to assign bitmap to menu item (for unchecked state
       only - for checked menu items default checkmark bitmap is used). }
    procedure AssignBitmaps( StartIdx: Integer; Bitmaps: array of HBitmap );
    {* Can be used to assign bitmaps to several menu items during one call. }
    property ItemText[ Idx: Integer ]: String read GetItemText write SetItemText;
    {* This property allows to get / modify menu item text at run time. }
    property ItemEnabled[ Idx: Integer ]: Boolean read GetItemEnabled write SetItemEnabled;
    {* Controls enabling / disabling menu items. Disabled menu items are
       displayed (grayed) but inaccessible to click. }
    property ItemVisible[ Idx: Integer ]: Boolean read GetItemVisible write SetItemVisible;
    {* This property allows to simulate visibility of menu items (implementing
       it by removing or inserting again if needed. For items of submenu, which
       is made invisible, True is returned. If such item made Visible, entire
       submenu with all its parent menu items becomes visible. To release menu
       properly it is necessary to make before all its items visible again.
       This does not matter, if menu is released at the end of execution, but
       can be sensible if owner form is destroyed and re-created at run time
       dynamically. }
    function ParentItem( Idx: Integer ): Integer;
    {* Returns index of parent menu item (for submenu item). If there are no
       such item (Idx corresponds to root level menu item), -1 is returned. }
    property ItemAccelerator[ Idx: Integer ]: TMenuAccelerator read GetItemAccelerator write SetItemAccelerator;
    {* Allows to get / change accelerator key kodes assigned to menu items.
       Has no effect unless SupportMnemonics called for a form. }
    property ItemSubmenu[ Idx: Integer ]: HMenu read GetItemSubmenu; // write SetItemSubmenu;
    {* Retrieves submenu item dynamically. See also SubMenu property. }

    // by Sergey Shisminzev:
    function AddItem(ACaption: PChar; Event: TOnMenuItem; Options: TMenuOptions): Integer;
    {* Adds menu item dynamically. Returns ID of the added item. }
    function InsertItem(InsertBefore: Integer; ACaption: PChar; Event: TOnMenuItem; Options: TMenuOptions): Integer;
    {* Inserts menu item before an item with ID, given by InsertBefore parameter. }
    function InsertItemEx(InsertBefore: Integer; ACaption: PChar; Event: TOnMenuItem; Options: TMenuOptions;
             ByPosition: Boolean): Integer;
    {* Inserts menu item by command or by position, dependant on ByPosition parameter }
    procedure RedrawFormMenuBar;
    {* }

    {$IFDEF USE_MENU_CURCTL}
    property CurCtl: PControl read fCurCtl;
    {* By Alexander Pravdin. This property is assigned to a control which were
       initiated a pop-up, for popup menu. }
    {$ENDIF USE_MENU_CURCTL}

  end;
//[END OF TMenu DEFINITION]

//[MenuStructSize VARIABLE]
function MenuStructSize: Integer;
{* Returns 44 under Windows95, and 48 (=sizeof(TMenuItemInfo) under all other
   Windows versions. }

//[NewMenu DECLARATION]
function NewMenu( AParent : PControl; MaxCmdReserve: DWORD; const Template : array of PChar;
                      aOnMenuItem: TOnMenuItem ): PMenu;
{* Menu constructor. First created menu becomes main menu of form (if AParent
   is a form). All other menus becomes popup (can be activated using Popup
   method). To provide dynamic replacing of main menu, create all popup
   menus as children of any other control, not form itself.
   When Menu is created, pass FirstCmd integer value to set it
   as ID of first menu item (all other ID's obtained by incrementing this value),
   and Template, which is an array of PChar (usually array of string constants),
   containing list of menu item identifiers and/or formatting characters.
|<br>&nbsp;&nbsp;&nbsp;
  FirstCmd value is assigned to first menu item created as its ID,
  all follow menu items are assigned to ID's obtained from FirstCmd incrementing
  it by 1. It is desirable to provide not intersected ranges of ID's for
  defferent menus in the applet.
|<br>&nbsp;&nbsp;&nbsp;
  Following formatting characters can be used in menu template strings:
|&L=<br><b>%1</b>
  <L &amp; (in identifier)> - to underline next character and use it as a shortcut character
           when possible;
  <L + (in front of identifier)> - to make item checked. If also
|<b>!</b> is used before <b>
  &
|</b> than radioitem is defined;
  <L - (in front of identifier)> - item not checked;
  <L - (separate)> - separator (between two items);
  <L ( (separate)> - start of submenu;
  <L ) (separate)> - end of submenu;
|<br>&nbsp;&nbsp;&nbsp;
  To get access to menu items, use constants 0, 1, etc. It is a good idea
  to create special enumerated type to index correspondent menu items
  using Ord( ) operator. Note in that case, that it is necessary only to
  define constants correspondent to identifiers (positions, correspondent
  to separators or submenu brackets are not identified by numbers).
|<br>&nbsp;&nbsp;&nbsp;
}

function NewMenuEx( AParent : PControl; FirstCmd : Integer; const Template : array of PChar;
                      aOnMenuItems: array of TOnMenuItem ): PMenu;
{* Creates menu, assigning its own event handler for every (enough) menu item. }

//[MakeAccelerator DECLARATION]
function MakeAccelerator( fVirt: Byte; Key: Word ): TMenuAccelerator;
{* Creates accelerator item to assign it to TMenu.ItemAccelerator[ ] property
   easy.}


//[ACTIONS OBJECT]
{ ----------------------------------------------------------------------

                TAction and TActionList

----------------------------------------------------------------------- }
type
  PControlRec = ^TControlRec;
  TOnUpdateCtrlEvent = procedure(Sender: PControlRec) of object;

  TCtrlKind = (ckControl, ckMenu, ckToolbar);
  TControlRec = record
    Ctrl: PObj;
    CtrlKind: TCtrlKind;
    ItemID: integer;
    UpdateProc: TOnUpdateCtrlEvent;
  end;

   TAction = class;
  PAction = TAction;

   TActionList = class;
  PActionList = TActionList;

//[TAction DEFINITION]
  TAction = class
  {*! Use action objects, in conjunction with action lists, to centralize the response
      to user commands (actions).
      Use AddControl, AddMenuItem, AddToolbarButton methods to link controls to an action.
      See also TActionList.
      }
  protected
    FControls: PList;
    FCaption: string;
    FChecked: boolean;
    FVisible: boolean;
    FEnabled: boolean;
    FHelpContext: integer;
    FHint: string;
    FOnExecute: TOnEvent;
    FAccelerator: TMenuAccelerator;
    FShortCut: string;
    procedure DoOnMenuItem(Sender: PMenu; Item: Integer);
    procedure DoOnToolbarButtonClick(Sender: PControl; BtnID: Integer);
    procedure DoOnControlClick(Sender: PObj);

    procedure SetCaption(const Value: string);
    procedure SetChecked(const Value: boolean);
    procedure SetEnabled(const Value: boolean);
    procedure SetHelpContext(const Value: integer);
    procedure SetHint(const Value: string);
    procedure SetVisible(const Value: boolean);
    procedure SetAccelerator(const Value: TMenuAccelerator);
    procedure UpdateControls;

    procedure LinkCtrl(ACtrl: PObj; ACtrlKind: TCtrlKind; AItemID: integer; AUpdateProc: TOnUpdateCtrlEvent);
    procedure SetOnExecute(const Value: TOnEvent);

    procedure UpdateCtrl(Sender: PControlRec);
    procedure UpdateMenu(Sender: PControlRec);
    procedure UpdateToolbar(Sender: PControlRec);

  public
    destructor Destroy; override;
    procedure LinkControl(Ctrl: PControl);
    {* Add a link to a TControl or descendant control. }
    procedure LinkMenuItem(Menu: PMenu; MenuItemIdx: integer);
    {* Add a link to a menu item. }
    procedure LinkToolbarButton(Toolbar: PControl; ButtonIdx: integer);
    {* Add a link to a toolbar button. }
    procedure Execute;
    {* Executes a OnExecute event handler. }
    property Caption: string read FCaption write SetCaption;
    {* Text caption. }
    property Hint: string read FHint write SetHint;
    {* Hint (tooltip). Currently used for toolbar buttons only. }
    property Checked: boolean read FChecked write SetChecked;
    {* Checked state. }
    property Enabled: boolean read FEnabled write SetEnabled;
    {* Enabled state. }
    property Visible: boolean read FVisible write SetVisible;
    {* Visible state. }
    property HelpContext: integer read FHelpContext write SetHelpContext;
    {* Help context. }
    property Accelerator: TMenuAccelerator read FAccelerator write SetAccelerator;
    {* Accelerator for menu items. }
    property OnExecute: TOnEvent read FOnExecute write SetOnExecute;
    {* This event is executed when user clicks on a linked object or Execute method was called. }
  end;
//[END OF TAction DEFINITION]

//[TActionList DEFINITION]
  TActionList = class
  {*! TActionList maintains a list of actions used with components and controls,
     such as menu items and buttons.
     Action lists are used, in conjunction with actions, to centralize the response
     to user commands (actions).
     Write an OnUpdateActions handler to update actions state.
     Created using function NewActionList.
     See also TAction.
  }
  protected
    FOwner: PControl;
    FActions: PList;
    FOnUpdateActions: TOnEvent;
    function GetActions(Idx: integer): PAction;
    function GetCount: integer;
  protected
    procedure DoUpdateActions(Sender: PObj);
  public
    destructor Destroy; override;
    function Add(const ACaption, AHint: string; OnExecute: TOnEvent): PAction;
    {* Add a new action to the list. Returns pointer to action object. }
    procedure Delete(Idx: integer);
    {* Delete action by index from list. }
    procedure Clear;
    {* Clear all actions in the list. }
    property Actions[Idx: integer]: PAction read GetActions;
    {* Access to actions in the list. }
    property Count: integer read GetCount;
    {* Number of actions in the list.. }
    property OnUpdateActions: TOnEvent read FOnUpdateActions write FOnUpdateActions;
    {* Event handler to update actions state. This event is called each time when application
      goes in the idle state (no messages in the queue). }
  end;
//[END OF TActionList DEFINITION]

//[NewActionList DECLARATION]
function NewActionList(AOwner: PControl): PActionList;
{* Action list constructor. AOwner - owner form.
|<hr>








   <R System functions and working with windows>
}
//[Window FUNCTIONS DECLARATIONS]
type
  TWindowChildKind = ( wcActive, wcFocus, wcCapture, wcMenuOwner,
                       wcMoveSize, wcCaret );
  {* Type of window child kind. Used in function GetWindowChild. }

function GetWindowChild( Wnd: HWnd; Kind: TWindowChildKind ): HWnd;
{* Returns child of given top-level window, having given characteristics.
   For example, it is possible to get know for foreground window,
   which of its child window has focus. This function does not work in old
   Windows 95 (returns Wnd in that case). But for Windows 98, Windows NT/2000
   this function works fine. To obtain focused child of the window,
   use GetFocusedWindow, which is independant from Windows version. }

function GetFocusedChild( Wnd: HWnd ): HWnd;
{* Returns focused child of given window (which should be foreground
   and active, certainly). 0 is returned either if Wnd is not active
   or Wnd has no focused child window. }

function Stroke2Window( Wnd: HWnd; const S: String ): Boolean;
{* Posts characters from string S to those child window of Wnd, which
   has focus now (top-level window Wnd must be foreground, and have
   focused edit-aware control to receive the stroke).
   |<br>
   This function allows only to post typeable characters (including
   such special symbols as #13 (Enter), #9 (Tab), #8 (BackSpace), etc.
   |<br>
   See also function Stroke2WindowEx, which allows to post any key down
   and up events, simulating keyboard for given (automated) application. }

function Stroke2WindowEx( Wnd: HWnd; const S: String; Wait: Boolean ): Boolean;
{* In addition to function Stroke2Window, this one can send special keys
   to given window, including functional keys and navigation keys. To
   post special key to target window, place a combination of names of
   such key together with keys, which should be passed simultaneously,
   between square or figure brackets. For example, [Ctrl F1], [Alt Shift Home],
   [Ctrl E]. For letters and usual characters, it is not necessary to
   simulate pressing it with determining all Shift combinations and it is
   sufficient to pass characters as is. (E.g., not '[Shift 1]', but '!'). }

function FindWindowByThreadID( ThreadID : DWORD ) : HWnd;
{* Searches for window, belonging to a given thread. }

function GetDesktopRect : TRect;
{* Returns rectangle of screen, free of taskbar and other
   similar app-bars, which reduces size of available desktop
   when created. }
function GetWorkArea: TRect;
{* The same as GetDesktopRect, but obtained calling SystemParametersInfo. }

function ExecuteWait( const AppPath, CmdLine, DfltDirectory: String;
         Show: DWORD; TimeOut: DWORD; ProcID: PDWORD ): Boolean;
{* Allows to execute an application and wait when it is finished. Pass
   INFINITE constant as TimeOut, if You sure that application is finished
   anyway. If another value passed as a TimeOut (in milliseconds), and
   application was not finished for that time, ExecuteWait is returning
   FALSE, and if ProcID is not nil, than ProcID^ contains started process
   handle (it can be used to wait it more, or to terminate it using
   TerminateProcess API function).
   |<br>
   Launching application can be console or GUI - it does not matter.
   Pass SW_SHOW, SW_HIDE or other SW_XXX constant as Show parameter
   as appropriate.
   |<br>
   Trie is returned only in case when application specified was launched
   successfully and finished for TimeOut specified. Otherwise, check
   ProcID^ variable: if it is 0, process could not be launched (and it
   is possible to get information about error using GetLastError API
   function in a such case). You can freely pass nil in place of ProcID
   parameter, but this is acually correct only when TimeOut is INFINITE. }
function ExecuteIORedirect( const AppPath, CmdLine, DfltDirectory: String;
         Show: DWORD; ProcID: PDWORD; InPipe, OutPipeWr, OutPipeRd: PHandle ): Boolean;
{* Executes an application with its console input and output redirection.
   Terminating of the application is not waiting, but if ProcID pointer
   is defined, it receives process Id launched, so it is possible to
   call WaitForSingleObject for it. InPipe is a pointer to THandle variable
   which receives a handle to input pipe of the console redirected. The same
   is for OutPipeWr and OutPipeRd, but for output of the console redirected.
   Before reading from OutPipeRd^, first close OutPipeWr^. If you run
   simple console application, for which you want to read results after its
   termination, you can use ExecuteConsoleAppIORedirect instead.
   |<br>&nbsp;&nbsp;&nbsp;
   Notes: if your application is not console and it does not create console
   using AllocConsole, this function will fail to redirect input-output. }
function ExecuteConsoleAppIORedirect( const AppPath, CmdLine, DfltDirectory: String;
         Show: DWORD; const InStr: String; var OutStr: String; WaitTimeout: DWORD )
         : Boolean;
{* Executes an application, redirecting its console input and output.
   After redirecting input and output and launching the application,
   content of InStr is written to input stream of the application, then
   the application is waiting for its termination (WaitTimeout milliseconds
   or INFINITE, as passed) and console output of the application is read to
   OutStr. TRUE is returned only in case, when all these tasks are
   completed successfully.
   |<br>&nbsp;&nbsp;&nbsp;
   Notes: if your application is not console and it does not create console
   using AllocConsole, this function will fail to redirect input-output. }


function WindowsShutdown( const Machine : String; Force, Reboot : Boolean ) : Boolean;
{* Shut down of Windows NT. Pass Machine = '' to shutdown this PC.
   Pass Reboot = True to reboot immediatelly after shut down. }

type
  TWindowsVersion = ( wv31, wv95, wv98, wvNT, wvY2K, wvXP, wvLongHorn );
  {* Windows versions constants. }
  TWindowsVersions = Set of TWindowsVersion;
  {* Set of Windows version (e.g. to define a range of versions supported by the
     application). }

function WinVer : TWindowsVersion;
{* Returns Windows version. }
function IsWinVer( Ver : TWindowsVersions ) : Boolean;
{* Returns True if Windows version is in given range of values. }

//[Parameters FUNCTIONS DECLARATIONS]
function ParamStr( Idx: Integer ): String;
{* Returns command-line parameter by index. This function supersides
   standard ParamStr function. }
function ParamCount: Integer;
{* Returns number of parameters in command line.
|<hr>
}


//{$DEFINE CHK_BITBLT}
procedure Chk_BitBlt;
{$IFDEF ASM_VERSION}
procedure StartDC;
procedure FinishDC;
{$ENDIF ASM_VERSION}

//[WndProcXXX OTHER DECLARATIONS]
function WndProcCtrl( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
function WndProcDoEraseBkgnd( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;

var CreatingWindow: PControl;
    //ActiveWindow: HWnd;

//[Assert OPERATOR DECLARATION]



//[CUSTOM EXTENSIONS]
{$IFDEF USE_CUSTOMEXTENSIONS}
  {$I CUSTOM_KOL_EXTENSION.inc} // See comments in TControl
{$ENDIF}


{$IFDEF DEBUG_ENDSESSION}
var EndSession_Initiated: Boolean;
{$ENDIF}

//[FMMNotify VARIABLE]
var
  FMMNotify: procedure( var Msg: TMsg );

//[IMPLEMENTATION]
implementation

//[USES-2]
uses
  ShellAPI,
  commdlg
  ; //, commctrl;
            // in Delphi3, including of commctrl.pas increases executable
            // onto about 30K. So, all needed definitions are copied here
            // (see commctrl.inc).
//[END OF USES-2]

{$IFDEF _D2orD3}
const
  OFN_ENABLESIZING = $00800000;
{$ENDIF}

//[procedure Chk_BitBlt_ShowError]
procedure Chk_BitBlt_ShowError;
var Rslt: Integer;
begin
    Rslt := GetLastError;
    ShowMessage( 'BitBlt ERROR: ' + Int2Str( Rslt )
                 + ' ' + SysErrorMessage( Rslt ) );
end;
//[ENDe Chk_BitBlt_ShowError]

//[procedure Chk_BitBlt]
procedure Chk_BitBlt;
var Rslt: Integer;
begin
  asm
    MOV Rslt, EAX
  end;
  if Rslt = 0 then
  begin
    Chk_BitBlt_ShowError;
    asm
      int 3;
    end;
  end;
end;
//[ENDe Chk_BitBlt]

//[FUNCTION MulDiv]
{$IFNDEF FPC}
function MulDiv( A, B, C: Integer ): Integer;
asm
  IMUL EDX
  IDIV ECX
end;
{$ENDIF}
//[END MulDiv]



//[API InitCommonControls]
procedure InitCommonControls; external cctrl name 'InitCommonControls';

type
  TInitCommonControlsEx = packed record
    dwSize: DWORD;
    dwICC: DWORD;
  end;
  PInitCommonControlsEx = ^TInitCommonControlsEx;

var ComCtl32_Module: HModule;
//[procedure DoInitCommonControls]
procedure DoInitCommonControls( dwICC: DWORD );
var Proc: procedure( ICC: PInitCommonControlsEx ); stdcall;
    ICC: TInitCommonControlsEx;
begin
  InitCommonControls;
  if ComCtl32_Module = 0 then
    ComCtl32_Module := LoadLibrary( 'comctl32.dll' );
  @ Proc := GetProcAddress( ComCtl32_Module, 'InitCommonControlsEx' );
  if Assigned( Proc ) then
  begin
    ICC.dwSize := Sizeof( ICC );
    ICC.dwICC := dwICC;
    Proc( @ ICC );
  end;
end;
//[END DoInitCommonControls]

const size_TRect = 16; // used often in assembler versions of code


//[PROCEDURE MsgOK]
procedure MsgOK( const S: String );
begin
  MsgBox( S, MB_OK );
end;

{$IFDEF ASM_VERSION}
//[function MsgBox]
function MsgBox( const S: String; Flags: DWORD ): DWORD;
asm
        PUSH      EDX
        PUSH      EAX

        MOV       ECX, [Applet]
        XOR       EAX, EAX
        JECXZ     @@1
        MOV       EAX, [ECX].TControl.fCaption
@@1:
        XCHG      EAX, [ESP]
        PUSH      EAX
        PUSH      0
        CALL      MessageBox
end;
{$ELSE ASM_VERSION} //Pascal
function MsgBox( const S: String; Flags: DWORD ): DWORD;
var Title: PChar;
begin
  Title := nil;
  if assigned( Applet ) then
  begin
    Title := PChar( Applet.fCaption );
  end;
  Result := MessageBox( 0 {Wnd}, PChar( S ), Title, Flags );
end;
//[END MsgBox]
{$ENDIF ASM_VERSION}

//[function ShowMsg]
function ShowMsg( const S: String; Flags: DWORD ): DWORD;
var Title: PChar;
    Wnd: HWnd;
begin
  Title := nil;
  Wnd := 0;
  if assigned( Applet ) then
  begin
     Title := PChar( Applet.fCaption );
     Wnd := Applet.Handle;
  end;
  Result := MessageBox( Wnd, PChar( S ), Title, Flags );
end;
//[END ShowMsg]

//[procedure ShowMessage]
procedure ShowMessage( const S: String );
begin
  ShowMsg( S, MB_OK or MB_SETFOREGROUND );
end;
//[ENDe ShowMessage]

//[procedure OKClick]
procedure OKClick( Dialog, Btn: PControl );
var Rslt: Integer;
begin
  Rslt := -1;
  if Btn <> nil then
    Rslt := Btn.Tag;
  Dialog.ModalResult := Rslt;
  Dialog.Close;
end;
//[END OKClick]

//[procedure KeyClick]
procedure KeyClick( Dialog, Btn: PControl; var Key: Longint; Shift: DWORD );
begin
  if (Key = VK_RETURN) or (Key = VK_ESCAPE) then
  begin
    if Key = VK_ESCAPE then
      Btn := nil;
    OKClick( Dialog, Btn );
  end;
end;
//[ENDe KeyClick]

//[procedure CloseMsg]
procedure CloseMsg( Dummy, Dialog: PControl; var Accept: Boolean );
begin
  Accept := FALSE;
  Dialog.ModalResult := -1;
end;
//[ENDe CloseMsg]

//[function ShowQuestionEx]
function ShowQuestionEx( const S: String; Answers: String; CallBack: TOnEvent ): Integer;
{$IFDEF F_P105ORBELOW}
type POnEvent = ^TOnEvent;
     PONKey = ^TOnKey;
var M: TMethod;
{$ENDIF F_P105ORBELOW}
var Dialog: PControl;
    Buttons: PList;
    Btn: PControl;
    AppTermFlag: Boolean;
    Lab: PControl;
    Y, W, I: Integer;
    Title: String;
    DlgWnd: HWnd;
    AppCtl: PControl;
begin
  AppTermFlag := AppletTerminated;
  AppCtl := Applet;
  AppletTerminated := FALSE;
  Title := 'Information';
  if pos( '/', Answers ) > 0 then
    Title := 'Question';
  if Applet <> nil then
    Title := Applet.Caption;
  Dialog := NewForm( Applet, Title ).SetSize( 300, 40 );
  Dialog.Style := Dialog.Style and not (WS_MINIMIZEBOX or WS_MAXIMIZEBOX);
  Dialog.OnClose := TOnEventAccept( MakeMethod( Dialog, @CloseMsg ) );
  Dialog.Margin := 8;
  Lab := NewEditbox( Dialog, [ eoMultiline, eoReadonly, eoNoHScroll, eoNoVScroll ] ).SetSize( 278, 20 );
  Lab.HasBorder := FALSE;
  Lab.Color := clBtnFace;
  Lab.Caption := S;
  Lab.Style := Lab.Style and not WS_TABSTOP;
  Lab.TabStop := FALSE;
  //Lab.LikeSpeedButton;

  //Lab.CreateWindow; //virtual!!! -- not needed, window created in Perform
  while TRUE do
  begin
    Y := HiWord( Lab.Perform( EM_POSFROMCHAR, Length( S ) - 1, 0 ) );
    if Y < Lab.Height - 20 then break;
    Lab.Height := Lab.Height + 4;
    if Lab.Height + 40 > GetSystemMetrics( SM_CYSCREEN ) then break;
  end;

  Buttons := NewList;
  W := 0;
  if Answers = '' then
  begin
    Btn := NewButton( Dialog, '  OK  ' ).PlaceUnder;
    W := Btn.Width;
    Buttons.Add( Btn );
  end
    else
  while Answers <> '' do
  begin
    Btn := NewButton( Dialog, '  ' + Parse( Answers, '/' ) + '  ' );
    Buttons.Add( Btn );
    if W = 0 then
      Btn.PlaceUnder
    else
      Btn.PlaceRight;
    Btn.AutoSize( TRUE );
    if W > 0 then
    begin
      //Inc( W, 6 );
      Btn.Left := Btn.Left + 6;
    end;
    W := Btn.BoundsRect.Right + 12;
  end;
  if Dialog.ClientWidth < W then
    Dialog.ClientWidth := W;
  W := (Dialog.ClientWidth - W) div 2;
  for I := 0 to Buttons.Count-1 do
  begin
    Btn := Buttons.Items[ I ];
    Btn.Tag := I + 1;
    {$IFDEF F_P105ORBELOW}
    M := MakeMethod( Dialog, @OKClick );
    Btn.OnClick := POnEvent( @ M )^;
    M := MakeMethod( Dialog, @KeyClick );
    Btn.OnKeyDown := POnKey( @ M )^;
    {$ELSE}
    Btn.OnClick := TOnEvent( MakeMethod( Dialog, @OKClick ) );
    Btn.OnKeyDown := TOnKey( MakeMethod( Dialog, @KeyClick ) );
    {$ENDIF}
    Btn.Left := Btn.Left + W;
    if I = 0 then
    begin
      Btn.ResizeParentBottom;
      Dialog.ActiveControl := Btn;
    end;
  end;
  Dialog.CenterOnParent.Tabulate.CanResize := FALSE;
  Buttons.Free;

  if Assigned( CallBack ) then
    CallBack( Dialog );
  Dialog.CreateWindow; // virtual!!!

  if (Applet <> nil) and Applet.IsApplet then
  begin
    Dialog.ShowModal;
    Result := Dialog.ModalResult;
    Dialog.Free;
  end
    else
  begin
    DlgWnd := Dialog.Handle;
    while IsWindow( DlgWnd ) and (Dialog.ModalResult = 0) do
      Dialog.ProcessMessage;
    Result := Dialog.ModalResult;
    Dialog.Free;
    CreatingWindow := nil;
    Applet := AppCtl;
  end;

  AppletTerminated := AppTermFlag;
end;
//[END ShowQuestionEx]

//[function ShowQuestion]
function ShowQuestion( const S: String; Answers: String ): Integer;
begin
  Result := ShowQuestionEx( S, Answers, nil );
end;
//[END ShowQuestion]

//[procedure ShowMsgModal]
procedure ShowMsgModal( const S: String );
begin
  ShowQuestion( S, '' );
end;
//[ENDe ShowMsgModal]

//[procedure SpeakerBeep]
procedure SpeakerBeep( Freq: Word; Duration: DWORD );
begin
  if WinVer >= wvNT then
    Windows.Beep( Freq, Duration )
  else
  begin
    if Freq < 18 then Exit;
    Freq := 1193181 div Freq;
    if Freq = 0 then Exit;
    asm
        mov al,0b6H
        out 43H,al
        mov ax,Freq
        //xchg al, ah
        out 42h,al
        xchg al, ah
        out 42h,al
        in  al,61H
        or  al,03H
        out 61H,al
    end {$IFDEF F_P} [ 'EAX' ] {$ENDIF} ;
    Sleep(Duration);
    asm
        in  al,61H
        and al,0fcH
        out 61H,al
    end {$IFDEF F_P} [ 'EAX' ] {$ENDIF} ;
  end;
end;
//[ENDe SpeakerBeep]


//[API FormatMessage]
function FormatMessage; external kernel32 name 'FormatMessageA';


//[FUNCTION SysErrorMessage]
function SysErrorMessage(ErrorCode: Integer): string;
var
  Len: Integer;
  Buffer: array[0..255] of Char;
begin
  Len := FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM or
    FORMAT_MESSAGE_ARGUMENT_ARRAY, nil, ErrorCode, 0, Buffer,
    SizeOf(Buffer), nil);
  while (Len > 0) and (Buffer[Len - 1] in [#0..#32 {, '.'}]) do Dec(Len);
  SetString(Result, Buffer, Len);
end;
//[END SysErrorMessage]

//[function MakeMethod]
function MakeMethod( Data, Code: Pointer ): TMethod;
begin
  Result.Data := Data;
  Result.Code := Code;
end;
//[END MakeMethod]

//[function GetShiftState]
function GetShiftState: DWORD;
begin
  Result := 0;
  if GetKeyState( VK_SHIFT ) < 0 then
    Result := Result or MK_SHIFT;
  if GetKeyState( VK_CONTROL ) < 0 then
    Result := Result or MK_CONTROL;
  //if LONGBOOL(Msg.lParam and $20000000) then
  if GetKeyState( VK_MENU ) < 0 then
    Result := Result or MK_ALT;
end;
//[END GetShiftState]

//[FUNCTION MakeRect]
{$IFDEF ASM_VERSION}
function MakeRect( Left, Top, Right, Bottom: Integer ): TRect; stdcall;
asm
        PUSH       ESI
        PUSH       EDI

        MOV        EDI, @Result
        LEA        ESI, [Left]

        MOVSD
        MOVSD
        MOVSD
        MOVSD

        POP        EDI
        POP        ESI
end;
{$ELSE ASM_VERSION} //Pascal
function MakeRect( Left, Top, Right, Bottom: Integer ): TRect; stdcall;
begin
   Result.Left := Left;
   Result.Top  := Top;
   Result.Right:= Right;
   Result.Bottom := Bottom;
end;
{$ENDIF ASM_VERSION}
//[END MakeRect]

//[FUNCTION RectsEqual]
{$IFDEF ASM_VERSION}
function RectsEqual( const R1, R2: TRect ): Boolean;
asm
        //LEA       EAX, [R1]
        //LEA       EDX, [R2]
        MOV       ECX, size_TRect
        CALL      CompareMem
end;
{$ELSE ASM_VERSION} //Pascal
function RectsEqual( const R1, R2: TRect ): Boolean;
begin
  Result := CompareMem( @R1, @R2, Sizeof( TRect ) );
end;
{$ENDIF ASM_VERSION}
//[END RectsEqual]

//[function RectsIntersected]
function RectsIntersected( const R1, R2: TRect ): Boolean;
begin
  Result := ((R1.Left <= R2.Left) and (R1.Right > R2.Left ) or
             (R1.Left <= R2.Right) and (R1.Right >= R2.Right) or
             (R1.Left >= R2.Left) and (R1.Right <= R2.Right))
             and
            ((R1.Top <= R2.Top) and (R1.Bottom > R2.Top) or
             (R1.Top <= R2.Bottom) and (R1.Bottom >= R2.Bottom) or
             (R1.Top >= R2.Top) and (R1.Bottom <= R2.Bottom)) ;
end;
//[END RectsIntersected]


//[FUNCTION PointInRect]
{$IFDEF ASM_VERSION}
function PointInRect( const P: TPoint; const R: TRect ): Boolean;
asm
        PUSH      ESI
        MOV       ECX, EAX
        MOV       ESI, EDX
        LODSD
        CMP       EAX, [ECX]
        JG        @@fail
        LODSD
        CMP       EAX, [ECX+4]
        JG        @@fail
        LODSD
        CMP       [ECX], EAX
        JG        @@fail
        LODSD
        CMP       [ECX+4], EAX
@@fail: SETLE     AL
        POP       ESI
end;
{$ELSE ASM_VERSION} //Pascal
function PointInRect( const P: TPoint; const R: TRect ): Boolean;
begin
   Result := (P.x >= R.Left) and (P.x < R.Right)
             and (P.y >= R.Top) and (P.y < R.Bottom);
end;
{$ENDIF ASM_VERSION}
//[END PointInRect]

//[FUNCTION MakePoint]
{$IFDEF ASM_VERSION}
function MakePoint( X, Y: Integer ): TPoint;
asm
        MOV      ECX, @Result
        MOV      [ECX].TPoint.x, EAX
        MOV      [ECX].TPoint.y, EDX
end;
{$ELSE ASM_VERSION} //Pascal
function MakePoint( X, Y: Integer ): TPoint;
begin
   Result.x := X;
   Result.y := Y;
end;
{$ENDIF ASM_VERSION}
//[END MakePoint]

//[FUNCTION MakeFlags]
{$IFDEF ASM_VERSION}
function MakeFlags( FlgSet: PDWORD; FlgArray: array of Integer): Integer;
asm
        PUSH     EBX
        PUSH     ESI
        MOV      EBX, [EAX]
        MOV      ESI, EDX
        XOR      EDX, EDX
        INC      ECX
        JZ       @@exit
@@loo:
        LODSD
        TEST     EAX, EAX
        JGE      @@ge
        NOT      EAX
        TEST     BL, 1
        JZ       @@or
        DEC      EBX
@@ge:
        TEST     BL, 1
        JZ       @@nx
@@or:
        OR       EDX, EAX
@@nx:
        SHR      EBX, 1
        LOOP     @@loo

@@exit:
        XCHG     EAX, EDX
        POP      ESI
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function MakeFlags( FlgSet: PDWORD; FlgArray: array of Integer): Integer;
var I : Integer;
    Mask : DWORD;
begin
  Result := 0;
  Mask := FlgSet^;
  for I := 0 to High( FlgArray ) do
  begin
    if (FlgArray[ I ] < 0) and not LongBool( Mask and 1 ) then
       Result := Result or not FlgArray[ I ]
    else
    if (FlgArray[ I ] >= 0) and LongBool( Mask and 1 ) then
       Result := Result or FlgArray[ I ];
    Mask := Mask shr 1;
  end;
end;
{$ENDIF ASM_VERSION}
//[END MakeFlags]

//[procedure HelpFastIncNum2Els]
procedure HelpFastIncNum2Els( DataArray: Pointer; Value, Count: Integer );
asm
  PUSH ESI
  PUSH EDI
  {$IFDEF F_P}
  MOV ESI, [DataArray]
  MOV EDX, [Value]
  MOV ECX, [Count]
  {$ELSE DELPHI}
  MOV ESI, EAX
  {$ENDIF F_P/DELPHI}
  MOV EDI, ESI
  CLD

@@1:
  LODSD
  ADD EAX, EDX
  STOSD
  LOOP @@1

  POP EDI
  POP ESI
end {$IFDEF F_P} [ 'EAX', 'EDX', 'ECX' ] {$ENDIF};
//[ENDe HelpFastIncNum2Els]

//[procedure Swap]
procedure Swap( var X, Y: Integer );
{$IFDEF F_P}
var Tmp: Integer;
begin
  Tmp := X;
  X := Y;
  Y := Tmp;
end;
{$ELSE DELPHI}
asm
  MOV  ECX, [EDX]
  XCHG ECX, [EAX]
  MOV  [EDX], ECX
end;
//[ENDe Swap]
{$ENDIF F_P/DELPHI}

//[function Min]
function Min( X, Y: Integer ): Integer;
asm
  {$IFDEF F_P}
  MOV EAX, [X]
  MOV EDX, [Y]
  {$ENDIF F_P}
  CMP EAX, EDX
  JLE @@exit
  MOV EAX, EDX
@@exit:
end {$IFDEF F_P} [ 'EAX', 'EDX' ] {$ENDIF};
//[END Min]

//[function Max]
function Max( X, Y: Integer ): Integer;
asm
  {$IFDEF F_P}
  MOV EAX, [X]
  MOV EDX, [Y]
  {$ENDIF F_P}
  CMP EAX, EDX
  JGE @@exit
  MOV EAX, EDX
@@exit:
end {$IFDEF F_P} [ 'EAX', 'EDX' ] {$ENDIF};
//[END Max]

//[function Abs]
function Abs( X: Integer ): Integer;
asm
  {$IFDEF F_P}
  MOV EAX, [X]
  {$ENDIF F_P}
  TEST EAX, EAX
  JGE @@1
  NEG EAX
@@1:
end {$IFDEF F_P} [ 'EAX' ] {$ENDIF};
//[END Abs]

{$IFDEF ASM_VERSION}
//[PROCEDURE StartDC]
procedure StartDC;
asm
  { <- EBX : PBitmap
    -> EAX = dc
       [ESP+8] = var dc
       [ESP+4] = var SaveBmp
  }
        PUSH     0
        CALL     CreateCompatibleDC
        POP      EDX
        PUSH     EAX
        PUSH     EDX
        MOV      EAX, EBX
        CALL     [EBX].TBitmap.fDetachCanvas
        MOV      EAX, EBX
        CALL     TBitmap.GetHandle
        PUSH     EAX
        PUSH     dword ptr [ESP+8]
        CALL     SelectObject
        POP      EDX
        PUSH     EAX
        PUSH     EDX
        MOV      EAX, [ESP+8]
end;
//[END StartDC]

//[procedure FinishDC]
procedure FinishDC;
asm
        POP      ECX
        POP      EAX
        POP      EDX
        PUSH     ECX
        PUSH     EDX
        PUSH     EAX
        PUSH     EDX
        CALL     SelectObject
        CALL     DeleteDC
end;
//[ENDe FinishDC]
{$ELSE ASM_VERSION}
{$ENDIF ASM_VERSION}

//[procedure FastIncNum2Elements]
procedure FastIncNum2Elements( List: TList; FromIdx, Count, Value: Integer );
begin
  HelpFastIncNum2Els( @List.fItems[ FromIdx ], Value, Count );
end;

//[function EnumDynHandlers FORWARD DECLARATION]
function EnumDynHandlers( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
  forward;

//[procedure DummyObjProc]
procedure DummyObjProc( Sender: PObj );
begin
end;

//[procedure DummyObjProcParam]
procedure DummyObjProcParam( Sender: PObj; Param: Pointer );
begin
end;

//[procedure DummyPaintProc]
procedure DummyPaintProc( Sender: PControl; DC: HDC );
begin
end;

//[procedure Free_And_Nil]
procedure Free_And_Nil( var Obj );
var Obj1: PObj;
begin
  Obj1 := PObj( Obj );
  Pointer( Obj ) := nil;
  Obj1.Free;
end;
//[ENDe Free_And_Nil]









{$IFDEF ASM_VERSION}
constructor TObj.Create;
asm
        //CALL      System.@ObjSetup - Generated always by compiler
        //JZ        @@exit

        PUSH      EAX
        MOV       EDX, [EAX]
        CALL      dword ptr [EDX]
        POP       EAX

@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
constructor TObj.Create;
begin
  Init;
   inherited;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TObj.DoDestroy]
procedure TObj.DoDestroy;
asm
        MOV       EDX, [EAX].fRefCount
        SAR       EDX, 1
        JZ        @@1
        JC        @@exit
        DEC       [EAX].fRefCount
        STC

@@1:    JC        @@exit
        MOV       EDX, [EAX]
        CALL      dword ptr [EDX + 4]
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TObj.DoDestroy;
begin
  if fRefCount <> 0 then
  begin
    if not LongBool( fRefCount and 1) then
       Dec( fRefCount );
  end
  else
     Self.Destroy;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TObj.RefDec]
procedure TObj.RefDec;
asm
        SUB      [EAX].fRefCount, 2
        JGE      @@exit
        TEST     [EAX].fRefCount, 1
        JZ       @@exit
        MOV      EDX, [EAX]
        PUSH     dword ptr [EDX+4]
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TObj.RefDec;
begin
  Dec( fRefCount, 2 );
  if (fRefCount < 0) and LongBool(fRefCount and 1) then
    Destroy;
end;
{$ENDIF ASM_VERSION}

//[procedure TObj.RefInc]
procedure TObj.RefInc;
begin
  Inc( fRefCount, 2 );
end;



//[procedure TObj.Free]
procedure TObj.Free;
{$IFDEF F_P}
begin
  if Self <> nil then
    DoDestroy;
end;
{$ELSE DELPHI}
asm
   TEST    EAX,EAX
   JNE     DoDestroy
end;
{$ENDIF F_P/DELPHI}

{$IFDEF ASM_VERSION}
destructor TObj.Destroy;
asm
        PUSH      EAX
        CALL      Final
        POP       EAX
        XOR       EDX, EDX
        CALL      System.@FreeMem
        //CALL      System.@Dispose
end;
{$ELSE ASM_VERSION} //Pascal
destructor TObj.Destroy;
begin
  Final;
  {$IFDEF DEBUG_ENDSESSION}
  if EndSession_Initiated then
    LogFileOutput( GetStartDir + 'es_debug.txt',
                   'FINALLED: ' + Int2Hex( DWORD( Self ), 8 ) );
  {$ENDIF}

  inherited;
end;
{$ENDIF ASM_VERSION}


//[procedure TObj.Init]
procedure TObj.Init;
begin

end;


{$IFDEF ASM_VERSION}
//[procedure TObj.Final]
procedure TObj.Final;
asm     //cmd    //opd
        XOR      ECX, ECX
        XCHG     ECX, [EAX].fOnDestroy.TMethod.Code
        JECXZ    @@doAutoFree
        PUSH     EAX
        XCHG     EDX, EAX
        MOV      EAX, [EDX].fOnDestroy.TMethod.Data
        CALL     ECX
        POP      EAX
@@doAutoFree:
        XOR      ECX, ECX
        XCHG     ECX, [EAX].fAutoFree
        JECXZ    @@exit
        PUSH     ESI
        PUSH     ECX
        MOV      ESI, [ECX].TList.fItems
        MOV      ECX, [ECX].TList.fCount
@@freeloop:
        LODSD
        XCHG     EDX, EAX
        LODSD
        PUSH     ECX
        CALL     EDX
        POP      ECX
        DEC      ECX
        LOOP     @@freeloop
        POP      EAX
        CALL     TObj.Free
        POP      ESI
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TObj.Final;
var I: Integer;
    ProcMethod: TMethod;
    Proc: TObjectMethod Absolute ProcMethod;
begin
  if Assigned( fOnDestroy ) then
  begin
    fOnDestroy( Self );
    fOnDestroy := nil;
  end;
  if fAutoFree <> nil then
  begin
    for I := 0 to fAutoFree.fCount div 2 - 1 do
    begin
      ProcMethod.Code := fAutoFree.fItems[ I * 2 ];
      ProcMethod.Data := fAutoFree.fItems[ I * 2 + 1 ];

      asm
        MOV  EAX, [ProcMethod.Data]
        {$IFDEF F_P}
        //PUSH EAX
        {$ENDIF F_P}
        MOV  ECX, [ProcMethod.Code]
        CALL ECX
      end {$IFDEF F_P}[ 'EAX', 'EDX', 'ECX' ]{$ENDIF};

    end;
    fAutoFree.Free;
    fAutoFree := nil;
  end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TObj.Add2AutoFree]
procedure TObj.Add2AutoFree(Obj: PObj);
asm     //cmd    //opd
        PUSH     EBX
        PUSH     EDX
        XCHG     EBX, EAX
        MOV      EAX, [EBX].fAutoFree
        TEST     EAX, EAX
        JNZ      @@1
        CALL     NewList
        MOV      [EBX].fAutoFree, EAX
@@1:    MOV      EBX, EAX
        XOR      EDX, EDX
        POP      ECX
        CALL     TList.Insert
        XCHG     EAX, EBX
        XOR      EDX, EDX
        MOV      ECX, offset TObj.Free
        //XOR      ECX, ECX
        CALL     TList.Insert
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TObj.Add2AutoFree(Obj: PObj);
begin
  if fAutoFree = nil then
    fAutoFree := NewList;
  fAutoFree.Insert( 0, Obj );
  fAutoFree.Insert( 0, Pointer( @TObj.Free ) );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TObj.Add2AutoFreeEx]
procedure TObj.Add2AutoFreeEx( Proc: TObjectMethod );
asm     //cmd    //opd
        PUSH     EBX
        XCHG     EAX, EBX
        MOV      EAX, [EBX].fAutoFree
        TEST     EAX, EAX
        JNZ      @@1
        CALL     NewList
        MOV      [EBX].fAutoFree, EAX
@@1:    XOR      EDX, EDX
        MOV      ECX, [EBP+12] // Data
        MOV      EBX, EAX
        CALL     TList.Insert
        XCHG     EAX, EBX
        XOR      EDX, EDX
        MOV      ECX, [EBP+8] // Code
        CALL     TList.Insert
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TObj.Add2AutoFreeEx( Proc: TObjectMethod );
{$IFDEF F_P}
var Ptr1, Ptr2: Pointer;
{$ENDIF F_P}
begin
  if fAutoFree = nil then
    fAutoFree := NewList;
  {$IFDEF F_P}
  asm
    MOV  EAX, [Proc]
    MOV  [Ptr1], EAX
    MOV  EAX, [Proc+4]
    MOV  [Ptr2], EAX
  end [ 'EAX' ];
  fAutoFree.Insert( 0, Ptr2 );
  fAutoFree.Insert( 0, Ptr1 );
  {$ELSE DELPHI}
  fAutoFree.Insert( 0, Pointer( TMethod( Proc ).Data ) );
  fAutoFree.Insert( 0, Pointer( TMethod( Proc ).Code ) );
  {$ENDIF}
end;
{$ENDIF ASM_VERSION}















{ TList }

{$IFDEF USE_CONSTRUCTORS}
//[function NewList]
function NewList: PList;
begin
  New( Result, Create );
  //Result.fAddBy := 4;
end;
//[END NewList]

//[procedure TList.Init]
procedure TList.Init;
begin
  inherited;
  fAddBy := 4;
end;
{$ELSE not_USE_CONSTRUCTORS}
//[function NewList]
function NewList: PList;
begin
    Result := PList.Create;
  Result.fAddBy := 4;
end;
//[END NewList]
{$ENDIF USE_CONSTRUCTORS}

{$IFDEF ASM_VERSION}
destructor TList.Destroy;
asm
        PUSH      EAX
        CALL      TList.Clear
        POP       EAX
        CALL      TObj.Destroy
end;
{$ELSE ASM_VERSION} //Pascal
destructor TList.Destroy;
begin
   Clear;
   inherited;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TList.Release]
procedure TList.Release;
asm
       TEST      EAX, EAX
       JZ        @@e
       MOV       ECX, [EAX].fCount
       JECXZ     @@e
       MOV       EDX, [EAX].fItems
       PUSH      EAX
@@1:
       MOV       EAX, [EDX+ECX*4-4]
       TEST      EAX, EAX
       JZ        @@2
       PUSH      EDX
       PUSH      ECX
       CALL      System.@FreeMem
       POP       ECX
       POP       EDX
@@2:   LOOP      @@1
       POP       EAX
@@e:   CALL      TObj.Free
end;
{$ELSE ASM_VERSION} //Pascal
procedure TList.Release;
var I: Integer;
begin
  if Self = nil then Exit;
  for I := 0 to fCount - 1 do
    if fItems[ I ] <> nil then
      FreeMem( fItems[ I ] );
  Free;
end;
{$ENDIF ASM_VERSION}

//[procedure TList.ReleaseObjects]
procedure TList.ReleaseObjects;
var I: Integer;
begin
  if Self = nil then Exit;
  for I := fCount-1 downto 0 do
    PObj( fItems[ I ] ).Free;
  Free;
end;

{$IFDEF ASM_VERSION}
//[procedure TList.SetCapacity]
procedure TList.SetCapacity( Value: Integer );
asm
        CMP       EDX, [EAX].fCount
        JGE       @@1
        MOV       EDX, [EAX].fCount
@@1:
        CMP       EDX, [EAX].fCapacity
        JE        @@exit

        MOV       [EAX].fCapacity, EDX
        SAL       EDX, 2
        LEA       EAX, [EAX].fItems
        CALL      System.@ReallocMem
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
//var NewItems: PPointerList;
procedure TList.SetCapacity( Value: Integer );
begin
   if Value < Count then
      Value := Count;
   if Value = fCapacity then Exit;
   {
   if fItems = nil then
     GetMem( fItems, Value * Sizeof( Pointer ) )
   else}
     ReallocMem( fItems, Value * Sizeof( Pointer ) );
   fCapacity := Value;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TList.Clear]
procedure TList.Clear;
asm
        PUSH      [EAX].fItems
        XOR       EDX, EDX
        MOV       [EAX].fItems, EDX
        MOV       [EAX].fCount, EDX
        MOV       [EAX].fCapacity, EDX
        POP       EAX
        CALL      System.@FreeMem
end;
{$ELSE ASM_VERSION} //Pascal
procedure TList.Clear;
begin
   if fItems <> nil then
      FreeMem( fItems );
   fItems := nil;
   fCount := 0;
   fCapacity := 0;
end;
{$ENDIF ASM_VERSION}

//[procedure TList.SetAddBy]
procedure TList.SetAddBy(Value: Integer);
begin
  if Value < 1 then Value := 1;
  fAddBy := Value;
end;

{$IFDEF ASM_VERSION}
//[procedure TList.Add]
procedure TList.Add( Value: Pointer );
asm
        PUSH      EDX
        LEA       ECX, [EAX].fCount
        MOV       EDX, [ECX]
        INC       dword ptr [ECX]
          PUSH      EDX
          CMP       EDX, [EAX].fCapacity
            PUSH      EAX
            JL        @@ok

            CMP       [EAX].fAddBy, 0
            JG        @@add
            MOV       [EAX].fAddBy, 4
          @@add:
            ADD       EDX, [EAX].fAddBy
            CALL      TList.SetCapacity
@@ok:
            POP       ECX  // ECX = Self
          POP       EAX    // EAX = fCount -> Result (for TList.Insert)
        POP       EDX      // EDX = Value

        MOV       ECX, [ECX].fItems
        MOV       [ECX + EAX*4], EDX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TList.Add( Value: Pointer );
begin
   if fAddBy <= 0 then fAddBy := 4;
   if fCapacity <= Count then
      Capacity := Count + fAddBy;
   fItems[ fCount ] := Value;
   Inc( fCount );
end;
{$ENDIF ASM_VERSION}

//[procedure TList.Delete]
procedure TList.Delete( Idx: Integer );
begin
   {Assert( (Idx >= 0) and (Idx < fCount), 'TList.Delete: index out of bounds' );
   Move( fItems[ Idx + 1 ], fItems[ Idx ], Sizeof( Pointer ) * (Count - Idx - 1) );
   Dec( fCount );}
   DeleteRange( Idx, 1 );
end;

{$IFDEF ASM_VERSION}
//[procedure TList.DeleteRange]
procedure TList.DeleteRange(Idx, Len: Integer);
asm     //cmd    //opd
        TEST     ECX, ECX
        JLE      @@exit
        PUSH     EBX
        XCHG     EBX, EAX
        LEA      EAX, [EDX+ECX]
        CMP      EAX, [EBX].fCount
        JBE      @@1
        MOV      ECX, [EBX].fCount
        SUB      ECX, EDX
@@1:
        MOV      EAX, [EBX].fItems
        PUSH     [EBX].fCount
        SUB      [EBX].fCount, ECX
        MOV      EBX, EDX
        LEA      EDX, [EAX+EDX*4]
        LEA      EAX, [EDX+ECX*4]
        ADD      EBX, ECX
        POP      ECX
        SUB      ECX, EBX
        SHL      ECX, 2
        CALL     System.Move
        POP      EBX
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TList.DeleteRange(Idx, Len: Integer);
begin
  if Len <= 0 then Exit;
  Assert( (Idx >= 0) and (Idx < fCount), 'TList.DeleteRange: index out of bounds' );
  if DWORD( Idx + Len ) > DWORD( Count ) then
    Len := Count - Idx;
  Move( fItems[ Idx + Len ], fItems[ Idx ], Sizeof( Pointer ) * (Count - Idx - Len) );
  Dec( fCount, Len );
end;
{$ENDIF ASM_VERSION}

//[procedure TList.Remove]
procedure TList.Remove(Value: Pointer);
var I: Integer;
begin
  I := IndexOf( Value );
  if I >= 0 then
    Delete( I );
end;

//[procedure TList.Put]
procedure TList.Put( Idx: Integer; Value: Pointer );
begin
   if Idx < 0 then Exit;
   if Idx >= Count then Exit;
   //Assert( (Idx >= 0) and (Idx < fCount), 'TList.Put: index out of bounds' );
   fItems[ Idx ] := Value;
end;

//[function TList.Get]
function TList.Get( Idx: Integer ): Pointer;
begin
   Result := nil;
   if Idx < 0 then Exit;
   if Idx >= fCount then Exit;
   //Assert( (Idx >= 0) and (Idx < fCount), 'TList.Get: index out of bounds' );
   Result := fItems[ Idx ];
end;

{$IFDEF ASM_VERSION}
//[function TList.IndexOf]
function TList.IndexOf( Value: Pointer ): Integer;
asm
        PUSH      EDI

        MOV       EDI, [EAX].fItems
        MOV       ECX, [EAX].fCount
          PUSH      EDI
          DEC       EAX            // make "NZ" - EAX always <> 1
          MOV       EAX, EDX
          REPNZ     SCASD
          POP       EDX
        JZ        @@succ
        MOV       EDI, EDX
@@succ:
        MOV       EAX, EDI
        STC
        SBB       EAX, EDX
        SAR       EAX, 2

        POP       EDI
end;
{$ELSE ASM_VERSION} //Pascal
function TList.IndexOf( Value: Pointer ): Integer;
var I: Integer;
begin
   Result := -1;
   for I := 0 to Count - 1 do
   begin
      if fItems[ I ] = Value then
      begin
         Result := I;
         break;
      end;
   end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TList.Insert]
procedure TList.Insert(Idx: Integer; Value: Pointer);
asm
        PUSH      ECX
        PUSH      EAX
          PUSH      EDX
          CALL      TList.Add   // don't matter what to add
          POP       EDX         // EDX = Idx, Eax = Count-1
        SUB       EAX, EDX

        SAL       EAX, 2
        MOV       ECX, EAX      // ECX = (Count - Idx - 1) * 4
        POP       EAX
        MOV       EAX, [EAX].fItems
        LEA       EAX, [EAX + EDX*4]
        JL        @@1
          PUSH      EAX
          LEA       EDX, [EAX + 4]
          CALL      System.Move

          POP       EAX          // EAX = @fItems[ Idx ]
@@1:
        POP       ECX            // ECX = Value
        MOV       [EAX], ECX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TList.Insert(Idx: Integer; Value: Pointer);
begin
   Assert( (Idx >= 0) and (Idx <= Count), 'List index out of bounds' );
   Add( nil );
   if fCount > Idx then
     Move( FItems[ Idx ], FItems[ Idx + 1 ], (fCount - Idx - 1) * Sizeof( Pointer ) );
   FItems[ Idx ] := Value;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TList.MoveItem]
procedure TList.MoveItem(OldIdx, NewIdx: Integer);
asm
        CMP       EDX, ECX
        JE        @@exit

        CMP       ECX, [EAX].fCount
        JGE       @@exit

        PUSH      EDI

        MOV       EDI, [EAX].fItems
        PUSH      dword ptr [EDI + EDX*4]
          PUSH      ECX
          PUSH      EAX
          CALL      TList.Delete
          POP       EAX
          POP       EDX
        POP       ECX

        POP       EDI
        CALL      TList.Insert
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TList.MoveItem(OldIdx, NewIdx: Integer);
var Item: Pointer;
    //I: Integer;
begin
  if OldIdx = NewIdx then Exit;
  if NewIdx >= Count then Exit;
  Item := Items[ OldIdx ];
  Delete( OldIdx );
  Insert( NewIdx, Item );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TList.Last]
function TList.Last: Pointer;
asm     //cmd    //opd
        MOV      ECX, [EAX].fCount
        JECXZ    @@0
        MOV      EAX, [EAX].fItems
        DEC      ECX
        MOV      ECX, [EAX + ECX*4]
@@0:    XCHG     EAX, ECX
end;
{$ELSE ASM_VERSION} //Pascal
function TList.Last: Pointer;
begin
  if Count = 0 then
    Result := nil
  else
    Result := Items[ Count-1 ];
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TList.Swap]
procedure TList.Swap(Idx1, Idx2: Integer);
asm
        MOV       EAX, [EAX].fItems
          PUSH      dword ptr [EAX + EDX*4]
            PUSH      ECX
            MOV       ECX, [EAX + ECX*4]
            MOV       [EAX + EDX*4], ECX
            POP       ECX
          POP       EDX
        MOV       [EAX + ECX*4], EDX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TList.Swap(Idx1, Idx2: Integer);
var Tmp: Pointer;
begin
  Tmp := FItems[ Idx1 ];
  FItems[ Idx1 ] := FItems[ Idx2 ];
  FItems[ Idx2 ] := Tmp;
end;
{$ENDIF ASM_VERSION}

//[procedure TList.SetCount]
procedure TList.SetCount(const Value: Integer);
begin
  if Value >= Count then exit;
  fCount := Value;
end;

//[procedure TList.Assign]
procedure TList.Assign(SrcList: PList);
begin
  Clear;
  if SrcList.fCount > 0 then
  begin
    Capacity := SrcList.fCount;
    fCount := SrcList.fCount;
    Move( SrcList.FItems[ 0 ], FItems[ 0 ], Sizeof( Pointer ) * fCount );
  end;
end;

{ TListEx }

//[function NewListEx]
function NewListEx: PListEx;
begin
  Result := PListEx.Create;
  Result.fList := NewList;
  Result.fObjects := NewList;
end;
//[END NewListEx]

//[procedure TListEx.Add]
procedure TListEx.Add(Value: Pointer);
begin
  AddObj( Value, nil );
end;

//[procedure TListEx.AddObj]
procedure TListEx.AddObj(Value, Obj: Pointer);
var C: Integer;
begin
  C := Count;
  fList.Add( Value );
  fObjects.Insert( C, Obj );
end;

//[procedure TListEx.Clear]
procedure TListEx.Clear;
begin
  fList.Clear;
  fObjects.Clear;
end;

//[procedure TListEx.Delete]
procedure TListEx.Delete(Idx: Integer);
begin
  DeleteRange( Idx, 1 );
end;

//[procedure TListEx.DeleteRange]
procedure TListEx.DeleteRange(Idx, Len: Integer);
begin
  fList.DeleteRange( Idx, Len );
  fObjects.DeleteRange( Idx, Len );
end;

//[destructor TListEx.Destroy]
destructor TListEx.Destroy;
begin
  fList.Free;
  fObjects.Free;
  inherited;
end;

//[function TListEx.GetAddBy]
function TListEx.GetAddBy: Integer;
begin
  Result := fList.AddBy;
end;

//[function TListEx.GetCount]
function TListEx.GetCount: Integer;
begin
  Result := fList.Count;
end;

//[function TListEx.GetEx]
function TListEx.GetEx(Idx: Integer): Pointer;
begin
  Result := fList.Items[ Idx ];
end;

//[function TListEx.IndexOf]
function TListEx.IndexOf(Value: Pointer): Integer;
begin
  Result := fList.IndexOf( Value );
end;

//[function TListEx.IndexOfObj]
function TListEx.IndexOfObj(Obj: Pointer): Integer;
begin
  Result := fObjects.IndexOf( Obj );
end;

//[procedure TListEx.Insert]
procedure TListEx.Insert(Idx: Integer; Value: Pointer);
begin
  InsertObj( Idx, Value, nil );
end;

//[procedure TListEx.InsertObj]
procedure TListEx.InsertObj(Idx: Integer; Value, Obj: Pointer);
begin
  fList.Insert( Idx, Value );
  fObjects.Insert( Idx, Obj );
end;

//[function TListEx.Last]
function TListEx.Last: Pointer;
begin
  Result := fList.Last;
end;

//[function TListEx.LastObj]
function TListEx.LastObj: Pointer;
begin
  Result := fObjects.Last;
end;

//[procedure TListEx.MoveItem]
procedure TListEx.MoveItem(OldIdx, NewIdx: Integer);
begin
  fList.MoveItem( OldIdx, NewIdx );
  fObjects.MoveItem( OldIdx, NewIdx );
end;

//[procedure TListEx.PutEx]
procedure TListEx.PutEx(Idx: Integer; const Value: Pointer);
begin
  fList.Items[ Idx ] := Value;
end;

//[procedure TListEx.Set_AddBy]
procedure TListEx.Set_AddBy(const Value: Integer);
begin
  fList.AddBy := Value;
  fObjects.AddBy := Value;
end;

//[procedure TListEx.Swap]
procedure TListEx.Swap(Idx1, Idx2: Integer);
begin
  fList.Swap( Idx1, Idx2 );
  fObjects.Swap( Idx1, Idx2 );
end;


















{ -- Window procedure -- }

{$IFDEF ASM_VERSION} //!!//!!
//[FUNCTION CallCtlWndProc]
function CallCtlWndProc( Ctl: PControl; var Msg: TMsg ): Integer;
begin
  Result := Ctl.WndProc( Msg );
end;
//[END CallCtlWndProc]

//[function WndFunc]
function WndFunc( W: HWnd; Msg: Cardinal; wParam, lParam: Integer )
                                   : Integer; stdcall;
const   size_TMsg = sizeof( TMsg );
asm
        ADD       ESP, -size_TMsg
        MOV       EDX, ESP

        PUSH      ESI
        PUSH      EDI

        MOV       EDI, EDX
        LEA       ESI, [W]

        MOVSD
        MOVSD
        MOVSD
        MOVSD

        MOV       EDI, EDX
        MOV       EAX, [EDI]
        TEST      EAX, EAX
        JZ        @Self_is_nil

        MOV       ECX, [CreatingWindow]
        JECXZ     @@get_self_prop

        MOV       [ECX].TControl.fHandle, EAX

//set_self_prop:
        PUSH      ECX
          PUSH      ECX
          PUSH      Offset[ID_SELF]
          PUSH      EAX
          CALL      SetProp

          XOR       EAX, EAX
          MOV       [CreatingWindow], EAX
        POP       EAX                 // EAX = self_
        JMP       @Self_got

@@get_self_prop:
        PUSH      Offset[ID_SELF]
        PUSH      EAX
        CALL      GetProp
        TEST      EAX, EAX
        JNZ       @Self_got

@Self_is_nil:
        OR        EAX, [ Applet ]
        JNZ       @Self_got

//try_defwndproc:
        POP       EDI
        POP       ESI
        MOV       ESP, EBP
        POP       EBP
        JMP       DefWindowProc

//@@id_self:
//        DB        'SELF_',0

@Self_got:
        MOV       EDX, EDI
        //CALL      TControl.WndProc
        CALL      CallCtlWndProc

        POP       EDI
        POP       ESI

        MOV       ESP, EBP
end;
{$ELSE ASM_VERSION} //Pascal
function WndFunc( W: HWnd; Msg: Cardinal; wParam, lParam: Integer )
                                   : Integer; stdcall;
var M: TMsg;
    self_: PControl;
begin
   M.hwnd := W;
   M.message := Msg;
   M.wParam := wParam;
   M.lParam := lParam;

   {$IFDEF DEBUG_ENDSESSION}
   if EndSession_Initiated then
   begin
     LogFileOutput( GetStartDir + 'es_debug.txt',
       'HWND:' + Int2Str( W ) + ' MSG:$' + Int2Hex( Msg, 4 ) +
       ' WParam: ' + Int2Str( wParam ) + '($' + Int2Hex( wParam, 8 ) + ')' +
       ' LParam: ' + Int2Str( lParam ) + '($' + Int2Hex( lParam, 8 ) + ')' );
   end;
   {$ENDIF}

   self_ := nil;
   if W <> 0 then
   begin
     if CreatingWindow <> nil then
     begin
        {$IFDEF DEBUG_CREATEWINDOW}
        LogFileOutput( GetStartDir + 'Session.log',
                       'WndFunc: Creating window = ' + Int2Hex( Integer( CreatingWindow ), 4 ) +
                       ' hwnd=' + Int2Str( M.hwnd ) +
                       ' message=' + Int2Hex( M.message, 4 ) +
                       ' wParam=' + Int2Str( M.wParam ) + '=$' + Int2Hex( M.wParam, 4 ) +
                       ' lParam=' + Int2Str( M.lParam ) + '=$' + Int2Hex( M.lParam, 4 )
                     );
        {$ENDIF DEBUG_CREATEWINDOW}
        self_ := CreatingWindow;
        CreatingWindow.fHandle := W;
        SetProp( W, ID_SELF, THandle( CreatingWindow ) );
        CreatingWindow := nil;
     end
        else
     self_ := Pointer( GetProp( W, ID_SELF ) );
   end;

   if self_ <> nil then
      Result := self_.WndProc( M )
   else
   if Assigned( Applet ) then
      Result := Applet.WndProc( M )
   else
      Result := DefWindowProc( W, Msg, wParam, lParam );
   {$IFDEF DEBUG_ENDSESSION}
   if EndSession_Initiated then
   begin
     LogFileOutput( GetStartDir + 'es_debug.txt',
       'HWND:' + Int2Str( W ) + ' MSG:$' + Int2Hex( Msg, 4 ) +
       ' Result: ' + Int2Str( Result ) + '($' + Int2Hex( Result, 8 ) + ')' );
   end;
   {$ENDIF}
end;
//[END WndFunc]
{$ENDIF ASM_VERSION}

var
  IdleHandlers: PList;
  ProcessIdle: procedure ( Sender: PObj ) = DummyObjProc;

//[procedure ProcessIdleProc]
procedure ProcessIdleProc( Sender: PObj );
var
  i: integer;
  m: TMethod;
begin
  i := 0;
  with IdleHandlers do
    while i < Count do begin
      m.Code:=Items[i];
      Inc(i);
      m.Data:=Items[i];
      Inc(i);
      TOnEvent(m)(Sender);
    end;
end;

//[function FindIdleHandler]
function FindIdleHandler( const OnIdle: TOnEvent ): integer;
var
  i: integer;
begin
  i := 0;
  with TMethod(OnIdle), IdleHandlers do
    while i < Count do begin
      if (Items[i] = Code) and (Items[i + 1] = Data) then
      begin
        Result := i;
        exit;
      end;
      Inc(i, 2);
    end;
  Result := -1;
end;
//[END FindIdleHandler]

//[procedure RegisterIdleHandler]
procedure RegisterIdleHandler( const OnIdle: TOnEvent );
begin
  if IdleHandlers = nil then begin
    IdleHandlers := NewList;
    if Applet <> nil then
      Applet.Add2AutoFree(IdleHandlers);
  end;
  with TMethod(OnIdle) do
  begin
    IdleHandlers.Add(Code);
    IdleHandlers.Add(Data);
  end;
  ProcessIdle := @ProcessIdleProc;
end;

//[procedure UnRegisterIdleHandler]
procedure UnRegisterIdleHandler( const OnIdle: TOnEvent );
var
  i: integer;
begin
  i := FindIdleHandler(OnIdle);
  if i <> -1 then
  with IdleHandlers do
  begin
    Delete(i);
    Delete(i);
  end;
end;

//[procedure TerminateExecution]
procedure TerminateExecution( var AppletWnd: PControl );
var App: PControl;
    Appalreadyterminated: Boolean;
begin
  Appalreadyterminated := AppletTerminated;
  AppletTerminated := TRUE;
  AppletRunning := FALSE;
  App := Applet;
  Applet := nil;
  if (App <> nil) {and (App.RefCount >= 0)} then
  begin
    App.RefInc;
    if not Appalreadyterminated then
    begin
      App.ProcessMessages;
      App.Perform( WM_CLOSE, 0, 0 );
    end;
    AppletWnd := nil;
    App.Free;
    App.RefDec;
  end;
end;

//[PROCEDURE CallTControlCreateWindow]
{$IFDEF ASM_VERSION}
procedure CallTControlCreateWindow( Ctl: PControl );
begin
  Ctl.CreateWindow;
end;
//[END CallTControlCreateWindow]

//[PROCEDURE Run]
procedure Run( var AppletWnd: PControl );
asm
        PUSH      EBX
        XCHG      EBX, EAX

        INC       [AppletRunning]
        MOV       EAX, [EBX]
        MOV       [Applet], EAX
        CALL      CallTControlCreateWindow
        JMP       @@2
@@1:
        CALL      WaitMessage
        MOV       EAX, [EBX]
        CALL      TControl.ProcessMessages
        {$IFNDEF NOT_USE_OnIdle}
        MOV       EAX, [EBX]
        CALL      [ProcessIdle]
        {$ENDIF}
@@2:
        CMP       [AppletTerminated],0
        JZ        @@1

        XCHG      EAX, EBX

        POP       EBX
        TEST      EAX, EAX
        JNZ       TerminateExecution
end;
{$ELSE ASM_VERSION} //Pascal
procedure Run( var AppletWnd: PControl );
begin
  AppletRunning := True;
  Applet := AppletWnd;
  AppletWnd.CreateWindow; //virtual!!!
  while not AppletTerminated do
  begin
    WaitMessage;
    AppletWnd.ProcessMessages;
    {$IFNDEF NOT_USE_OnIdle}
    ProcessIdle( AppletWnd );
    {$ENDIF}
  end;
  if AppletWnd <> nil then
    TerminateExecution( AppletWnd );
end;
//[END Run]
{$ENDIF ASM_VERSION}

//[procedure AppletMinimize]
procedure AppletMinimize;
begin
  if Applet = nil then Exit;
  Applet.Perform( WM_SYSCOMMAND, SC_MINIMIZE, 0 );
end;

//[procedure AppletHide]
procedure AppletHide;
begin
  if Applet = nil then Exit;
  AppletMinimize;
  Applet.Hide;
end;

//[procedure AppletRestore]
procedure AppletRestore;
begin
  if Applet = nil then Exit;
  Applet.Show;
  Applet.Perform( WM_SYSCOMMAND, SC_RESTORE, 0 );
end;

//[function ScreenWidth]
function ScreenWidth: Integer;
begin
  Result := GetSystemMetrics( SM_CXSCREEN );
end;
//[END ScreenWidth]

//[function ScreenHeight]
function ScreenHeight: Integer;
begin
  Result := GetSystemMetrics( SM_CYSCREEN );
end;
//[END ScreenHeight]







{$IFDEF USE_CONSTRUCTORS}
  {$DEFINE WNDPROCAPP_USED}
  {$DEFINE WNDPROCAPP_ASM_USED}
{$ENDIF USE_CONSTRUCTORS}
{$IFNDEF ASM_VERSION}
  {$DEFINE WNDPROCAPP_USED}
{$ENDIF  ASM_VERSION}

  {$DEFINE WNDPROCAPP_USED}



{$IFNDEF WNDPROCAPP_USED}
//[WndProcXXX FORWARD DECLARATIONS]
  {$IFNDEF ASM_VERSION}
function WndProcApp( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean; forward;
  {$ENDIF}
{$ENDIF}
function WndProcForm( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean; forward;
//function WndProcCtrl( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean; forward;
function WndProcPaint( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean; forward;
function WndProcGradient( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean; forward;
function WndProcGradientEx( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean; forward;
function WndProcLabelEffect( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean; forward;
//function WndProcParentResize(Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean; forward;
//function WndProcResize(Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean; forward;
function WndProcNotify( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean; forward;
function WndProcCommonNotify( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean; forward;
var fGlobalProcKeybd: function( Sender: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean =
    WndProcDummy;
//[END OF WndProcXXX FORWARD DECLARATIONS]













{ -- Graphics support -- }

//[function _NewGraphicTool]
function _NewGraphicTool: PGraphicTool;
begin

  Result := PGraphicTool.Create;
end;
//[END _NewGraphicTool]

//[FUNCTION SimpleGetCtlBrushHandle]
{$IFDEF ASM_VERSION}
function SimpleGetCtlBrushHandle( Sender: PControl ): HBrush;
asm     //        //
@@1:    MOV       ECX, [EAX].TControl.fParent
        JECXZ     @@2
        MOV       EDX, [EAX].TControl.fColor
        CMP       EDX, [ECX].TControl.fColor
        XCHG      EAX, ECX
        JE        @@1
        XCHG      EAX, ECX
@@2:    PUSH      EBX
        XCHG      EBX, EAX
        MOV       ECX, [EBX].TControl.fTmpBrush
        JECXZ     @@3
        MOV       EAX, [EBX].TControl.fColor
        CALL      Color2RGB
        CMP       EAX, [EBX].TControl.fTmpBrushColorRGB
        JE        @@3
        XOR       EAX, EAX
        XCHG      [EBX].TControl.fTmpBrush, EAX
        PUSH      EAX
        CALL      DeleteObject
@@3:    MOV       EAX, [EBX].TControl.fTmpBrush
        TEST      EAX, EAX
        JNE       @@4
        MOV       EAX, [EBX].TControl.fColor
        CALL      Color2RGB
        MOV       [EBX].TControl.fTmpBrushColorRGB, EAX
        PUSH      EAX
        CALL      CreateSolidBrush
        MOV       [EBX].TControl.fTmpBrush, EAX
@@4:    POP       EBX
end;
{$ELSE ASM_VERSION PAS_VERSION}
function SimpleGetCtlBrushHandle( Sender: PControl ): HBrush;
begin
  if (Sender.fParent <> nil) and (Sender.fColor = Sender.fParent.fColor) then
    Result := SimpleGetCtlBrushHandle( Sender.fParent )
  else
  begin
    if (Sender.fTmpBrush <> 0) and
       (Color2RGB( Sender.fColor ) <> Sender.fTmpBrushColorRGB) then
    begin
      DeleteObject( Sender.fTmpBrush );
      Sender.fTmpBrush := 0;
    end;
    if Sender.fTmpBrush = 0 then
    begin
      Sender.fTmpBrushColorRGB := Color2RGB( Sender.fColor );
      Sender.fTmpBrush := CreateSolidBrush( Sender.fTmpBrushColorRGB );
    end;
    Result := Sender.fTmpBrush;
  end;
end;
{$ENDIF ASM_VERSION}
//[END SimpleGetCtlBrushHandle]

//[function NormalGetCtlBrushHandle]
function NormalGetCtlBrushHandle( Sender: PControl ): HBrush;
begin
  if Sender.fParent <> nil then
    Sender.Brush.fParentGDITool := Sender.fParent.Brush;
  {if (Sender.Brush.fHandle <> 0) and
     (Color2RGB( Sender.fBrush.fData.Color ) <> Sender.fBrush.fColorRGB) then
    DeleteObject( Sender.Brush.ReleaseHandle );}
  Result := Sender.Brush.Handle;
end;
//[END NormalGetCtlBrushHandle]


//[API CreateFontIndirect]
function CreateFontIndirect(const p1: TLogFont): HFONT; stdcall;
external gdi32 name 'CreateFontIndirectA';

//[MakeXXXHandle FORWARD DECLARATIONS]
function MakeFontHandle( Self_: PGraphicTool ): THandle; forward;
function MakeBrushHandle( Self_: PGraphicTool ): THandle; forward;
function MakePenHandle( Self_: PGraphicTool ): THandle; forward;
function MakeGeometricPenHandle( Self_: PGraphicTool ): THandle; forward;
//[END OF MakeXXXHandle FORWARD DECLARATIONS]

//[FUNCTION NewBrush]
{$IFDEF ASM_VERSION}
function NewBrush: PGraphicTool;
asm
        MOV      [Global_GetCtlBrushHandle], offset NormalGetCtlBrushHandle
        CALL     _NewGraphicTool
        MOV      [EAX].TGraphicTool.fNewProc, offset[NewBrush]
        MOV      [EAX].TGraphicTool.fType, gttBrush
        MOV      [EAX].TGraphicTool.fMakeHandleProc, offset[MakeBrushHandle]
        MOV      [EAX].TGraphicTool.fData.Color, clBtnFace
end;
{$ELSE ASM_VERSION} //Pascal
function NewBrush: PGraphicTool;
begin
  Global_GetCtlBrushHandle := NormalGetCtlBrushHandle;
  Result := _NewGraphicTool;
  with Result  do
  begin
    fNewProc := @ NewBrush;
    fType := gttBrush;
    fMakeHandleProc := @ MakeBrushHandle;
    Result.fData.Color := clBtnFace;
    //Result.fData.Brush.Style := bsSolid;
  end;
end;
{$ENDIF ASM_VERSION}
//[END NewBrush]

const size_FontData = sizeof( Integer {fFontHeight} ) + sizeof( Integer {fFontWidth} ) +
                      sizeof( TFontPitch ) +  sizeof( TFontStyle ) +
                      sizeof( Integer {fFontOrientation} ) +
                      sizeof( Integer {fFontWeight} ) + sizeof( TFontCharset ) +
                      sizeof( TFontQuality );

//[FUNCTION NewFont]
{$IFDEF ASM_VERSION}
function NewFont: PGraphicTool;
const FontDtSz = sizeof( TGDIFont );
asm
        CALL     _NewGraphicTool
        MOV      [EAX].TGraphicTool.fNewProc, offset[NewFont]
        MOV      [EAX].TGraphicTool.fType, gttFont
        MOV      [EAX].TGraphicTool.fMakeHandleProc, offset[MakeFontHandle]
        MOV      EDX, [DefFontColor]
        MOV      [EAX].TGraphicTool.fData.Color, EDX

        PUSH     EAX
        LEA      EDX, [EAX].TGraphicTool.fData.Font
        MOV      EAX, offset[ DefFont ]
        XOR      ECX, ECX
        MOV      CL, FontDtSz
        CALL     System.Move
        POP      EAX
end;
{$ELSE ASM_VERSION} //Pascal
function NewFont: PGraphicTool;
begin
  Result := _NewGraphicTool;
  with Result  do
  begin
    fNewProc := @ NewFont;
    fType := gttFont;
    fMakeHandleProc := @ MakeFontHandle;
    fData.Color := DefFontColor;
    Move( DefFont, fData.Font, Sizeof( TGDIFont ) );
  end;
end;
{$ENDIF ASM_VERSION}
//[END NewFont]

//[FUNCTION NewPen]
{$IFDEF ASM_VERSION}
function NewPen: PGraphicTool;
asm
        CALL     _NewGraphicTool
        MOV      [EAX].TGraphicTool.fNewProc, offset[NewPen]
        MOV      [EAX].TGraphicTool.fType, gttPen
        MOV      [EAX].TGraphicTool.fMakeHandleProc, offset[MakePenHandle]
        MOV      [EAX].TGraphicTool.fData.Pen.Mode, pmCopy
end;
{$ELSE ASM_VERSION} //Pascal
function NewPen: PGraphicTool;
begin
  Result := _NewGraphicTool;
  with Result do
  begin
    fNewProc := @ NewPen;
    fType := gttPen;
    fMakeHandleProc := @ MakePenHandle;
    fData.Pen.Mode := pmCopy;
  end;
end;
{$ENDIF ASM_VERSION}
//[END NewPen]

//+
//[function Color2RGB]
function Color2RGB( Color: TColor ): TColor;
begin
  if Color < 0 then
    Result := GetSysColor(Color and $FF) else
    Result := Color;
end;
//[END Color2RGB]

//[function ColorsMix]
function ColorsMix( Color1, Color2: TColor ): TColor;
{$IFDEF F_P}
begin
  Result := ((Color2RGB( Color1 ) and $FEFEFE) shr 1) +
            ((Color2RGB( Color2 ) and $FEFEFE) shr 1);
end;
{$ELSE DELPHI}
asm
   PUSH EDX
   CALL Color2Rgb
   XCHG EAX, [ESP]
   CALL Color2Rgb
   POP EDX
   AND EAX, 0FEFEFEh
   AND EDX, 0FEFEFEh
   SHR EAX, 1
   SHR EDX, 1
   ADD EAX, EDX
end;
{$ENDIF F_P/DELPHI}
//[END ColorsMix]

//[FUNCTION Color2RGBQuad]
{$IFDEF ASM_VERSION}
function Color2RGBQuad( Color: TColor ): TRGBQuad;
asm
        CALL     Color2RGB
        // code by bart:
        xchg    ah,al                   // xxRRGGBB
        ror     eax,16                  // BBGGxxRR
        xchg    ah,al                   // BBGGRRxx
        shr     eax,8                   // 00BBGGRR
end;
{$ELSE ASM_VERSION} //Pascal
function Color2RGBQuad( Color: TColor ): TRGBQuad;
var C: Integer;
begin
  C := Color2RGB( Color );
  C := ((C shr 16) and $FF)
    or ((C shl 16) and $FF0000)
    or (C and $FF00);
  Result := TRGBQuad( C );
end;
{$ENDIF ASM_VERSION}
//[END Color2RGBQuad]

//[FUNCTION Color2Color16]
{$IFDEF ASM_VERSION}
function Color2Color16( Color: TColor ): WORD;
asm
  MOV  EDX, EAX
  SHR  EDX, 19
  AND  EDX, $1F
  MOV  ECX, EAX
  SHR  ECX, 5
  AND  ECX, $7E0;
  MOV  AH, AL
  AND  EAX, $F800
  OR   EAX, EDX
  OR   EAX, ECX
end;
{$ELSE ASM_VERSION}
function Color2Color16( Color: TColor ): WORD;
begin
  Color := Color2RGB( Color );
  Result := (Color shr 19) and $1F or
            (Color shr 5) and $7E0 or
            (Color shl 8) and $F800;
end;
{$ENDIF ASM_VERSION}
//[END Color2Color16]

{ TGraphicTool }

{$IFDEF ASM_VERSION}
//[function TGraphicTool.Assign]
function TGraphicTool.Assign(Value: PGraphicTool): PGraphicTool;
const SzfData = sizeof( fData );
asm     //        //
        TEST      EDX, EDX
        JNZ       @@1
        TEST      EAX, EAX
        JZ        @@0
        CALL      TObj.DoDestroy
        XOR       EAX, EAX
@@0:    RET
@@1:    PUSH      EDI
        MOV       EDI, EDX
        TEST      EAX, EAX
        JNZ       @@2
        XCHG      EAX, EDX
        CALL      dword ptr[EAX].TGraphicTool.fNewProc
@@2:    CMP       EAX, EDI
        JE        @@exit
        PUSH      EBX
        XCHG      EBX, EAX

        MOV       ECX, [EBX].TGraphicTool.fHandle
        JECXZ     @@3
        CMP       ECX, [EDI].TGraphicTool.fHandle
        JE        @@exit1
@@3:
        MOV       EAX, EBX
        CALL      TGraphicTool.Changed
        LEA       EDX, [EBX].TGraphicTool.fData
        LEA       EAX, [EDI].TGraphicTool.fData
        MOV       ECX, SzfData
        CALL      System.Move
        MOV       EAX, EBX
        CALL      TGraphicTool.Changed

@@exit1:
        XCHG      EAX, EBX
        POP       EBX
@@exit: POP       EDI
end;
{$ELSE ASM_VERSION}
function TGraphicTool.Assign(Value: PGraphicTool): PGraphicTool;
var _Self: PGraphicTool;
begin
  Result := nil;
  if Value = nil then
  begin
    if Self <> nil then
       DoDestroy;
    Exit;
  end;
  _Self := Self;
  if _Self = nil then
    _Self := Value.fNewProc();
  Result := _Self;
  if _Self = Value then Exit; // to avoid infinite loop when assigning to itself
  if _Self.fHandle <> 0 then
     if Value.fHandle = _Self.fHandle then Exit;
  _Self.Changed; // to destroy handle if allocated and release it from the canvas (if any uses it)
  Assert( Value.fType = _Self.fType, 'Attempt to assign to different GDI tool type' );
  Move( Value.fData, _Self.fData, Sizeof( fData ) );
  _Self.Changed; // to inform owner control, that its tool (font, brush) changed
end;
{$ENDIF ASM_VERSION}

//[procedure TGraphicTool.AssignHandle]
procedure TGraphicTool.AssignHandle(NewHandle: Integer);
begin
  //------------ by Yury Sidorov --------
  //Changed;
  //-------------------------------------//
  if fHandle <> 0 then                   //
    DeleteObject( fHandle );             //
  //-------------------------------------//
  fHandle := NewHandle;
  GetObject( fHandle, Sizeof( TGDIFont ), @ fData.Font );
  Changed;
end;

{$IFDEF ASM_VERSION}
//[procedure TGraphicTool.Changed]
procedure TGraphicTool.Changed;
asm
        XOR      ECX, ECX
        XCHG     ECX, [EAX].fHandle
        JECXZ    @@exit
        PUSH     EAX
        PUSH     ECX

        CALL     @@CallOnChange

        CALL     DeleteObject
        POP      EAX
@@exit:

@@CallOnChange:
        MOV      ECX, [EAX].fOnChange.TMethod.Code
        JECXZ    @@no_onChange
        PUSH     EAX
        XCHG     EDX, EAX
        MOV      EAX, [EDX].fOnChange.TMethod.Data
        CALL     ECX
        POP      EAX
@@no_onChange:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TGraphicTool.Changed;
var H: THandle;
begin
   if fHandle <> 0 then
   begin
     H := fHandle;
     fHandle := 0;
     ////////////////////////////////
     if Assigned( fOnChange ) then
        fOnChange( Self );
     ////////////////////////////////
     DeleteObject( H );
      {$IFDEF DEBUG_GDIOBJECTS}
      case fType of
      gttBrush:  Dec( BrushCount );
      gttFont:   Dec( FontCount );
      gttPen:    Dec( PenCount );
      end;
      {$ENDIF}
   end;
   //////////////////////////////////
   if Assigned( fOnChange ) then
      fOnChange( Self );
   //////////////////////////////////
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[destructor TGraphicTool.Destroy]
destructor TGraphicTool.Destroy;
asm
          PUSH      EAX
          CMP       [EAX].fType, gttFont
          JE        @@0
          MOV       ECX, [EAX].fData.Brush.Bitmap
          JECXZ     @@0
          PUSH      ECX
          CALL      DeleteObject
          POP       EAX
          PUSH      EAX
@@0:
        MOV       ECX, [EAX].fHandle
        JECXZ     @@1
        PUSH      ECX
        CALL      DeleteObject
@@1:
          POP       EAX
          CALL      TObj.Destroy
end;
{$ELSE ASM_VERSION} //Pascal
destructor TGraphicTool.Destroy;
begin
  case fType of
  gttBrush: if fData.Brush.Bitmap <> 0 then
               DeleteObject( fData.Brush.Bitmap );
  gttPen:   if fData.Pen.BrushBitmap <> 0 then
               DeleteObject( fData.Pen.BrushBitmap )
  end;
  if fHandle <> 0 then
  begin
     DeleteObject( fHandle );
     {$IFDEF DEBUG_GDIOBJECTS}
     case fType of
     gttPen:    Dec( PenCount );
     gttBrush:  Dec( BrushCount );
     gttFont:   Dec( FontCount );
     end;
     {$ENDIF}
     //fHandle := 0; Why to do this? It is now destroying!
  end;
  inherited;
end;
{$ENDIF ASM_VERSION}

//[function TGraphicTool.HandleAllocated]
function TGraphicTool.HandleAllocated: Boolean;
begin
  Result := fHandle <> 0;
end;

{$IFDEF ASM_VERSION}
//[function TGraphicTool.ReleaseHandle]
function TGraphicTool.ReleaseHandle: Integer;
asm     //        //
        PUSH      EAX
        CALL      Changed
        POP       EDX
        XOR       EAX, EAX
        XCHG      [EDX].fHandle, EAX
end;
{$ELSE ASM_VERSION PAS_VERSION}
function TGraphicTool.ReleaseHandle: Integer;
begin
  Changed;
  Result := fHandle;
  fHandle := 0;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TGraphicTool.SetInt]
procedure TGraphicTool.SetInt( const Index: Integer; Value: Integer );
asm
        LEA    EDX, [EDX+EAX].fData
        CMP    [EDX], ECX
        JE     @@exit
        MOV    [EDX], ECX
        CALL   Changed
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TGraphicTool.SetInt( const Index: Integer; Value: Integer );
var Where: PInteger;
begin
  Where := Pointer( Integer( @ fData ) + Index );
  if Where^ = Value then Exit;
  Where^ := Value;
  Changed;
end;
{$ENDIF ASM_VERSION}

{$IFDEF F_P}
//[function TGraphicTool.GetInt]
function TGraphicTool.GetInt(const Index: Integer): Integer;
var Where: PInteger;
begin
  Where := Pointer( Integer( @ fData ) + Index );
  Result := Where^;
end;
{$ENDIF}

//[procedure TGraphicTool.SetColor]
procedure TGraphicTool.SetColor( Value: TColor );
begin
  SetInt( go_Color, Value );
  fColorRGB := Color2RGB( Value );
end;

{$IFDEF ASM_VERSION}
//[function TGraphicTool.IsFontTrueType]
function TGraphicTool.IsFontTrueType: Boolean;
asm
        CALL     GetHandle
        TEST     EAX, EAX
        JZ       @@exit

        PUSH     EBX

        PUSH     EAX                  // fHandle

        PUSH     0
        CALL     GetDC

        PUSH     EAX                  // DC
        MOV      EBX, EAX
        CALL     SelectObject
        PUSH     EAX

        XOR      ECX, ECX
        PUSH     ECX
        PUSH     ECX
        PUSH     ECX
        PUSH     ECX
        PUSH     EBX
        CALL     GetFontData

        XCHG     EAX, [ESP]

        PUSH     EAX
        PUSH     EBX
        CALL     SelectObject

        PUSH     EBX
        PUSH     0
        CALL     ReleaseDC

        POP      EAX
        INC      EAX
        SETNZ    AL

        POP      EBX
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
function TGraphicTool.IsFontTrueType: Boolean;
var OldFont: HFont;
    DC: HDC;
begin
  Result := False;
  if GetHandle = 0 then Exit;
  DC := GetDC( 0 );
  OldFont := SelectObject( DC, fHandle );
  if GetFontData( DC, 0, 0, nil, 0 ) <> GDI_ERROR then
     Result := True;
  SelectObject( DC, OldFont );
  ReleaseDC( 0, DC );
end;
{$ENDIF ASM_VERSION}

//[procedure TGraphicTool.SetBrushBitmap]
procedure TGraphicTool.SetBrushBitmap(const Value: HBitmap);
begin
  if fData.Brush.Bitmap = Value then Exit;
  if fData.Brush.Bitmap <> 0 then
  begin
    ///////////
    Changed; // !!!
    ///////////
    DeleteObject( fData.Brush.Bitmap );
  end;
  fData.Brush.Bitmap := Value;
  Changed;
end;

//[procedure TGraphicTool.SetBrushStyle]
procedure TGraphicTool.SetBrushStyle(const Value: TBrushStyle);
begin
  if fData.Brush.Style = Value then Exit;
  fData.Brush.Style := Value;
  Changed;
end;

//[procedure TGraphicTool.SetFontCharset]
procedure TGraphicTool.SetFontCharset(const Value: TFontCharset);
begin
  if fData.Font.Charset = Value then Exit;
  fData.Font.Charset := Value;
  Changed;
end;

//[procedure TGraphicTool.SetFontQuality]
procedure TGraphicTool.SetFontQuality(const Value: TFontQuality);
begin
  if fData.Font.Quality = Value then Exit;
  fData.Font.Quality := Value;
  Changed;
end;

//[function TGraphicTool.GetFontName]
function TGraphicTool.GetFontName: String;
begin
  Result := fData.Font.Name;
end;

//[procedure TGraphicTool.SetFontName]
procedure TGraphicTool.SetFontName(const Value: String);
begin
  if fData.Font.Name = Value then Exit;
  FillChar( fData.Font.Name[ 0 ], LF_FACESIZE, 0 );
  StrLCopy( fData.Font.Name, PChar( Value ), LF_FACESIZE );
  Changed;
end;

{$IFDEF ASM_VERSION}
//[procedure TextAreaEx]
procedure TextAreaEx( Sender: PCanvas; var Sz : TSize; var Pt : TPoint );
asm
        PUSH     EBX
        PUSH     ESI
        PUSH     EDI
        PUSH     EBP
        MOV      EBP, ESP
        PUSH     EDX // [EBP-4] = @Sz
        PUSH     ECX // [EBP-8] = @Pt
        MOV      EBX, EAX
        CALL     TCanvas.GetFont
        MOV      ESI, [EAX].TGraphicTool.fData.Font.Orientation
        CALL     TGraphicTool.IsFontTrueType
        TEST     AL, AL
        JZ       @@exit

        MOV      EDI, [EBP-8]
        XOR      EAX, EAX
        STOSD
        STOSD
        TEST     ESI, ESI
        JZ       @@exit

        PUSH     EAX // Pts[1].x
        PUSH     EAX // Pts[1].y

        PUSH     ESI
        FILD     dword ptr [ESP]
        POP      EDX

        FILD     word ptr [@@1800]
        FDIV
        //FWAIT
        FLDPI
        FMUL
        //FWAIT

        FLD      ST(0)
        FSINCOS
        FWAIT

        MOV      ESI, [EBP-4]
        LODSD         // Sz.cx
        PUSH     EAX
        FILD     dword ptr [ESP]
        FMUL
        FISTP    dword ptr [ESP] // Pts[2].x
        FWAIT
        NEG      EAX
        PUSH     EAX
        FILD     dword ptr [ESP]
        FMUL
        FISTP    dword ptr [ESP] // Pts[2].y
        FWAIT

        FLDPI
        FLD1
        FLD1
        FADD
        FDIV
        FADD
        FSINCOS
        FWAIT

        LODSD
        NEG      EAX
        PUSH     EAX
        FILD     dword ptr [ESP]
        FMUL
        FISTP    dword ptr [ESP] // Pts[4].x
        FWAIT
        NEG      EAX
        PUSH     EAX
        FILD     dword ptr [ESP]
        FMUL
        FISTP    dword ptr [ESP] // Pts[4].y
        FWAIT

        POP      ECX
        POP      EDX
        PUSH     EDX
        PUSH     ECX
        ADD      EDX, [ESP+12]
        ADD      ECX, [ESP+8]
        PUSH     EDX
        PUSH     ECX

        MOV      ESI, ESP
        XOR      EDX, EDX // MinX
        XOR      EDI, EDI // MinY
        XOR      ECX, ECX
        MOV      CL, 3

@@loo1: LODSD
        CMP      EAX, EDI
        JGE      @@1
        XCHG     EDI, EAX
@@1:    LODSD
        CMP      EAX, EDX
        JGE      @@2
        XCHG     EDX, EAX
@@2:    LOOP     @@loo1

        MOV      ESI, [EBP-4]
        MOV      [ESI], ECX
        MOV      [ESI+4], ECX
        MOV      CL, 4
@@loo2:
        POP      EBX
        SUB      EBX, EDI
        CMP      EBX, [ESI+4]
        JLE      @@3
        MOV      [ESI+4], EBX
@@3:
        POP      EAX
        SUB      EAX, EDX
        CMP      EAX, [ESI]
        JLE      @@4
        MOV      [ESI], EAX
@@4:
        LOOP     @@loo2

        MOV      EDI, [EBP-8]
        STOSD
        XCHG     EAX, EBX
        STOSD
        JMP      @@exit

@@1800: DW  1800

@@exit:
        MOV      ESP, EBP
        POP      EBP
        POP      EDI
        POP      ESI
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TextAreaEx( Sender: PCanvas; var Sz : TSize; var Pt : TPoint );
var Orient : Integer;
    Pts : array[ 1..4 ] of TPoint;
    MinX, MinY, I : Integer;
    A : Double;
begin
   if not Sender.Font.IsFontTrueType then Exit;
   Orient := Sender.Font.FontOrientation;
   Pt.x := 0; Pt.y := 0;
   if Orient = 0 then
      Exit;
   A := Orient / 1800.0 * PI;
   Pts[ 1 ] := Pt;
   Pts[ 2 ].x := Round( Sz.cx * cos( A ) );
   Pts[ 2 ].y := - Round( Sz.cx * sin( A ) );
   Pts[ 4 ].x := - Round( Sz.cy * cos( A + PI / 2 ) );
   Pts[ 4 ].y := Round( Sz.cy * sin( A + PI / 2 ) );
   Pts[ 3 ].x := Pts[ 2 ].x + Pts[ 4 ].x;
   Pts[ 3 ].y := Pts[ 2 ].y + Pts[ 4 ].y;
   MinX := 0; MinY := 0;
   for I := 2 to 4 do
   begin
      if Pts[ I ].x < MinX then
         MinX := Pts[ I ].x;
      if Pts[ I ].y < MinY then
         MinY := Pts[ I ].y;
   end;
   Sz.cx := 0;
   Sz.cy := 0;
   for I := 1 to 4 do
   begin
      Pts[ I ].x := Pts[ I ].x - MinX;
      Pts[ I ].y := Pts[ I ].y - MinY;
      if Pts[ I ].x > Sz.cx then
         Sz.cx := Pts[ I ].x;
      if Pts[ I ].y > Sz.cy then
         Sz.cy := Pts[ I ].y;
   end;
   Pt := Pts[ 1 ];
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TGraphicTool.SetFontOrientation]
procedure TGraphicTool.SetFontOrientation(Value: Integer);
asm
        PUSH     EAX
@@1:    MOV      EAX, EDX
        MOV      ECX, 3600
        CDQ
        IDIV     ECX     // EDX = Value mod 3600
        POP      EAX

        MOV      byte ptr [GlobalGraphics_UseFontOrient], 1
        MOV      [GlobalCanvas_OnTextArea], offset[TextAreaEx]

        MOV      [EAX].fData.Font.Escapement, EDX
        MOV      ECX, EDX
        MOV      DX, go_FontOrientation
        CALL     SetInt
end;
{$ELSE ASM_VERSION} //Pascal
procedure TGraphicTool.SetFontOrientation(Value: Integer);
begin
  GlobalGraphics_UseFontOrient := True;
  GlobalCanvas_OnTextArea := TextAreaEx;
  Value := Value mod 3600; // -3599..+3599
  SetInt( go_FontOrientation, Value );
  SetInt( go_FontEscapement, Value );
end;
{$ENDIF ASM_VERSION}

//[procedure TGraphicTool.SetFontPitch]
procedure TGraphicTool.SetFontPitch(const Value: TFontPitch);
begin
  if fData.Font.Pitch = Value then Exit;
  fData.Font.Pitch := Value;
  Changed;
end;

{$IFDEF ASM_VERSION}
//[function TGraphicTool.GetFontStyle]
function TGraphicTool.GetFontStyle: TFontStyle;
asm
       MOV   EDX, dword ptr [EAX].fData.Font.Italic
       AND   EDX, $010101
       MOV   EAX, [EAX].fData.Font.Weight
       CMP   EAX, 700
       SETGE AL       //AL:1 = fsBold
       ADD   EDX, EDX
       OR    EAX, EDX //AL:2 = fsItalic
       SHR   EDX, 7
       OR    EAX, EDX //AL:3 = fsUnderline
       SHR   EDX, 7
       OR    EAX, EDX //AL:4 = fsStrikeOut
end;
{$ELSE ASM_VERSION} //Pascal
function TGraphicTool.GetFontStyle: TFontStyle;
type PFontStyle = ^TFontStyle;
begin
  Result := [ ];
  if fData.Font.Weight >= 700 then Result := [ fsBold ];
  if fData.Font.Italic        then Result := Result + [ fsItalic ];
  if fData.Font.Underline     then Result := Result + [ fsUnderline ];
  if fData.Font.StrikeOut     then Result := Result + [ fsStrikeOut ];
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TGraphicTool.SetFontStyle]
procedure TGraphicTool.SetFontStyle(const Value: TFontStyle);
asm
        PUSH     EDI
        MOV      EDI, EAX
        PUSH     EDX
        CALL     GetFontStyle
        POP      EDX
        CMP      AL, DL
        JE       @@exit
        PUSH     EDI

        LEA      EDI, [EDI].fData.Font.Weight
        MOV      ECX, [EDI]
        SHR      EDX, 1
        JNC      @@1
        CMP      ECX, 700
        JGE      @@2
        MOV      ECX, 700
        JMP      @@2
@@1:    CMP      ECX, 700
        JL       @@2
        XOR      ECX, ECX
@@2:    XCHG     EAX, ECX
        STOSD    // change Weight
        SHR      EDX, 1
        SETC     AL
        STOSB    // change Italic
        SHR      EDX, 1
        SETC     AL
        STOSB    // change Underline
        SHR      EDX, 1
        SETC     AL
        STOSB    // change StrikeOut
        POP      EAX
        CALL     Changed
@@exit: POP      EDI
end;
{$ELSE ASM_VERSION} //Pascal
procedure TGraphicTool.SetFontStyle(const Value: TFontStyle);
begin
  if FontStyle = Value then Exit;
  if fsBold in Value then
  begin
    if fData.Font.Weight < 700 then
      fData.Font.Weight := 700;
  end
    else
  begin
    if fData.Font.Weight >= 700 then
      fData.Font.Weight := 0;
  end;
  fData.Font.Italic := fsItalic in Value;
  fData.Font.Underline := fsUnderline in Value;
  fData.Font.StrikeOut := fsStrikeOut in Value;
  Changed;
end;
{$ENDIF ASM_VERSION}

//[procedure TGraphicTool.SetPenMode]
procedure TGraphicTool.SetPenMode(const Value: TPenMode);
begin
  if fData.Pen.Mode = Value then Exit;
  fData.Pen.Mode := Value;
  Changed;
end;

//[procedure TGraphicTool.SetPenStyle]
procedure TGraphicTool.SetPenStyle(const Value: TPenStyle);
begin
  if fData.Pen.Style = Value then Exit;
  fData.Pen.Style := Value;
  Changed;
end;

{$IFDEF ASM_VERSION}
//[function TGraphicTool.GetHandle]
function TGraphicTool.GetHandle: THandle;
const DataSz = sizeof( TGDIToolData );
asm
        PUSH      EBX
@@start:
        XCHG      EBX, EAX
        MOV       ECX, [EBX].fHandle
        JECXZ     @@1

        MOV       EAX, [EBX].fData.Color
        CALL      Color2RGB
        CMP       EAX, [EBX].fColorRGB
        JE        @@1

        MOV       EAX, EBX
        CALL      ReleaseHandle
        PUSH      EAX
        CALL      DeleteObject

@@1:    MOV       ECX, [EBX].fHandle
        INC       ECX
        LOOP      @@exit

        MOV       ECX, [EBX].fParentGDITool
        JECXZ     @@2
        LEA       EDX, [ECX].fData
        LEA       EAX, [EBX].fData
        MOV       ECX, DataSz
        CALL      CompareMem
        TEST      AL, AL
        MOV       EAX, [EBX].fParentGDITool
        JNZ       @@start

@@2:    MOV       ECX, [EBX].fHandle
        INC       ECX
        LOOP      @@exit

        MOV       EAX, [EBX].fData.Color
        CALL      Color2RGB
        MOV       [EBX].fColorRGB, EAX
        XCHG      EAX, EBX
        CALL      dword ptr [EAX].fMakeHandleProc
        XCHG      ECX, EAX

@@exit: XCHG      EAX, ECX
        POP       EBX
end;
{$ELSE ASM_VERSION} //Pascal
function TGraphicTool.GetHandle: THandle;
begin
  Result := fHandle;
  if Result <> 0 then
  begin
    if Color2RGB( fData.Color ) <> fColorRGB then
    begin
      DeleteObject( ReleaseHandle );
      Result := 0;
    end;
  end;
  if Result = 0 then
  begin
    if Assigned( fParentGDITool ) then
    begin
      if CompareMem( @ fData, @ fParentGDITool.fData, Sizeof( fData ) ) then
      begin
        Result := fParentGDITool.Handle;
        Exit;
      end;
    end;

    if fHandle = 0 then
    begin
      fColorRGB := Color2RGB( fData.Color );
      fMakeHandleProc( Self );
    end;
    Result := fHandle;
  end;
end;
{$ENDIF ASM_VERSION}

//[FUNCTION MakeBrushHandle]
{$IFDEF ASM_VERSION}
function MakeBrushHandle( Self_: PGraphicTool ): THandle;
asm
        PUSH     EBX
        XCHG     EBX, EAX
        MOV      EAX, [EBX].TGraphicTool.fHandle
        TEST     EAX, EAX
        JNZ      @@exit

        MOV      EAX, [EBX].TGraphicTool.fData.Color
        CALL     Color2RGB   // EAX = ColorRef

        XOR      EDX, EDX

        MOV      ECX, [EBX].TGraphicTool.fData.Brush.Bitmap
        PUSH     ECX
        JECXZ    @@1

        MOV      DL, BS_PATTERN
        JMP      @@2

@@1:
        MOV      CL, [EBX].TGraphicTool.fData.Brush.Style
        MOV      DL, CL
        SUB      CL, 2
        JL       @@2

        XCHG     ECX, [ESP]

@@2:    PUSH     EAX
        PUSH     EDX

        PUSH     ESP
        CALL     CreateBrushIndirect
        MOV      [EBX].TGraphicTool.fHandle, EAX

        ADD      ESP, 12

@@exit:
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function MakeBrushHandle( Self_: PGraphicTool ): THandle;
var
  LogBrush: TLogBrush;
begin
  if Self_.fHandle = 0 then
  begin
   LogBrush.lbColor := Color2RGB( Self_.fData.Color );
   if Self_.fData.Brush.Bitmap <> 0 then
   begin
     LogBrush.lbStyle := BS_PATTERN;
     LogBrush.lbHatch := Self_.fData.Brush.Bitmap;
   end
      else
   begin
     LogBrush.lbHatch := 0;
     case Self_.fData.Brush.Style of
       bsSolid: LogBrush.lbStyle := BS_SOLID;
       bsClear: LogBrush.lbStyle := BS_NULL;
     else
       LogBrush.lbStyle := BS_HATCHED;
       LogBrush.lbHatch := Ord( Self_.fData.Brush.Style ) - Ord( bsHorizontal );
       LogBrush.lbColor := Color2RGB( Self_.fData.Brush.LineColor );
     end;
   end;
   Self_.fHandle := CreateBrushIndirect(LogBrush);
   {$IFDEF DEBUG_GDIOBJECTS}
   if Self_.fHandle <> 0 then
     Inc( BrushCount )
   else
     ShowMessage( 'Could not create brush, error ' + Int2Str( GetLastError ) +
                  ': ' + SysErrorMessage( GetLastError ) );
   {$ENDIF}
  end;
  //GlobalGraphics_OnObjectCreated( Self );
  Result := Self_.fHandle;
end;
{$ENDIF ASM_VERSION}
//[END MakeBrushHandle]

//[FUNCTION MakeFontHandle]
{$IFDEF ASM_VERSION}
function MakeFontHandle( Self_: PGraphicTool ): THandle;
asm
         XCHG   EDX, EAX
         MOV    EAX, [EDX].TGraphicTool.fHandle
         TEST   EAX, EAX
         JNZ    @@exit
         PUSH   EDX
         LEA    ECX, [EDX].TGraphicTool.fData.Font
         PUSH   ECX
         CALL   CreateFontIndirect
         POP    EDX
         MOV    [EDX].TGraphicTool.fHandle, EAX
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
function MakeFontHandle( Self_: PGraphicTool ): THandle;
//var LogFont: TLogFont;
begin
  with Self_ do
  begin
    if fHandle = 0 then
    begin
      fHandle := CreateFontIndirect( PLogFont( @ fData.Font )^ );
      {$IFDEF DEBUG_GDIOBJECTS}
      Inc( FontCount );
      {$ENDIF}
    end;
    Result := fHandle;
  end;
end;
{$ENDIF ASM_VERSION}
//[END MakeFontHandle]

//[FUNCTION MakePenHandle]
{$IFDEF ASM_VERSION}
function MakePenHandle( Self_: PGraphicTool ): THandle;
asm
        PUSH     EBX
        MOV      EBX, EAX

        MOV      EAX, [EBX].TGraphicTool.fHandle
        TEST     EAX, EAX
        JNZ      @@exit

        MOV      EAX, [EBX].TGraphicTool.fData.Color
        CALL     Color2RGB
        PUSH     EAX
        PUSH     EAX
        PUSH     [EBX].TGraphicTool.fData.Pen.Width
        MOVZX    EAX, [EBX].TGraphicTool.fData.Pen.Style
        PUSH     EAX
        PUSH     ESP
        CALL     CreatePenIndirect
        MOV      [EBX].TGraphicTool.fHandle, EAX
        ADD      ESP, 16
@@exit:
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function MakePenHandle( Self_: PGraphicTool ): THandle;
var
  LogPen: TLogPen;
begin
  with Self_ do
  begin
    //GlobalGraphics_OnObjectCreating( Self );
    if fHandle = 0 then
    with LogPen do
    begin
      lopnStyle := Byte( fData.Pen.Style );
      lopnWidth.X := fData.Pen.Width;
      lopnColor := Color2RGB( fData.Color );
      fHandle := CreatePenIndirect( LogPen );
      {$IFDEF DEBUG_GDIOBJECTS}
      Inc( PenCount );
      {$ENDIF}
    end;
    //GlobalGraphics_OnObjectCreated( Self );
    Result := fHandle;
  end;
end;
{$ENDIF ASM_VERSION}
//[END MakePenHandle]

//+
//[procedure TGraphicTool.SetGeometricPen]
procedure TGraphicTool.SetGeometricPen(const Value: Boolean);
begin
  if fData.Pen.Geometric = Value then Exit;
  fData.Pen.Geometric := Value;
  fMakeHandleProc := MakeGeometricPenHandle;
  Changed;
end;

//[procedure TGraphicTool.SetPenEndCap]
procedure TGraphicTool.SetPenEndCap(const Value: TPenEndCap);
begin
  if fData.Pen.EndCap = Value then Exit;
  fData.Pen.EndCap := Value;
  Changed;
end;

//[procedure TGraphicTool.SetPenJoin]
procedure TGraphicTool.SetPenJoin(const Value: TPenJoin);
begin
  if fData.Pen.Join = Value then Exit;
  fData.Pen.Join := Value;
  Changed;
end;

//[FUNCTION MakeGeometricPenHandle]
{$IFDEF ASM_VERSION}
function MakeGeometricPenHandle( Self_: PGraphicTool ): THandle;
asm
        MOV      ECX, [EAX].TGraphicTool.fHandle
        INC      ECX
        LOOP     @@exit

        PUSH     EBX
        XCHG     EBX, EAX
        MOV      EAX, [EBX].TGraphicTool.fData.Color
        CALL     Color2RGB // EAX = Color2RGB( fColor )
        CDQ                // EDX = lbHatch (0)
        MOV      ECX, [EBX].TGraphicTool.fData.Pen.BrushBitmap
        JECXZ    @@no_brush_bitmap

        XCHG     EDX, ECX // lbHatch = fPenBrushBitmap
        MOV      CL, BS_PATTERN // = 3
        JMP      @@create_pen

@@no_brush_bitmap:
        MOVZX    ECX, [EBX].TGraphicTool.fData.Pen.BrushStyle
        CMP      CL, 1
        JLE      @@create_pen
        MOV      EDX, ECX
        MOV      CL, 2
        SUB      EDX, ECX

@@create_pen:
        PUSH     EDX
        PUSH     EAX
        PUSH     ECX
        MOV      ECX, ESP

        CDQ
        PUSH     EDX
        PUSH     EDX
        PUSH     ECX
        PUSH     [EBX].TGraphicTool.fData.Pen.Width
        MOVZX    ECX, [EBX].TGraphicTool.fData.Pen.Join
        SHL      ECX, 12
        MOVZX    EDX, [EBX].TGraphicTool.fData.Pen.EndCap
        SHL      EDX, 8
        OR       EDX, ECX
        OR       DL, byte ptr [EBX].TGraphicTool.fData.Pen.Style
        OR       EDX, PS_GEOMETRIC
        PUSH     EDX
        CALL     ExtCreatePen

        POP      ECX
        POP      ECX
        POP      ECX

        MOV      [EBX].TGraphicTool.fHandle, EAX
        POP      EBX
        RET
@@exit:
        XCHG     EAX, ECX
end;
{$ELSE ASM_VERSION} //Pascal
function MakeGeometricPenHandle( Self_: PGraphicTool ): THandle;
const
  PenStyles: array[ TPenStyle ] of Word =
    (PS_SOLID, PS_DASH, PS_DOT, PS_DASHDOT, PS_DASHDOTDOT, PS_NULL,
     PS_INSIDEFRAME);
  PenEndCapStyles: array[ TPenEndCap ] of Word =
    (PS_ENDCAP_ROUND, PS_ENDCAP_SQUARE, PS_ENDCAP_FLAT);
  PenJoinStyles: array[ TPenJoin ] of Word =
    (PS_JOIN_ROUND, PS_JOIN_BEVEL, PS_JOIN_MITER );
var
  LogBrush: TLogBrush;
begin
  if Self_.fHandle = 0 then
  with Self_, LogBrush do
  begin
      lbColor := Color2RGB( fData.Color );
      lbHatch := 0;
      if fData.Pen.BrushBitmap <> 0 then
      begin
        lbStyle := BS_PATTERN;
        lbHatch := fData.Pen.BrushBitmap;
      end
         else
      case fData.Pen.BrushStyle of
      bsSolid: lbStyle := BS_SOLID;
      bsClear: lbStyle := BS_NULL;
      else  begin
               lbStyle := BS_HATCHED;
               case fData.Pen.BrushStyle of
               bsHorizontal: lbHatch := HS_HORIZONTAL;
               bsVertical:   lbHatch := HS_VERTICAL;
               bsFDiagonal:  lbHatch := HS_FDIAGONAL;
               bsBDiagonal:  lbHatch := HS_BDIAGONAL;
               bsCross:      lbHatch := HS_CROSS;
               bsDiagCross:  lbHatch := HS_DIAGCROSS;
               end;
            end;
      end;
  end;
  Self_.fHandle := ExtCreatePen( PS_GEOMETRIC or Byte( Self_.fData.Pen.Style ) or
                           PenEndCapStyles[ Self_.fData.Pen.EndCap ] or
                           PenJoinStyles[ Self_.fData.Pen.Join ],
             Self_.fData.Pen.Width, LogBrush, 0, nil );
  {Assert( Self_.fHandle <> 0, 'Error ' + Int2Str( GetLastError ) +
                              ': ' + SysErrorMessage( GetLastError ) );}
  {$IFDEF DEBUG_GDIOBJECTS}
  Inc( PenCount );
  {$ENDIF}
  Result := Self_.fHandle;
end;
{$ENDIF ASM_VERSION}
//[END MakeGeometricPenHandle]

//[procedure TGraphicTool.SetFontWeight]
procedure TGraphicTool.SetFontWeight(const Value: Integer);
begin
  if fData.Font.Weight = Value then Exit;
  fData.Font.Weight := Value;
  Changed;
end;

//[procedure TGraphicTool.SetLogFontStruct]
procedure TGraphicTool.SetLogFontStruct(const Value: TLogFont);
begin
  if  CompareMem(@fData.Font, @Value, SizeOf(TLogFont)) then Exit;
  Move(Value, fData.Font, SizeOF(TLogFont));
  Changed;
end;

//[function TGraphicTool.GetLogFontStruct]
function TGraphicTool.GetLogFontStruct: TLogFont;
begin
  Move(fData.Font, Result, SizeOf(TLogFont));
end;












{ TCanvas }

type
  TStock = Packed Record
    StockPen: HPEN;
    StockBrush: HBRUSH;
    StockFont: HFONT;
  end;

var
  Stock: TStock;

//[destructor TCanvas.Destroy]
destructor TCanvas.Destroy;
begin
  Handle := 0;
  fPen.Free;
  fBrush.Free;
  fFont.Free;
  //if Assigned( GlobalCanvas_OnDestroyCanvas ) then
  //   GlobalCanvas_OnDestroyCanvas( Self );
  inherited;
end;

{$IFDEF ASM_VERSION}
//[function TCanvas.Assign]
function TCanvas.Assign(SrcCanvas: PCanvas): Boolean;
asm
        PUSH     EBX
        PUSH     ESI
        XCHG     EBX, EAX
        MOV      ESI, EDX

        MOV      EAX, [EBX].fFont
        MOV      EDX, [ESI].fFont
        CALL     TGraphicTool.Assign
        MOV      [EBX].fFont, EAX

        MOV      EAX, [EBX].fBrush
        MOV      EDX, [ESI].fBrush
        CALL     TGraphicTool.Assign
        MOV      [EBX].fBrush, EAX

        MOV      EAX, [EBX].fPen
        MOV      EDX, [ESI].fPen
        CALL     TGraphicTool.Assign
        MOV      [EBX].fPen, EAX

        CALL     AssignChangeEvents

        MOV      ECX, [EBX].fFont
        OR       ECX, [EBX].fBrush
        OR       ECX, [EBX].fPen
        SETNZ    AL

        MOV      EDX, [ESI].fPenPos.x
        MOV      ECX, [ESI].fPenPos.y
        CMP      EDX, [EBX].fPenPos.x
        JNE      @@chg_penpos
        CMP      ECX, [EBX].fPenPos.y
        JE       @@1
@@chg_penpos:
        MOV      AL, 1
        MOV      [EBX].fPenPos.x, EDX
        MOV      [EBX].fPenPos.y, ECX
@@1:
        MOV       EDX, [ESI].fCopyMode
        CMP       EDX, [EBX].fCopyMode
        JE        @@2
        MOV       [EBX].fCopyMode, EDX
        MOV       AL, 1
@@2:
        POP       ESI
        POP       EBX
end;
{$ELSE ASM_VERSION} //Pascal
function TCanvas.Assign(SrcCanvas: PCanvas): Boolean;
begin
  fFont := fFont.Assign( SrcCanvas.fFont );
  fBrush := fBrush.Assign( SrcCanvas.fBrush );
  fPen := fPen.Assign( SrcCanvas.fPen );
  AssignChangeEvents;
  Result := (fFont <> nil) or (fBrush <> nil) or (fPen <> nil);
  if (SrcCanvas.PenPos.x <> PenPos.x) or (SrcCanvas.PenPos.y <> PenPos.y) then
  begin
     Result := True;
     PenPos := SrcCanvas.PenPos;
  end;
  if SrcCanvas.ModeCopy <> ModeCopy then
  begin
     Result := True;
     ModeCopy := SrcCanvas.ModeCopy;
  end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TCanvas.CreateBrush]
procedure TCanvas.CreateBrush;
asm
        PUSH     EBX
        MOV      EBX, EAX

        MOV      ECX, [EAX].fBrush
        JECXZ    @@chk_owner

        MOV      EAX, ECX
        CALL     TGraphicTool.GetHandle
        PUSH     EAX

        MOV      EAX, EBX
        CALL     AssignChangeEvents

        MOV      EAX, EBX
        CALL     TCanvas.GetHandle
        PUSH     EAX

        CALL     SelectObject

        MOV      EDX, [EBX].TCanvas.fBrush
        CMP      [EDX].TGraphicTool.fData.Brush.Style, bsSolid

        MOV      EAX, [EDX].TGraphicTool.fData.Color
@@0:
        MOV      EBX, [EBX].TCanvas.fHandle
        MOV      ECX, offset[Color2RGB]
        JNZ      @@1

        PUSH     OPAQUE
        PUSH     EBX

        CALL     ECX //Color2RGB
        PUSH     EAX
        PUSH     EBX
        JMP      @@2
@@1:
        PUSH     TRANSPARENT
        PUSH     EBX

        CALL     ECX //Color2RGB
        NOT      EAX
        PUSH     EAX
        PUSH     EBX
@@2:
        CALL     SetBkColor
        CALL     SetBkMode
@@exit:
        POP      EBX
        RET

@@chk_owner:
        MOV      ECX, [EBX].fOwnerControl
        JECXZ    @@exit

        MOV      EAX, [ECX].TControl.fColor
        XOR      ECX, ECX
        JMP      @@0
end;
{$ELSE ASM_VERSION} //Pascal
procedure TCanvas.CreateBrush;
begin
  //UnrealizeObject( Brush.Handle );
  // if GdiObject parameter of UnrealizeObject is brush handle,
  // this call does nothing (from Win32.hlp)

  if assigned( fBrush ) then
  begin
    SelectObject( GetHandle, fBrush.Handle );
    //fBrush.fOnChange := ObjectChanged;
    AssignChangeEvents;
    if fBrush.fData.Brush.Style = bsSolid then
    begin
      SetBkColor( fHandle, Color2RGB( fBrush.fData.Color ) );
      SetBkMode( fHandle, OPAQUE );
    end
       else
    begin
      { Win95 doesn't draw brush hatches if bkcolor = brush color }
      { Since bkmode is transparent, nothing should use bkcolor anyway }
      SetBkColor( fHandle, not Color2RGB( fBrush.fData.Color ) );
      SetBkMode( fHandle, TRANSPARENT );
    end;
  end
     else
  if Assigned( fOwnerControl ) then
  begin
    SetBkColor( GetHandle, Color2RGB( PControl( fOwnerControl ).fColor ) );
    SetBkMode( fHandle, OPAQUE );
  end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TCanvas.CreateFont]
procedure TCanvas.CreateFont;
asm
        PUSH     EBX
        MOV      EBX, EAX

        MOV      ECX, [EAX].TCanvas.fFont
        JECXZ    @@chk_owner

        MOV      EAX, [ECX].TGraphicTool.fData.Color
        PUSH     ECX
        CALL     Color2RGB
        XCHG     EAX, [ESP]

        CALL     TGraphicTool.GetHandle
        PUSH     EAX

        MOV      EAX, EBX
        CALL     AssignChangeEvents;

        MOV      EAX, EBX
        CALL     TCanvas.GetHandle
        PUSH     EAX
        MOV      EBX, EAX

        CALL     SelectObject

@@set_txcolor:
        PUSH     EBX
        CALL     SetTextColor

@@exit:
        POP      EBX
        RET

@@chk_owner:
        MOV      ECX, [EBX].fOwnerControl
        JECXZ    @@exit

        MOV      EBX, [EBX].fHandle
        MOV      EAX, [ECX].TControl.fTextColor
        CALL     Color2RGB
        PUSH     EAX
        JMP      @@set_txcolor
end;
{$ELSE ASM_VERSION} //Pascal
procedure TCanvas.CreateFont;
begin
  if assigned( fFont ) then
  begin
    SelectObject( GetHandle, fFont.Handle );
    SetTextColor( fHandle, Color2RGB( fFont.fData.Color ) );
    //fFont.fOnChange := ObjectChanged;
    AssignChangeEvents;
  end
     else
  if Assigned( fOwnerControl ) then
  begin
    SetTextColor( fHandle, Color2RGB( PControl( fOwnerControl ).fTextColor ) );
  end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TCanvas.CreatePen]
procedure TCanvas.CreatePen;
asm
        MOV      ECX, [EAX].TCanvas.fPen
        JECXZ    @@exit

        PUSH     EBX
        MOV      EBX, EAX

        MOV      DL, [ECX].TGraphicTool.fData.Pen.Mode
        MOVZX    EDX, DL
        INC      EDX
        PUSH     EDX

        MOV      EAX, ECX
        CALL     TGraphicTool.GetHandle
        PUSH     EAX

        MOV      EAX, EBX
        CALL     AssignChangeEvents

        MOV      EAX, EBX
        CALL     TCanvas.GetHandle
        PUSH     EAX
        MOV      EBX, EAX

        CALL     SelectObject
        PUSH     EBX
        CALL     SetROP2

        POP      EBX
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TCanvas.CreatePen;
begin
  if assigned( fPen ) then
  begin
    SelectObject( GetHandle, fPen.Handle );
    SetROP2( fHandle, Ord( fPen.fData.Pen.Mode ) + 1 );
    //fPen.fOnChange := ObjectChanged;
    AssignChangeEvents;
  end;
end;
{$ENDIF ASM_VERSION}

//[function TCanvas.GetPixels]
function TCanvas.GetPixels(X, Y: Integer): TColor;
begin
  RequiredState( HandleValid );
  Result := Windows.GetPixel(FHandle, X, Y);
end;

//[procedure TCanvas.SetPixels]
procedure TCanvas.SetPixels(X, Y: Integer; const Value: TColor);
begin
  Changing;
  RequiredState( HandleValid );
  Windows.SetPixel(FHandle, X, Y, Color2RGB( Value ));
end;

{$IFDEF ASM_VERSION}
//[procedure TCanvas.DeselectHandles]
procedure TCanvas.DeselectHandles;
asm
        PUSH     EBX
        PUSH     ESI
        PUSH     EDI
        LEA      EBX, [EAX].TCanvas.fState
        //CALL     TCanvas.GetHandle
        MOV      EAX, [EAX].TCanvas.fHandle
        TEST     EAX, EAX
        JZ       @@exit

        MOVZX    EDX, byte ptr[EBX]
        AND      DL, PenValid or BrushValid or FontValid
        JZ       @@exit

        PUSH     EAX
        LEA      EDI, [Stock]

        MOV      ECX, [EDI]
        INC      ECX
        LOOP     @@1

        MOV      ESI, offset[ GetStockObject ]

        PUSH     BLACK_PEN
        CALL     ESI
        STOSD

        PUSH     HOLLOW_BRUSH
        CALL     ESI
        STOSD

        PUSH     SYSTEM_FONT
        CALL     ESI
        STOSD

@@1:
        LEA      ESI, [Stock]
        POP      EDX

        LODSD
        PUSH     EAX
        PUSH     EDX

        LODSD
        PUSH     EAX
        PUSH     EDX

        LODSD
        PUSH     EAX
        PUSH     EDX

        MOV      ESI, offset[ SelectObject ]
        CALL     ESI
        CALL     ESI
        CALL     ESI

        AND      byte ptr [EBX], not( PenValid or BrushValid or FontValid )
@@exit:
        POP      EDI
        POP      ESI
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TCanvas.DeselectHandles;
begin
   //if (GetHandle <> 0) and
   if (fHandle <> 0) and
      LongBool(fState and (PenValid or BrushValid or FontValid)) then
   with Stock do
   begin
     if StockPen = 0 then
     begin
       StockPen := GetStockObject(BLACK_PEN);
       StockBrush := GetStockObject(HOLLOW_BRUSH);
       StockFont := GetStockObject(SYSTEM_FONT);
     end;
     SelectObject( fHandle, StockPen );
     SelectObject( fHandle, StockBrush );
     SelectObject( fHandle, StockFont );
     fState := fState and not( PenValid or BrushValid or FontValid );
   end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TCanvas.RequiredState]
function TCanvas.RequiredState(ReqState: DWORD): Integer; stdcall;
asm
        PUSH     EBX
        PUSH     ESI
        MOV      EBX, ReqState
        MOV      ESI, [EBP+8] //Self
        MOV      EAX, ESI
        TEST     BL, ChangingCanvas
        JZ       @@1
        CALL     Changing
@@1:    AND      BL, 0Fh

        TEST     BL, HandleValid
        JZ       @@2
        CALL     TCanvas.GetHandle
        TEST     EAX, EAX
        JZ       @@ret_0
@@2:
        MOV      AL, [ESI].TCanvas.fState
        NOT      EAX
        AND      BL, AL
        JZ       @@ret_handle

        TEST     BL, FontValid
        JZ       @@3
        MOV      EAX, ESI
        CALL     CreateFont
@@3:    TEST     BL, PenValid
        JZ       @@5
        MOV      EAX, ESI
        CALL     CreatePen
        MOV      ECX, [ESI].TCanvas.fPen
        JCXZ     @@5
        MOV      AL, [ECX].TGraphicTool.fData.Pen.Style
        DEC      AL
        {$IFDEF PARANOIA}
        DB $2C, 3
        {$ELSE}
        SUB      AL, 3
        {$ENDIF}
        JB       @@6
@@5:    TEST     BL, BrushValid
        JZ       @@7
@@6:    MOV      EAX, ESI
        CALL     CreateBrush
@@7:    OR       [ESI].TCanvas.fState, BL
@@ret_handle:
        MOV      EAX, [ESI].TCanvas.fHandle
@@ret_0:
        POP      ESI
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function TCanvas.RequiredState(ReqState: DWORD): Integer; stdcall;
var
  NeededState: Byte;
begin
  if Boolean(ReqState and ChangingCanvas) then
     Changing;
  ReqState := ReqState and 15;
  NeededState := Byte( ReqState ) and not fState;
  Result := 0;
    if Boolean(ReqState and HandleValid) then
    begin
      if GetHandle = 0 then Exit;
      // Important!
    end;
  if NeededState <> 0 then
  begin
    if Boolean( NeededState and FontValid ) then
       CreateFont;
    if Boolean( NeededState and PenValid ) then
    begin
      CreatePen;
      if assigned( fPen ) then
      if fPen.fData.Pen.Style in [psDash, psDot, psDashDot, psDashDotDot] then
        NeededState := NeededState or BrushValid;
    end;
    if Boolean( NeededState and BrushValid ) then
       CreateBrush;
    fState := fState or NeededState;
  end;
  Result := fHandle;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TCanvas.SetHandle]
procedure TCanvas.SetHandle(Value: HDC);
asm
        PUSH     EBX
        MOV      EBX, EAX
        MOV      ECX, [EBX].fHandle
        CMP      ECX, EDX
        JZ       @@exit
        JECXZ    @@chk_val

        PUSH     EDX
        PUSH     ECX
          CALL     DeselectHandles
        POP      EDX

        MOV      ECX, [EBX].fOwnerControl
        JECXZ    @@chk_Release
        CMP      [ECX].TControl.fPaintDC, EDX
        JE       @@clr_Handle

@@chk_Release:
        PUSH     EDX
        CMP      [EBX].fOnGetHandle.TMethod.Code, offset[TControl.DC2Canvas]
        JNE      @@deldc
        PUSH     [ECX].TControl.fHandle
        CALL     ReleaseDC
        JMP      @@clr_Handle
@@deldc:
        CALL     DeleteDC

@@clr_Handle:
        XOR      ECX, ECX
        MOV      [EBX].TCanvas.fHandle, ECX
        MOV      [EBX].TCanvas.fIsPaintDC, CL
        AND      [EBX].TCanvas.fState, not HandleValid

        POP      EDX
@@chk_val:
        TEST     EDX, EDX
        JZ       @@exit

        OR       [EBX].TCanvas.fState, HandleValid
        MOV      [EBX].TCanvas.fHandle, EDX
        LEA      EDX, [EBX].TCanvas.fPenPos
        MOV      EAX, EBX
        CALL     SetPenPos

@@exit: POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TCanvas.SetHandle(Value: HDC);
{$IFDEF F_P}
var Ptr1: Pointer;
{$ENDIF F_P}
begin
  if fHandle = Value then Exit;
  if fHandle <> 0 then
  begin
    DeselectHandles;
    {if not fIsPaintDC and
       not( assigned(fOwnerControl) and
            PControl(fOwnerControl).fDoubleBuffered )
       then}
      if not( assigned(fOwnerControl) and
              (PControl(fOwnerControl).fPaintDC = fHandle) ) then
      begin
        {$IFDEF F_P}
        Ptr1 := Self;
        asm
          MOV  EAX, [Ptr1]
          MOV  EAX, [EAX].TCanvas.fOnGetHandle
          MOV  [Ptr1], EAX
        end [ 'EAX' ];
        if Ptr1 = @ TControl.DC2Canvas then
        {$ELSE DELPHI}
      //////////////////// SLAG
        if   TMethod(fOnGetHandle).Code =
             @TControl.Dc2Canvas then
        {$ENDIF F_P/DELPHI}
             ReleaseDC(PControl(fOwnerControl).Handle, fHandle )
        else
             DeleteDC( fHandle );
      ////////////////////
      end;
    fHandle := 0;
    fIsPaintDC := False;
    fState := fState and not HandleValid;
  end;
  if Value <> 0 then
  begin
    fState := fState or HandleValid;
    fHandle := Value;
    SetPenPos( fPenPos );
  end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TCanvas.SetPenPos]
procedure TCanvas.SetPenPos(const Value: TPoint);
asm
          MOV     ECX, [EDX].TPoint.y
          MOV     EDX, [EDX].TPoint.x
          MOV     [EAX].fPenPos.x, EDX
          MOV     [EAX].fPenPos.y, ECX
          CALL    MoveTo
end;
{$ELSE ASM_VERSION} //Pascal
procedure TCanvas.SetPenPos(const Value: TPoint);
begin
  fPenPos := Value;
  MoveTo( Value.x, Value.y );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TCanvas.Changing]
procedure TCanvas.Changing;
asm
        PUSHAD
        MOV      ECX, [EAX].fOnChange.TMethod.Code
        JECXZ    @@exit
        XCHG     EDX, EAX
        MOV      EAX, [EDX].fOnChange.TMethod.Data
        CALL     ECX
@@exit:
        POPAD
end;
{$ELSE ASM_VERSION} //Pascal
procedure TCanvas.Changing;
begin
  if Assigned( fOnChange ) then
     fOnChange( Self );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TCanvas.Arc]
procedure TCanvas.Arc(X1, Y1, X2, Y2, X3, Y3, X4, Y4: Integer); stdcall;
asm
        PUSH     ESI

        PUSH     HandleValid or PenValid or ChangingCanvas
        PUSH     dword ptr [EBP+8]
        CALL     RequiredState

        MOV      EDX, EAX

        LEA      ESI, [Y4]
        STD

        XOR      ECX, ECX
        MOV      CL, 8
@@1:
        LODSD
        PUSH     EAX

        LOOP     @@1

        CLD
        PUSH     EDX  //Canvas.fHandle
        CALL     Windows.Arc
        POP      ESI
end;
{$ELSE ASM_VERSION} //Pascal
procedure TCanvas.Arc(X1, Y1, X2, Y2, X3, Y3, X4, Y4: Integer); stdcall;
begin
  RequiredState( HandleValid or PenValid or ChangingCanvas );
  Windows.Arc(FHandle, X1, Y1, X2, Y2, X3, Y3, X4, Y4);
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TCanvas.Chord]
procedure TCanvas.Chord(X1, Y1, X2, Y2, X3, Y3, X4, Y4: Integer); stdcall;
asm
        PUSH     HandleValid or PenValid or BrushValid or ChangingCanvas
        PUSH     dword ptr [EBP + 8]
        CALL     RequiredState

        MOV      EDX, EAX

        PUSH     ESI
        LEA      ESI, [Y4]
        STD

        XOR      ECX, ECX
        MOV      CL, 8
@@1:
        LODSD
        PUSH     EAX

        LOOP     @@1

        CLD
        PUSH     EDX  //Canvas.fHandle
        CALL     Windows.Chord
        POP      ESI
end;
{$ELSE ASM_VERSION} //Pascal
procedure TCanvas.Chord(X1, Y1, X2, Y2, X3, Y3, X4, Y4: Integer); stdcall;
begin
  RequiredState( HandleValid or PenValid or BrushValid or ChangingCanvas );
  Windows.Chord(FHandle, X1, Y1, X2, Y2, X3, Y3, X4, Y4);
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TCanvas.CopyRect]
procedure TCanvas.CopyRect(const DstRect: TRect; SrcCanvas: PCanvas;
  const SrcRect: TRect);
asm
        PUSH     ESI
        PUSH     EDI

        PUSH     [EAX].fCopyMode

        PUSH     EDX

          PUSH     HandleValid or BrushValid
          PUSH     ECX

          PUSH     HandleValid or FontValid or BrushValid or ChangingCanvas
          PUSH     EAX
          MOV      ESI, offset[ RequiredState ]
          CALL     ESI
          MOV      EDI, EAX     // EDI = Self.fHandle

          CALL     ESI
          MOV      EDX, EAX     // EDX = SrcCanvas.fHandle

        POP      ECX          // ECX = @DstRect

        MOV      ESI, [SrcRect]

        MOV      EAX, [ESI].TRect.Bottom
        SUB      EAX, [ESI].TRect.Top
        PUSH     EAX

        MOV      EAX, [ESI].TRect.Right
        SUB      EAX, [ESI].TRect.Left
        PUSH     EAX

        PUSH     [ESI].TRect.Top

        LODSD
        PUSH     EAX

        PUSH     EDX

        MOV      EAX, [ECX].TRect.Bottom
        MOV      EDX, [ECX].TRect.Top
        SUB      EAX, EDX
        PUSH     EAX

        MOV      EAX, [ECX].TRect.Right
        MOV      ESI, [ECX].TRect.Left
        SUB      EAX, ESI
        PUSH     EAX

        PUSH     EDX

        PUSH     ESI

        PUSH     EDI

        CALL     StretchBlt

        POP      EDI
        POP      ESI
end;
{$ELSE ASM_VERSION} //Pascal
procedure TCanvas.CopyRect(const DstRect: TRect; SrcCanvas: PCanvas;
  const SrcRect: TRect);
begin
  RequiredState( HandleValid or FontValid or BrushValid or ChangingCanvas );
  SrcCanvas.RequiredState( HandleValid or BrushValid );
  StretchBlt( fHandle, DstRect.Left, DstRect.Top, DstRect.Right - DstRect.Left,
    DstRect.Bottom - DstRect.Top, SrcCanvas.Handle, SrcRect.Left, SrcRect.Top,
    SrcRect.Right - SrcRect.Left, SrcRect.Bottom - SrcRect.Top, ModeCopy);
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TCanvas.DrawFocusRect]
procedure TCanvas.DrawFocusRect({$IFNDEF FPC}const{$ENDIF} Rect: TRect);
asm
        PUSH     EDX

        PUSH     HandleValid or BrushValid or FontValid or ChangingCanvas
        PUSH     EAX
        CALL     RequiredState

        PUSH     EAX
        CALL     Windows.DrawFocusRect
end;
{$ELSE ASM_VERSION} //Pascal
procedure TCanvas.DrawFocusRect({$IFNDEF FPC}const{$ENDIF} Rect: TRect);
begin
  RequiredState( HandleValid or BrushValid or FontValid or ChangingCanvas );
  Windows.DrawFocusRect(FHandle, Rect);
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TCanvas.Ellipse]
procedure TCanvas.Ellipse(X1, Y1, X2, Y2: Integer);
asm
        PUSH     [Y2]
        PUSH     [X2]
        PUSH     ECX
        PUSH     EDX

        PUSH     HandleValid or PenValid or BrushValid or ChangingCanvas
        PUSH     EAX
        CALL     RequiredState

        PUSH     EAX
        CALL     Windows.Ellipse
end;
{$ELSE ASM_VERSION} //Pascal
procedure TCanvas.Ellipse(X1, Y1, X2, Y2: Integer);
begin
  RequiredState( HandleValid or PenValid or BrushValid or ChangingCanvas );
  Windows.Ellipse(FHandle, X1, Y1, X2, Y2);
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TCanvas.FillRect]
procedure TCanvas.FillRect({$IFNDEF FPC}const{$ENDIF} Rect: TRect);
asm
        PUSH     EBX
        XCHG     EBX, EAX
        PUSH     EDX
        PUSH     HandleValid or BrushValid or ChangingCanvas
        PUSH     EBX
        CALL     RequiredState
        MOV      ECX, [EBX].fBrush
        JECXZ    @@chk_ctl

@@fill_with_Brush:
        XCHG     EAX, ECX
        CALL     TGraphicTool.GetHandle
        POP      EDX
        PUSH     EAX
        JMP      @@fin
@@chk_ctl:
        MOV      ECX, [EBX].fOwnerControl
        JECXZ    @@dflt_fill
        XCHG     EAX, ECX
        MOV      ECX, [EAX].TControl.fBrush
        INC      ECX
        LOOP     @@fill_with_Brush
        MOV      EAX, [EAX].TControl.fColor
        CALL     Color2RGB
        PUSH     EAX
        CALL     CreateSolidBrush
        POP      EDX
        PUSH     EAX
        PUSH     EAX
        PUSH     EDX
        PUSH     [EBX].fHandle
        CALL     Windows.FillRect
        CALL     DeleteObject
        POP      EBX
        RET
@@dflt_fill:
        POP      EDX
        PUSH     COLOR_WINDOW + 1
@@fin:
        PUSH     EDX
        PUSH     [EBX].fHandle
        CALL     Windows.FillRect
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TCanvas.FillRect({$IFNDEF FPC}const{$ENDIF} Rect: TRect);
var Br: HBrush;
begin
  RequiredState( HandleValid or BrushValid or ChangingCanvas );
  if assigned( fBrush ) then
  begin
    Windows.FillRect(fHandle, Rect, fBrush.Handle);
  end
    else
  if assigned( fOwnerControl ) then
  begin
    if assigned( PControl( fOwnerControl ).fBrush ) then
      Windows.FillRect( fHandle, Rect, PControl( fOwnerControl ).fBrush.Handle )
    else
    begin
      Br := CreateSolidBrush( Color2RGB(PControl(fOwnerControl).fColor) );
      Windows.FillRect(fHandle, Rect, Br );
      DeleteObject( Br );
    end;
  end
  else
  begin
    Windows.FillRect(fHandle, Rect, HBrush(COLOR_WINDOW + 1) );
  end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TCanvas.FillRgn]
procedure TCanvas.FillRgn(const Rgn: HRgn);
asm
        PUSH     EBX
        XCHG     EBX, EAX
        PUSH     EDX

        PUSH     HandleValid or BrushValid or ChangingCanvas
        PUSH     EBX
        CALL     RequiredState

        MOV      ECX, [EBX].TCanvas.fBrush
        JECXZ    @@1

        //PUSH     [ECX].TGraphicTool.fData.Color
        //JMP      @@cr_br

@@fill_rgn_using_Brush:
        XCHG     EAX, ECX
        CALL     TGraphicTool.GetHandle
        POP      EDX
        PUSH     EAX
        PUSH     EDX
        PUSH     [EBX].fHandle
        CALL     Windows.FillRgn
        JMP      @@fin

@@1:    MOV      ECX, [EBX].TCanvas.fOwnerControl
        MOV      EAX, -1 // clWhite
        JECXZ    @@2

        XCHG     EAX, ECX
        MOV      ECX, [EAX].TControl.fBrush
        INC      ECX
        LOOP     @@fill_rgn_using_Brush

        MOV      EAX, [EAX].TControl.fColor
@@2:
        CALL     Color2RGB
        PUSH     EAX
        CALL     CreateSolidBrush // EAX = Br

        POP      EDX // Rgn

        PUSH     EAX //-------------------//
        PUSH     EAX           // Br
        PUSH     EDX           // Rgn
        PUSH     [EBX].FHandle // fHandle
        CALL     Windows.FillRgn

        CALL     DeleteObject

@@fin:
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TCanvas.FillRgn(const Rgn: HRgn);
var Br : HBrush;
begin
  RequiredState( HandleValid or BrushValid or ChangingCanvas );
  if assigned( fBrush ) then
    Windows.FillRgn(FHandle, Rgn, fBrush.Handle )
    else
  if assigned( fOwnerControl ) then
  begin
    if Assigned( PControl( fOwnerControl ).fBrush ) then
      Windows.FillRgn( FHandle, Rgn, PControl( fOwnerControl ).fBrush.Handle )
    else
    begin
      Br := CreateSolidBrush( Color2RGB(PControl(fOwnerControl).fColor) );
      Windows.FillRgn( fHandle, Rgn, Br );
      DeleteObject( Br );
    end;
  end
     else
  begin
    Br := CreateSolidBrush( DWORD(clWindow) );
    Windows.FillRgn( fHandle, Rgn, Br );
    DeleteObject( Br );
  end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TCanvas.FloodFill]
procedure TCanvas.FloodFill(X, Y: Integer; Color: TColor;
  FillStyle: TFillStyle);
asm
        PUSH     EBX
        MOV      EBX, EAX

        MOVZX    EAX, [FillStyle]
        TEST     EAX, EAX
        MOV      EAX, FLOODFILLSURFACE
        JZ       @@1
        MOV      EAX, FLOODFILLBORDER
@@1:    PUSH     EAX
        PUSH     [Color]
        PUSH     ECX
        PUSH     EDX

        PUSH     HandleValid or BrushValid or ChangingCanvas
        PUSH     EBX
        CALL     RequiredState
        PUSH     EAX
        CALL     Windows.ExtFloodFill

        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TCanvas.FloodFill(X, Y: Integer; Color: TColor;
  FillStyle: TFillStyle);
const
  FillStyles: array[TFillStyle] of Word =
    (FLOODFILLSURFACE, FLOODFILLBORDER);
begin
  RequiredState( HandleValid or BrushValid or ChangingCanvas );
  Windows.ExtFloodFill(FHandle, X, Y, Color, FillStyles[FillStyle]);
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TCanvas.FrameRect]
procedure TCanvas.FrameRect({$IFNDEF FPC}const{$ENDIF} Rect: TRect);
asm
        PUSH     EBX
        XCHG     EBX, EAX
        PUSH     EDX

        MOV      ECX, [EBX].TCanvas.fBrush
        JECXZ    @@1

        PUSH     [ECX].TGraphicTool.fData.Color
        JMP      @@cr_br

@@1:    MOV      ECX, [EBX].TCanvas.fOwnerControl
        JECXZ    @@2

        PUSH     [ECX].TControl.fColor
        JMP      @@cr_br

@@2:    PUSH     clWhite
@@cr_br:POP      EAX                  // @Rect
        CALL     Color2RGB
        PUSH     EAX
        CALL     CreateSolidBrush
        POP      EDX
          PUSH     EAX
        PUSH     EAX
        PUSH     EDX

        PUSH     HandleValid or ChangingCanvas
        PUSH     EBX
        ///MOV      EBX, EDX
        CALL     RequiredState

        PUSH     EAX
        CALL     Windows.FrameRect

        ///PUSH     EBX
        CALL     DeleteObject

        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TCanvas.FrameRect({$IFNDEF FPC}const{$ENDIF} Rect: TRect);
var SolidBr : HBrush;
begin
  RequiredState( HandleValid or ChangingCanvas );
  if assigned( fBrush ) then
    SolidBr := CreateSolidBrush( Color2RGB( fBrush.fData.Color ) )
  else
  if assigned( fOwnerControl ) then
    SolidBr := CreateSolidBrush( PControl(fOwnerControl).fColor )
  else
    SolidBr := CreateSolidBrush( clWhite );
  Windows.FrameRect(FHandle, Rect, SolidBr);
  DeleteObject( SolidBr );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TCanvas.LineTo]
procedure TCanvas.LineTo(X, Y: Integer);
asm
        PUSH     ECX
        PUSH     EDX
        PUSH     HandleValid or PenValid or BrushValid or ChangingCanvas
        PUSH     EAX
        CALL     RequiredState
        PUSH     EAX  //Canvas.fHandle
        CALL     Windows.LineTo
end;
{$ELSE ASM_VERSION} //Pascal
procedure TCanvas.LineTo(X, Y: Integer);
begin
  RequiredState( HandleValid or PenValid or BrushValid or ChangingCanvas );
  Windows.LineTo( fHandle, X, Y );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TCanvas.MoveTo]
procedure TCanvas.MoveTo(X, Y: Integer);
asm
        PUSH     0
        PUSH     ECX
        PUSH     EDX
        PUSH     HandleValid
        PUSH     EAX
        CALL     RequiredState
        PUSH     EAX  //Canvas.fHandle
        CALL     Windows.MoveToEx
end;
{$ELSE ASM_VERSION} //Pascal
procedure TCanvas.MoveTo(X, Y: Integer);
begin
  RequiredState( HandleValid );
  Windows.MoveToEx( fHandle, X, Y, nil );
end;
{$ENDIF ASM_VERSION}

//[procedure TCanvas.ObjectChanged]
procedure TCanvas.ObjectChanged(Sender: PGraphicTool);
begin
  DeselectHandles;
  //if Assigned( GlobalCanvas_OnObjectChanged ) then
  //   GlobalCanvas_OnObjectChanged( Sender );
end;

{$IFDEF ASM_VERSION}
//[procedure TCanvas.Pie]
procedure TCanvas.Pie(X1, Y1, X2, Y2, X3, Y3, X4, Y4: Integer); stdcall;
asm
        PUSH     HandleValid or PenValid or BrushValid or ChangingCanvas
        PUSH     dword ptr [EBP + 8]
        CALL     RequiredState

        MOV      EDX, EAX

        PUSH     ESI
        LEA      ESI, [Y4]
        STD

        XOR      ECX, ECX
        MOV      CL, 8
@@1:
        LODSD
        PUSH     EAX

        LOOP     @@1

        CLD
        PUSH     EDX  //Canvas.fHandle
        CALL     Windows.Pie
        POP      ESI
end;
{$ELSE ASM_VERSION} //Pascal
procedure TCanvas.Pie(X1, Y1, X2, Y2, X3, Y3, X4, Y4: Integer); stdcall;
begin
  RequiredState( HandleValid or PenValid or BrushValid or ChangingCanvas );
  Windows.Pie( fHandle, X1, Y1, X2, Y2, X3, Y3, X4, Y4);
end;
{$ENDIF ASM_VERSION}


{$IFDEF F_P}
//[Windows API FUNCTIONS ADDITIONAL DECLARATIONS FOR Free Pascal]
function Windows_Polygon; external gdi32 name 'Polygon';
function Windows_Polyline; external gdi32 name 'Polyline';
function FillRect; external user32 name 'FillRect';
function OffsetRect; external user32 name 'OffsetRect';
function CreateAcceleratorTable; external user32 name 'CreateAcceleratorTableA';
function TrackPopupMenu; external user32 name 'TrackPopupMenu';
function AdjustTokenPrivileges(TokenHandle: THandle; DisableAllPrivileges: BOOL;
  const NewState: TTokenPrivileges; BufferLength: DWORD;
  var PreviousState: TTokenPrivileges; var ReturnLength: DWORD): BOOL; external advapi32 name 'AdjustTokenPrivileges';
function InflateRect; external user32 name 'InflateRect';
{$IFDEF F_P105ORBELOW}
function InvalidateRect; external user32 name 'InvalidateRect';
function ValidateRect; external user32 name 'ValidateRect';
{$ENDIF F_P105ORBELOW}
//[END OF Windows API FUNCTIONS ADDITIONAL DECLARATIONS FOR Free Pascal]
{$ENDIF}


{$IFDEF ASM_VERSION}
//[procedure TCanvas.Polygon]
procedure TCanvas.Polygon(const Points: array of TPoint);
asm
        INC      ECX
        PUSH     ECX
        PUSH     EDX

        PUSH     HandleValid or PenValid or BrushValid or ChangingCanvas
        PUSH     EAX
        CALL     RequiredState

        PUSH     EAX
        CALL     Windows.Polygon
end;
{$ELSE ASM_VERSION} //Pascal
procedure TCanvas.Polygon(const Points: array of TPoint);
type
  PPoints = ^TPoints;
  TPoints = array[0..0] of TPoint;
begin
  RequiredState( HandleValid or PenValid or BrushValid or ChangingCanvas );
  {$IFDEF F_P} Windows_Polygon
  {$ELSE DELPHI} Windows.Polygon
  {$ENDIF}( fHandle, PPoints(@Points)^, High(Points) + 1);
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TCanvas.Polyline]
procedure TCanvas.Polyline(const Points: array of TPoint);
asm
        INC      ECX
        PUSH     ECX
        PUSH     EDX

        PUSH     HandleValid or PenValid or BrushValid or ChangingCanvas
        PUSH     EAX
        CALL     RequiredState

        PUSH     EAX
        CALL     Windows.Polyline
end;
{$ELSE ASM_VERSION} //Pascal
procedure TCanvas.Polyline(const Points: array of TPoint);
type
  PPoints = ^TPoints;
  TPoints = array[0..0] of TPoint;
begin
  RequiredState( HandleValid or PenValid or BrushValid or ChangingCanvas );
  {$IFDEF F_P}Windows_Polyline
  {$ELSE DELPHI}Windows.Polyline
  {$ENDIF}( fHandle, PPoints(@Points)^, High(Points) + 1);
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TCanvas.Rectangle]
procedure TCanvas.Rectangle(X1, Y1, X2, Y2: Integer);
asm
        PUSH     [Y2]
        PUSH     [X2]
        PUSH     ECX
        PUSH     EDX

        PUSH     HandleValid or BrushValid or PenValid or ChangingCanvas
        PUSH     EAX
        CALL     RequiredState

        PUSH     EAX
        CALL     Windows.Rectangle
end;
{$ELSE ASM_VERSION} //Pascal
procedure TCanvas.Rectangle(X1, Y1, X2, Y2: Integer);
begin
  RequiredState( HandleValid or BrushValid or PenValid or ChangingCanvas );
  Windows.Rectangle( fHandle, X1, Y1, X2, Y2);
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TCanvas.RoundRect]
procedure TCanvas.RoundRect(X1, Y1, X2, Y2, X3, Y3: Integer);
asm
        PUSH     [Y3]
        PUSH     [X3]
        PUSH     [Y2]
        PUSH     [X2]
        PUSH     ECX
        PUSH     EDX

        PUSH     HandleValid or BrushValid or PenValid or ChangingCanvas
        PUSH     EAX
        CALL     RequiredState

        PUSH     EAX
        CALL     Windows.RoundRect
end;
{$ELSE ASM_VERSION} //Pascal
procedure TCanvas.RoundRect(X1, Y1, X2, Y2, X3, Y3: Integer);
begin
  RequiredState( HandleValid or BrushValid or PenValid or ChangingCanvas );
  Windows.RoundRect( fHandle, X1, Y1, X2, Y2, X3, Y3);
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TCanvas.TextArea]
procedure TCanvas.TextArea(const Text: String; var Sz: TSize;
  var P0: TPoint);
asm
        PUSH     EBX
        MOV      EBX, EAX

        PUSH     ECX
        CALL     TextExtent
        POP      EDX

        MOV      ECX, [P0]
        XOR      EAX, EAX
        MOV      [ECX].TPoint.x, EAX
        MOV      [ECX].TPoint.y, EAX

        CMP      [GlobalCanvas_OnTextArea], EAX
        JZ       @@exit
        MOV      EAX, EBX
        CALL     [GlobalCanvas_OnTextArea]

@@exit:
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TCanvas.TextArea(const Text: String; var Sz: TSize;
  var P0: TPoint);
begin
  Sz := TextExtent( Text );
  P0.x := 0; P0.y := 0;
  if Assigned( GlobalCanvas_OnTextArea ) then
     GlobalCanvas_OnTextArea( Self, Sz, P0 );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TCanvas.TextExtent]
function TCanvas.TextExtent(const Text: string): TSize;
asm
        PUSH     EBX
        PUSH     ESI
        MOV      EBX, EAX

        PUSH     ECX               // prepare @Result

        MOV      EAX, EDX
        CALL     System.@LStrLen
        PUSH     EAX               // prepare Length(Text)

        CALL     EDX2PChar
        PUSH     EDX               // prepare PChar(Text)

        PUSH     HandleValid or FontValid
        PUSH     EBX
        CALL     RequiredState

        XCHG     ESI, EAX
        TEST     ESI, ESI          // ESI = fHandle before
        JNZ      @@1

        PUSH     ESI
        CALL     CreateCompatibleDC

        MOV      EDX, EBX
        XCHG     EAX, EDX // EAX := Self; EDX := DC
        CALL     SetHandle
@@1:
//********************************************************** // Added By M.Gerasimov
//*
        CMP      [EBX].TCanvas.fIsPaintDC, 1
        JZ       @@2
        XOR      ESI,ESI
@@2:
//*
//********************************************************** // Added By M.Gerasimov
        PUSH     HandleValid or FontValid
        PUSH     EBX
        CALL     RequiredState
        PUSH     EAX               // prepare DC

        CALL     Windows.GetTextExtentPoint32

        TEST     ESI, ESI
        JNZ      @@exit

        XOR      EDX, EDX
        XCHG     EAX, EBX
        CALL     SetHandle

@@exit:
        POP      ESI
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function TCanvas.TextExtent(const Text: string): TSize;
var DC : HDC;
    ClearHandle : Boolean;
begin
  //Result.cX := 0;
  //Result.cY := 0;
  ClearHandle := False;
  RequiredState( HandleValid or FontValid );
  DC := fHandle;
  if DC = 0 then
  begin
     DC := CreateCompatibleDC( 0 );
     ClearHandle := True;
     SetHandle( DC );
  end;
//********************************************************** // Added By Gerasimov
//*
  If Not fIsPaintDC then ClearHandle := True;
//*
//********************************************************** // Added By Gerasimov
  RequiredState( HandleValid or FontValid );
  Windows.GetTextExtentPoint32( fHandle, PChar(Text), Length(Text), Result);
  if ClearHandle then
    SetHandle( 0 );
    { DC must be freed here automatically (never leaks):
      if Canvas created on base of existing DC, no memDC created,
      if Canvas has fHandle:HDC = 0, it is not fIsPaintDC always. }
end;
{$ENDIF ASM_VERSION}

//[function TCanvas.TextHeight]
function TCanvas.TextHeight(const Text: string): Integer;
begin
  Result := TextExtent(Text).cY;
end;

{$IFDEF ASM_VERSION}
//[procedure TCanvas.TextOut]
procedure TCanvas.TextOut(X, Y: Integer; const Text: String); stdcall;
asm
        PUSH     EBX
        MOV      EBX, [EBP+8]

        MOV      EAX, [Text]
        PUSH     EAX
        CALL     System.@LStrLen
        XCHG     EAX, [ESP]             // prepare Length(Text)

        //CALL     System.@LStrToPChar  // string does not need to be null-terminated !
        PUSH     EAX                    // prepare PChar(Text)
        PUSH     [Y]                    // prepare Y
        PUSH     [X]                    // prepare X

        PUSH     HandleValid or FontValid or BrushValid or ChangingCanvas
        PUSH     EBX
        CALL     RequiredState
        PUSH     EAX                    // prepare fHandle
        CALL     Windows.TextOut

        { -- by suggetion of Alexey (Lecha2002)
        MOV      EAX, EBX
        MOV      EDX, [Text]
        CALL     TextWidth
        MOV      EDX, [X]
        ADD      EDX, EAX

        MOV      ECX, [Y]
        MOV      EAX, EBX
        CALL     MoveTo
        }

        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TCanvas.TextOut(X, Y: Integer; const Text: String); stdcall;
begin
  RequiredState( HandleValid or FontValid or BrushValid or ChangingCanvas );
  Windows.TextOut(FHandle, X, Y, PChar(Text), Length(Text));
  //MoveTo(X + TextWidth(Text), Y); -- by suggestion of Alexey (Lecha2002)
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TCanvas.TextRect]
procedure TCanvas.TextRect(const Rect: TRect; X, Y: Integer; const Text: string);
asm
        PUSH     EBX
        XCHG     EBX, EAX

        PUSH     0              // prepare 0

        PUSH     EDX
        PUSH     ECX

        MOV      EAX, [Text]
        //CALL     System.@LStrToPChar
        PUSH     EAX

        //MOV      EAX, [Text]
        CALL     System.@LStrLen

        POP      ECX            // ECX = @Text[1]

        POP      EDX            // EDX = X
        XCHG     EAX, [ESP]     // prepare Length(Text), EAX = @Rect
        PUSH     ECX            // prepare PChar(Text)
        PUSH     EAX            // prepare @Rect

        XOR      EAX, EAX
        MOV      AL, ETO_CLIPPED // = 4
        MOV      ECX, [EBX].fBrush
        JECXZ    @@opaque

        CMP      [ECX].TGraphicTool.fData.Brush.Style, bsClear
        JZ       @@txtout

@@opaque:
        DB $0C, ETO_OPAQUE //OR       AL, ETO_OPAQUE
@@txtout:
        PUSH     EAX            // prepare Options
        PUSH     [Y]            // prepare Y
        PUSH     EDX            // prepare X

        PUSH     HandleValid or FontValid or BrushValid or ChangingCanvas
        PUSH     EBX
        CALL     RequiredState  // EAX = fHandle
        PUSH     EAX            // prepare fHandle

        CALL     Windows.ExtTextOut

        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TCanvas.TextRect(const Rect: TRect; X, Y: Integer; const Text: string);
var
  Options: Integer;
begin
  //Changing;
  RequiredState( HandleValid or FontValid or BrushValid or ChangingCanvas );
  Options := ETO_CLIPPED;
  if assigned( fBrush ) and (fBrush.fData.Brush.Style <> bsClear)
  or not assigned( fBrush ) then Inc(Options, ETO_OPAQUE);
  Windows.ExtTextOut( fHandle, X, Y, Options,
                      @Rect, PChar(Text),
                      Length(Text), nil);
end;
{$ENDIF ASM_VERSION}

//[procedure TCanvas.ExtTextOut]
procedure TCanvas.ExtTextOut( X, Y: Integer; Options: DWORD; const Rect: TRect; const Text: String;
          const Spacing: array of Integer );
begin
  RequiredState( HandleValid or FontValid or BrushValid or ChangingCanvas );
  Windows.ExtTextOut(FHandle, X, Y, Options, @Rect, PChar(Text), Length(Text), @Spacing[ 0 ]);
end;

//[procedure TCanvas.DrawText]
procedure TCanvas.DrawText(Text:String; var Rect:TRect; Flags:DWord);
begin
  RequiredState( HandleValid or FontValid or BrushValid or ChangingCanvas );
  Windows.DrawText(Handle,PChar(Text),Length(Text),Rect,Flags);
end;

//[function TCanvas.ClipRect]
function TCanvas.ClipRect: TRect;
begin
  RequiredState( HandleValid or FontValid or BrushValid or ChangingCanvas );
  GetClipBox(Handle, Result);
end;

//[function TCanvas.TextWidth]
function TCanvas.TextWidth(const Text: string): Integer;
begin
  Result := TextExtent(Text).cX;
end;

{$IFDEF ASM_VERSION}
//[function TCanvas.GetBrush]
function TCanvas.GetBrush: PGraphicTool;
asm
        MOV      ECX, [EAX].fBrush
        INC      ECX
        LOOP     @@exit

        PUSH     EAX
        CALL     NewBrush
        POP      EDX
        PUSH     EAX

        MOV      [EDX].fBrush, EAX

        MOV      [EAX].TGraphicTool.fOnChange.TMethod.Code, Offset[TCanvas.ObjectChanged]
        MOV      [EAX].TGraphicTool.fOnChange.TMethod.Data, EDX
        MOV      ECX, [EDX].fOwnerControl
        JECXZ    @@1

        PUSH     [ECX].TControl.fBrush
        MOV      ECX, [ECX].TControl.fColor
        MOV      [EAX].TGraphicTool.fData.Color, ECX
        POP      EDX
        TEST     EDX, EDX
        JZ       @@1

        CALL     TGraphicTool.Assign

@@1:    POP      ECX

@@exit: XCHG     EAX, ECX
end;
{$ELSE ASM_VERSION} //Pascal
function TCanvas.GetBrush: PGraphicTool;
begin
  if not assigned( fBrush ) then
  begin
    fBrush := NewBrush;
    if assigned( fOwnerControl ) then
    begin
      fBrush.fData.Color := PControl(fOwnerControl).fColor;
      if assigned( PControl(fOwnerControl).fBrush ) then
         {fBrush := }fBrush.Assign( PControl(fOwnerControl).fBrush );
      // both statements above needed
    end;
    //fBrush.OnChange := ObjectChanged;
    AssignChangeEvents;
  end;
  Result := fBrush;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TCanvas.GetFont]
function TCanvas.GetFont: PGraphicTool;
asm
        MOV      ECX, [EAX].TCanvas.fFont
        INC      ECX
        LOOP     @@exit

        PUSH     EAX
        CALL     NewFont
        POP      EDX
        PUSH     EAX

        MOV      [EDX].TCanvas.fFont, EAX
        MOV      [EAX].TGraphicTool.fOnChange.TMethod.Code, Offset[TCanvas.ObjectChanged]
        MOV      [EAX].TGraphicTool.fOnChange.TMethod.Data, EDX

        MOV      ECX, [EDX].fOwnerControl
        JECXZ    @@1

        PUSH     [ECX].TControl.fFont
        MOV      ECX, [ECX].TControl.fTextColor
        MOV      [EAX].TGraphicTool.fData.Color, ECX
        POP      EDX
        TEST     EDX, EDX
        JZ       @@1

        CALL     TGraphicTool.Assign

@@1:    POP      ECX

@@exit: MOV      EAX, ECX
end;
{$ELSE ASM_VERSION} //Pascal
function TCanvas.GetFont: PGraphicTool;
begin
  if not assigned( fFont ) then
  begin
    fFont := NewFont;
    if assigned( fOwnerControl ) then
    begin
      fFont.Color := PControl(fOwnerControl).fTextColor;
      if assigned( PControl(fOwnerControl).fFont ) then
        {fFont := }fFont.Assign( PControl(fOwnerControl).fFont );
    end;
    //fFont.OnChange := ObjectChanged;
    AssignChangeEvents;
  end;
  Result := fFont;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TCanvas.GetPen]
function TCanvas.GetPen: PGraphicTool;
asm
        MOV      ECX, [EAX].TCanvas.fPen
        INC      ECX
        LOOP     @@exit

        PUSH     EAX
        CALL     NewPen
        POP      EDX
        MOV      [EDX].fPen, EAX
        PUSH     EAX
        MOV      EAX, EDX
        CALL     AssignChangeEvents
        POP      ECX

@@exit: MOV      EAX, ECX
end;
{$ELSE ASM_VERSION} //Pascal
function TCanvas.GetPen: PGraphicTool;
begin
  if not assigned( fPen ) then
  begin
    fPen := NewPen;
    AssignChangeEvents;
  end;
  Result := fPen;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TCanvas.GetHandle]
function TCanvas.GetHandle: HDC;
asm
        CMP      word ptr[EAX].fOnGetHandle.TMethod.Code+2, 0
        MOV      EDX, EAX
        MOV      EAX, [EDX].fHandle
        JZ       @@exit
        MOV      EAX, [EDX].fOnGetHandle.TMethod.Data
        PUSH     EDX
        CALL     [EDX].fOnGetHandle.TMethod.Code
        XCHG     EAX, [ESP]
        POP      EDX
        PUSH     EDX
        CALL     SetHandle
        POP      EAX
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
function TCanvas.GetHandle: HDC;
begin
  if assigned( fOnGetHandle ) then
  begin
    Result := fOnGetHandle( Self );
    //fHandle := Result;
    SetHandle( Result );
  end
  else
    Result := fHandle;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TCanvas.AssignChangeEvents]
procedure TCanvas.AssignChangeEvents;
asm
        PUSH     ESI
        LEA      ESI, [EAX].fBrush
        MOV      CL, 3
        MOV      EDX, EAX
@@1:    LODSD
        TEST     EAX, EAX
        JZ       @@nxt
        MOV      [EAX].TGraphicTool.fOnChange.TMethod.Data, EDX
        MOV      [EAX].TGraphicTool.fOnChange.TMethod.Code, offset[ ObjectChanged ]
@@nxt:  DEC      CL
        JNZ      @@1
        POP      ESI
end;
{$ELSE ASM_VERSION} //Pascal
procedure TCanvas.AssignChangeEvents;
begin
  if assigned( fFont ) then
     fFont.fOnChange := ObjectChanged;
  if assigned( fBrush ) then
     fBrush.fOnChange := ObjectChanged;
  if assigned( fPen ) then
     fPen.fOnChange := ObjectChanged;
end;
{$ENDIF ASM_VERSION}

{$IFNDEF _FPC}
{$IFNDEF _D2}
//[procedure TCanvas.WDrawText]
procedure TCanvas.WDrawText(WText: WideString; var Rect: TRect;
  Flags: DWord);
begin
  RequiredState( HandleValid or FontValid or BrushValid or ChangingCanvas );
  Windows.DrawTextW(Handle,PWideChar(WText),Length(WText),Rect,Flags);
end;

//[procedure TCanvas.WExtTextOut]
procedure TCanvas.WExtTextOut(X, Y: Integer; Options: DWORD;
  const Rect: TRect; const WText: WideString;
  const Spacing: array of Integer);
begin
  RequiredState( HandleValid or FontValid or BrushValid or ChangingCanvas );
  Windows.ExtTextOutW(FHandle, X, Y, Options, @Rect, PWideChar(WText), Length(WText), @Spacing[ 0 ]);
end;

//[procedure TCanvas.WTextOut]
procedure TCanvas.WTextOut(X, Y: Integer; const WText: WideString);
begin
  RequiredState( HandleValid or FontValid or BrushValid or ChangingCanvas );
  Windows.TextOutW(FHandle, X, Y, PWideChar(WText), Length(WText));
  MoveTo(X + WTextWidth(WText), Y);
end;

//[procedure TCanvas.WTextRect]
procedure TCanvas.WTextRect(const Rect: TRect; X, Y: Integer;
  const WText: WideString);
var
  Options: Integer;
begin
  //Changing;
  RequiredState( HandleValid or FontValid or BrushValid or ChangingCanvas );
  Options := ETO_CLIPPED;
  if assigned( fBrush ) and (fBrush.fData.Brush.Style <> bsClear)
  or not assigned( fBrush ) then Inc(Options, ETO_OPAQUE);
  Windows.ExtTextOutW( fHandle, X, Y, Options,
                      @Rect, PWideChar(WText),
                      Length(WText), nil);
end;

//[function TCanvas.WTextExtent]
function TCanvas.WTextExtent(const WText: WideString): TSize;
var DC : HDC;
    ClearHandle : Boolean;
begin
  ClearHandle := False;
  RequiredState( HandleValid or FontValid );
  DC := fHandle;
  if DC = 0 then
  begin
     DC := CreateCompatibleDC( 0 );
     ClearHandle := True;
     SetHandle( DC );
  end;
  RequiredState( HandleValid or FontValid );
  Windows.GetTextExtentPoint32W( fHandle, PWideChar(WText), Length(WText), Result);
  if ClearHandle then
    SetHandle( 0 );
end;

//[function TCanvas.WTextHeight]
function TCanvas.WTextHeight(const WText: WideString): Integer;
begin
  Result := WTextExtent( WText ).cy;
end;

//[function TCanvas.WTextWidth]
function TCanvas.WTextWidth(const WText: WideString): Integer;
begin
  Result := WTextExtent( WText ).cx;
end;
{$ENDIF _D2}
{$ENDIF _FPC}











//[function IntPower]
function IntPower(Base: Extended; Exponent: Integer): Extended;
{$IFDEF F_P}
begin
  if Exponent = 0 then
  begin
    Result := 1.0;
    Exit;
  end;
  if Exponent < 0 then
  begin
    Exponent := -Exponent;
    Base := 1.0 / Base;
  end;
  Result := Base;
  REPEAT
    Result := Result * Base;
    Dec( Exponent );
  UNTIL Exponent <= 0;
end;
{$ELSE DELPHI}
asm
        mov     ecx, eax
        cdq
        fld1                      { Result := 1 }
        xor     eax, edx
        sub     eax, edx          { eax := Abs(Exponent) }
        jz      @@3
        fld     Base
        jmp     @@2
@@1:    fmul    ST, ST            { X := Base * Base }
@@2:    shr     eax,1
        jnc     @@1
        fmul    ST(1),ST          { Result := Result * X }
        jnz     @@1
        fstp    st                { pop X from FPU stack }
        cmp     ecx, 0
        jge     @@3
        fld1
        fdivrp                    { Result := 1 / Result }
@@3:
        fwait
end;
{$ENDIF F_P/DELPHI}

//[function Str2Double]
function Str2Double( const S: String ): Double;
var I: Integer;
    M, Pt: Boolean;
    D: Double;
    Ex: Integer;
begin
  Result := 0.0;
  if S = '' then Exit;
  M := FALSE;
  I := 1;
  if S[ 1 ] = '-' then
  begin
    M := TRUE;
    Inc( I );
  end;
  Pt := FALSE;
  D := 1.0;
  while I <= Length( S ) do
  begin
    case S[ I ] of
    '.': if not Pt then Pt := TRUE else break;
    '0'..'9': if not Pt then
                 Result := Result * 10.0 + Integer( S[ I ] ) - Integer( '0' )
              else
              begin
                D := D * 0.1;
                Result := Result + (Integer( S[ I ] ) - Integer( '0' )) * D;
              end;
    'e', 'E': begin
                Ex := Str2Int( CopyEnd( S, I + 1 ) );
                Result := Result * IntPower( 10.0, Ex );
                break;
              end;
    end;
    Inc( I );
  end;
  if M then
    Result := -Result;
end;

//[function TruncD]
function TruncD( D: Double ): Double;

begin
  Result := Trunc( D );
end;


// Precision 15
//[function Extended2Str]
function Extended2Str( E: Extended ): String;
    function UnpackFromBuf( const Buf: array of Byte; N: Integer ): String;
    var I, J, K, L: Integer;
    begin
      SetLength( Result, 16 );
      J := 1;
      for I := 7 downto 0 do
      begin
        K := Buf[ I ] shr 4;
        Result[ J ] := Char( Ord('0') + K );
        Inc( J );
        K := Buf[ I ] and $F;
        Result[ J ] := Char( Ord('0') + K );
        Inc( J );
      end;

      Assert( Result[ 1 ] = '0', 'error!' );
      Delete( Result, 1, 1 );

      if N <= 0 then
      begin
        while N < 0 do
        begin
          Result := '0' + Result;
          Inc( N );
        end;
        Result := '0.' + Result;
      end
        else
      if N < Length( Result ) then
      begin
        Result := Copy( Result, 1, N ) + '.' + CopyEnd( Result, N + 1 );
      end
        else
      begin
        while N > Length( Result ) do
        begin
          Result := Result + '0';
        end;
        Exit;
      end;

      L := Length( Result );
      while L > 1 do
      begin
        if not (Result[ L ] in ['0','.']) then break;
        Dec( L );
        if Result[ L + 1 ] = '.' then break;
      end;
      if L < Length( Result ) then Delete( Result, L + 1, MaxInt );

    end;

var
  S: Boolean;
var F: Extended;
    N: Integer;
    Buf1: array[ 0..9 ] of Byte;
    I10: Integer;
begin
  Result := '0';
  if E = 0 then Exit;
  S := E < 0;
  if S then E := -E;

  N := 15;
  F := 5E12;
  I10 := 10;
  while E < F do
  begin
    Dec( N );
    E := E * I10;
  end;
  if N = 15 then
  while E >= 1E13 do
  begin
    Inc( N );
    E := E / I10;
  end;

  while TRUE do
  begin
    asm
      FLD    [E]
      FBSTP  [Buf1]
    end;
    if Buf1[ 7 ] <> 0 then break;
    E := E * I10;
    Dec( N );
  end;

  Result := UnpackFromBuf( Buf1, N );

  if S then Result := '-' + Result;
end;

//[function Double2Str]
function Double2Str( D: Double ): String;
begin
  Result := Extended2Str( D );
end;

//[function Double2StrEx]
function Double2StrEx( D: Double ): String;
var E, E1, E2: Double;
    S: String;
begin
  Result := Double2Str( D );
  E := Str2Double( Result );
  E1 := E - D;
  if E1 < 0.0 then E1 := -E1;
  if E1 < 1e-307 then Exit;
  while TRUE do
  begin
    E := D - (E - D) * 0.3;
    S := Double2Str( E );
    if S = Result then break;
    E := Str2Double( S );
    E2 := E - D;
    if E2 < 0.0 then E2 := -E2;
    if E2 > E1 * 0.75 then break;
    Result := S;
    if E2 < E1 * 0.1 then break;
  end;
end;

//[function GetBits]
function GetBits( N: DWORD; first, last: Byte ): DWord;
{$IFDEF F_P}
begin
  Result := 0;
  if last > 31 then last := 31;
  if first > last then Exit;
  Result := (N and not ($FFFFFFFF shl last)) shr first;
end;
{$ELSE DELPHI}
asm
   XCHG EAX, EDX  // (1) EDX=N, AL=first
   {$IFDEF PARANOIA}
   DB $3C, 31
   {$ELSE}
   CMP AL, 31 // first(AL) > 31 ?
   {$ENDIF}
   JBE  @@1       // (2) если да, то Result := 0;
@@0:
   XOR  EAX, EAX  // (2)
   RET            // (1)
@@1:

   XCHG EAX, ECX  // (1) AL = last CL = first
   SHR  EDX, CL   // (2) EDX = N shr first
   SUB  AL,  CL	  // (2) AL = last - first
   JL @@0         // (2) если last < first то Result := 0;

   {$IFDEF PARANOIA}
   DB $3C, 32
   {$ELSE}
   CMP AL, 32     // (2) last - first >= 32 ?
   {$ENDIF}
   XCHG ECX, EAX  // (1) CL = last - first
   XCHG EAX, EDX  // (1) EAX = N shr first
   JAE  @@exit    // (2) если last - first > 31, то Result := EAX;
   SBB  EDX, EDX  // (2) EDX = -1
   DEC  EDX       // (1) EDX = 1111...10 = -2
   SHL  EDX, CL   // (2) EDX = 111...100..0 (где n(0)=last-first+1)
   NOT  EDX       // (2) EDX = маска 000..0111...1 (где n(1)=last-first+1)
   AND  EAX, EDX  // (2)
@@exit:
   // EAX = результат, (1 байт на команду RET)
end;
{$ENDIF F_P/DELPHI}

//[function GetBitsL]
function GetBitsL( N: DWORD; from, len: Byte ): DWord;
{$IFDEF F_P}
begin
  Result := GetBits( N, from, from + len - 1 );
end;
{$ELSE DELPHI}
asm
   ADD  CL, DL
   DEC  CL
   JMP  GetBits
end;
{$ENDIF F_P/DELPHI}

//[FUNCTION Int2Hex]
{$IFDEF ASM_VERSION}
function Int2Hex( Value : DWord; Digits : Integer ) : String;
asm

        // EAX = Value
        // EDX = Digits (actually DL needed)
        // ECX = @Result

        PUSH      0
        ADD       ESP, -0Ch

        PUSH      EBX
        PUSH      ECX

        LEA       EBX, [ESP+8+0Fh]  // EBX := @Buf[ 15 ]
        AND       EDX, $F

@@loop: DEC       EBX
        DEC       EDX

        PUSH      EAX
        {$IFDEF PARANOIA}
        DB $24, $0F
        {$ELSE}
        AND       AL, 0Fh
        {$ENDIF}
        {$IFDEF PARANOIA}
        DB $3C, 9
        {$ELSE}
        CMP       AL, 9
        {$ENDIF}
        JA        @@10
        {$IFDEF PARANOIA}
        DB $04, 30h-41h+0Ah
        {$ELSE}
        ADD       AL,30h-41h+0Ah
        {$ENDIF}
@@10:
        {$IFDEF PARANOIA}
        DB $04, 41h-0Ah
        {$ELSE}
        ADD       AL,41h-0Ah
        {$ENDIF}
        MOV       byte ptr [EBX], AL
        POP       EAX
        SHR       EAX, 4

        JNZ       @@loop

        TEST      EDX, EDX
        JG        @@loop

        POP       EAX      // EAX = @Result
        MOV       EDX, EBX // EDX = @resulting string
        CALL      System.@LStrFromPChar

        POP       EBX
        ADD       ESP, 10h

{== by KSer - to test it only.
function Int2Hex( Value : DWord; Digits : Integer ) : shortString;
asm
        MOV       [ECX], DL
        XADD      EDX, ECX
@@loop1:
        PUSH      EAX
        db   $24, $0F    // and  al,$0F
        AAM
        //AAD
        DB $D5, $11
        db   $04, $30    // add  al,$30
        MOV       [EDX], AL
        POP       EAX
        SHR       EAX, 4
        DEC       EDX
        LOOP      @@loop1
}
end;
{$ELSE ASM_VERSION} //Pascal (mixed)
function Int2Hex( Value : DWord; Digits : Integer ) : String;
var Buf: array[ 0..8 ] of Char;
    Dest : PChar;

    function HexDigit( B : Byte ) : Char;
    {$IFDEF F_P}
    const
      HexDigitChr: array[ 0..15 ] of Char = ( '0','1','2','3','4','5','6','7',
                                              '8','9','A','B','C','D','E','F' );
    begin
      Result := HexDigitChr[ B and $F ];
    end;
    {$ELSE DELPHI}
    asm
            {$IFDEF PARANOIA}
             DB $3C,9
             {$ELSE}
             CMP  AL,9
             {$ENDIF}
             JA   @@1
             {$IFDEF PARANOIA}
             DB $04, $30-$41+$0A
             {$ELSE}
             ADD  AL,30h-41h+0Ah
             {$ENDIF}
    @@1:
             {$IFDEF PARANOIA}
             DB $04, $41-$0A
             {$ELSE}
             ADD  AL,41h-0Ah
             {$ENDIF}
    end;
    {$ENDIF F_P/DELPHI}
begin
  Dest := @Buf[ 8 ];
  Dest^ := #0;
  repeat
    Dec( Dest );
    Dest^ := '0';
    if Value <> 0 then
    begin
      Dest^ := HexDigit( Value and $F );
      Value := Value shr 4;
    end;
    Dec( Digits );
  until (Value = 0) and (Digits <= 0);
  Result := Dest;
end;
{$ENDIF ASM_VERSION}
//[END Int2Hex]

//[FUNCTION Hex2Int]
{$IFDEF ASM_VERSION}
function Hex2Int( const Value : String) : Integer;
asm
        CALL     EAX2PChar
        PUSH     ESI
        XCHG     ESI, EAX
        XOR      EDX, EDX
        TEST     ESI, ESI
        JE       @@exit
        LODSB
        {$IFDEF PARANOIA}
        DB $3C, '$'
        {$ELSE}
        CMP      AL, '$'
        {$ENDIF}
        JNE      @@1
@@0:    LODSB
@@1:    TEST     AL, AL
        JE       @@exit
        {$IFDEF PARANOIA}
        DB $2C, '0'
        {$ELSE}
        SUB      AL, '0'
        {$ENDIF}
        {$IFDEF PARANOIA}
        DB $3C, 9
        {$ELSE}
        CMP      AL, '9' - '0'
        {$ENDIF}
        JBE      @@3

        {$IFDEF PARANOIA}
        DB $2C, $11
        {$ELSE}
        SUB      AL, 'A' - '0'
        {$ENDIF}
        {$IFDEF PARANOIA}
        DB $3C, 5
        {$ELSE}
        CMP      AL, 'F' - 'A'
        {$ENDIF}
        JBE      @@2

        {$IFDEF PARANOIA}
        DB $2C, 32
        {$ELSE}
        SUB      AL, 32
        {$ENDIF}
        {$IFDEF PARANOIA}
        DB $3C, 5
        {$ELSE}
        CMP      AL, 'F' - 'A'
        {$ENDIF}
        JA       @@exit
@@2:
        {$IFDEF PARANOIA}
        DB $04, 0Ah
        {$ELSE}
        ADD      AL, 0Ah
        {$ENDIF}
@@3:
        SHL      EDX, 4
        ADD      DL, AL
        JMP      @@0

@@exit: XCHG     EAX, EDX
        POP      ESI
end;
{$ELSE ASM_VERSION} //Pascal
function Hex2Int( const Value : String) : Integer;
var I : Integer;
begin
  Result := 0;
  I := 1;
  if Value = '' then Exit;
  if Value[ 1 ] = '$' then Inc( I );
  while I <= Length( Value ) do
  begin
    if Value[ I ] in [ '0'..'9' ] then
       Result := (Result shl 4) or (Ord(Value[I]) - Ord('0'))
    else
    if Value[ I ] in [ 'A'..'F' ] then
       Result := (Result shl 4) or (Ord(Value[I]) - Ord('A') + 10)
    else
    if Value[ I ] in [ 'a'..'f' ] then
       Result := (Result shl 4) or (Ord(Value[I]) - Ord('a') + 10)
    else
      break;
    Inc( I );
  end;
end;
{$ENDIF ASM_VERSION}
//[END Hex2Int]

//[FUNCTION cHex2Int]
{$IFDEF ASM_VERSION}
function cHex2Int( const Value : String) : Integer;
asm
     TEST  EAX, EAX
     JZ    @@exit
     CMP   word ptr [EAX], '0x'
     JZ    @@skip_2_chars
     CMP   word ptr [EAX], '0X'
     JNZ   @@2Hex2Int
@@skip_2_chars:
     INC   EAX
     INC   EAX
@@2Hex2Int:
     JMP   Hex2Int
@@exit:
end;
{$ELSE ASM_VERSION}
function cHex2Int( const Value : String) : Integer;
begin
  if StrEq( Copy( Value, 1, 2 ), '0x' ) then
    Result := Hex2Int( CopyEnd( Value, 3 ) )
  else Result := Hex2Int( Value );
end;
{$ENDIF ASM_VERSION}
//[END cHex2Int]

//[FUNCTION Int2Str]
{$IFDEF ASM_VERSION}
function Int2Str( Value : Integer ) : String;
asm
        XOR       ECX, ECX
        PUSH      ECX
        ADD       ESP, -0Ch

        PUSH      EBX
        LEA       EBX, [ESP + 15 + 4]
        PUSH      EDX
        CMP       EAX, ECX
        PUSHFD
        JGE       @@1
        NEG       EAX
@@1:
        MOV       CL, 10

@@2:
        DEC       EBX
        XOR       EDX, EDX
        DIV       ECX
        ADD       DL, 30h
        MOV       [EBX], DL
        TEST      EAX, EAX
        JNZ       @@2

        POPFD
        JGE       @@3

        DEC       EBX
        MOV       byte ptr [EBX], '-'
@@3:
        POP       EAX
        MOV       EDX, EBX
        CALL      System.@LStrFromPChar

        POP       EBX
        ADD       ESP, 10h
end;
{$ELSE ASM_VERSION} //Pascal
function Int2Str( Value : Integer ) : String;
var Buf : array[ 0..15 ] of Char;
    Dst : PChar;
    Minus : Boolean;
    D: DWORD;
begin
  Dst := @Buf[ 15 ];
  Dst^ := #0;
  Minus := False;
  if Value < 0 then
  begin
    Value := -Value;
    Minus := True;
  end;
  D := Value;
  repeat
    Dec( Dst );
    Dst^ := Char( (D mod 10) + Byte( '0' ) );
    D := D div 10;
  until D = 0;
  if Minus then
  begin
    Dec( Dst );
    Dst^ := '-';
  end;
  Result := Dst;
end;
{$ENDIF ASM_VERSION}
//[END Int2Str]

//[function UInt2Str]
function UInt2Str( Value: DWORD ): String;
var Buf : array[ 0..15 ] of Char;
    Dst : PChar;
    D: DWORD;
begin
  Dst := @Buf[ 15 ];
  Dst^ := #0;
  D := Value;
  repeat
    Dec( Dst );
    Dst^ := Char( (D mod 10) + Byte( '0' ) );
    D := D div 10;
  until D = 0;
  Result := Dst;
end;

//[function Int2StrEx]
function Int2StrEx( Value, MinWidth: Integer ): String;
begin
  Result := Int2Str( Value );
  while Length( Result ) < MinWidth do
    Result := ' ' + Result;
end;

//[function Int2Rome]
function Int2Rome( Value: Integer ): String;
const RomeDigs: String = 'IVXLCDMT';
  function RomeNum( N, FromIdx: Integer ): String;
  begin
    CASE N OF
    1, 2, 3:    Result := StrRepeat( RomeDigs[ FromIdx ], N );
    4:          Result := RomeDigs[ FromIdx ] + RomeDigs[ FromIdx + 1 ];
    5, 6, 7, 8: Result := RomeDigs[ FromIdx + 1 ] + StrRepeat( RomeDigs[ FromIdx ],
                       N - 5 );
    9:          Result := RomeDigs[ FromIdx ] + RomeDigs[ FromIdx + 2 ]
    else Result := '';
    END;
  end;
var I, J: Integer;
begin
  Result := '';
  if Value < 1 then Exit;
  if Value > 8999 then Exit;
  // maximum possible is TMMMCMXCIX, i.e. 8999
  J := 1;
  for I := 1 to 3 do
  begin
    Result := RomeNum( Value mod 10, J ) + Result;
    Value := Value div 10;
    if Value = 0 then Exit;
    Inc( J, 2 );
  end;
end;

//[FUNCTION Int2Ths]
{$IFDEF ASM_VERSION}
function Int2Ths( I : Integer ) : String;
asm
        PUSH     EBP
        MOV      EBP, ESP
        PUSH     EAX
        PUSH     EDX
        CALL     Int2Str
        POP      EDX
        POP      EAX
        CMP      EAX, 1000
        JL       @@Exit
        PUSH     EDX
        MOV      EAX, [EDX]
        PUSH     EAX
        CALL     System.@LStrLen         // EAX = Length(Result)
        POP      EDX
        PUSH     EDX                     // EDX = @Result[ 1 ]
        XOR      ECX, ECX

@@1:
        ROL      ECX, 8
        DEC      EAX
        MOV      CL, [EDX+EAX]
        JZ       @@fin
        CMP      ECX, 300000h
        JL       @@1

        PUSH     ECX
        XOR      ECX, ECX
        MOV      CL, ','
        JMP      @@1

@@fin:  CMP      CX, ',-'
        JNE      @@fin1
        MOV      CH, 0                   // this corrects -,ddd,...
@@fin1: CMP      ECX, 01000000h
        JGE      @@fin2
        INC      EAX
        ROL      ECX, 8
        JMP      @@fin1
@@fin2: PUSH     ECX

        LEA      EDX, [ESP+EAX]
        MOV      EAX, [EBP-4]
        CALL     System.@LStrFromPChar
@@Exit:
        MOV      ESP, EBP
        POP      EBP
end;
{$ELSE ASM_VERSION} //Pascal
function Int2Ths( I : Integer ) : String;
var S : String;
begin
  S := Int2Str( I );
  Result := '';
  while S <> '' do
  begin
    if Result <> '' then
       Result := ',' + Result;
    Result := CopyTail( S, 3 ) + Result;
    S := Copy( S, 1, Length( S ) - 3 );
  end;
  if Copy( Result, 1, 2 ) = '-,' then
     Result := '-' + CopyEnd( Result, 3 );
end;
{$ENDIF ASM_VERSION}
//[END Int2Ths]

//[FUNCTION Int2Digs]
{$IFDEF ASM_VERSION}
function Int2Digs( Value, Digits : Integer ) : String;
asm
        PUSH     EBP
        MOV      EBP, ESP
        PUSH     EDX             // [EBP-4] = Digits
        PUSH     ECX
        MOV      EDX, ECX
        CALL     Int2Str
        POP      ECX
        PUSH     ECX             // [EBP-8] = @Result
        MOV      EAX, [ECX]
        PUSH     EAX
        CALL     System.@LStrLen
        POP      EDX             // EDX = @Result[1]
        MOV      ECX, EAX        // ECX = Length( Result )
        ADD      EAX, EAX
        SUB      ESP, EAX
        MOV      EAX, ESP
        PUSHAD
        CALL     StrCopy
        POPAD
        MOV      EDX, EAX
        ADD      ESP, -100
        CMP      byte ptr [EDX], '-'
        PUSHFD
        JNE      @@1
        INC      EDX
@@1:
        MOV      EAX, [EBP-4]    // EAX = Digits
        CMP      ECX, EAX
        JGE      @@2
        DEC      EDX
        MOV      byte ptr [EDX], '0'
        INC      ECX
        JMP      @@1
@@2:
        POPFD
        JNE      @@3
        DEC      EDX
        MOV      byte ptr [EDX], '-'
@@3:
        MOV      EAX, [EBP-8]
        CALL     System.@LStrFromPChar
        MOV      ESP, EBP
        POP      EBP
end;
{$ELSE ASM_VERSION} //Pascal
function Int2Digs( Value, Digits : Integer ) : String;
var M : String;
begin
  Result := Int2Str( Value );
  M := '';
  if Value < 0 then
  begin
    M := '-';
    Result := CopyEnd( Result, 2 );
  end;
  if Digits >= 0 then
    while Length( M + Result ) < Digits do
          Result := '0' + Result
  else
    while Length( Result ) < -Digits do
          Result := '0' + Result;
  Result := M + Result;
end;
{$ENDIF ASM_VERSION}
//[END Int2Digs]

//[FUNCTION Num2Bytes]
{$IFDEF ASM_VERSION}
function Num2Bytes( Value : Double ) : String;
asm
        PUSH     EBX
        PUSH     ESI
        PUSH     EDI
        MOV      EBX, ESP
        MOV      ESI, EAX

        MOV      ECX, 4
        MOV      EDX, 'TGMk'
@@1:
        FLD      [Value]
@@10:
        FICOM    dword ptr [@@1024]
        FSTSW    AX
        SAHF
        JB       @@2

        FIDIV    dword ptr [@@1024]
        FST      [Value]
        WAIT

        TEST     DL, 20h
        JE       @@ror
        AND      DL, not 20h
        JMP      @@nxt
@@1024: DD       1024
@@100:  DD       100

@@ror:
        ROR      EDX, 8
@@nxt:
        LOOP     @@10
@@2:
        TEST     DL, 20h
        JZ       @@3
        MOV      DL, 0
@@3:    MOV      DH, 0
        PUSH     DX
        MOV      EDI, ESP

        FLD      ST(0)
        CALL     System.@TRUNC
        {$IFDEF _D2orD3}
        PUSH     0
        {$ELSE}
        PUSH     EDX
        {$ENDIF}
        PUSH     EAX
        FILD     qword ptr [ESP]
        POP      EDX
        POP      EDX

        MOV      EDX, ESI
        CALL     Int2Str

        FSUBP    ST(1), ST
        FIMUL    dword ptr [@@100]
        CALL     System.@TRUNC

        TEST     EAX, EAX
        JZ       @@4

        XOR      ECX, ECX
        MOV      CL, 0Ah
        CDQ
        IDIV     ECX
        TEST     EDX, EDX
        JZ       @@5

        MOV      AH, DL
        SHL      EAX, 16
        ADD      EAX, '00. '
        PUSH     EAX
        MOV      EDI, ESP
        INC      EDI
        JMP      @@4

@@5:    SHL      EAX, 8
        ADD      AX, '0.'
        PUSH     AX
        MOV      EDI, ESP

@@4:
        MOV      EAX, [ESI]
        CALL     System.@LStrLen
        ADD      ESP, -100

        SUB      EDI, EAX
        PUSH     ESI
        PUSH     EDI
        MOV      ESI, [ESI]
        MOV      ECX, EAX
        REP      MOVSB

        POP      EDX
        POP      EAX
        CALL     System.@LStrFromPChar

        MOV      ESP, EBX
        POP      EDI
        POP      ESI
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function Num2Bytes( Value : Double ) : String;
const Suffix = 'KMGT';
var V, I : Integer;
begin
  Result := '';
  I := 0;
  while (Value >= 1024) and (I < 4) do
  begin
    Inc( I );
    Value := Value / 1024.0;
  end;
  Result := Int2Str( Trunc( Value ) );
  V := Trunc( (Value - Trunc( Value )) * 100 );
  if V <> 0 then
  begin
    if (V mod 10) = 0 then
       V := V div 10;
    Result := Result + ',' + Int2Str( V );
  end;
  if I > 0 then
     Result := Result + Suffix[ I ];
end;
{$ENDIF ASM_VERSION}
//[END Num2Bytes]

//[FUNCTION S2Int]
{$IFDEF ASM_VERSION}
function S2Int( S: PChar ): Integer;
asm
        XCHG     EDX, EAX
        XOR      EAX, EAX
        TEST     EDX, EDX
        JZ       @@exit

        XOR      ECX, ECX
        MOV      CL, [EDX]
        INC      EDX
        CMP      CL, '-'
        PUSHFD
        JE       @@0
@@1:    CMP      CL, '+'
        JNE      @@2
@@0:    MOV      CL, [EDX]
        INC      EDX
@@2:    SUB      CL, '0'
        CMP      CL, '9'-'0'
        JA       @@fin
        LEA      EAX, [EAX+EAX*4] //
        LEA      EAX, [ECX+EAX*2] //
        JMP      @@0
@@fin:  POPFD
        JNE      @@exit
        NEG      EAX
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
function S2Int( S: PChar ): Integer;
var M : Integer;
begin
   Result := 0;
   if S = '' then Exit;
   M := 1;
   if S^ = '-' then
   begin
      M := -1;
      Inc( S );
   end
     else
   if S^ = '+' then
     Inc( S );
   while S^ in [ '0'..'9' ] do
   begin
      Result := Result * 10 + Integer( S^ ) - Integer( '0' );
      Inc( S );
   end;
   if M < 0 then
      Result := -Result;
end;
{$ENDIF ASM_VERSION}
//[END S2Int]

//[FUNCTION Str2Int]
{$IFDEF ASM_VERSION}
function Str2Int(const Value : String) : Integer;
asm
        CALL     EAX2PChar
        CALL     S2Int
end;
{$ELSE ASM_VERSION} //Pascal
function Str2Int(const Value : String) : Integer;
begin
  Result := S2Int( PChar( Value ) );
end;
{$ENDIF ASM_VERSION}
//[END Str2Int]

//[function StrCopy]
function StrCopy( Dest, Source: PChar ): PChar; assembler;
asm
  {$IFDEF F_P}
        MOV     EAX, [Dest]
        MOV     EDX, [Source]
  {$ENDIF F_P}
        PUSH    EDI
        PUSH    ESI
        MOV     ESI,EAX
        MOV     EDI,EDX
        OR      ECX, -1
        XOR     AL,AL
        REPNE   SCASB
        NOT     ECX
        MOV     EDI,ESI
        MOV     ESI,EDX
        MOV     EDX,ECX
        MOV     EAX,EDI
        SHR     ECX,2
        REP     MOVSD
        MOV     ECX,EDX
        AND     ECX,3
        REP     MOVSB
        POP     ESI
        POP     EDI
end {$IFDEF F_P} [ 'EAX', 'EDX', 'ECX' ] {$ENDIF};

//[function StrScan]
function StrScan(Str: PChar; Chr: Char): PChar; assembler;
asm
  {$IFDEF F_P}
  MOV   EAX, [Str]
  MOVZX EDX, [Chr]
  {$ENDIF}
        PUSH    EDI
        PUSH    EAX
        MOV     EDI,Str
        OR      ECX, -1
        XOR     AL,AL
        REPNE   SCASB
        NOT     ECX
        POP     EDI
        XCHG    EAX, EDX
        REPNE   SCASB

        XCHG    EAX, EDI
        POP     EDI

        JE      @@1
        XOR     EAX, EAX
        RET

@@1:    DEC     EAX
end {$IFDEF F_P} [ 'EAX', 'EDX', 'ECX' ] {$ENDIF};

//[function StrRScan]
function StrRScan(const Str: PChar; Chr: Char): PChar; assembler;
asm
  {$IFDEF F_P}
        MOV     EAX, [Str]
        MOVZX   EDX, [Chr]
  {$ENDIF F_P}
        PUSH    EDI
        MOV     EDI,Str
        MOV     ECX,0FFFFFFFFH
        XOR     AL,AL
        REPNE   SCASB
        NOT     ECX
        STD
        DEC     EDI
        MOV     AL,Chr
        REPNE   SCASB
        MOV     EAX,0
        JNE     @@1
        MOV     EAX,EDI
        INC     EAX
@@1:    CLD
        POP     EDI
end {$IFDEF F_P} [ 'EAX', 'EDX', 'ECX' ] {$ENDIF};

//[function StrScanLen]
function StrScanLen(Str: PChar; Chr: Char; Len: Integer): PChar; assembler;
asm
  {$IFDEF F_P}
        MOV     EAX, [Str]
        MOVZX   EDX, [Chr]
        MOV     ECX, [Len]
  {$ENDIF F_P}
        PUSH    EDI
        XCHG    EDI, EAX
        XCHG    EAX, EDX
        REPNE   SCASB

        XCHG    EAX, EDI
        POP     EDI
        { -> EAX => to next character after found or to the end of Str,
             ZF = 0 if character found. }
end {$IFDEF F_P} [ 'EAX', 'EDX', 'ECX' ] {$ENDIF};

//[FUNCTION TrimLeft]
{$IFDEF ASM_VERSION}
function TrimLeft(const S: string): string;
asm
        XCHG     EAX, EDX
        CALL     EDX2PChar
        DEC      EDX
@@1:    INC      EDX
        MOVZX    ECX, byte ptr [EDX]
        JECXZ    @@fin
        CMP      CL, ' '
        JBE      @@1
@@fin:
        CALL     System.@LStrFromPChar
end;
{$ELSE ASM_VERSION} //Pascal
function TrimLeft(const S: string): string;
var
  I, L: Integer;
begin
  L := Length(S);
  I := 1;
  while (I <= L) and (S[I] <= ' ') do Inc(I);
  Result := Copy(S, I, Maxint);
end;
{$ENDIF ASM_VERSION}
//[END TrimLeft]

//[FUNCTION TrimRight]
{$IFDEF ASM_VERSION}
function TrimRight(const S: string): string;
asm
        PUSH     EDX
        PUSH     EAX

        PUSH     EAX
        CALL     System.@LStrLen
        XCHG     EAX, [ESP]
        //CALL     System.@LStrToPChar
        CALL     EAX2PChar
        POP      ECX
        INC      ECX
@@1:    DEC      ECX
        MOV      DL, [EAX+ECX]
        JZ       @@fin
        CMP      DL, ' '
        JBE      @@1
@@fin:
        INC      ECX
        POP      EAX
        XOR      EDX, EDX
        INC      EDX
        CALL     System.@LStrCopy
end;
{$ELSE ASM_VERSION} //Pascal
function TrimRight(const S: string): string;
var
  I: Integer;
begin
  I := Length(S);
  while (I > 0) and (S[I] <= ' ') do Dec(I);
  Result := Copy(S, 1, I);
end;
{$ENDIF ASM_VERSION}
//[END TrimRight]

//[FUNCTION Trim]
{$IFDEF ASM_VERSION}
function Trim( const S : string): string;
asm
        PUSH     EDX
        CALL     TrimRight
        POP      EDX
        MOV      EAX, [EDX]
        CALL     TrimLeft
end;
{$ELSE ASM_VERSION} //Pascal
function Trim( const S : string): string;
begin
   Result := TrimLeft( TrimRight( S ) );
end;
{$ENDIF ASM_VERSION}
//[END Trim]

//[function RemoveSpaces]
function RemoveSpaces( const S: String ): String;
var I: Integer;
begin
  Result := S;
  for I := Length( S ) downto 1 do
    if S[ I ] <= ' ' then Delete( Result, I, 1 );
end;

//[procedure Str2LowerCase]
procedure Str2LowerCase( S: PChar );
asm
  {$IFDEF F_P}
        MOV      EAX, [S]
  {$ENDIF}
        XOR      ECX, ECX
@@1:
        MOV      CL, byte ptr [EAX]
        JECXZ    @@exit
        SUB      CL, 'A'
        CMP      CL, 'Z'-'A'
        JA       @@2
        ADD      byte ptr [EAX], 32
@@2:    INC      EAX
        JMP      @@1
@@exit:
end {$IFDEF F_P} [ 'EAX', 'ECX' ] {$ENDIF};

//[FUNCTION LowerCase]
{$IFDEF ASM_VERSION}
function LowerCase(const S: string): string;
asm
        PUSH     ESI
        XCHG     EAX, EDX
        PUSH     EAX
        CALL     System.@LStrAsg
        POP      EAX

        CALL     UniqueString

        PUSH     EAX
        CALL     System.@LStrLen
        POP      ESI

        XCHG     ECX, EAX

        JECXZ    @@exit

@@go:
        LODSB
        {$IFDEF PARANOIA}
        DB $2C, 'A'
        {$ELSE}
        SUB      AL, 'A'
        {$ENDIF}
        {$IFDEF PARANOIA}
        DB $3C, 26
        {$ELSE}
        CMP      AL, 'Z'-'A'+1
        {$ENDIF}
        JNB      @@1

        ADD      byte ptr [ESI - 1], 20h
@@1:
        LOOP     @@go
@@exit:
        POP      ESI
end;
{$ELSE ASM_VERSION} //Pascal
function LowerCase(const S: string): string;
var I : Integer;
begin
  Result := S;
  for I := 1 to Length( S ) do
    if Result[ I ] in [ 'A'..'Z' ] then
       Inc( Result[ I ], 32 );
end;
{$ENDIF ASM_VERSION}
//[END LowerCase]

//[FUNCTION UpperCase]
{$IFDEF ASM_VERSION}
function UpperCase(const S: string): string;
asm
        PUSH     ESI
        XCHG     EAX, EDX
        PUSH     EAX
        CALL     System.@LStrAsg
        POP      EAX

        CALL     UniqueString

        PUSH     EAX
        CALL     System.@LStrLen
        POP      ESI

        XCHG     ECX, EAX

        JECXZ    @@exit

@@go:
        LODSB
        {$IFDEF PARANOIA}
        DB $2C, 'a'
        {$ELSE}
        SUB      AL, 'a'
        {$ENDIF}
        {$IFDEF PARANOIA}
        DB $3C, $1A
        {$ELSE}
        CMP      AL, 'z'-'a'+1
        {$ENDIF}
        JNB      @@1

        SUB      byte ptr [ESI - 1], 20h
@@1:
        LOOP     @@go
@@exit:
        POP      ESI
end;
{$ELSE ASM_VERSION} //Pascal
function UpperCase(const S: string): string;
var I : Integer;
begin
  Result := S;
  for I := 1 to Length( S ) do
    if Result[ I ] in [ 'a'..'z' ] then
       Dec( Result[ I ], 32 );
end;
{$ENDIF ASM_VERSION}
//[END UpperCase]

{$IFDEF F_P}
//[function DummyStrFun]
function DummyStrFun( const S: String ): String;
begin
  Result := S;
end;
{$ENDIF F_P}

//[FUNCTION CopyEnd]
{$IFDEF ASM_VERSION}
function CopyEnd( const S : String; Idx : Integer ) : String;
asm
        PUSH     ECX
        PUSH     EAX
        PUSH     EDX

        CALL     System.@LStrLen

        POP      EDX
        TEST     EDX, EDX
        JG       @@1
        XOR      EDX, EDX
        INC      EDX
@@1:
        SUB      EAX, EDX
        MOV      ECX, EAX

        POP      EAX
        JGE      @@ret_end

        POP      EAX
        JL       System.@LStrClr

@@ret_end:
        INC      ECX
        CALL     System.@LStrCopy
end;
{$ELSE ASM_VERSION} //Pascal
function CopyEnd( const S : String; Idx : Integer ) : String;
begin
  Result := Copy( S, Idx, MaxInt );
end;
{$ENDIF ASM_VERSION}
//[END CopyEnd]

//[FUNCTION CopyTail]
{$IFDEF ASM_VERSION}
function CopyTail( const S : String; Len : Integer ) : String;
asm
        PUSH     ECX
        PUSH     EAX
          PUSH     EDX
            CALL     System.@LStrLen
          POP      ECX
          CMP      ECX, EAX
          JLE      @@1
          MOV      ECX, EAX
@@1:
        MOV      EDX, EAX
        SUB      EDX, ECX
        INC      EDX
        POP      EAX
        CALL     System.@LStrCopy
end;
{$ELSE ASM_VERSION} //Pascal
function CopyTail( const S : String; Len : Integer ) : String;
var L : Integer;
begin
  L := Length( S );
  if L < Len then
     Len := L;
  Result := '';
  if Len = 0 then Exit;
  Result := Copy( S, L - Len + 1, Len );
end;
{$ENDIF ASM_VERSION}
//[END CopyTail]

//[PROCEDURE DeleteTail]
{$IFDEF ASM_VERSION}
procedure DeleteTail( var S : String; Len : Integer );
asm
        PUSH     EAX
        PUSH     EDX
        MOV      EAX, [EAX]
        CALL     System.@LStrLen
        POP      ECX
        CMP      ECX, EAX
        JLE      @@1
        MOV      ECX, EAX
@@1:    MOV      EDX, EAX
        SUB      EDX, ECX
        INC      EDX
        POP      EAX
        CALL     System.@LStrDelete
end;
{$ELSE ASM_VERSION} //Pascal
procedure DeleteTail( var S : String; Len : Integer );
var L : Integer;
begin
  L := Length( S );
  if Len > L then
     Len := L;
  Delete( S, L - Len + 1, Len );
end;
{$ENDIF ASM_VERSION}
//[END DeleteTail]

//[FUNCTION IndexOfChar]
{$IFDEF ASM_VERSION}
function IndexOfChar( const S : String; Chr : Char ) : Integer;
asm
        //PUSH     EDX
        //CALL     System.@LStrToPChar
        //POP      EDX
        CALL     EAX2PChar
        PUSH     EAX
        CALL     StrScan
        POP      EDX
        TEST     EAX, EAX
        JE       @@exit__1
        SUB      EAX, EDX
        INC      EAX
        RET
@@exit__1:
        DEC      EAX
end;
{$ELSE ASM_VERSION} //Pascal
function IndexOfChar( const S : String; Chr : Char ) : Integer;
var P, F : PChar;
begin
   P := PChar( S );
   F := StrScan( P, Chr );
   Result := -1;
   if F = nil then Exit;
   Result := Integer( F ) - Integer( P ) + 1;
end;
{$ENDIF ASM_VERSION}
//[END IndexOfChar]

//[FUNCTION IndexOfCharsMin]
{$IFDEF ASM_VERSION}
function IndexOfCharsMin( const S, Chars : String ) : Integer;
asm
        PUSH     ESI
        PUSH     EAX
        CALL     EDX2PChar
        MOV      ESI, EDX

        XOR      ECX, ECX
        DEC      ECX

@@1:    LODSB
        TEST     AL, AL
        JZ       @@exit

        XCHG     EDX, EAX
        POP      EAX
        PUSH     EAX

        PUSH     ECX
        CALL     IndexOfChar
        POP      ECX
        TEST     EAX, EAX
        JLE      @@1

        TEST     ECX, ECX
        JLE      @@2
        CMP      EAX, ECX
        JGE      @@1
@@2:    //XCHG     ECX, EAX
        //JMP      @@1

@@exit: XCHG     EAX, ECX
          JL     @@1
        POP      ECX
        POP      ESI
end;
{$ELSE ASM_VERSION} //Pascal
function IndexOfCharsMin( const S, Chars : String ) : Integer;
var I, J : Integer;
begin
  Result := -1;
  for I := 1 to Length( Chars ) do
  begin
    J := IndexOfChar( S, Chars[ I ] );
    if J > 0 then
    begin
      if (Result < 0) or (J < Result) then
         Result := J;
    end;
  end;
end;
{$ENDIF ASM_VERSION}
//[END IndexOfCharsMin]

{$IFNDEF _FPC}
{$IFNDEF _D2}
//[function IndexOfWideCharsMin]
function IndexOfWideCharsMin( const S, Chars : WideString ) : Integer;
var I, J : Integer;
begin
  Result := -1;
  for I := 1 to Length( Chars ) do
  begin
    J := pos( Chars[ I ], S );
    if J > 0 then
    begin
      if (Result < 0) or (J < Result) then
         Result := J;
    end;
  end;
end;
{$ENDIF _D2}
{$ENDIF _FPC}

//[FUNCTION IndexOfStr]
{$IFDEF ASM_VERSION}
function IndexOfStr( const S, Sub : String ) : Integer;
asm
        PUSH     EBX
        PUSH     ESI
        PUSH     EDI

        PUSH     EAX
        MOV      EAX, EDX
        PUSH     EDX
        CALL     System.@LStrLen
        MOV      EDI, EAX
        POP      EAX
        //CALL     System.@LStrToPChar
        CALL     EAX2PChar
        MOV      BL, [EAX]
        XCHG     EAX, [ESP]
        //CALL     System.@LStrToPChar
        CALL     EAX2PChar

        MOV      ESI, EAX

        DEC      EAX
@@1:    INC      EAX
        MOV      DL, BL
        CALL     StrScan
        TEST     EAX, EAX
        JE       @@exit__1

        POP      EDX
        PUSH     EDX

        MOV      ECX, EDI
        PUSH     EAX
        CALL     StrLComp
        POP      EAX
        JNE      @@1

        SUB      EAX, ESI
        INC      EAX
        JMP      @@exit

@@exit__1:
        DEC      EAX
@@exit:
        POP      EDX
        POP      EDI
        POP      ESI
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function IndexOfStr( const S, Sub : String ) : Integer;
var I : Integer;
begin
  Result := Length( S );
  if Sub = '' then Exit;
  Result := 0;
  if S = '' then Exit;
  if Length( Sub ) > Length( S ) then Exit;
  Result := 1;
  while Result + Length( Sub ) - 1 <= Length( S ) do
  begin
    I := IndexOfChar( CopyEnd( S, Result ), Sub[ 1 ] );
    if I <= 0 then break;
    Result := Result + I - 1;
    if Result <= 0 then Exit;
    if Copy( S, Result, Length( Sub ) ) = Sub then Exit;
    Inc( Result );
  end;
  Result := -1;
end;
{$ENDIF ASM_VERSION}
//[END IndexOfStr]

//[FUNCTION Parse]
{$IFDEF ASM_VERSION} //???
function Parse( var S : String; const Separators : String ) : String;
asm
         PUSH    EBX
         PUSH    EDI
         MOV     EBX, EAX

         PUSH    ECX
         MOV     EAX, [EBX]
         CALL    IndexOfCharsMin
         INC     EAX
         JNE     @@1
         MOV     EAX, [EBX]
         CALL    System.@LStrLen
         INC     EAX
         INC     EAX
@@1:
         DEC     EAX
         MOV     EDI, EAX
         MOV     ECX, EAX
         DEC     ECX
         XOR     EDX, EDX
         INC     EDX
         MOV     EAX, [EBX]
         CALL    System.@LStrCopy

         MOV     EAX, [EBX]
         MOV     EDX, EDI
         INC     EDX
         MOV     ECX, EBX
         CALL    CopyEnd

         POP     EDI
         POP     EBX
end;
{$ELSE ASM_VERSION} //Pascal
function Parse( var S : String; const Separators : String ) : String;
var Pos : Integer;
begin
  Pos := IndexOfCharsMin( S, Separators );
  if Pos <= 0 then
     Pos := Length( S ) + 1;
  Result := S;
  S := Copy( Result, Pos + 1, MaxInt );
  Result := Copy( Result, 1, Pos - 1 );
end;
{$ENDIF ASM_VERSION}
//[END Parse]

{$IFNDEF _FPC}
{$IFNDEF _D2}
//[function WParse]
function WParse( var S : WideString; const Separators : WideString ) : WideString;
var Pos : Integer;
begin
  Pos := IndexOfWideCharsMin( S, Separators );
  if Pos <= 0 then
     Pos := Length( S ) + 1;
  Result := S;
  S := Copy( Result, Pos + 1, MaxInt );
  Result := Copy( Result, 1, Pos - 1 );
end;
{$ENDIF _D2}
{$ENDIF _FPC}

//[function ParsePascalString]
function ParsePascalString( var S : String; const Separators : String ) : String;
var Pos, Idx : Integer;
    Hex, Spc : boolean;
    procedure SkipSpaces;
    begin
      if not Spc then
        while (Length( S ) >= Pos) and (S[ Pos ] = ' ') do
          Inc( Pos );
    end;
var Buf : String;
    Ou, Val : Integer;
begin
  Pos := 1;
  Spc := IndexOfChar( Separators, ' ' ) >= 0;
  SkipSpaces;
  if Length( S ) < Pos then
  begin
    Result := S;
    S := '';
    exit;
  end;
  Buf := PChar( S );
  Ou := 1;
  if S[ Pos ] in [ '''', '#' ] then
  begin
    // skip here string constant expression
    while Pos <= Length( S ) do
    begin
      if S[ Pos ] = '''' then
      begin
        Inc( Pos );
        while Pos <= Length( S ) do
        begin
          if S[ Pos ] = '''' then
            if (Pos = Length( S )) or (S[ Pos+1 ] <> '''') then
            begin
              Inc( Pos );
              break;
            end
            else Inc( Pos );
          Buf[ Ou ] := S[ Pos ];
          Inc( Ou );
          Inc( Pos );
        end;
        //if Pos < Length( S ) then Inc( Pos );
      end
         else
      if S[ Pos ] = '#' then
      begin
        Inc( Pos ); Hex := False; Val := 0;
        if (Pos < Length( S )) and (S[ Pos ] = '$') then
        begin
           Inc( Pos ); Hex := True;
        end;
        Dec( Pos );
        while Pos < Length( S ) do
        begin
          Inc( Pos );
          if (S[ Pos ] in [ '0'..'9' ]) or
             Hex and (S[ Pos ] in [ 'a'..'f', 'A'..'F' ]) then
          begin
            if Hex then
               Val := Val * 16
            else
               Val := Val * 10;
            if S[ Pos ] <= '9' then
               Val := Val + Integer( S[ Pos ] ) - Integer( '0' )
            else
            if S[ Pos ] <= 'F' then
               Val := Val + 10 + Integer( S[ Pos ] ) - Integer( 'A' )
            else
               Val := Val + 10 + Integer( S[ Pos ] ) - Integer( 'a' );
            continue;
          end;
          Inc( Pos ); break;
        end;
        Buf[ Ou ] := Char( Val );
        Inc( Ou );
      end
         else break;
      SkipSpaces;
      if S[ Pos ] <> '+' then break;
      SkipSpaces;
    end;
  end;
  Idx := IndexOfCharsMin( CopyEnd( S, Pos ), Separators );
  if Idx <= 0 then
  begin
    Result := Copy( Buf, 1, Ou - 1 ) + CopyEnd( S, Pos );
    S := '';
  end
     else
  begin
    Result := Copy( Buf, 1, Ou - 1 ) + Copy( S, Pos, Idx - 1 );
    S := CopyEnd( S, Pos + Idx );
  end;
end;

//[function String2PascalStrExpr]
function String2PascalStrExpr( const S : String ) : String;
var I, Strt : Integer;
  function String2DoubleQuotas( const S : String ) : String;
  var I, J : Integer;
  begin
    if IndexOfChar( S, '''' ) <= 0 then
       Result := S
    else
    begin
      J := 0;
      for I := 1 to Length( S ) do
        if S[ I ] = '''' then Inc( J );
      SetLength( Result, Length( S ) + J );
      J := 1;
      for I := 1 to Length( S ) do
      begin
        Result[ J ] := S[ I ];
        Inc( J );
        if S[ I ] = '''' then
        begin
          Result[ J ] := '''';
          Inc( J );
        end;
      end;
    end;
  end;
begin
  Result := '';
  if S = '' then
  begin
    Result := '''''';
    exit;
  end;
  Strt := 1;
  for I := 1 to Length( S ) + 1 do
  begin
    if (I > Length( S )) or (S[ I ] < ' ') then
    begin
      if (I > Strt) and (I > 1) then
      begin
        if Result <> '' then
           Result := Result + '+';
        Result := Result + '''' + String2DoubleQuotas( Copy( S, Strt, I - Strt ) ) + '''';
      end;
      if I > Length( S ) then break;
      if Result <> '' then
         Result := Result + '+'
      else
         Result := Result + '''''+';
      Result := Result + '#' + Int2Str( Integer( S[ I ] ) );
      Strt := I + 1;
    end;
  end;
end;

//[function CompareMem]
function CompareMem(P1, P2: Pointer; Length: Integer): Boolean; assembler;
asm
  {$IFDEF F_P}
        MOV     EAX, [P1]
        MOV     EDX, [P2]
        MOV     ECX, [Length]
  {$ENDIF}
        PUSH    ESI
        PUSH    EDI
        MOV     ESI,P1
        MOV     EDI,P2
        MOV     EDX,ECX
        XOR     EAX,EAX
        AND     EDX,3
        SHR     ECX,1
        SHR     ECX,1
        REPE    CMPSD
        JNE     @@2
        MOV     ECX,EDX
        REPE    CMPSB
        JNE     @@2
@@1:    INC     EAX
@@2:    POP     EDI
        POP     ESI
end {$IFDEF F_P} [ 'EAX', 'EDX', 'ECX' ] {$ENDIF};

//[FUNCTION AllocMem]
{$IFDEF ASM_VERSION}
function AllocMem( Size : Integer ) : Pointer;
asm     //cmd    //opd
        TEST     EAX, EAX
        JZ       @@exit
        PUSH     EAX
        CALL     System.@GetMem
        POP      EDX
        PUSH     EAX
        MOV      CL, 0
        CALL     System.@FillChar
        POP      EAX
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
function AllocMem( Size : Integer ) : Pointer;
begin
   Result := nil;
   if Size > 0 then
   begin
     GetMem( Result, Size );
     FillChar( Result^, Size, 0 );
   end;
end;
{$ENDIF ASM_VERSION}
//[END AllocMem]

//[procedure DisposeMem]
procedure DisposeMem( var Addr : Pointer );
begin
   if Addr <> nil then
      FreeMem( Addr );
   Addr := nil;
end;

//[function AnsiUpperCase]
function AnsiUpperCase(const S: string): string;
var
  Len: Integer;
begin
  Len := Length(S);
  SetString(Result, PChar(S), Len);
  if Len > 0 then CharUpperBuff(Pointer(Result), Len);
end;

//[function AnsiLowerCase]
function AnsiLowerCase(const S: string): string;
var
  Len: Integer;
begin
  Len := Length(S);
  SetString(Result, PChar(S), Len);
  if Len > 0 then CharLowerBuff(Pointer(Result), Len);
end;

{$IFNDEF _D2}
{$IFNDEF _FPC}
//[function WAnsiUpperCase]
function WAnsiUpperCase(const S: WideString): WideString;
var Len: Integer;
begin
  Len := Length(S);
  Result := S;
  if Len > 0 then CharUpperBuffW(Pointer(Result), Len);
end;

//[function WAnsiLowerCase]
function WAnsiLowerCase(const S: WideString): WideString;
var Len: Integer;
begin
  Len := Length(S);
  Result := S;
  if Len > 0 then CharLowerBuffW(Pointer(Result), Len);
end;
{$ENDIF _FPC}
{$ENDIF _D2}

//[function AnsiCompareStr]
function AnsiCompareStr(const S1, S2: string): Integer;
begin
  Result := CompareString(LOCALE_USER_DEFAULT, 0, PChar(S1), -1,
    PChar(S2), -1 ) - 2;
end;

//[function _AnsiCompareStr]
function _AnsiCompareStr(S1, S2: PChar): Integer;
begin
  Result := CompareString( LOCALE_USER_DEFAULT, 0, S1, -1,
                           S2, -1) - 2;
end;

//[function AnsiCompareStrNoCase]
function AnsiCompareStrNoCase(const S1, S2: string): Integer;
begin
  Result := CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE, PChar(S1), -1,
    PChar(S2), -1 ) - 2;
end;

//[function _AnsiCompareStrNoCase]
function _AnsiCompareStrNoCase(S1, S2: PChar): Integer;
begin
  Result := CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE, S1, -1,
                           S2, -1) - 2;
end;

//[function AnsiCompareText]
function AnsiCompareText( const S1, S2: String ): Integer;
begin
  Result := AnsiCompareStrNoCase( S1, S2 );
end;

//[function StrLCopy]
function StrLCopy(Dest: PChar; const Source: PChar; MaxLen: Cardinal): PChar; assembler;
asm
  {$IFDEF F_P}
        MOV     EAX, [Dest]
        MOV     EDX, [Source]
        MOV     ECX, [MaxLen]
  {$ENDIF F_P}
        PUSH    EDI
        PUSH    ESI
        PUSH    EBX
        MOV     ESI,EAX
        MOV     EDI,EDX
        MOV     EBX,ECX
        XOR     AL,AL
        TEST    ECX,ECX
        JZ      @@1
        REPNE   SCASB
        JNE     @@1
        INC     ECX
@@1:    SUB     EBX,ECX
        MOV     EDI,ESI
        MOV     ESI,EDX
        MOV     EDX,EDI
        MOV     ECX,EBX
        SHR     ECX,2
        REP     MOVSD
        MOV     ECX,EBX
        AND     ECX,3
        REP     MOVSB
        STOSB
        MOV     EAX,EDX
        POP     EBX
        POP     ESI
        POP     EDI
end {$IFDEF F_P} [ 'EAX', 'EDX', 'ECX' ] {$ENDIF};

//[FUNCTION StrPCopy]
{$IFDEF ASM_VERSION}
function StrPCopy(Dest: PChar; const Source: string): PChar;
asm
        PUSH     EAX
        MOV      EAX, EDX
        CALL     System.@LStrLen
        MOV      ECX, EAX
        POP      EAX
        CALL     EDX2PChar
        CALL     StrLCopy
end;
{$ELSE ASM_VERSION} //Pascal
function StrPCopy(Dest: PChar; const Source: string): PChar;
begin
  Result := StrLCopy(Dest, PChar(Source), Length(Source));
end;
{$ENDIF ASM_VERSION}
//[END StrPCopy]

//[FUNCTION StrEq]
{$IFDEF ASM_VERSION}
function StrEq( const S1, S2 : String ) : Boolean;
asm
        TEST     EDX, EDX
        JNZ      @@1
@@0:    CMP      EAX, EDX
        JMP      @@exit
@@1:    TEST     EAX, EAX
        JZ       @@0
        MOV      ECX, [EAX-4]
        CMP      ECX, [EDX-4]
        JNE      @@exit
        PUSH     EAX
        PUSH     EDX
        PUSH     0
        MOV      EDX, ESP
        CALL     LowerCase
        PUSH     0
        MOV      EAX, [ESP + 8]
        MOV      EDX, ESP
        CALL     LowerCase
        POP      EAX
        POP      EDX
        PUSH     EDX
        PUSH     EAX
        CALL     System.@LStrCmp
        MOV      EAX, ESP
        PUSHFD
        XOR      EDX, EDX
        MOV      DL, 2
        CALL     System.@LStrArrayClr
        POPFD
        POP      EDX
        POP      EDX
        POP      EDX
        POP      EDX
@@exit:
        SETZ     AL
end;
{$ELSE ASM_VERSION} //Pascal
function StrEq( const S1, S2 : String ) : Boolean;
begin
  Result := (Length( S1 ) = Length( S2 )) and
            (LowerCase( S1 ) = LowerCase( S2 ));
end;
{$ENDIF ASM_VERSION}
//[END StrEq]

//[FUNCTION AnsiEq]
{$IFDEF ASM_VERSION}
function AnsiEq( const S1, S2 : String ) : Boolean;
asm
        CALL     AnsiCompareStrNoCase
        TEST     EAX, EAX
        SETZ     AL
end;
{$ELSE ASM_VERSION} //Pascal
function AnsiEq( const S1, S2 : String ) : Boolean;
begin
  Result := AnsiCompareStrNoCase( S1, S2 ) = 0;
end;
{$ENDIF ASM_VERSION}
//[END AnsiEq]

{$IFNDEF _D2}
{$IFNDEF _FPC}
//[function WAnsiEq]
function WAnsiEq( const S1, S2 : WideString ) : Boolean;
begin
  Result := WAnsiLowerCase( S1 )=WAnsiLowerCase( S2 );
end;
{$ENDIF _FPC}
{$ENDIF _D2}

//[FUNCTION StrIn]
{$IFDEF ASM_VERSION}
function StrIn(const S: String; const A: array of String): Boolean;
asm
@@1:
        TEST     ECX, ECX
        JL       @@ret_0

        PUSH     EDX
        MOV      EDX, [EDX+ECX*4]
        DEC      ECX

        PUSH     ECX
        PUSH     EAX
        CALL     StrEq
        DEC      AL
        POP      EAX
        POP      ECX

        POP      EDX
        JNZ      @@1

        MOV      AL, 1
        RET

@@ret_0:XOR      EAX, EAX
end;
{$ELSE ASM_VERSION} //Pascal
function StrIn(const S: String; const A: array of String): Boolean;
var I : Integer;
begin
  for I := Low( A ) to High( A ) do
      if StrEq( S, A[ I ] ) then
      begin
        Result := True;
        Exit;
      end;
  Result := False;
end;
{$ENDIF ASM_VERSION}
//[END StrIn]

{$IFNDEF _D2}
{$IFNDEF _FPC}
//[function WStrIn]
function WStrIn( const S : WideString; const A : array of WideString ) : Boolean;
var I : Integer;
begin
  for I := Low( A ) to High( A ) do
      if WAnsiEq( S, A[ I ] ) then
      begin
        Result := True;
        Exit;
      end;
  Result := False;
end;
{$ENDIF _FPC}
{$ENDIF _D2}

//[function StrIs]
function StrIs( const S : String; const A : array of String; var Idx: Integer ) : Boolean;
var I : Integer;
begin
  Idx := -1;
  for I := Low( A ) to High( A ) do
      if StrEq( S, A[ I ] ) then
      begin
        Idx := I;
        Result := True;
        Exit;
      end;
  Result := False;
end;

//[function IntIn]
function IntIn( Value: Integer; const List: array of Integer ): Boolean;
var I: Integer;
begin
  Result := FALSE;
  for I := 0 to High( List ) do
  begin
    if Value = List[ I ] then
    begin
      Result := TRUE;
      break;
    end;
  end;
end;

//[FUNCTION _StrSatisfy]
{$IFDEF ASM_VERSION}
function _StrSatisfy( S, Mask : PChar ) : Boolean;
asm
        XCHG     ECX, EAX
        //       EDX <- Mask
        //       ECX <- S
        XOR      EAX, EAX
        MOV      AL, '*'
@@rest_satisfy:
        PUSH     ECX
        PUSH     EDX

@@nx_char:
        MOV      AH, [EDX]
        OR       AH, [ECX]
        JZ       @@fin //@@ret_true

        MOV      AH, 0

        CMP      word ptr [EDX], AX //'*'
        JE       @@fin //@@ret_true

        CMP      byte ptr [ECX], AH
        JNE      @@10

        DEC      EDX
@@1:
        INC      EDX
        CMP      byte ptr [EDX], AL //'*'
        JE       @@1
        //CMP      byte ptr [EDX], '?'
        //JE       @@1

        CMP      byte ptr [EDX], AH
        SETZ     AL
        JMP      @@fin

@@10:   CMP      byte ptr [EDX], AH
        JE       @@ret_false

        CMP      byte ptr [EDX], '?'
        JNE      @@11

@@go_nx_char:
        INC      ECX
        INC      EDX
        JMP      @@nx_char

@@11:
        CMP      byte ptr [EDX], AL //'*'
        JNE      @@20

        INC      EDX
@@12:   CMP      byte ptr [ECX], AH
        JE       @@ret_false

        CALL     @@rest_satisfy
        TEST     AL, AL
        JNE      @@fin
        MOV      AL, '*'

        INC      ECX
        JMP      @@12

@@20:   MOV      AH, [EDX]
        XOR      AH, [ECX]

        JE       @@go_nx_char
@@ret_false:
        XOR      EAX, EAX

@@fin:
        POP      EDX
        POP      ECX
end;
{$ELSE ASM_VERSION} //Pascal
function _StrSatisfy( S, Mask : PChar ) : Boolean;
label next_char;
begin
next_char:
  Result := True;
  if (S^ = #0) and (Mask^ = #0) then exit;
  if (Mask^ = '*') and (Mask[1] = #0) then exit;
  if S^ = #0 then
  begin
    while Mask^ = '*' do
          Inc( Mask );
    Result := Mask^ = #0;
    exit;
  end;
  Result := False;
  if Mask^ = #0 then exit;
  if Mask^ = '?' then
  begin
    Inc( S ); Inc( Mask ); goto next_char;
  end;
  if Mask^ = '*' then
  begin
    Inc( Mask );
    while S^ <> #0 do
    begin
      Result := _StrSatisfy( S, Mask );
      if Result then exit;
      Inc( S );
    end;
    exit; // (Result = False)
  end;
  Result := S^ = Mask^;
  Inc( S ); Inc( Mask );
  if Result then goto next_char;
end;
{$ENDIF ASM_VERSION}
//[END _StrSatisfy]

//[FUNCTION StrSatisfy]
{$IFDEF ASM_VERSION}
function StrSatisfy( const S, Mask: String ): Boolean;
asm
        PUSH     ESI
        XCHG     ESI, EAX
        PUSH     0
        XCHG     EAX, EDX
        CALL     EAX2PChar
        MOV      EDX, ESP
        CALL     AnsiLowerCase

        XCHG     EAX, ESI
        PUSH     0
        CALL     EAX2PChar
        MOV      EDX, ESP
        CALL     AnsiLowerCase

        POP      EAX
        POP      EDX
        PUSH     EDX
        PUSH     EAX
        CALL     _StrSatisfy

        XCHG     ESI, EAX

        CALL     RemoveStr
        CALL     RemoveStr
        XCHG     EAX, ESI

        POP      ESI
end;
{$ELSE ASM_VERSION} //Pascal
function StrSatisfy( const S, Mask: String ): Boolean;
begin
  Result := _StrSatisfy( PChar( AnsiLowerCase( S ) ),
                         PChar( AnsiLowerCase( Mask ) ) );
end;
{$ENDIF ASM_VERSION}
//[END StrSatisfy]

//[FUNCTION _2StrSatisfy]
{$IFDEF ASM_VERSION}
function _2StrSatisfy( S, Mask: PChar ): Boolean;
asm     //     //
        PUSH   EBX
        XCHG   EBX, EAX
        PUSH   0
        MOV    EAX, ESP
        CALL   System.@LStrFromPChar
        PUSH   0
        MOV    EAX, ESP
        MOV    EDX, EBX
        CALL   System.@LStrFromPChar
        POP    EAX
        POP    EDX
        PUSH   EDX
        PUSH   EAX
        CALL   StrSatisfy
        XCHG   EBX, EAX
        CALL   RemoveStr
        CALL   RemoveStr
        XCHG   EAX, EBX
        POP    EBX
end;
{$ELSE ASM_VERSION} // Pascal
function _2StrSatisfy( S, Mask: PChar ): Boolean;
begin
  Result := StrSatisfy( S, Mask );
end;
{$ENDIF ASM_VERSION}
//[END _2StrSatisfy]

//[function StrReplace]
function StrReplace( var S: String; const From, ReplTo: String ): Boolean;
var I: Integer;
begin
  I := pos( From, S );
  if I > 0 then
  begin
    S := Copy( S, 1, I - 1 ) + ReplTo + CopyEnd( S, I + Length( From ) );
    Result := TRUE;
  end
  else Result := FALSE;
end;


//[function StrRepeat]
function StrRepeat( const S: String; Count: Integer ): String;
var I, L: Integer;
begin
  L := Length( S );
  SetLength( Result, L * Count );
  for I := 0 to Count-1 do
    Move( S[ 1 ], Result[ 1 + I * L ], L );
end;


//[PROCEDURE NormalizeUnixText]
{$IFDEF ASM_VERSION}
procedure NormalizeUnixText( var S: String );
asm     //cmd    //opd
        CMP      dword ptr [EAX], 0
        JZ       @@exit
        PUSH     EBX
        PUSH     EDI
        MOV      EBX, EAX
        CALL     UniqueString
        MOV      EDI, [EBX]
@@1:    MOV      EAX, EDI
        CALL     System.@LStrLen
        XCHG     ECX, EAX
        MOV      AX, $0D0A

        CMP      byte ptr [EDI], AL
        JNE      @@loo
        MOV      byte ptr [EDI], AH
@@loo:
        TEST     ECX, ECX
        JZ       @@fin
@@loo1:
        REPNZ SCASB
        JNZ      @@fin
        CMP      byte ptr [EDI-2], AH
        JE       @@loo
        MOV      byte ptr [EDI-1], AH
        JNE      @@loo1
@@fin:  POP      EDI
        POP      EBX
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure NormalizeUnixText( var S: String );
var I: Integer;
begin
  if S <> '' then
  begin
    if S[ 1 ] = #10 then
      S[ 1 ] := #13;
    for I := 2 to Length(S) do
      if (S[I]=#10) and (S[I-1]<>#13) then
        S[I] := #13;
  end;
end;
{$ENDIF ASM_VERSION}
//[END NormalizeUnixText]

//[function StrComp]
function StrComp(const Str1, Str2: PChar): Integer; assembler;
asm
  {$IFDEF F_P}
        MOV     EAX, [Str1]
        MOV     EDX, [Str2]
  {$ENDIF F_P}
        PUSH    EDI
        PUSH    ESI
        MOV     EDI,EDX
        XCHG    ESI,EAX
        OR      ECX, -1
        XOR     EAX,EAX
        REPNE   SCASB
        NOT     ECX
        MOV     EDI,EDX
        XOR     EDX,EDX
        REPE    CMPSB
        MOV     AL,[ESI-1]
        MOV     DL,[EDI-1]
        SUB     EAX,EDX
        POP     ESI
        POP     EDI
end {$IFDEF F_P} [ 'EAX', 'EDX', 'ECX' ] {$ENDIF};

//[function StrLComp]
function StrLComp(const Str1, Str2: PChar; MaxLen: Cardinal): Integer; assembler;
asm
  {$IFDEF F_P}
        MOV     EAX, [Str1]
        MOV     EDX, [Str2]
        MOV     ECX, [MaxLen]
  {$ENDIF F_P}
        PUSH    EDI
        PUSH    ESI
        PUSH    EBX
        MOV     EDI,EDX
        MOV     ESI,EAX
        MOV     EBX,ECX
        XOR     EAX,EAX
        OR      ECX,ECX
        JE      @@1
        REPNE   SCASB
        SUB     EBX,ECX
        MOV     ECX,EBX
        MOV     EDI,EDX
        XOR     EDX,EDX
        REPE    CMPSB
        MOV     AL,[ESI-1]
        MOV     DL,[EDI-1]
        SUB     EAX,EDX
@@1:    POP     EBX
        POP     ESI
        POP     EDI
end {$IFDEF F_P} [ 'EAX', 'EDX', 'ECX' ] {$ENDIF};

//[function StrLen]
function StrLen(const Str: PChar): Cardinal; assembler;
asm
  {$IFDEF F_P}
        MOV     EAX, [Str]
  {$ENDIF F_P}
        XCHG    EAX, EDI
        XCHG    EDX, EAX
        OR      ECX, -1
        XOR     EAX, EAX
        CMP     EAX, EDI
        JE      @@exit0
        REPNE   SCASB
        DEC     EAX
        DEC     EAX
        SUB     EAX,ECX
@@exit0:
        MOV     EDI,EDX
end {$IFDEF F_P} [ 'EAX', 'EDX', 'ECX' ] {$ENDIF};

//[FUNCTION __DelimiterLast]
{$IFDEF ASM_VERSION}
function __DelimiterLast( Str: PChar; Delimiters: PChar ): PChar;
asm
        PUSH     ESI

        CALL     EAX2PChar

        MOV      ESI, EDX
        MOV      EDX, EAX

@@tolast:
        CMP      byte ptr [EAX], 0
        JZ       @@next1
        INC      EAX
        JMP      @@tolast

@@next1:
        PUSH     EAX

@@next:
        LODSB
        TEST     AL, AL
        JZ       @@exit

        PUSH     EDX
        XCHG     EDX, EAX
        CALL     StrRScan
        POP      EDX

        TEST     EAX, EAX
        JZ       @@next

        POP      ECX
        CMP      byte ptr [ECX], 0
        JZ       @@next1

        CMP      EAX, ECX
        JG       @@next1

        PUSH     ECX
        JLE      @@next

@@exit: POP      EAX
        POP      ESI
end;
{$ELSE ASM_VERSION} //Pascal
function __DelimiterLast( Str: PChar; Delimiters: PChar ): PChar;
var
    P, F : PChar;
begin
  P := Str;
  Result := P + StrLen( Str );
  while Delimiters^ <> #0 do
  begin
    F := StrRScan( P, Delimiters^ );
    if F <> nil then
    if (Result^ = #0) or (Integer(F) > Integer(Result)) then
       Result := F;
    Inc( Delimiters );
  end;
end;
{$ENDIF ASM_VERSION}
//[END __DelimiterLast]

//[function SkipSpaces]
function SkipSpaces( P: PChar ): PChar;
begin
  while True do
  begin
    while (P[0] <> #0) and (P[0] <= ' ') do Inc(P);
    if (P[0] = '"') and (P[1] = '"') then Inc(P, 2) else Break;
  end;
  Result := P;
end;

//[function SkipParam]
function SkipParam(P: PChar): PChar;
begin
  P := SkipSpaces( P );
  while P[0] > ' ' do
    if P[0] = '"' then
    begin
      Inc(P);
      while (P[0] <> #0) and (P[0] <> '"') do
        Inc(P);
      if P[0] <> #0 then Inc(P);
    end
      else
      Inc(P);
  Result := P;
end;

//[FUNCTION ParamStr]
function ParamStr( Idx: Integer ): String;
var
  P, P1: PChar;
  Buffer: array[ 0..260 ] of Char;
begin
  if Idx = 0 then
    SetString( Result, Buffer, GetModuleFileName( 0, Buffer, Sizeof( Buffer ) ) )
  else
  begin
    P := GetCommandLine;
    repeat
      P := SkipSpaces( P );
      P1 := P;
      P := SkipParam(P);
      if Idx = 0 then Break;
      Dec(Idx);
    until (Idx < 0) or (P = P1);
    Result := Copy( P1, 1, P - P1 );
    if Length( Result ) >= 2 then
    if (Result[ 1 ] = '"') and (Result[ Length( Result ) ] = '"') then
      Result := Copy( Result, 2, Length( Result ) - 2 );
  end;
end;
//[END ParamStr]

//[FUNCTION ParamCount]
function ParamCount: Integer;
var
  S: string;
begin
  Result := 0;
  while True do
  begin
    S := ParamStr(Result + 1);
    if S = '' then Break;
    Inc(Result);
  end;
end;
//[END ParamCount]

//[FUNCTION DelimiterLast]
{$IFDEF ASM_VERSION}
function DelimiterLast( const Str, Delimiters: String ): Integer;
asm
        CALL     EAX2PChar
        CALL     EDX2PChar
        PUSH     EAX
        CALL     __DelimiterLast
        POP      EDX
        SUB      EAX, EDX
        INC      EAX
end;
{$ELSE ASM_VERSION} //Pascal
function DelimiterLast( const Str, Delimiters: String ): Integer;
var PStr: PChar;
begin
  PStr := PChar( Str );
  Result := Integer( __DelimiterLast( PStr, PChar( Delimiters ) ) )
          - Integer( PStr );
end;
{$ENDIF ASM_VERSION}
//[END DelimiterLast]

// Thanks to Marco Bobba - Marisa Bo for this code
//[function StrIsStartingFrom]
function StrIsStartingFrom( Str, Pattern: PChar ): Boolean;
asm
  {$IFDEF F_P}
        MOV     EAX, [Str]
        MOV     EDX, [Pattern]
  {$ENDIF F_P}
        XOR     ECX, ECX
      @@1:
        MOV     CL, [EDX]   // pattern[ i ]
        INC     EDX
        MOV     CH, [EAX]   // str[ i ]
        INC     EAX
        JECXZ   @@2         // str = pattern; CL = #0, CH = #0
        CMP     CL, CH
        JE      @@1
      @@2:
        TEST    CL, CL
        SETZ    AL
end {$IFDEF F_P} [ 'EAX', 'EDX', 'ECX' ] {$ENDIF};

{$IFNDEF _FPC}
//[FUNCTION Format]
{$IFDEF ASM_VERSION}
function Format( const fmt: string; params: array of const ): String;
asm
        PUSH    ESI
        PUSH    EDI
        PUSH    EBX
        MOV     EBX, ESP
        ADD     ESP, -2048
        MOV     ESI, ESP

        INC     ECX
        JZ      @@2
@@1:
        MOV     EDI, [EDX + ECX*8 - 8]
        PUSH    EDI
        LOOP    @@1
@@2:
        PUSH    ESP
        PUSH    EAX
        PUSH    ESI

        CALL    wvsprintf

        MOV     EDX, ESI
        MOV     EAX, @Result
        CALL    System.@LStrFromPChar

        MOV     ESP, EBX
        POP     EBX
        POP     EDI
        POP     ESI
end;
{$ELSE ASM_VERSION} //Pascal
function Format( const fmt: string; params: array of const ): String;
var Buffer: array[ 0..2047 ] of Char;
    ElsArray, El: PDWORD;
    I : Integer;
    P : PDWORD;
begin
  ElsArray := nil;
  if High( params ) >= 0 then
    GetMem( ElsArray, (High( params ) + 1) * sizeof( Pointer ) );
  El := ElsArray;
  for I := 0 to High( params ) do
  begin
    P := @params[ I ];
    P := Pointer( P^ );
    El^ := DWORD( P );
    Inc( El );
  end;
  wvsprintf( @Buffer[0], PChar( fmt ), PChar( ElsArray ) );
  Result := Buffer;
  if ElsArray <> nil then
     FreeMem( ElsArray );
end;
{$ENDIF ASM_VERSION}
//[END Format]

//[function LStrFromPWCharLen]
function LStrFromPWCharLen(Source: PWideChar; Length: Integer): String;
var
  DestLen: Integer;
  Buffer: array[0..2047] of Char;
begin
  if Length <= 0 then
  begin
    //_LStrClr(Result);
    Result := '';
    Exit;
  end;
  if Length < SizeOf(Buffer) div 2 then
  begin
    DestLen := WideCharToMultiByte(0, 0, Source, Length,
      Buffer, SizeOf(Buffer), nil, nil);
    if DestLen > 0 then
    begin
      Result := Buffer;
      //System.LStrFromPCharLen(Result, Buffer, DestLen);
      Exit;
    end;
  end;
  DestLen := WideCharToMultiByte(0, 0, Source, Length, nil, 0, nil, nil);
  // _LStrFromPCharLen(Dest, nil, DestLen);
  SetLength( Result, DestLen );
  WideCharToMultiByte(0, 0, Source, Length, Pointer(Result), DestLen, nil, nil);
end;

//[function LStrFromPWChar]
function LStrFromPWChar(Source: PWideChar): String;
{* from Delphi5 - because D2 does not contain it. }
asm
        PUSH    EDX
        XOR     EDX,EDX
        TEST    EAX,EAX
        JE      @@5
        PUSH    EAX
@@0:    CMP     DX,[EAX+0]
        JE      @@4
        CMP     DX,[EAX+2]
        JE      @@3
        CMP     DX,[EAX+4]
        JE      @@2
        CMP     DX,[EAX+6]
        JE      @@1
        ADD     EAX,8
        JMP     @@0
@@1:    ADD     EAX,2
@@2:    ADD     EAX,2
@@3:    ADD     EAX,2
@@4:    XCHG    EDX,EAX
        POP     EAX
        SUB     EDX,EAX
        SHR     EDX,1
@@5:    POP     ECX
        JMP     LStrFromPWCharLen
end {$IFDEF F_P} [ 'EAX', 'EDX', 'ECX' ] {$ENDIF};
{$ENDIF _FPC}


/////////////////////////////////////////////////////////////////////////
//
//
//                          F   I   L   E   S
//
//
/////////////////////////////////////////////////////////////////////////
//[FILES]
{
   This part of the unit modified by Tim Slusher and Vladimir Kladov.
}

{* Set of utility methods to work with files
   and reqistry.
   When programming KOL, which is Windows API-oriented, You should
   avoid alien (for Windows) embedded Pascal files handling, and
   use API-calls which implemented very well. This set of functions
   is intended to make this easier.
   Also TDirList object implementation present here and some registry
   access functions, which allow to make code more elegant.
}

{$UNDEF ASM_LOCAL}
{$IFDEF ASM_VERSION}
  {$DEFINE ASM_LOCAL}
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
function FileCreate(const FileName: string; OpenFlags: DWord): THandle;
asm
        XOR      ECX, ECX
        PUSH     ECX
        MOV      ECX, EDX
        SHR      ECX, 16
        AND      CX, $1FFF
        JNZ      @@1
        MOV      CL, FILE_ATTRIBUTE_NORMAL
@@1:    PUSH     ECX
        MOV      CL, DH
        PUSH     ECX                  // CreationMode
        PUSH     0
        MOV      CL, DL
        PUSH     ECX                  // ShareMode
        MOV      DX, 0
        PUSH     EDX                  // AccessMode
        //CALL     System.@LStrToPChar // FileName must not be ''
        PUSH     EAX
        CALL     CreateFile
end;
{$ELSE ASM_VERSION} //Pascal
function FileCreate(const FileName: string; OpenFlags: DWord): THandle;
var Attr: DWORD;
begin
  Attr := (OpenFlags shr 16) and $1FFF;
  if Attr = 0 then Attr := FILE_ATTRIBUTE_NORMAL;
  Result := CreateFile( PChar(FileName), OpenFlags and $F0000000,
                        OpenFlags and $F, nil, (OpenFlags shr 8) and $F,
                        Attr, 0 );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
function FileClose(Handle: THandle): Boolean;
asm
        PUSH     EAX
        CALL     CloseHandle
        TEST     EAX, EAX
        SETNZ    AL
end;
{$ELSE ASM_VERSION} //Pascal
function FileClose(Handle: THandle): boolean;
begin
     Result := CloseHandle(Handle);
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
function FileExists( const FileName : String ) : Boolean;
const size_TWin32FindData = sizeof( TWin32FindData );
asm
        CALL     EAX2PChar
        PUSH     EAX
        CALL     GetFileAttributes
        INC      EAX
        JZ       @@exit
        DEC      EAX
        {$IFDEF PARANOIA}
        DB $24, FILE_ATTRIBUTE_DIRECTORY
        {$ELSE}
        AND      AL, FILE_ATTRIBUTE_DIRECTORY
        {$ENDIF}
        SETZ     AL
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
function FileExists( const FileName : String ) : Boolean;
var
  Code: Integer;
begin
  Code := GetFileAttributes(PChar(FileName));
  Result := (Code <> -1) and (FILE_ATTRIBUTE_DIRECTORY and Code = 0);
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
function FileSeek(Handle: THandle; MoveTo: integer; MoveMethod: TMoveMethod): DWord;
asm
        MOVZX    ECX, CL
        PUSH     ECX
        PUSH     0
        PUSH     EDX
        PUSH     EAX
        CALL     SetFilePointer
end;
{$ELSE ASM_VERSION} //Pascal
function FileSeek(Handle: THandle; MoveTo: integer; MoveMethod: TMoveMethod): DWord;
begin
  Result := SetFilePointer(Handle, MoveTo, nil, Ord( MoveMethod ) );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
function FileRead(Handle: THandle; var Buffer; Count: DWord): DWord;
asm
        PUSH     EBP
        PUSH     0
        MOV      EBP, ESP
        PUSH     0
        PUSH     EBP
        PUSH     ECX
        PUSH     EDX
        PUSH     EAX
        CALL     ReadFile
        TEST     EAX, EAX
        POP      EAX
        JNZ      @@exit
        XOR      EAX, EAX
@@exit:
        POP      EBP
end;
{$ELSE ASM_VERSION} //Pascal
function FileRead(Handle: THandle; var Buffer; Count: DWord): DWord;
begin
     if not ReadFile(Handle, Buffer, Count, Result, nil) then
       Result := 0;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
function File2Str(Handle: THandle): String;
asm
        PUSH     EDX
        TEST     EAX, EAX
        JZ       @@exit // return ''

        PUSH     EBX
        MOV      EBX, EAX // EBX = Handle
        XOR      EDX, EDX
        XOR      ECX, ECX
        INC      ECX
        CALL     FileSeek
        PUSH     EAX // Pos
        PUSH     0
        PUSH     EBX
        CALL     GetFileSize
        POP      EDX
        SUB      EAX, EDX // EAX = Size - Pos
        JZ       @@exitEBX

        PUSH     EAX
        CALL     System.@GetMem
        XCHG     EAX, EBX
        MOV      EDX, EBX
        POP      ECX
        PUSH     ECX
        CALL     FileRead
        POP      ECX
        MOV      EDX, EBX
        POP      EBX
        POP      EAX
        PUSH     EDX
        {$IFDEF _D2}
        CALL     _LStrFromPCharLen
        {$ELSE}
        CALL     System.@LStrFromPCharLen
        {$ENDIF}
        JMP      @@freebuf

@@exitEBX:
        POP      EBX
@@exit:
        XCHG     EDX, EAX
        POP      EAX // @Result
        PUSH     EDX
        CALL     System.@LStrFromPChar
@@freebuf:
        POP      EAX
        TEST     EAX, EAX
        JZ       @@fin
        CALL     System.@FreeMem
@@fin:
end;
{$ELSE ASM_VERSION} //Pascal
function File2Str(Handle: THandle): String;
var Pos, Size: DWORD;
begin
  Result := '';
  if Handle = 0 then Exit;
  Pos := FileSeek( Handle, 0, spCurrent );
  Size := GetFileSize( Handle, nil );
  SetString( Result, nil, Size - Pos + 1 );
  FileRead( Handle, Result[ 1 ], Size - Pos );
  Result[ Size - Pos + 1 ] := #0;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
function FileWrite(Handle: THandle; const Buffer; Count: DWord): DWord;
asm
        PUSH     EBP
        PUSH     EBP
        MOV      EBP, ESP
        PUSH     0
        PUSH     EBP
        PUSH     ECX
        PUSH     EDX
        PUSH     EAX
        CALL     WriteFile
        TEST     EAX, EAX
        POP      EAX
        JNZ      @@exit
        XOR      EAX, EAX
@@exit:
        POP      EBP
end;
{$ELSE ASM_VERSION} //Pascal
function FileWrite(Handle: THandle; const Buffer; Count: DWord): DWord;
begin
     if not WriteFile(Handle, Buffer, Count, Result, nil) then
       Result := 0;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
function FileEOF( Handle: THandle ) : Boolean;
asm
        PUSH     EAX

        PUSH     0
        PUSH     EAX
        CALL     GetFileSize

        XCHG     EAX, [ESP]

        MOV      CL, spCurrent
        XOR      EDX, EDX
        CALL     FileSeek

        POP      EDX
        CMP      EAX, EDX
        SETGE    AL
end;
{$ELSE ASM_VERSION} //Pascal
function FileEOF( Handle: THandle ) : Boolean;
var Siz, Pos : DWord;
begin
  Siz := GetFileSize( Handle, nil );
  Pos := FileSeek( Handle, 0, spCurrent );
  Result := Pos >= Siz;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_noVERSION}
function FileFullPath( const FileName: String ) : String;
const
  BkSlash: String = '\';
  szTShFileInfo = sizeof( TShFileInfo );
asm
        PUSH     EBX
        PUSH     ESI
        MOV      EBX, EDX
        PUSH     EAX

        XCHG     EAX, EDX
        CALL     System.@LStrClr

        POP      EDX
        PUSH     0
        MOV      EAX, ESP
        CALL     System.@LStrAsg
        MOV      ESI, ESP

@@loo:  CMP      dword ptr [ESI], 0
        JZ       @@fin

        MOV      EAX, ESI
        MOV      EDX, [BkSlash]
        PUSH     0
        MOV      ECX, ESP
        CALL     Parse

        CMP      dword ptr [EBX], 0
        JE       @@1
        MOV      EAX, EBX
        MOV      EDX, [BkSlash]
        CALL     System.@LStrCat
        JMP      @@2
@@1:
        POP      EAX
        PUSH     EAX
        CALL     System.@LStrLen
        CMP      EAX, 2
        JNE      @@2
        POP      EAX
        PUSH     EAX
        CMP      byte ptr [EAX+1], ':'
        JNE      @@2

        MOV      EAX, EBX
        POP      EDX
        PUSH     EDX
        CALL     System.@LStrAsg
        JMP      @@3
@@2:
        PUSH     0
        MOV      EAX, ESP
        MOV      EDX, [EBX]
        CALL     System.@LStrAsg
        MOV      EAX, ESP
        MOV      EDX, [ESP+4]
        CALL     System.@LStrCat
        POP      EAX
        PUSH     EAX
        SUB      ESP, szTShFileInfo
        MOV      EDX, ESP
        PUSH     SHGFI_DISPLAYNAME
        PUSH     szTShFileInfo
        PUSH     EDX
        PUSH     0
        PUSH     EAX
        CALL     ShGetFileInfo
        LEA      EDX, [ESP].TShFileInfo.szDisplayName
        CMP      byte ptr [EDX], 0
        JE       @@clr_stk
        LEA      EAX, [ESP+szTShFileInfo+4]
        CALL     System.@LStrFromPChar
@@clr_stk:
        ADD      ESP, szTShFileInfo
        CALL     RemoveStr
        POP      EDX
        PUSH     EDX
        MOV      EAX, EBX
        CALL     System.@LStrCat

@@3:    CALL     RemoveStr
        JMP      @@loo

@@fin:  CALL     RemoveStr
        POP      ESI
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function FileFullPath( const FileName: String ) : String;
var SFI: TShFileInfo;
    Src, S: String;
begin
  Result := '';
  Src := FileName;
  while Src <> '' do
  begin
    S := Parse( Src, '\' );
    if Result <> '' then
      Result := Result + '\';
    if (Result = '') and (Length( S ) = 2) and (S[ 2 ] = ':') then
      Result := S
    else
    begin
      ShGetFileInfo( PChar( Result + S ), 0, SFI, Sizeof( SFI ),
                     SHGFI_DISPLAYNAME );
      if SFI.szDisplayName[ 0 ] <> #0 then
        S := SFI.szDisplayName;
      Result := Result + S;
    end;
  end;
  if ExtractFileExt( Result ) = '' then
  // case when flag 'Hide extensions for registered file types' is set on
  // in the Explorer:
    Result := Result + ExtractFileExt( FileName );
end;
{$ENDIF ASM_VERSION}

function FileShortPath( const FileName: String ): String;
var Buf: array[ 0..MAX_PATH ] of Char;
begin
  GetShortPathName( PChar( FileName ), Buf, Sizeof( Buf ) );
  Result := Buf;
end;

function FileIconSystemIdx( const Path: String ): Integer;
var SFI: TShFileInfo;
begin
  SFI.iIcon := 0; // Bartov
  ShGetFileInfo( PChar( Path ), 0, SFI, sizeof( SFI ),
                 //-- Babenko Alexey: -----------------//
                 // SHGFI_ICON or                     //
                 //----------------------------------//
                 SHGFI_SMALLICON or SHGFI_SYSICONINDEX );
  Result := SFI.iIcon;
end;

function FileIconSysIdxOffline( const Path: String ): Integer;
var SFI: TShFileInfo;
begin
  SFI.iIcon := 0; // Bartov
  ShGetFileInfo( PChar( Path ), FILE_ATTRIBUTE_NORMAL, SFI, sizeof( SFI ),
                 //-- Babenko Alexey: -----------------//
                 // SHGFI_ATTRIBUTES or SHGFI_ICON or //
                 //----------------------------------//
                 SHGFI_SMALLICON or SHGFI_SYSICONINDEX or SHGFI_USEFILEATTRIBUTES );
  Result := SFI.iIcon;
end;

procedure LogFileOutput( const filepath, str: String );
var F: HFile;
begin
  F := FileCreate( filepath, ofOpenWrite or ofOpenAlways );
  if F = INVALID_HANDLE_VALUE then Exit;
  FileSeek( F, 0, spEnd );
  //FileWrite( F, {$IFNDEF _D2} String {$ENDIF}
  //           ( str + #13#10 )[ 1 ], Length( str ) + 2 );
  FileClose( F );
end;

function StrSaveToFile( const Filename, Str: String ): Boolean;
begin
  //Result := Mem2File( PChar( Filename ), PChar( Str ), Length( Str ) )
  //          = Length( Str );
end;

function StrLoadFromFile( const Filename: String ): String;
var F: HFile;
begin
  Result := '';
  F := FileCreate( Filename, ofOpenRead or ofOpenExisting or ofShareDenyWrite );
  if F = INVALID_HANDLE_VALUE then Exit;
  Result := File2Str( F );
  FileClose( F ); {??ee(zhog); Dark Knight}
end;

function Mem2File( Filename: PChar; Mem: Pointer; Len: Integer ): Integer;
var F: HFile;
begin
  Result := 0;
  F := FileCreate( Filename, ofOpenWrite or ofOpenAlways );
  if F = INVALID_HANDLE_VALUE then Exit;
  Result := FileWrite( F, Mem^, Len );
  FileClose( F );
end;

function File2Mem( Filename: PChar; Mem: Pointer; MaxLen: Integer ): Integer;
var F: HFile;
begin
  Result := 0;
  F := FileCreate( Filename, ofOpenRead or ofOpenExisting or ofShareDenyWrite );
  if F = INVALID_HANDLE_VALUE then Exit;
  Result := FileRead( F, Mem^, MaxLen );
  FileClose( F );
end;

{$IFDEF ASM_VERSION}
function DirectoryExists(const Name: string): Boolean;
asm
        //CALL     System.@LStrToPChar // Name must not be ''
        PUSH     EAX
        CALL     GetFileAttributes
        INC      EAX
        JZ       @@exit
        DEC      EAX
        {$IFDEF PARANOIA}
        DB $24, FILE_ATTRIBUTE_DIRECTORY
        {$ELSE}
        AND      AL, FILE_ATTRIBUTE_DIRECTORY
        {$ENDIF}
        SETNZ    AL
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
function DirectoryExists(const Name: string): Boolean;
var
  Code: Integer;
begin
  Code := GetFileAttributes(PChar(Name));
  Result := (Code <> -1) and (FILE_ATTRIBUTE_DIRECTORY and Code <> 0);
end;
{$ENDIF ASM_VERSION}

function CheckDirectoryContent( const Name: String; SubDirsOnly: Boolean; const Mask: String ): Boolean;
var FD: TWin32FindData;
    FH: THandle;
begin
  if not DirectoryExists( Name ) then
    Result := TRUE
  else
  begin
    FH := Windows.FindFirstFile( PChar( IncludeTrailingPathDelimiter( Name )
       + Mask ), FD );
    if FH = INVALID_HANDLE_VALUE then
      Result := TRUE
    else
    begin
      Result := TRUE;
      repeat
        if not StrIn( FD.cFileName, ['.','..'] ) then
        begin
          if SubDirsOnly and LongBool(FD.dwFileAttributes and FILE_ATTRIBUTE_DIRECTORY)
             or not SubDirsOnly then
          begin
            Result := FALSE;
            break;
          end;
        end;
      until not Windows.FindNextFile( FH, FD );
      Windows.FindClose( FH );
    end;
  end;
end;

function DirectoryEmpty(const Name: String): Boolean;
begin
  Result := CheckDirectoryContent( Name, FALSE, '*.*' );
end;



function DirectoryHasSubdirs( const Path: String ): Boolean;
begin
  Result := not CheckDirectoryContent( Path, TRUE, '*.*' );
end;

function  GetFileList(const dir: string): PStrList;
var
   Srch: TWin32FindData;
   flag: Integer;
   succ: boolean;
begin
   result := nil;
   flag := FindFirstFile(PChar(dir), Srch);
   succ := flag <> 0;
   while succ do begin
      if (not (Srch.dwFileAttributes and FILE_ATTRIBUTE_DIRECTORY > 0))then begin
         if Result = nil then begin
            Result := NewStrList;
         end;
         Result.Add(Srch.cFileName);
      end;
      succ := FindNextFile(Flag, Srch);
   end;
   FindClose(Flag);
end;

function ExcludeTrailingChar( const S: String; C: Char ): String;
begin
  Result := S;
  if Result <> '' then
  if Result[ Length( Result ) ] = C then
    Delete( Result, Length( Result ), 1 );
end;

function IncludeTrailingChar( const S: String; C: Char ): String;
begin
  Result := S;
  if (Result = '') or (Result[ Length( Result ) ] <> C) then
    Result := Result + C;
end;

//---------------------------------------------------------
// Following functions/procedures are created by Edward Aretino:
// IncludeTrailingPathDelimiter, ExcludeTrailingPathDelimiter,
// ForceDirectories, CreateDir, ChangeFileExt
//---------------------------------------------------------
function IncludeTrailingPathDelimiter(const S: string): string;
begin
   {if CopyTail(S, 1) <> '\' then
     Result := S + '\'
   else
     Result := S;}
   Result := IncludeTrailingChar( S, '\' );
end;

function ExcludeTrailingPathDelimiter(const S: string): string;
begin
   {Result := S;
   if Length(Result) = 0 then Exit;

   if (CopyTail(Result, 1) = '\') then
     DeleteTail(Result, 1);}
   Result := ExcludeTrailingChar( S, '\' );
end;

function ForceDirectories(Dir: string): Boolean;
begin
 Result := Length(Dir) > 0; {Centronix}
 If not Result then Exit;
 Dir := ExcludeTrailingPathDelimiter(Dir);
 If (Length(Dir) < 3) or DirectoryExists(Dir) or
   (ExtractFilePath(Dir) = Dir) then Exit; // avoid 'xyz:\' problem.
 Result := ForceDirectories(ExtractFilePath(Dir)) and CreateDir(Dir);
end;

function CreateDir(const Dir: string): Boolean;
begin
   Result := Windows.CreateDirectory(PChar(Dir), nil);
end;

function ChangeFileExt(FileName: String; const Extension: string): string;
var
   FileExt: String;
begin
   FileExt := ExtractFileExt(FileName);
   DeleteTail(FileName, Length(FileExt));
   Result := FileName+ Extension;
end;

{$IFDEF ASM_VERSION}
{$IFNDEF _D2}
{$DEFINE ASM_LStrFromPCharLen}
{$ENDIF}
{$ENDIF ASM_VERSION}

{$IFDEF ASM_LStrFromPCharLen}
  {$DEFINE ASM_DIRDelimiters}
{$ENDIF}

{$IFDEF ASM_VERSION}
  {$DEFINE ASM_DIRDelimiters}
{$ENDIF ASM_VERSION}

{$IFDEF ASM_DIRDelimiters}
const
  DirDelimiters: PChar = ':\';
{$ENDIF}

{$IFDEF ASM_VERSION}
function ExtractFileName( const Path : String ) : String;
asm
        PUSH     EDX
        PUSH     EAX
        MOV      EDX, [DirDelimiters]
        CALL     __DelimiterLast
        POP      EDX
        CMP      byte ptr [EAX], 0
        JZ       @@1
        XCHG     EDX, EAX
        INC      EDX
@@1:    POP      EAX
        CALL     System.@LStrFromPChar
end;
{$ELSE ASM_VERSION} //Pascal
function ExtractFileName( const Path : String ) : String;
var P: PChar;
begin
  P := __DelimiterLast( PChar( Path ), ':\' );
  if P^ = #0 then
    Result := Path
  else
    Result := P + 1;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_LStrFromPCharLen} // LStrFromPCharLen - there are no in D2
function ExtractFilePath( const Path : String ) : String;
asm
        PUSH     EDX
        MOV      EDX, [DirDelimiters]
        CALL     EAX2PChar
        PUSH     EAX
        CALL     __DelimiterLast
        XCHG     EDX, EAX
        XOR      ECX, ECX
        POP      EAX
        CMP      byte ptr [EDX], CL
        JZ       @@ret_0
        SUB      EDX, EAX
        INC      EDX
        XCHG     EDX, EAX
        XCHG     ECX, EAX
@@ret_0:
        POP      EAX
        CALL     System.@LStrFromPCharLen
end;
{$ELSE} //Pascal
function ExtractFilePath( const Path : String ) : String;
//var I : Integer;
var P, P0: PChar;
begin
  P0 := PChar( Path );
  P := __DelimiterLast( P0, ':\' );
  if P^ = #0 then
    Result := ''
  else
    Result := Copy( Path, 1, P - P0 + 1 );
end;
{$ENDIF}

function ExtractFileNameWOext( const Path : String ) : String;
begin
  Result := ExtractFileName( Path );
  Result := Copy( Result, 1, Length( Result ) - Length( ExtractFileExt( Result ) ) );
end;

{$IFDEF ASM_VERSION}
const
  ExtDelimeters: PChar = '.';

function ExtractFileExt( const Path : String ) : String;
asm
        PUSH     EDX
        MOV      EDX, [ExtDelimeters]
        CALL     EAX2PChar
        CALL     __DelimiterLast
@@1:    XCHG     EDX, EAX
        POP      EAX
        CALL     System.@LStrFromPChar
end;
{$ELSE ASM_VERSION} //Pascal
function ExtractFileExt( const Path : String ) : String;
var P: PChar;
begin
  P := __DelimiterLast( PChar( Path ), '.' );
  Result := P;
end;
{$ENDIF ASM_VERSION}

function ReplaceFileExt( const Path, NewExt: String ): String;
begin
  Result := ExtractFilePath( Path ) +
            ExtractFileNameWOext( ExtractFileName( Path ) ) +
            NewExt;
end;

function ExtractShortPathName( const Path: String ): String;
var
  Buffer: array[0..MAX_PATH - 1] of Char;
begin
  SetString(Result, Buffer,
    GetShortPathName(PChar(Path), Buffer, SizeOf(Buffer)));
end;

function FilePathShortened( const Path: String; MaxLen: Integer ): String;
begin
  Result := FilePathShortenPixels( Path, 0, MaxLen );
end;

function PixelsLength( DC: HDC; const Text: String ): Integer;
var Sz: TSize;
begin
  if DC = 0 then
    Result := Length( Text )
  else
  begin
    Windows.GetTextExtentPoint32( DC, PChar( Text ), Length( Text ), Sz );
    Result := Sz.cx;
  end;
end;

function FilePathShortenPixels( const Path: String; DC: HDC; MaxPixels: Integer ): String;
var L0, L1: Integer;
    Prev: String;
begin
 Result := Path;
 L0 := PixelsLength( DC, Result );
 while L0 > MaxPixels do
 begin
   Prev := Result;
   L1 := pos( '\...\', Result );
   if L1 <= 0 then
     Result := ExcludeTrailingPathDelimiter( ExtractFilePath( Result ) )
   else
     Result := Copy( Result, 1, L1 - 1 );
   if Result <> '' then
     Result := IncludeTrailingPathDelimiter( ExtractFilePath( Result ) ) + '...\' + ExtractFileName( Path );
   if (Result = '') or (Result = Prev) then
   begin
     L1 := Length( ExtractFilePath( Result ) );
     while (PixelsLength( DC, Result ) > MaxPixels) and (L1 > 1) do
     begin
       Dec( L1 );
       Result := Copy( Result, 1, L1 ) + '...\' + ExtractFileName( Result );
     end;
     if PixelsLength( DC, Result ) > MaxPixels then
     begin
       L1 := MaxPixels + 1;
       while ((MaxPixels > 0) and (L1 > 1) or (MaxPixels = 0) and (L1 > 0)) and
             (PixelsLength( DC, Result ) > MaxPixels) do
       begin
         Dec( L1 );
         Result := Copy( ExtractFileName( Path ), 1, L1 ) + '...';
       end;
     end;
     break;
   end;
   L0 := PixelsLength( DC, Result );
 end;
end;

procedure CutFirstDirectory(var S: String);
var
  Root: Boolean;
  P: Integer;
begin
  if S = '\' then
    S := ''
  else
  begin
    if S[1] = '\' then
    begin
      Root := True;
      Delete(S, 1, 1);
    end
    else
      Root := False;
    if S[1] = '.' then
      Delete(S, 1, 4);
    P := pos('\',S);
    if P <> 0 then
    begin
      Delete(S, 1, P);
      S := '...\' + S;
    end
    else
      S := '';
    if Root then
      S := '\' + S;
  end;
end;

function MinimizeName( const Path: String; DC: HDC; MaxPixels: Integer ): String;
var
  Drive, Dir, Name: String;
begin
  Result := Path;
  Dir := ExtractFilePath(Result);
  Name := ExtractFileName(Result);

  if (Length(Dir) >= 2) and (Dir[2] = ':') then
  begin
    Drive := Copy(Dir, 1, 2);
    Delete(Dir, 1, 2);
  end
  else
    Drive := '';
  while ((Dir <> '') or (Drive <> '')) and (PixelsLength(DC, Result) > MaxPixels) do
  begin
    if Dir = '\...\' then
    begin
      Drive := '';
      Dir := '...\';
    end
    else if Dir = '' then
      Drive := ''
    else
      CutFirstDirectory(Dir);
    Result := Drive + Dir + Name;
  end;
end;

{$IFDEF ASM_VERSION}
function FileSize( const Path : String ) : Integer;
const size_TWin32FindData = sizeof( TWin32FindData );
asm
        ADD      ESP, - size_TWin32FindData
        PUSH     ESP
        //CALL     System.@LStrToPChar // Path must not be ''
        PUSH     EAX
        CALL     FindFirstFile
        INC      EAX
        JZ       @@exit
        DEC      EAX
        PUSH     EAX
        CALL     FindClose

        MOV      EAX, [ESP].TWin32FindData.nFileSizeLow
@@exit:
        ADD      ESP, size_TWin32FindData
end;
{$ELSE ASM_VERSION} //Pascal
function FileSize( const Path : String ) : Integer;
var FD : TWin32FindData;
    FH : THandle;
begin
  FH := FindFirstFile( PChar( Path ), FD );
  Result := 0;
  if FH = INVALID_HANDLE_VALUE then exit;
  Result := FD.nFileSizeLow;
  if ((FD.nFileSizeLow and $80000000) <> 0) or
     (FD.nFileSizeHigh <> 0) then Result := -1;
  FindClose( FH );
end;
{$ENDIF ASM_VERSION}

//*
function FileTimeCompare( const FT1, FT2 : TFileTime ) : Integer;
var ST1, ST2 : TSystemTime;
begin
  FileTimeToSystemTime( FT1, ST1 );
  FileTimeToSystemTime( FT2, ST2 );
  Result := CompareSystemTime( ST1, ST2 );
end;

function GetSystemDir: String;
var Buf: array[ 0..MAX_PATH ] of Char;
begin
  GetSystemDirectory( @ Buf[ 0 ], MAX_PATH + 1 );
  Result := IncludeTrailingPathDelimiter( PChar( @ Buf[ 0 ] ) );
end;

//*
function GetWindowsDir : string;
var Buf : array[ 0..MAX_PATH ] of Char;
begin
  GetWindowsDirectory( @Buf[ 0 ], MAX_PATH + 1 );
  Result := IncludeTrailingPathDelimiter( PChar( @ Buf[ 0 ] ) );
end;

function GetWorkDir : string;
var Buf: array[ 0..MAX_PATH ] of Char;
begin
  GetCurrentDirectory( MAX_PATH + 1, @ Buf[ 0 ] );
  Result := IncludeTrailingPathDelimiter( PChar( @ Buf[ 0 ] ) );
end;

//*
function GetTempDir : string;
var Buf : array[ 0..MAX_PATH ] of Char;
begin
  Windows.GetTempPath( MAX_PATH + 1, @Buf[ 0 ] );
  Result := IncludeTrailingPathDelimiter( PChar( @ Buf[ 0 ] ) );
end;

function CreateTempFile( const DirPath, Prefix: String ): String;
var Buf: array[ 0..MAX_PATH ] of Char;
begin
  GetTempFileName( PChar( DirPath ), PChar( Prefix ), 0, Buf );
  Result := Buf;
end;

function  GetFileListStr(FPath{e.g.'c:\tmp\'}, FMask{e.g.'*.*'}: string): string;
{* List of files in string, separating each path from others with semicolon (';').
   E.g.: 'c:\tmp\unit1.dcu;c:\tmp\unit1.~pa' (for use with DeleteFile2Recycle())}
var
   Srch: TWin32FindData;
   flag: Integer;
   succ: boolean;
   dir:string;
begin
   result := '';
   if (FPath<>'') and (FPath[length(FPath)]<>'\') then FPath:=FPath+'\';
   if (FMask<>'') and (FMask[1]='\') then FMask:=CopyEnd(FMask,2);
   dir:=FPath+FMask;
   flag := FindFirstFile(PChar(dir), Srch);
   succ := flag <> 0;
   while succ do begin
      if (not (Srch.dwFileAttributes and FILE_ATTRIBUTE_DIRECTORY > 0))then begin
         if Result<>''then Result:=Result+';';
         Result:=Result+FPath+Srch.cFileName;
      end;
      succ := FindNextFile(Flag, Srch);
   end;
   FindClose(Flag);
end;

function DeleteFiles( const DirPath: String ): Boolean;
var Files, Name: String;
begin
  Files := GetFileListStr( ExtractFilePath( DirPath ), ExtractFileName( DirPath ) );
  Result := TRUE;
  while Files <> '' do
  begin
    Name := Parse( Files, ';' );
    Result := Result and DeleteFile( PChar( Name ) );
  end;
end;

//*
function DeleteFile2Recycle( const Filename : String ) : Boolean;
var FOS : TSHFileOpStruct;
    Buf : PChar;
    L : Integer;
begin
  L := Length( Filename );
  GetMem( Buf, L + 2 );
  StrCopy( Buf, PChar( Filename ) );
  Buf[ L + 1 ] := #0;
  for L := L downto 0 do
    if Buf[ L ] = ';' then Buf[ L ] := #0;
  FillChar( FOS, Sizeof( FOS ), 0 );
  if Applet <> nil then
    FOS.Wnd := Applet.Handle;
  FOS.wFunc := FO_DELETE;
  FOS.pFrom := Buf;
  FOS.fFlags := FOF_ALLOWUNDO or FOF_NOCONFIRMATION;
  FOS.fAnyOperationsAborted := True;
  FOS.lpszProgressTitle := PChar( 'Delete ' + Filename + ' to Recycle bin' );
  Result := SHFileOperation( FOS ) = 0;
  if Result then
    Result := not FOS.fAnyOperationsAborted;
  FreeMem( Buf );
end;

function CopyMoveFiles( const FromList, ToList: String; Move: Boolean ): Boolean;
var FOS : TSHFileOpStruct;
    Buf : PChar;
    L : Integer;
begin
  L := Length( FromList );
  GetMem( Buf, L + 2 );
  StrCopy( Buf, PChar( FromList ) );
  Buf[ L + 1 ] := #0;
  for L := L downto 0 do
    if Buf[ L ] = ';' then Buf[ L ] := #0;
  FillChar( FOS, Sizeof( FOS ), 0 );
  if Applet <> nil then
    FOS.Wnd := Applet.Handle;
  if Move then
  begin
    FOS.wFunc := FO_MOVE;
    FOS.lpszProgressTitle := PChar( 'Move files' );
  end
    else
  begin
    FOS.wFunc := FO_COPY;
    FOS.lpszProgressTitle := PChar( 'Copy files' );
  end;
  FOS.pFrom := Buf;
  FOS.pTo := PChar( ToList + #0 );
  FOS.fFlags := FOF_ALLOWUNDO;
  FOS.fAnyOperationsAborted := True;
  Result := SHFileOperation( FOS ) = 0;
  if Result then
    Result := not FOS.fAnyOperationsAborted;
  FreeMem( Buf );
end;



//*
function GetUniqueFilename( PathName: string ) : String;
var Path, Nam, Ext : String;
    I, J, K : Integer;
begin
  Result := PathName;
  Path := ExtractFilePath( PathName );
  if not DirectoryExists( Path ) then Exit;
  Nam := ExtractFileNameWOext( PathName );
  if Nam = '' then
  begin
    if Path[ Length( Path ) ] = '\' then
       Path := Copy( Path, 1, Length( Path ) - 1 );
    PathName := Path;
    Result := Path;
  end;
  Nam := ExtractFileNameWOext( PathName );
  Ext := ExtractFileExt( PathName );
  I := Length( Nam );
  for J := I downto 1 do
  if not (Nam[ J ] in [ '0'..'9' ]) then
  begin
    I := J;
    break;
  end;
  K := Str2Int( CopyEnd( Nam, I + 1 ) );
  while FileExists( Result ) do
  begin
    Inc( K );
    Result := Path + Copy( Nam, 1, I ) + Int2Str( K ) + Ext;
  end;
end;

{$IFDEF ASM_VERSION}
function GetStartDir : String;
asm
        PUSH     EBX
        MOV      EBX, EAX

        XOR      EAX, EAX
        MOV      AH, 2
        SUB      ESP, EAX
        MOV      EDX, ESP
        PUSH     EAX
        PUSH     EDX
        PUSH     0
        CALL     GetModuleFileName

        LEA      EDX, [ESP + EAX]
@@1:    DEC      EDX
        CMP      byte ptr [EDX], '\'
        JNZ      @@1

        INC      EDX
        MOV      byte ptr [EDX], 0

        MOV      EAX, EBX
        MOV      EDX, ESP
        CALL     System.@LStrFromPChar

        ADD      ESP, 200h
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function GetStartDir : String;
var Buffer:array[0..260] of Char;
    I : Integer;
begin
  I := GetModuleFileName( 0, Buffer, Sizeof( Buffer ) );
  for I := I downto 0 do
    if Buffer[ I ] = '\' then
    begin
      Buffer[ I + 1 ] := #0;
      break;
    end;
  Result := Buffer;
end;
{$ENDIF ASM_VERSION}

//{$ENDIF LINUX/WIN32}



{ TDirList }

//[function NewDirList]
function NewDirList( const DirPath, Filter: String; Attr: DWORD ): PDirList;
begin
  Result := PDirList.Create;
  Result.ScanDirectory( DirPath, Filter, Attr );
end;
//[END NewDirList]

//[function NewDirListEx]
function NewDirListEx( const DirPath, Filters: String; Attr: DWORD ): PDirList;
begin
  Result := PDirList.Create;
  Result.ScanDirectoryEx( DirPath, Filters, Attr );
end;
//[END NewDirListEx]

{$IFDEF ASM_VERSION}
//[procedure TDirList.Clear]
procedure TDirList.Clear;
asm
        XOR      ECX, ECX
        XCHG     ECX, [EAX].fList
        JECXZ    @@exit
        XCHG     EAX, ECX
        CALL     TList.Release
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TDirList.Clear;
begin
  if FList <> nil then
    FList.Release;
  FList := nil;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[destructor TDirList.Destroy]
destructor TDirList.Destroy;
asm
        PUSH     EBX
        MOV      EBX, EAX
        CALL     Clear
        LEA      EAX, [EBX].FPath
        CALL     System.@LStrClr
        XCHG     EAX, EBX
        CALL     TObj.Destroy
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
destructor TDirList.Destroy;
begin
  Clear;
  FPath := '';
  inherited;
end;
{$ENDIF ASM_VERSION}

//[FUNCTION FindFilter]
{$IFDEF ASM_VERSION}
function FindFilter( const Filter: String): String;
asm
        XCHG     EAX, EDX
        PUSH     EAX
        CALL     System.@LStrAsg
        POP      EAX
        CMP      dword ptr [EAX], 0
        JNE      @@exit
        LEA      EDX, @@mask_all
        JE       System.@LStrFromPChar
@@mask_all:  DB  '*.*',0
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
function FindFilter(const Filter: String): String;
begin
  Result := Filter;
  if Result = '' then Result := '*.*';
end;
{$ENDIF ASM_VERSION}
//[END FindFilter]

//+
//[function TDirList.Get]
function TDirList.Get(Idx: Integer): PWin32FindData;
begin
  Result := FList.fItems[ Idx ];
end;

{$IFDEF ASM_VERSION}
//[function TDirList.GetCount]
function TDirList.GetCount: Integer;
asm
        MOV      EAX, [EAX].fList
        TEST     EAX, EAX
        JZ       @@exit
        MOV      EAX, [EAX].TList.fCount
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
function TDirList.GetCount: Integer;
begin
  Result := 0;
  if FList = nil then Exit;
  Result := FList.Count;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TDirList.GetNames]
function TDirList.GetNames(Idx: Integer): string;
asm
        MOV      EAX, [EAX].fList
        MOV      EAX, [EAX].TList.fItems
        MOV      EDX, [EAX + EDX*4]
//*/////////////////////////////////////////////////////
//      ADD      EDX, TWin32FindData.cFileName
//*/////////////////////////////////////////////////////
        ADD      EDX, offset TWin32FindData.cFileName //
//*/////////////////////////////////////////////////////
        MOV      EAX, ECX
        CALL     System.@LStrFromPChar
end;
{$ELSE ASM_VERSION} //Pascal
function TDirList.GetNames(Idx: Integer): string;
begin
  Result := PChar(@PWin32FindData(fList.fItems[ Idx ]).cFileName[0]);
  //Result := PChar(@Items[Idx].cFileName[0]);
end;
{$ENDIF ASM_VERSION}

//[function TDirList.GetIsDirectory]
function TDirList.GetIsDirectory(Idx: Integer): Boolean;
begin
  Result := LongBool( Items[ Idx ].dwFileAttributes and FILE_ATTRIBUTE_DIRECTORY );
end;

{$IFDEF ASM_noVERSION}
//[function TDirList.SatisfyFilter]
function TDirList.SatisfyFilter(FileName: PChar; FileAttr,
  FindAttr: DWord): Boolean;
asm
        PUSH     EBX
        PUSH     ESI
        PUSH     EDI
        XCHG     EBX, EAX // EBX = Self
        MOV      EAX, [FindAttr]
        MOV      EDI, EDX // EDI = FileName
        MOV      EDX, EAX
        AND      EDX, ECX
        CMP      EDX, EAX
        JE       @@1

        TEST AL, FILE_ATTRIBUTE_NORMAL
        JZ      @@ret_false
@@1:
        CMP      word ptr [EDI], '.'
        JE       @@1_1
        CMP      word ptr [EDI], '..'
        JNE      @@1_1
        CMP      byte ptr [EDI+2], 0
        JNE      @@1_1
@@1_0:
        MOV      ECX, [FindAttr]
        TEST     CL, FILE_ATTRIBUTE_NORMAL
        JZ       @@1_1
        CMP      ECX, FILE_ATTRIBUTE_NORMAL
        JE       @@1_1
        TEST     AL, FILE_ATTRIBUTE_DIRECTORY
        JZ       @@1_1
        TEST     CL, FILE_ATTRIBUTE_DIRECTORY
        JNZ      @@ret_true

@@1_1:
        MOV      ECX, [EBX].fFilters
        JECXZ    @@ret_false //?

        MOV      ESI, [ECX].TStrList.fList
        MOV      ESI, [ESI].TList.fItems
        MOV      ECX, [ECX].TStrList.fCount
        JECXZ    @@ret_false

@@2:
        LODSD
        TEST     EAX, EAX
        JZ       @@nx_filter

        PUSHAD

        MOV      EDX, [EAX]
        CMP      DX, $002E
        JE       @@F_d_dd
        AND      EDX, $FFFFFF
        CMP      EDX, $002E2E
        JE       @@F_d_dd

        MOV      EDX, [EDI]
        CMP      DX, $002E
        JE       @@4
        AND      EDX, $FFFFFF
        CMP      EDX, $002E2E
        JE       @@4
        JMP      @@chk_anti

@@F_d_dd:
        MOV      EDX, EDI
        PUSH     EAX
        CALL     StrComp
        TEST     EAX, EAX
        POP      EAX
        JZ       @@popad_ret_true

@@chk_anti:
        XCHG     EDX, EAX // EDX = filter[ i ]
        MOV      EAX, EDI // EAX = FileName
        CMP      byte ptr [EDX], '^'
        JNE      @@3

        INC      EDX
        CALL     _2StrSatisfy
        TEST     AL, AL
        JZ       @@4
        POPAD
        JMP      @@ret_false

@@3:    CALL     _2StrSatisfy
        TEST     AL, AL
        JZ       @@4
@@popad_ret_true:
        POPAD
@@ret_true:
        MOV      AL, 1
        JMP      @@exit

@@4:    POPAD
@@nx_filter:
        LOOP     @@2

@@ret_false:
        XOR      EAX, EAX
@@exit:
        POP      EDI
        POP      ESI
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function TDirList.SatisfyFilter(FileName: PChar; FileAttr,
  FindAttr: DWord): Boolean;
{$IFDEF F_P}
const Dot: String = '.';
{$ENDIF F_P}
var I: Integer;
    F: PChar;
    HasOnlyNegFilters: Boolean;
begin
  Result := (((FileAttr and FindAttr) = FindAttr) or
            LongBool(FindAttr and FILE_ATTRIBUTE_NORMAL));
  if not Result then Exit;

  if (FileName <> {$IFDEF F_P}Dot{$ELSE}'.'{$ENDIF}) and
     (FileName <> '..') then
  if LongBool( FindAttr and FILE_ATTRIBUTE_NORMAL ) and
     (FindAttr <> FILE_ATTRIBUTE_NORMAL) then
     if LongBool( FindAttr and FILE_ATTRIBUTE_DIRECTORY ) and
        LongBool( FileAttr and FILE_ATTRIBUTE_DIRECTORY ) then Exit;

  HasOnlyNegFilters := TRUE;
  for I := 0 to fFilters.fCount - 1 do
  begin
    F := PChar(fFilters.fList.fItems[ I ]);
    if F = '' then continue;

    if (F = {$IFDEF F_P}Dot{$ELSE}'.'{$ENDIF}) or (F = '..') then
    begin
      if FileName = F then
        Exit;
    end
      else
    if (Filename = {$IFDEF F_P}Dot{$ELSE}'.'{$ENDIF}) or (FileName = '..') then
    begin
      //Result := FALSE;
      continue;
    end;

    if F[ 0 ] = '^' then
    begin
      if StrSatisfy( FileName, PChar(@F[ 1 ]) ) then
      begin
         Result := False;
         Exit;
      end;
    end
      else
    begin
      HasOnlyNegFilters := FALSE;
      if StrSatisfy( FileName, F ) then
      begin
        Result := True;
        Exit;
      end;
    end;
  end;

  Result := HasOnlyNegFilters and
            (FileName <> {$IFDEF F_P}Dot{$ELSE}'.'{$ENDIF}) and
            (FileName <> '..');

end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TDirList.ScanDirectory]
procedure TDirList.ScanDirectory(const DirPath, Filter: String;
  Attr: DWord);
const   sz_win32finddata = sizeof(TWin32FindData);
asm
        PUSH     EBX
        PUSH     EDI
        MOV      EBX, EAX

        PUSHAD
        CALL     Clear
        CALL     NewList
        MOV      [EBX].fList, EAX
        POPAD

        PUSHAD
        LEA      EAX, [EBX].fPath
        CALL     System.@LStrAsg
        POPAD

        MOV      EAX, [EBX].fPath
        TEST     EAX, EAX
        JE       @@exit

        PUSHAD
        LEA      EDX, [EBX].fPath
        MOV      EAX, [EDX]
        CALL     IncludeTrailingPathDelimiter

        {PUSH     EAX
        CALL     System.@LStrLen
        POP      EDX
        CMP      byte ptr [EAX+EDX-1], '\'
        JE       @@1

        LEA      EAX, [EBX].fPath
        MOV      EDX, offset[@@bk_slush]
        CALL     System.@LStrCat

        JMP      @@1
        // '\' string constant
        DD       -1, 1
@@bk_slush: DB '\',0}
        MOV      EAX, [EBX].fFilters
        TEST     EAX, EAX
        JNZ      @@1
        CALL     NewStrList
        MOV      [EBX].fFilters, EAX
        POPAD

        PUSHAD
        PUSH     ECX
        XCHG     EAX, ECX
        MOV      EDX, offset[@@star_d_star]
        CALL     StrComp
        TEST     AL, AL
        POP      EDX
        JNZ      @@asg_Filter
        MOV      EDX, offset[@@star]
@@asg_Filter:
        MOV      EAX, [EBX].fFilters
        CALL     TStrList.Add
        JMP      @@1

@@star_d_star:
        DB       '*.*', 0
        DD       -1, 1
@@star: DB       '*', 0

@@1:
        POPAD

        ADD      ESP, -sz_win32finddata
        XOR      EDX, EDX
        PUSH     EDX
        PUSH     EDX
        XCHG     EAX, ECX
        MOV      EDX, ESP
        CALL     FindFilter

        LEA      EAX, [ESP+4]
        MOV      EDX, [EBX].fPath
        POP      ECX
        PUSH     ECX
        CALL     System.@LStrCat3
        CALL     RemoveStr

        POP      EAX
        MOV      EDX, ESP
        PUSH     EAX
        PUSH     EDX
        PUSH     EAX
        CALL     FindFirstFile
        MOV      EDI, EAX
        INC      EAX
        MOV      EAX, ESP

        PUSHFD
        CALL     System.@LStrClr
        POPFD
        POP      ECX

        JZ       @@fin

@@loop:
        MOV      ECX, [ESP].TWin32FindData.dwFileAttributes
        PUSH     [Attr]
        LEA      EDX, [ESP+4].TWin32FindData.cFileName
        MOV      EAX, EBX
        CALL     SatisfyFilter

        TEST     AL, AL
        JZ       @@next

        MOV      EAX, sz_win32finddata
        PUSH     EAX
          CALL     System.@GetMem
          PUSH     EAX
            XCHG     EDX, EAX
            MOV      EAX, [EBX].fList
            CALL     TList.Add
          POP      EDX
        POP      ECX
        MOV      EAX, ESP
        CALL     System.Move

@@next:
        PUSH     ESP
        PUSH     EDI
        CALL     FindNextFile
        TEST     EAX, EAX
        JNZ      @@loop

        PUSH     EDI
        CALL     FindClose

@@fin:
        ADD      ESP, sz_win32finddata
@@exit:
        XOR      EAX, EAX
        XCHG     EAX, [EBX].fFilters
        CALL     TObj.Free
        POP      EDI
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TDirList.ScanDirectory(const DirPath, Filter: String;
  Attr: DWord);
var FindData : TWin32FindData;
    E : PWin32FindData;
    FindHandle : THandle;
begin
  Clear;
  FList := NewList;
  FPath := DirPath;
  if FPath = '' then Exit;
  FPath := IncludeTrailingPathDelimiter( FPath );
  if fFilters = nil then
  begin
    fFilters := NewStrList;
    if Filter = '*.*' then
      fFilters.Add( '*' )
    else
      fFilters.Add( Filter );
  end;
  FindHandle := FindFirstFile( PChar( FPath + FindFilter( Filter ) ),
                               FindData );
  if FindHandle = INVALID_HANDLE_VALUE then Exit;
  while True do
  begin
    if SatisfyFilter( PChar(@FindData.cFileName[0]),
                      FindData.dwFileAttributes, Attr ) then
    begin
      GetMem( E, Sizeof( FindData ) );
      FList.Add( E );
      Move( FindData, E^, Sizeof( FindData ) );
    end;
    if not FindNextFile( FindHandle, FindData ) then break;
  end;
  FindClose( FindHandle );
  fFilters.Free;
  fFilters := nil;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TDirList.ScanDirectoryEx]
procedure TDirList.ScanDirectoryEx(const DirPath, Filters: String;
  Attr: DWord);
asm
        PUSH     EBX
        MOV      EBX, EAX

        PUSHAD
        CALL     NewStrList
        MOV      [EBX].fFilters, EAX
        POPAD

        PUSHAD
        PUSH     0
        MOV      EAX, ESP
        MOV      EDX, ECX
        CALL     System.@LStrLAsg
@@1:    MOV      ECX, [ESP]
        JECXZ    @@2
        MOV      EAX, ESP
        MOV      EDX, offset[@@semicolon]
        PUSH     0
        MOV      ECX, ESP
        CALL     Parse
        MOV      EAX, [ESP]
        MOV      EDX, ESP
        CALL     Trim
        POP      EDX
        PUSH     EDX
        TEST     EDX, EDX
        JZ       @@filt_added
        MOV      EAX, [EBX].fFilters
        CALL     TStrList.Add
@@filt_added:
        CALL     RemoveStr
        JMP      @@1

        //       ';' string literal
        DD       -1, 1
@@semicolon:
        DB       ';',0

@@2:    POP      ECX
        POPAD
        XOR      ECX, ECX
        PUSH     [Attr]
        CALL     ScanDirectory
        {XOR      EAX, EAX
        XCHG     EAX, [EBX].fFilters
        CALL     TObj.Free}
        POP      EBX
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TDirList.ScanDirectoryEx(const DirPath, Filters: String;
  Attr: DWord);
var F, FF: String;
begin
  FF := Filters;
  fFilters := NewStrList;
  while FF <> '' do
  begin
    F := Trim( Parse( FF, ';' ) );
    if F <> '' then
      fFilters.Add( F );
  end;
  ScanDirectory( DirPath, '', Attr );
end;
{$ENDIF ASM_VERSION}

type
  PSortDirData = ^TSortDirData;
  TSortDirData = packed Record
    FoldersFirst, CaseSensitive : Boolean;
    Rules : array[ 0..11 ] of TSortDirRules;
    Dir : PDirList;
  end;

//[FUNCTION CompareDirItems]
{$IFDEF ASM_noVERSION}
function CompareDirItems( const Data : PSortDirData; const e1, e2 : DWORD ) : Integer;
asm
        PUSH     EBX
        PUSH     ESI
        PUSH     EDI
        XCHG     EBX, EAX
        MOV      EAX, [EBX].TSortDirData.Dir
        MOV      EAX, [EAX].TDirList.fList
        MOV      EAX, [EAX].TList.fItems
        MOV      ESI, [EAX+EDX*4]
        MOV      EDI, [EAX+ECX*4]
        MOV      DL, byte ptr[ESI].TWin32FindData.dwFileAttributes
        MOV      DH, byte ptr[EDI].TWin32FindData.dwFileAttributes
        AND      DX, 2020h
        XOR      EAX, EAX
        CMP      DL, DH
        JE       @@1
        CMP      [EBX].TSortDirData.FoldersFirst, AL
        JE       @@1
        OR       AL, DL
        JNE      @@exit_near
        DEC      EAX
        //JMP      @@exit
@@exit_near:
        POP      EDI
        POP      ESI
        POP      EBX
        RET

@@sdrByDateChanged:
        LEA      EAX, [ESI].TWin32FindData.ftLastWriteTime
        LEA      EDX, [EDI].TWin32FindData.ftLastWriteTime
        JMP      @@sdrByDate1

@@sdrByDateAccessed:
        LEA      EAX, [ESI].TWin32FindData.ftLastAccessTime
        LEA      EDX, [EDI].TWin32FindData.ftLastAccessTime
        JMP      @@sdrByDate1

@@jmp_table:
        DD       offset[@@exit1], offset[@@2], offset[@@2]
        DD       offset[@@sdrByName], offset[@@sdrByExt]
        DD       offset[@@sdrBySize], offset[@@sdrBySize]
        DD       offset[@@sdrByDateCreate], offset[@@sdrByDateChanged]
        DD       offset[@@sdrByDateAccessed]

@@1:
        LEA      EDX, [EBX].TSortDirData.Rules
        PUSH     EDX
@@2:
        POP      EDX
        XOR      EAX, EAX
        MOV      AL, [EDX]
        INC      EDX
        PUSH     EDX

        JMP      dword ptr [@@jmp_table+EAX*4]
        //////// ///////////////////

@@sdrByDateCreate:
        LEA      EAX, [ESI].TWin32FindData.ftCreationTime
        LEA      EDX, [EDI].TWin32FindData.ftCreationTime
@@sdrByDate1:
        PUSH     EDX
        PUSH     EAX
        CALL     CompareFileTime
        TEST     EAX, EAX
        JE       @@2
        JMP      @@exit1

@@sdrBySize:
        MOV      EAX, [ESI].TWin32FindData.nFileSizeHigh
        SUB      EAX, [EDI].TWin32FindData.nFileSizeHigh
        JNE      @@sdrBySize1
        MOV      EAX, [ESI].TWin32FindData.nFileSizeLow
        SUB      EAX, [EDI].TWin32FindData.nFileSizeLow
@@to_2:
        JE       @@2
@@sdrBySize1:
        POP      EDX
        DEC      EDX
        CMP      byte ptr[EDX], sdrBySizeDescending
        JNE      @@sdrBySize2
        NEG      EAX
@@sdrBySize2:
        JNE      @@exit
        //////// ///////////////////

        DD       -1, 1
@@point:DB       '.',0

@@sdrByExt:
        LEA      EAX, [EDI].TWin32FindData.cFileName
        MOV      EDX, offset[@@point]
        PUSH     EDX
        CALL     __DelimiterLast
        POP      EDX
        PUSH     EAX
        LEA      EAX, [ESI].TWin32FindData.cFileName
        CALL     __DelimiterLast
        POP      EDX
        JMP      @@sdrByName0

@@sdrByName:
        LEA      EAX, [ESI].TWin32FindData.cFileName
        LEA      EDX, [EDI].TWin32FindData.cFileName
@@sdrByName0:
        CMP      [EBX].TSortDirData.CaseSensitive, 0
        JNE      @@sdrByName1
        CALL     _AnsiCompareStrNoCase
        JMP      @@sdrByName2
@@sdrByName1:
        CALL     _AnsiCompareStr
@@sdrByName2:
        TEST     EAX, EAX
        JE       @@to_2
        //JMP    @@exit1

@@exit1:
        POP      EDX
@@exit:
        POP      EDI
        POP      ESI
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function CompareDirItems( const Data : PSortDirData; const e1, e2 : DWORD ) : Integer;
var I : Integer;
    Item1, Item2 : PWin32FindData;
    S1, S2 : PChar;
    IsDir1, IsDir2 : Boolean;
    Date1, Date2 : PFileTime;
begin
  Item1 := Data.Dir.fList.fItems[ e1 ];
  Item2 := Data.Dir.fList.fItems[ e2 ];
  Result := 0;
  IsDir1 := (Item1.dwFileAttributes and FILE_ATTRIBUTE_DIRECTORY) <> 0;
  IsDir2 := (Item2.dwFileAttributes and FILE_ATTRIBUTE_DIRECTORY) <> 0;
  if (IsDir1 <> IsDir2) and Data.FoldersFirst then
  begin
    if IsDir1 then Result := -1 else Result := 1;
    exit;
  end;
  for I := 0 to High(Data.Rules) do
  begin
    case Data.Rules[ I ] of
    sdrByName:
      begin
        S1 := Item1.cFileName;
        S2 := Item2.cFileName;
        if not Data.CaseSensitive then
          Result := _AnsiCompareStrNoCase( S1, S2 )
        else
          Result := _AnsiCompareStr( S1, S2 );
      end;
    sdrByExt:
      begin
        S1 := Item1.cFileName;
        S2 := Item2.cFileName;
        S1 := __DelimiterLast( S1, '.' );
        S2 := __DelimiterLast( S2, '.' );
        if not Data.CaseSensitive then
           Result := _AnsiCompareStrNoCase( S1, S2 )
        else
           Result := _AnsiCompareStr( S1, S2 );
      end;
    sdrBySize, sdrBySizeDescending:
      begin
        if Item1.nFileSizeHigh < Item2.nFileSizeHigh then
           Result := -1
        else
        if Item1.nFileSizeHigh > Item2.nFileSizeHigh then
           Result := 1
        else
        if Item1.nFileSizeLow < Item2.nFileSizeLow then
           Result := -1
        else
        if Item1.nFileSizeLow > Item2.nFileSizeLow then
           Result := 1;
        if Data.Rules[ I ] = sdrBySizeDescending then
           Result := -Result;
      end;
    sdrByDateCreate:
      begin
        Date1 := @Item1.ftCreationTime;
        Date2 := @Item2.ftCreationTime;
        Result := CompareFileTime( Date1^, Date2^ );
      end;
    sdrByDateChanged:
      begin
        Date1 := @Item1.ftLastWriteTime;
        Date2 := @Item2.ftLastWriteTime;
        Result := CompareFileTime( Date1^, Date2^ );
      end;
    sdrByDateAccessed:
      begin
        Date1 := @Item1.ftLastAccessTime;
        Date2 := @Item2.ftLastAccessTime;
        Result := CompareFileTime( Date1^, Date2^ );
      end;
    end; {case}
    if Result <> 0 then break;
  end;
end;
{$ENDIF ASM_VERSION}
//[END CompareDirItems]

//[PROCEDURE SwapDirItems]
{$IFDEF ASM_VERSION}
procedure SwapDirItems( const Data : PSortDirData; const e1, e2 : DWORD );
asm
        MOV      EAX, [EAX].TSortDirData.Dir
        MOV      EAX, [EAX].TDirList.fList
        MOV      EAX, [EAX].TList.fItems
        LEA      EDX, [EAX+EDX*4]
        LEA      ECX, [EAX+ECX*4]
        MOV      EAX, [EDX]
        XCHG     EAX, [ECX]
        MOV      [EDX], EAX
end;
{$ELSE ASM_VERSION} //Pascal
procedure SwapDirItems( const Data : PSortDirData; const e1, e2 : DWORD );
var Tmp : Pointer;
begin
  Tmp := Data.Dir.FList.fItems[ e1 ];
  Data.Dir.FList.fItems[ e1 ] := Data.Dir.FList.fItems[ e2 ];
  Data.Dir.FList.fItems[ e2 ] := Tmp;
end;
{$ENDIF ASM_VERSION}
//[END SwapDirItems]

{
  TSortDirData = packed Record
    FoldersFirst, CaseSensitive : Boolean;
    Rules : array[ 0..11 ] of TSortDirRules;
    Dir : PDirList;
  end;
}
{$IFDEF ASM_VERSION}
procedure TDirList.Sort(Rules: array of TSortDirRules);
const   high_DefSortDirRules = High( DefSortDirRules );
asm
        PUSH     EBX
        PUSH     ESI
        XOR      EBX,EBX
        CMP      [EAX].fList, EBX
        JE       @@exit

        PUSH     EAX           // prepare Dir = Self
        XOR      EAX, EAX
        PUSH     EAX
        PUSH     EAX
        PUSH     EAX
        MOV      ESI, ESP
        INC      ECX           // ECX = High(Rules)
        JZ       @@2
@@1:    MOV      AH, [EDX]     // AH = Rules[ I ]
        INC      EDX
        CALL     @@add_rule
        LOOP     @@1
@@2:    LEA      EDX, [DefSortDirRules]
        MOV      CL, high_DefSortDirRules + 1
@@21:   MOV      AH, [EDX]
        INC      EDX
        CALL     @@add_rule
        LOOP     @@21

        PUSH     BX           // prepare FoldersFirst(BL), CaseSensitive(BH)
        MOV      EBX, [ESP].TSortDirData.Dir
        MOV      EAX, ESP
        PUSH     offset[SwapDirItems]
        MOV      ECX, offset[CompareDirItems]
        MOV      EDX, [EBX].fList
        MOV      EDX, [EDX].TList.fCount
        CALL     SortData

        ADD      ESP, 18
        JMP      @@exit

@@add_rule:
        PUSH     ESI
        PUSH     ECX
        MOV      CL, 11
@@a1:   LODSB
        TEST     AL, AL
        JZ       @@a2
        CMP      AL, AH
        JE       @@a3
        LOOP     @@a1
@@a2:   DEC      ESI
        MOV      [ESI], AH
        CMP      AH, sdrFoldersFirst
        JNE      @@a4
        INC      BL
@@a4:   CMP      AH, sdrCaseSensitive
        JNE      @@a3
        INC      BH
@@a3:   POP      ECX
        POP      ESI
        RET

@@exit:
        POP      ESI
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TDirList.Sort(Rules: array of TSortDirRules);
var SortDirData : TSortDirData;
    I, J : Integer;

    function RulePresent( Rule : TSortDirRules ) : Boolean;
    var K : Integer;
    begin
      Result := True;
      for K := J - 1 downto 0 do
        if Rule = SortDirData.Rules[ K ] then exit;
      Result := False;
    end;

    procedure AddRule( Rule : TSortDirRules );
    begin
      if J > High( SortDirData.Rules ) then exit;
      if RulePresent( Rule ) then exit;
      SortDirData.Rules[ J ] := Rule;
      Inc( J );
    end;
begin
  if fList = nil then Exit;
  J := 0;
  for I := 0 to High(Rules) do
    AddRule( Rules[ I ] );
  for I := 0 to High(DefSortDirRules) do
    AddRule( DefSortDirRules[ I ] );
  while J < High( SortDirData.Rules ) do
  begin
    SortDirData.Rules[ J ] := sdrNone;
    Inc( J );
  end;

  SortDirData.Dir := Self;
  SortDirData.FoldersFirst := RulePresent( sdrFoldersFirst );
  SortDirData.CaseSensitive := RulePresent( sdrCaseSensitive );
  SortData( Pointer( @SortDirData ), fList.fCount, @CompareDirItems, @SwapDirItems );
end;
{$ENDIF ASM_VERSION}


//[function TDirList.FileList]
function TDirList.FileList(const Separator: String; Dirs,
  FullPaths: Boolean): String;
var I: Integer;
begin
  Result := '';
  for I := 0 to Count-1 do
  begin
    if not Dirs and IsDirectory[ I ] then Continue;
    if FullPaths then
      Result := Result + Path;
    Result := Result + Names[ I ] + Separator;
  end;
end;





////////////////////////////////////////////////////////////////////////
//
//
//                        R  E  G  I  S  T  R  Y
//
//
////////////////////////////////////////////////////////////////////////




function RegSetValueEx; external advapi32 name 'RegSetValueExA';



{ -- registry -- }

//[function RegKeyOpenRead]
function RegKeyOpenRead( Key: HKey; const SubKey: String ): HKey;
begin
  if RegOpenKeyEx( Key, PChar( SubKey ), 0, KEY_READ, Result ) <> ERROR_SUCCESS then
     Result := 0;
end;

//[function RegKeyOpenWrite]
function RegKeyOpenWrite( Key: HKey; const SubKey: String ): HKey;
begin
  if RegOpenKeyEx( Key, PChar( SubKey ), 0, KEY_READ or KEY_WRITE, Result ) <> ERROR_SUCCESS then
     Result := 0;
end;

//[function RegKeyOpenCreate]
function RegKeyOpenCreate( Key: HKey; const SubKey: String ): HKey;
var dwDisp: DWORD;
begin
  if RegCreateKeyEx( Key, PChar( SubKey ), 0, nil, 0, KEY_ALL_ACCESS, nil, Result,
                     @dwDisp ) <> ERROR_SUCCESS then
    Result := 0;
end;

//[function RegKeyGetDw]
function RegKeyGetDw( Key: HKey; const ValueName: String ): DWORD;
var dwType, dwSize: DWORD;
begin
  dwSize := sizeof( DWORD );
  Result := 0;
  if (Key = 0) or
     (RegQueryValueEx( Key, PChar( ValueName ), nil, @dwType, PByte( @Result ), @dwSize ) <> ERROR_SUCCESS)
     or (dwType <> REG_DWORD) then Result := 0;
end;

//[function RegKeyGetStr]
function RegKeyGetStr( Key: HKey; const ValueName: String ): String;
var dwType, dwSize: DWORD;
    Buffer: PChar;

    function Query: Boolean;
    begin
      Result := RegQueryValueEx( Key, PChar( ValueName ), nil, @dwType,
                Pointer( Buffer ), @dwSize ) = ERROR_SUCCESS;
    end;
begin
  Result := '';
  if Key = 0 then Exit;
  dwSize := 0;
  Buffer := nil;
  if not Query or (dwType <> REG_SZ) then Exit;
  GetMem( Buffer, dwSize );
  if Query then
    Result := Buffer;
  FreeMem( Buffer );
end;

//[function RegKeyGetStrEx]
function RegKeyGetStrEx( Key: HKey; const ValueName: String ): String;
var dwType, dwSize: DWORD;
    Buffer: PChar;
    Sz: Integer;
    function Query: Boolean;
    begin
      Result := RegQueryValueEx( Key, PChar( ValueName ), nil, @dwType,
                Pointer( Buffer ), @dwSize ) = ERROR_SUCCESS;
    end;
begin
  Result := '';
  if Key = 0 then Exit;
  dwSize := 0;
  Buffer := nil;
  if not Query or ((dwType <> REG_SZ) and (dwtype <> REG_EXPAND_SZ)) then Exit;
  GetMem( Buffer, dwSize );
  if Query then
  begin
    if dwtype = REG_EXPAND_SZ then
    begin
      Sz := ExpandEnvironmentStrings(Buffer,nil,0);
      SetLength( Result, Sz );
      ExpandEnvironmentStrings(Buffer, PChar(Result), Sz);
    end
      else
    Result := Buffer;
  end;
  FreeMem( Buffer );
end;

//[function RegKeySetDw]
function RegKeySetDw( Key: HKey; const ValueName: String; Value: DWORD ): Boolean;
begin
  Result := (Key <> 0) and (RegSetValueEx( Key, PChar( ValueName ), 0, REG_DWORD, @Value, sizeof( DWORD ) )
            = ERROR_SUCCESS);
end;

//[function RegKeySetStr]
function RegKeySetStr( Key: HKey; const ValueName: String; const Value: String ): Boolean;
begin
  Result := (Key <> 0) and (RegSetValueEx( Key, PChar( ValueName ), 0,
            REG_SZ, PChar(Value),
             Length( Value ) + 1 ) = ERROR_SUCCESS);
end;

//[function RegKeySetStrEx]
function RegKeySetStrEx( Key: HKey; const ValueName: string; const Value: string;
                         expand: boolean): Boolean;
var dwType: DWORD;
begin
  dwType := REG_SZ;
  if expand then
    dwType := REG_EXPAND_SZ;
  Result := (Key <> 0) and (RegSetValueEx(Key, PChar(ValueName), 0, dwType,
            PChar(Value), Length(Value) + 1) = ERROR_SUCCESS);
end;

//[procedure RegKeyClose]
procedure RegKeyClose( Key: HKey );
begin
  if Key <> 0 then
    RegCloseKey( Key );
end;

//[function RegKeyDelete]
function RegKeyDelete( Key: HKey; const SubKey: String ): Boolean;
begin
  Result := FALSE;
  if Key <> 0 then
    Result := RegDeleteKey( Key, PChar( SubKey ) ) = ERROR_SUCCESS;
end;

//[function RegKeyDeleteValue]
function RegKeyDeleteValue( Key: HKey; const SubKey: String ): Boolean;
begin
  Result := FALSE;
  if Key <> 0 then
    Result := RegDeleteValue( Key, PChar( SubKey ) ) = ERROR_SUCCESS;
end;

//[function RegKeyExists]
function RegKeyExists( Key: HKey; const SubKey: String ): Boolean;
var K: Integer;
begin
  if Key = 0 then
  begin
    Result := FALSE;
    Exit;
  end;
  K := RegKeyOpenRead( Key, SubKey );
  Result := K <> 0;
  if K <> 0 then
    RegKeyClose( K );
end;

//[function RegKeyValExists]
function RegKeyValExists( Key: HKey; const ValueName: String ): Boolean;
var dwType, dwSize: DWORD;
begin
  Result := (Key <> 0) and
            (RegQueryValueEx( Key, PChar( ValueName ), nil,
            @dwType, nil, @dwSize ) = ERROR_SUCCESS);
end;

//[function RegKeyValueSize]
function RegKeyValueSize( Key: HKey; const ValueName: String ): Integer;
begin
  Result := 0;
  if Key = 0 then Exit;
  RegQueryValueEx( Key, PChar( ValueName ), nil, nil, nil, @ DWORD( Result ) );
end;

//[function RegKeyGetBinary]
function RegKeyGetBinary( Key: HKey; const ValueName: String; var Buffer; Count: Integer ): Integer;
begin
  Result := 0;
  if Key = 0 then Exit;
  Result := Count;
  RegQueryValueEx( Key, PChar( ValueName ), nil, nil, @ Buffer, @ Result );
end;

//[function RegKeySetBinary]
function RegKeySetBinary( Key: HKey; const ValueName: String; const Buffer; Count: Integer ): Boolean;
begin
  Result := (Key <> 0) and (RegSetValueEx( Key, PChar( ValueName ), 0,
                    REG_BINARY, @ Buffer, Count ) = ERROR_SUCCESS);
end;

//[function RegKeyGetDateTime]
function RegKeyGetDateTime(Key: HKey; const ValueName: String): TDateTime;
begin
  RegKeyGetBinary( Key, ValueName, Result, Sizeof( Result ) );
end;

//[function RegKeySetDateTime]
function RegKeySetDateTime(Key: HKey; const ValueName: String; DateTime: TDateTime): Boolean;
begin
  Result := RegKeySetBinary( Key, ValueName, DateTime, Sizeof( DateTime ) );
end;

//-----------------------------------------------
// functions by Valerian Luft <luft@valerian.de>
//-----------------------------------------------
//[function RegKeyGetSubKeys]
function RegKeyGetSubKeys( const Key: HKEY; List: PStrList) : Boolean;
var
  I, Size, NumSubKeys, MaxSubKeyLen : DWORD;
  KeyName: String;
begin
  Result := False;
  List.Clear ;
  if RegQueryInfoKey(Key, nil, nil, nil, @NumSubKeys, @MaxSubKeyLen, nil, nil, nil, nil,
nil, nil) = ERROR_SUCCESS then
    begin
      if NumSubKeys > 0 then begin
        for I := 0 to NumSubKeys-1 do
        begin
          Size := MaxSubKeyLen+1;
          SetLength(KeyName, Size);
          //FillChar(KeyName[1],Size,#0);
          RegEnumKeyEx(Key, I, @KeyName[1], Size, nil, nil, nil, nil);
          SetLength(KeyName, lstrlen(@KeyName[1]));
          List.Add(KeyName);
        end;
      end;
      Result:= True;
  end;
end;


//[function RegKeyGetValueNames]
function RegKeyGetValueNames(const Key: HKEY; List: PStrList): Boolean;
var
  I, Size, NumSubKeys, NumValueNames, MaxValueNameLen: DWORD;
  ValueName: String;
begin
  List.Clear ;
  Result:=False;
  if RegQueryInfoKey(Key, nil, nil, nil, @NumSubKeys, nil, nil, @NumValueNames,
@MaxValueNameLen, nil, nil, nil) = ERROR_SUCCESS then
  begin
     if NumValueNames > 0 then
        for I := 0 to NumValueNames - 1 do begin
          Size := MaxValueNameLen + 1;
          SetLength(ValueName, Size);
          //FillChar(ValueName[1],Size,#0);
          RegEnumValue(Key, I, @ValueName[1], Size, nil, nil, nil, nil);
          SetLength(ValueName, lstrlen(@ValueName[1]));
          List.Add(ValueName);
        end;
     Result := True;
  end ;
end;


//[function RegKeyGetValueTyp]
function RegKeyGetValueTyp (const Key:HKEY; const ValueName: String) : DWORD;
begin
Result:= Key ;
if Key <> 0 then
   RegQueryValueEx (Key,@ValueName[1],NIL,@Result,NIL,NIL)
end;

//[procedure FileTypeReg]
procedure FileTypeReg(FExt,Desc,Cmd,Exe: string; IconIndex: integer;
Default,Run: boolean);
var Reg: HKey;
    Key: string;
begin
  Reg:=RegKeyOpenWrite(HKEY_CLASSES_ROOT,'Applications');
  if not RegKeyExists(Reg,ExtractFileName(Exe)) then
    begin
      RegKeyClose(Reg);
      Reg := RegKeyOpenCreate(HKEY_CLASSES_ROOT,
          'Applications\'+ExtractFileName(Exe)+'\Shell\Open\Command');
      RegKeySetStr(Reg,'',Exe+' "%1"');
      RegKeyClose(Reg);
    end
  else RegKeyClose( Reg ); // {VK}
  Reg:=RegKeyOpenCreate(HKEY_CLASSES_ROOT,FExt);
  Key:=LowerCase(FExt)+'file';
  Delete(Key,1,1);
  RegKeySetStr(Reg,'',Key);
  RegKeyClose(Reg);
  Reg:=RegKeyOpenCreate(HKEY_CLASSES_ROOT,Key);
  RegKeySetStr(Reg,'',Desc);
  RegKeyClose(Reg);
  if IconIndex<>-1 then
    begin
      Reg:=RegKeyOpenCreate(HKEY_CLASSES_ROOT,Key+'\DefaultIcon');
      RegKeySetStr(Reg,'',Exe + ',' + Int2Str(IconIndex) );
      RegKeyClose(Reg);
    end;
  if Run then
    begin
      Reg:=RegKeyOpenCreate(HKEY_CLASSES_ROOT,Key+'\Shell');
      if Default then RegKeySetStr(Reg,'',Cmd)
                 else RegKeySetStr(Reg,'','');
      RegKeyClose(Reg);
      Reg:=RegKeyOpenCreate(HKEY_CLASSES_ROOT,Key+'\Shell\'+Cmd);
      RegKeyClose(Reg);

      Reg:=RegKeyOpenCreate(HKEY_CLASSES_ROOT,Key+'\Shell\'+Cmd+'\Command');
      RegKeySetStr(Reg,'',Exe+' "%1"');
      RegKeyClose(Reg);
    end;
end;














{ -- TDirChange -- }

const FilterFlags: array[ TFileChangeFilters ] of Integer = (
      FILE_NOTIFY_CHANGE_FILE_NAME, FILE_NOTIFY_CHANGE_DIR_NAME,
      FILE_NOTIFY_CHANGE_ATTRIBUTES, FILE_NOTIFY_CHANGE_SIZE,
      FILE_NOTIFY_CHANGE_LAST_WRITE, $20 {FILE_NOTIFY_CHANGE_LAST_ACCESS},
      $40 {FILE_NOTIFY_CHANGE_CREATION}, FILE_NOTIFY_CHANGE_SECURITY );

//[FUNCTION _NewDirChgNotifier]
{$IFDEF ASM_VERSION}
function _NewDirChgNotifier: PDirChange;
begin
  New( Result, Create );
end;
//[function NewDirChangeNotifier]
function NewDirChangeNotifier( const Path: String; Filter: TFileChangeFilter;
                               WatchSubtree: Boolean; ChangeProc: TOnDirChange )
                               : PDirChange;
const Dflt_Flags = FILE_NOTIFY_CHANGE_FILE_NAME or FILE_NOTIFY_CHANGE_DIR_NAME or
      FILE_NOTIFY_CHANGE_ATTRIBUTES or FILE_NOTIFY_CHANGE_SIZE or
      FILE_NOTIFY_CHANGE_LAST_WRITE;
asm
        PUSH     EBX
        PUSH     ECX // [EBP-8] = WatchSubtree
        PUSH     EDX // [EBP-12] = Filter
        PUSH     EAX // [EBP-16] = Path
        CALL     _NewDirChgNotifier
        XCHG     EBX, EAX
        LEA      EAX, [EBX].TDirChange.FPath
        POP      EDX
        CALL     System.@LStrAsg
        MOV      EAX, [ChangeProc].TMethod.Code
        MOV      [EBX].TDirChange.FOnChange.TMethod.Code, EAX
        MOV      EAX, [ChangeProc].TMethod.Data
        MOV      [EBX].TDirChange.FOnChange.TMethod.Data, EAX
        POP      ECX
        MOV      EAX, Dflt_Flags
        MOVZX    ECX, CL
        JECXZ    @@flags_ready
        PUSH     ECX
        MOV      EAX, ESP
        MOV      EDX, offset[FilterFlags]
        XOR      ECX, ECX
        MOV      CL, 7
        CALL     MakeFlags
        POP      ECX
@@flags_ready:           // EAX = Flags
        POP      EDX
        MOVZX    EDX, DL // EDX = WatchSubtree
        PUSH     EAX
        PUSH     EDX
        PUSH     [EBX].TDirChange.FPath
        CALL     FindFirstChangeNotification
        MOV      [EBX].TDirChange.FHandle, EAX
        INC      EAX
        JZ       @@fault
        PUSH     EBX
        PUSH     offset[TDirChange.Execute]
        CALL     NewThreadEx
        MOV      [EBX].TDirChange.FMonitor, EAX
        JMP      @@exit
@@fault:
        XCHG     EAX, EBX
        CALL     TObj.Free
@@exit:
        XCHG     EAX, EBX
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function NewDirChangeNotifier( const Path: String; Filter: TFileChangeFilter;
                               WatchSubtree: Boolean; ChangeProc: TOnDirChange )
                               : PDirChange;
var Flags: DWORD;
begin
  Result := PDirChange.Create;

  Result.FPath := Path;
  Result.FOnChange := ChangeProc;
  if Filter = [ ] then
    Flags := FILE_NOTIFY_CHANGE_FILE_NAME or FILE_NOTIFY_CHANGE_DIR_NAME or
      FILE_NOTIFY_CHANGE_ATTRIBUTES or FILE_NOTIFY_CHANGE_SIZE or
      FILE_NOTIFY_CHANGE_LAST_WRITE
  else
    Flags := MakeFlags( @Filter, FilterFlags );
  Result.FHandle := FindFirstChangeNotification(PChar(Result.FPath),
                    Bool( Integer( WatchSubtree ) ), Flags);
  if Result.FHandle <> INVALID_HANDLE_VALUE then
    Result.FMonitor := NewThreadEx( Result.Execute )
  else //MsgOK( 'Can not monitor ' + Result.FPath + #13'Error ' + Int2Str( GetLastError ) );
  begin
    Result.Free;
    Result := nil;
  end;
end;
{$ENDIF ASM_VERSION}
//[END _NewDirChgNotifier]

{ TDirChange }

{$IFDEF ASM_VERSION}
//[procedure TDirChange.Changed]
procedure TDirChange.Changed;
asm
        MOV      ECX, [EAX].FPath
        XCHG     EDX, EAX
        MOV      EAX, [EDX].FOnChange.TMethod.Data
        CALL     [EDX].FOnChange.TMethod.Code
end;
{$ELSE ASM_VERSION} //Pascal
procedure TDirChange.Changed;
begin
  FOnChange(Self, FPath); // must be assigned always!!!
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[destructor TDirChange.Destroy]
destructor TDirChange.Destroy;
asm
        PUSH     EBX
        XCHG     EBX, EAX
        MOV      ECX, [EBX].FMonitor
        JECXZ    @@no_monitor
        XCHG     EAX, ECX
        CALL     TObj.Free
@@no_monitor:
        MOV      ECX, [EBX].FHandle
        JECXZ    @@exit
        PUSH     ECX
        CALL     FindCloseChangeNotification
@@exit:
        LEA      EAX, [EBX].FPath
        CALL     System.@LStrClr
        XCHG     EAX, EBX
        CALL     TObj.Destroy
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
destructor TDirChange.Destroy;
begin
  if FMonitor <> nil then
     FMonitor.Free;
  if FHandle > 0 then // FHandle <> INVALID_HANDLE_VALUE AND FHandle <> 0
     FindCloseChangeNotification(FHandle);
  FPath := '';
  inherited;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_noVERSION}
//[function TDirChange.Execute]
function TDirChange.Execute(Sender: PThread): Integer;
asm
        PUSH     EBX
        PUSH     ESI
        XCHG     EBX, EAX
        MOV      ESI, EDX
@@loo:
        MOVZX    ECX, [ESI].TThread.FTerminated
        INC      ECX
        LOOP     @@e_loop

        MOV      ECX, [EBX].FHandle
        INC      ECX
        JZ       @@e_loop

        PUSH     INFINITE
        PUSH     ECX
        CALL     WaitForSingleObject
        OR       EAX, EAX
        JNZ      @@loo

        PUSH     [EBX].FHandle
        MOV      EAX, [EBX].FMonitor
        PUSH     EBX
        PUSH     offset[TDirChange.Changed]
        CALL     TThread.Synchronize
        CALL     FindNextChangeNotification
        JMP      @@loo
@@e_loop:

        POP      ESI
        POP      EBX
        XOR      EAX, EAX
end;
{$ELSE ASM_VERSION} //Pascal
function TDirChange.Execute(Sender: PThread): Integer;
begin
  while (not Sender.Terminated and (FHandle <> INVALID_HANDLE_VALUE)) do
    if (WaitForSingleObject(FHandle, INFINITE) = WAIT_OBJECT_0) then
    begin
      if AppletTerminated then break;
      Applet.GetWindowHandle;
      FMonitor.Synchronize( Changed );
      FindNextChangeNotification(FHandle);
    end;
  Result := 0;
end;
{$ENDIF ASM_VERSION}













//////////////////////////////////////////////////////////////////////
//
//
//                D  A  T  E     A  N  D     T  I  M  E
//
//
//////////////////////////////////////////////////////////////////////











{ -- date and time utilities -- }

{* This part of the unit contains date-time routines. It is not a simple compilation
   of Delphi VCL date-time. E.g., TDateTime type is not based on 31-Dec-1899,
   but it is based on 31-Dec-0000 instead, allowing easy manipulating of dates
   at all Christian era, and all other historical era too. }

//[procedure DivMod]
procedure DivMod(Dividend: Integer; Divisor: Word;
  var Result, Remainder: Word);
{$IFDEF F_P}
begin
        Result    := Dividend div Divisor;
        Remainder := Dividend mod Divisor;
end;
{$ELSE DELPHI}
asm
        PUSH    EBX
        MOV     EBX,EDX
        MOV     EDX,EAX
        SHR     EDX,16
        DIV     BX
        MOV     EBX,Remainder
        MOV     [ECX],AX
        MOV     [EBX],DX
        POP     EBX
end;
{$ENDIF}


//[API GetLocalTime, GetSystemTime]
procedure GetLocalTime; external kernel32 name 'GetLocalTime';
procedure GetSystemTime; external kernel32 name 'GetSystemTime';


//*
//[function Now]
function Now : TDateTime;
var SystemTime : TSystemTime;
begin
   GetLocalTime( SystemTime );
   SystemTime2DateTime( SystemTime, Result );
end;

//[function Date]
function Date: TDateTime;
begin
  Result := Trunc( Now );
end;

//[procedure DecodeDateFully]
procedure DecodeDateFully( DateTime: TDateTime; var Year, Month, Day, DayOfWeek: WORD );
var ST: TSystemTime;
begin
  DateTime2SystemTime( DateTime, ST );
  Year := ST.wYear;
  Month := ST.wMonth;
  Day := ST.wDay;
  DayOfWeek := ST.wDayOfWeek;
end;

//[procedure DecodeDate]
procedure DecodeDate( DateTime: TDateTime; var Year, Month, Day: WORD );
var Dummy: Word;
begin
  DecodeDateFully( DateTime, Year, Month, Day, Dummy );
end;

//[function EncodeDate]
function EncodeDate( Year, Month, Day: WORD; var DateTime: TDateTime ): Boolean;
var ST: TSystemTime;
begin
  FillChar( ST, Sizeof( ST ), 0 );
  ST.wYear := Year;
  ST.wMonth := Month;
  ST.wDay := Day;
  Result := SystemTime2DateTime( ST, DateTime );
end;

//[FUNCTION CompareSystemTime]
{$IFDEF ASM_VERSION}
function CompareSystemTime( const D1, D2 : TSystemTime) : Integer; assembler;
asm
        PUSH     ESI
        PUSH     EBX
        MOV      ESI, EAX
        XOR      EAX, EAX
        XOR      ECX, ECX
        MOV      CL, 8  // 8 words: wYear, wMonth,..., wMilliseconds
@@loo:
        LODSW
        MOV      BX, [EDX]
        INC      EDX
        INC      EDX

        CMP      CL, 6
        JE       @@cont  // skip compare DayOfWeek

        SUB      AX, BX
        JNE      @@calc

@@cont:
        LOOP     @@loo
        JMP      @@exit

@@calc:
        SBB      EAX, EAX
        {$IFDEF PARANOIA}
        DB $0C, 1
        {$ELSE}
        OR       AL, 1
        {$ENDIF}

@@exit:
        POP      EBX
        POP      ESI
end;
{$ELSE ASM_VERSION} //Pascal
function CompareSystemTime(const D1, D2 : TSystemTime) : Integer;
var R: Integer;
   procedure CompareFields(const F1, F2 : Integer);
   begin
      if R <> 0 then Exit;
      if F1 = F2 then Exit;
      if F1 < F2 then
         R := -1
      else
         R := 1;
   end;
begin
   R := 0;
   CompareFields( D1.wYear, D2.wYear );
   CompareFields( D1.wMonth, D2.wMonth );
   CompareFields( D1.wDay, D2.wDay );
   CompareFields( D1.wHour, D2.wHour );
   CompareFields( D1.wMinute, D2.wMinute );
   CompareFields( D1.wSecond, D2.wSecond );
   CompareFields( D1.wMilliseconds, D2.wMilliseconds );
   Result := R;
end;
{$ENDIF ASM_VERSION}
//[END CompareSystemTime]

//*
//[procedure IncDays]
procedure IncDays( var SystemTime : TSystemTime; DaysNum : Integer );
var DateTime : TDateTime;
begin
   SystemTime2DateTime( SystemTime, DateTime );
   DateTime := DateTime + DaysNum;
   DateTime2SystemTime( DateTime, SystemTime );
end;

//*
//[procedure IncMonths]
procedure IncMonths( var SystemTime : TSystemTime; MonthsNum : Integer );
var M : Integer;
    DateTime : TDateTime;
begin
   M := SystemTime.wMonth + MonthsNum - 1;
   Inc( SystemTime.wYear, M div 12 );
   SystemTime.wMonth := M mod 12 + 1;

   // Normalize wDayOfWeek field:
   SystemTime2DateTime( SystemTime, DateTime );
   DateTime2SystemTime( DateTime, SystemTime );
end;

//*
//[function IsLeapYear]
function IsLeapYear(Year: Word): Boolean;
begin
  Result := (Year mod 4 = 0) and ((Year mod 100 <> 0) or (Year mod 400 = 0));
end;

//*
//[function SystemTime2DateTime]
function SystemTime2DateTime(const SystemTime : TSystemTime; var DateTime : TDateTime ) : Boolean;
var I : Integer;
    Day : Integer;
    DayTable: PDayTable;
begin
  Result := False;
  DateTime := 0.0;
  DayTable := @MonthDays[IsLeapYear(SystemTime.wYear)];
  with SystemTime do
//-------- by Vadim Petrov ----------------------------------------------------------------
//if (wYear >= 1) and (wYear <= 9999) and (wMonth >= 1) and (wMonth <= 12) and
//  (wDay >= 1) and (wDay <= DayTable^[wMonth]) and
//  (wHour < 24) and (wMinute < 60) and (wSecond < 60) and (wMilliSeconds < 1000) then
//---------------------------------------------------------------------------------------//
  if {(wYear >= 0) !always true! and} (wYear <= 9999) and
    {(wMonth >= 0) !always true! and} (wMonth <= 12) and
    {(wDay >= 0) !always true! and} (wDay <= DayTable^[wMonth]) and                                      //
    (wHour < 24) and (wMinute < 60) and (wSecond < 60) and (wMilliSeconds < 1000) then   //
//---------------------------------------------------------------------------------------//
  begin
    Day := wDay;
    for I := 1 to wMonth - 1 do
        Inc(Day, DayTable^[I]);
    I := wYear - 1;
    //--------------- by Vadim Petrov ------++
    if I<0 then i := 0;                     //
    //--------------------------------------++
    DateTime := I * 365 + I div 4 - I div 100 + I div 400 + Day
             + (wHour * 3600000 + wMinute * 60000 + wSecond * 1000 + wMilliSeconds) / MSecsPerDay;
    Result := True;
  end;
end;

//*
//[function DayOfWeek]
function DayOfWeek(Date: TDateTime): Integer;
begin
  Result := (Trunc( Date ) + 6) mod 7 + 1;
end;

//*
//[function DateTime2SystemTime]
function DateTime2SystemTime(const DateTime : TDateTime; var SystemTime : TSystemTime ) : Boolean;
const
  D1 = 365;
  D4 = D1 * 4 + 1;
  D100 = D4 * 25 - 1;
  D400 = D100 * 4 + 1;
var Days : Integer;
    Y, M, D, I: Word;
    MSec : Integer;
    DayTable: PDayTable;
    MinCount, MSecCount: Word;
begin
  Days := Trunc( DateTime );
  MSec := Round((DateTime - Days) * MSecsPerDay);
  Result := False;
  with SystemTime do
  if Days > 0 then
  begin
    Dec(Days);
    Y := 1;
    while Days >= D400 do
    begin
      Dec(Days, D400);
      Inc(Y, 400);
    end;
    DivMod(Days, D100, I, D);
    if I = 4 then
    begin
      Dec(I);
      Inc(D, D100);
    end;
    Inc(Y, I * 100);
    DivMod(D, D4, I, D);
    Inc(Y, I * 4);
    DivMod(D, D1, I, D);
    if I = 4 then
    begin
      Dec(I);
      Inc(D, D1);
    end;
    Inc(Y, I);
    DayTable := @MonthDays[IsLeapYear(Y)];
    M := 1;
    while True do
    begin
      I := DayTable^[M];
      if D < I then Break;
      Dec(D, I);
      Inc(M);
    end;
    wYear := Y;
    wMonth := M;
    wDay := D + 1;
    wDayOfWeek := DayOfWeek( DateTime );
    DivMod(MSec, 60000, MinCount, MSecCount);
    DivMod(MinCount, 60, wHour, wMinute);
    DivMod(MSecCount, 1000, wSecond, wMilliSeconds);
    Result := True;
  end;
end;

//*
//[function CatholicEaster]
function CatholicEaster( nYear: Integer ): TDateTime;
var
   nMoon, nEpact, nSunday, nGold, nCent, nCorx, nCorz: Integer;
   SystemTime : TSystemTime;
begin
   FillChar( SystemTime, Sizeof( SystemTime ), 0 );
   with SystemTime do
   begin

    wYear := nYear;

    { The Golden Number of the year in the 19 year Metonic Cycle }
    nGold := ( ( wYear mod 19 ) + 1  );

    { Calculate the Century }
    nCent := ( ( wYear div 100 ) + 1 );

    { No. of Years in which leap year was dropped in order to keep in step
      with the sun }
    nCorx := ( ( 3 * nCent ) div 4 - 12 );

    { Special Correction to Syncronize Easter with the moon's orbit }
    nCorz := ( ( 8 * nCent + 5 ) div 25 - 5 );

    { Find Sunday }
    nSunday := ( ( 5 * wYear ) div 4 - nCorx - 10 );

    { Set Epact (specifies occurance of full moon }
    nEpact := ( ( 11 * nGold + 20 + nCorz - nCorx ) mod 30 );

    if ( nEpact < 0 ) then
       nEpact := nEpact + 30;

    if ( ( nEpact = 25 ) and ( nGold > 11 ) ) or ( nEpact = 24 ) then
       nEpact := nEpact + 1;

    { Find Full Moon }
    nMoon := 44 - nEpact;

    if ( nMoon < 21 ) then
       nMoon := nMoon + 30;

    { Advance to Sunday }
    nMoon := ( nMoon + 7 - ( ( nSunday + nMoon ) mod 7 ) );

    if ( nMoon > 31 ) then
       begin
         wMonth := 4;
         wDay   := ( nMoon - 31 );
       end
    else
       begin
         wMonth := 3;
         wDay   := nMoon;
       end;
   end;
   SystemTime2DateTime( SystemTime, Result );
end;

//*
//[function SystemDate2Str]
function SystemDate2Str( const SystemTime : TSystemTime; const LocaleID : DWORD;
                         const DfltDateFormat : TDateFormat; const DateFormat : PChar ) : String;
var Buf : PChar;
    Sz : Integer;
    Flags : DWORD;
begin
   Sz := 100;
   Buf := nil;
   Result := '';
   Flags := 0;
   if DateFormat = nil then
   if DfltDateFormat = dfShortDate then
      Flags := DATE_SHORTDATE
   else
      Flags := DATE_LONGDATE;
   while True do
   begin
      if Buf <> nil then
         FreeMem( Buf );
      GetMem( Buf, Sz );
      if Buf = nil then Exit;
      if GetDateFormat( LocaleID, Flags, @SystemTime, DateFormat, Buf, Sz )
         = 0 then
      begin
         if GetLastError = ERROR_INSUFFICIENT_BUFFER then
            Sz := Sz * 2
         else
            break;
      end
         else
      begin
         Result := Buf;
         break;
      end;
   end;
   if Buf <> nil then
      FreeMem( Buf );
end;

//*
//[function SystemTime2Str]
function SystemTime2Str( const SystemTime : TSystemTime; const LocaleID : DWORD;
                         const Flags : TTimeFormatFlags; const TimeFormat : PChar ) : String;
var Buf : PChar;
    Sz : Integer;
    Flg : DWORD;
begin
   Sz := 100;
   Buf := nil;
   Result := '';
   Flg := 0;
   if tffNoMinutes in Flags then
      Flg := TIME_NOMINUTESORSECONDS
   else
   if tffNoSeconds in Flags then
      Flg := TIME_NOSECONDS;
   if tffNoMarker in Flags then
      Flg := Flg or TIME_NOTIMEMARKER;
   if tffForce24 in Flags then
      Flg := Flg or TIME_FORCE24HOURFORMAT;
   while True do
   begin
      if Buf <> nil then
         FreeMem( Buf );
      GetMem( Buf, Sz );
      if Buf = nil then Exit;
      if GetTimeFormat( LocaleID, Flg, @SystemTime, TimeFormat, Buf, Sz )
         = 0 then
      begin
         if GetLastError = ERROR_INSUFFICIENT_BUFFER then
            Sz := Sz * 2
         else
            break;
      end
         else
      begin
         Result := Buf;
         break;
      end;
   end;
   if Buf <> nil then
      FreeMem( Buf );
end;

//[function Date2StrFmt]
function Date2StrFmt( const Fmt: String; D: TDateTime ): String;
var ST: TSystemTime;
begin
  DateTime2SystemTime( D, ST );
  Result := SystemDate2Str( ST, LOCALE_USER_DEFAULT, dfShortDate, PChar( Fmt ) );
end;

//[function Time2StrFmt]
function Time2StrFmt( const Fmt: String; D: TDateTime ): String;
var ST: TSystemTime;
begin
  if D < 1 then D := D + 1;
  DateTime2SystemTime( D, ST );
  Result := SystemTime2Str( ST, LOCALE_USER_DEFAULT, [], PChar( Fmt ) );
end;

//[function DateTime2StrShort]
function DateTime2StrShort( D: TDateTime ): String;
var ST: TSystemTime;
begin
  //--------- by Vadim Petrov --------++
  if D < 1 then D := D + 1;           //
  //----------------------------------++
  DateTime2SystemTime( D, ST );
  Result := SystemDate2Str( ST, LOCALE_USER_DEFAULT {GetUserDefaultLCID}, dfShortDate, nil ) + ' ' +
            SystemTime2Str( ST, LOCALE_USER_DEFAULT {GetUserDefaultLCID}, [], nil );
end;

//[function Str2DateTimeFmt]
function Str2DateTimeFmt( const sFmtStr, sS: String ): TDateTime;
var h12, hAM: Boolean;
    FmtStr, S: PChar;

  function GetNum( var S: PChar; NChars: Integer ): Integer;
  begin
    Result := 0;
    while (S^ <> #0) and (NChars <> 0) do
    begin
      Dec( NChars );
      if S^ in ['0'..'9'] then
      begin
        Result := Result * 10 + Ord(S^) - Ord('0');
        Inc( S );
      end
      else
        break;
    end;
  end;

  function GetYear( var S: PChar; NChars: Integer ): Integer;
  var STNow: TSystemTime;
      OldDate: Boolean;
  begin
    Result := GetNum( S, NChars );
    GetSystemTime( STNow );
    OldDate := Result < 50;
    Result := Result + STNow.wYear - STNow.wYear mod 100;
    if OldDate then Dec( Result, 100 );
  end;

  function GetMonth( const fmt: String; var S: PChar ): Integer;
  var SD: TSystemTime;
      M: Integer;
      C, MonthStr: String;
  begin
    GetSystemTime( SD );
    for M := 1 to 12 do
    begin
      SD.wMonth := M;
      C := SystemDate2Str( SD, LOCALE_USER_DEFAULT, dfLongDate, PChar( fmt + '/dd/yyyy/' ) );
      MonthStr := Parse( C, '/' );
      if AnsiCompareStrNoCase( MonthStr, Copy( S, 1, Length( MonthStr ) ) ) = 0 then
      begin
        Result := M;
        Inc( S, Length( MonthStr ) );
        Exit;
      end;
    end;
    Result := 1;
  end;

  procedure SkipDayOfWeek( const fmt: String; var S: PChar );
  var SD: TSystemTime;
      Dt: TDateTime;
      D: Integer;
      C, DayWeekStr: String;
  begin
    GetSystemTime( SD );
    SystemTime2DateTime( SD, Dt );
    Dt := Dt - SD.wDayOfWeek;
    for D := 0 to 6 do
    begin
      DateTime2SystemTime( Dt, SD );
      C := SystemDate2Str( SD, LOCALE_USER_DEFAULT, dfLongDate, PChar( fmt + '/MM/yyyy/' ) );
      DayWeekStr := Parse( C, '/' );
      if AnsiCompareStrNoCase( DayWeekStr, Copy( S, 1, Length( DayWeekStr ) ) ) = 0 then
      begin
        Inc( S, Length( DayWeekStr ) );
        Exit;
      end;
      Dt := Dt + 1.0;
    end;
  end;

  procedure GetTimeMark( const fmt: String; var S: PChar );
  var SD: TSystemTime;
      AM: Boolean;
      C, TimeMarkStr: String;
  begin
    GetSystemTime( SD );
    SD.wHour := 0;
    for AM := FALSE to TRUE do
    begin
      C := SystemDate2Str( SD, LOCALE_USER_DEFAULT, dfLongDate, PChar( fmt + '/HH/mm' ) );
      TimeMarkStr := Parse( C, '/' );
      if AnsiCompareStrNoCase( TimeMarkStr, Copy( S, 1, Length( TimeMarkStr ) ) ) = 0 then
      begin
        Inc( S, Length( TimeMarkStr ) );
        hAM := AM;
        Exit;
      end;
      SD.wHour := 13;
    end;
    Result := 1;
  end;

  function FmtIs1( S: PChar ): Boolean;
  begin
    if StrIsStartingFrom( FmtStr, S ) then
    begin
      Inc( FmtStr, StrLen( S ) );
      Result := TRUE;
    end
      else
      Result := FALSE;
  end;

  function FmtIs( S1, S2: PChar ): Boolean;
  begin
    Result := FmtIs1( S1 ) or FmtIs1( S2 );
  end;

var ST: TSystemTime;
begin
  FmtStr := PChar( sFmtStr);
  S := PChar( sS );
  FillChar( ST, Sizeof( ST ), 0 );
  h12 := FALSE;
  hAM := FALSE;
  while (FmtStr^ <> #0) and (S^ <> #0) do
  begin
    if (FmtStr^ in ['a'..'z','A'..'Z']) and (S^ in ['0'..'9']) then
    begin
      if      FmtIs1( 'yyyy'   ) then ST.wYear := GetNum( S, 4 )
      else if FmtIs1( 'yy' )     then ST.wYear := GetYear( S, 2 )
      else if FmtIs1( 'y' )      then ST.wYear := GetYear( S, -1 )
      else if FmtIs( 'dd', 'd' ) then ST.wDay := GetNum( S, 2 )
      else if FmtIs( 'MM', 'M' ) then ST.wMonth := GetNum( S, 2 )
      else if FmtIs( 'HH', 'H' ) then ST.wHour := GetNum( S, 2 )
      else if FmtIs( 'hh', 'h' ) then begin ST.wHour := GetNum( S, 2 ); h12 := TRUE end
      else if FmtIs( 'mm', 'm' ) then ST.wMinute := GetNum( S, 2 )
      else if FmtIs( 'ss', 's' ) then ST.wSecond := GetNum( S, 2 );
    end
      else
    if (FmtStr^ in [ 'M', 'd', 'g' ]) then
    begin
      if      FmtIs1( 'MMMM' ) then ST.wMonth := GetMonth( 'MMMM', S )
      else if FmtIs1( 'MMM'  ) then ST.wMonth := GetMonth( 'MMM', S )
      else if FmtIs1( 'dddd' ) then SkipDayOfWeek( 'dddd', S )
      else if FmtIs1( 'ddd'  ) then SkipDayOfWeek( 'ddd', S )
      else if FmtIs1( 'tt'   ) then GetTimeMark( 'tt', S )
      else if FmtIs1( 't'    ) then GetTimeMark( 't', S );
    end
      else
    begin
      if FmtStr^ = S^ then
        Inc( FmtStr );
      Inc( S );
    end;
  end;

  if h12 then
  if hAM then
    Inc( ST.wHour, 12 );

  SystemTime2DateTime( ST, Result );
end;

var FmtBuf: PChar;

//[function Str2DateTimeShort]
function Str2DateTimeShort( const S: String ): TDateTime;
var FmtStr, FmtStr2: String;

  function EnumDateFmt( lpstrFmt: PChar ): Boolean; stdcall;
  begin
    GetMem( FmtBuf, StrLen( lpstrFmt ) + 1 );
    StrCopy( FmtBuf, lpstrFmt );
    Result := FALSE;
  end;

begin
  FmtStr := 'dd.MM.yyyy';
  FmtBuf := nil;
  EnumDateFormats( @ EnumDateFmt, LOCALE_USER_DEFAULT, DATE_SHORTDATE );
  if FmtBuf <> nil then
  begin
    FmtStr := FmtBuf;
    FreeMem( FmtBuf );
  end;

  FmtStr2 := 'H:mm:ss';
  FmtBuf := nil;
  EnumTimeFormats( @ EnumDateFmt, LOCALE_USER_DEFAULT, 0 );
  if FmtBuf <> nil then
  begin
    FmtStr2 := FmtBuf;
    FreeMem( FmtBuf );
  end;

  Result := Str2DateTimeFmt( FmtStr + ' ' + FmtStr2, S );
end;




















///////////////////////////////////////////////////////////////////////
//
//
//                          T  H  R  E  A  D  S
//
//
///////////////////////////////////////////////////////////////////////








{ -- Thread -- }

//[function ThreadFunc]
function ThreadFunc(Thread: PThread): integer; stdcall;
begin
  Result := Thread.Execute;
end;

{$IFDEF USE_CONSTRUCTORS}
//[function NewThread]
function NewThread: PThread;
begin
  new( Result, ThreadCreate );
end;
//[END NewThread]
{$ELSE not_USE_CONSTRUCTORS}
//*
//[function NewThread]
function NewThread: PThread;
begin
  {$IFNDEF FPC105ORBELOW}
  IsMultiThread := True;
  {$ENDIF}

  Result := PThread.Create;
  Result.FSuspended := True;
  Result.FHandle := CreateThread( nil, // no security
                                  0,   // the same stack size
                                  @ThreadFunc, // thread entry point
                                  Result,      // parameter to pass to ThreadFunc
                                  CREATE_SUSPENDED,   // always SUSPENDED
                                  Result.FThreadID ); // receive thread ID
end;
//[END NewThread]
{$ENDIF USE_CONSTRUCTORS}

{$IFDEF USE_CONSTRUCTORS}
//[function NewThreadEx]
function NewThreadEx( const Proc: TOnThreadExecute ): PThread;
begin
  new( Result, ThreadCreateEx( Proc ) );
end;
{$ELSE not_USE_CONSTRUCTORS}

//[FUNCTION NewThreadEx]
{$IFDEF ASM_VERSION}
function NewThreadEx( const Proc: TOnThreadExecute ): PThread;
asm
        CALL     NewThread
        POP      EBP
        POP      ECX
        POP      EDX
        MOV      [EAX].TThread.fOnExecute.TMethod.Code, EDX
        POP      EDX
        MOV      [EAX].TThread.fOnExecute.TMethod.Data, EDX
        PUSH     ECX
        PUSH     EAX
        CALL     TThread.Resume
        POP      EAX
        RET
end;
{$ELSE ASM_VERSION} //Pascal
function NewThreadEx( const Proc: TOnThreadExecute ): PThread;
begin
  Result := NewThread;
  Result.OnExecute := {$IFDEF F_P}  {$ENDIF}Proc;
  Result.Resume;
end;
{$ENDIF ASM_VERSION}
//[END NewThreadEx]

{$ENDIF USE_CONSTRUCTORS}

//[function NewThreadAutoFree]
function NewThreadAutoFree( const Proc: TOnThreadExecute ): PThread;
begin
  Result := NewThread;
  Result.OnExecute := {$IFDEF F_P}  {$ENDIF}Proc;
  Result.F_AutoFree := TRUE;
  if Assigned( Proc ) then
    Result.Resume;
end;

{ TThread }

{$IFDEF ASM_VERSION}
//[destructor TThread.Destroy]
destructor TThread.Destroy;
asm
        PUSH     EBX
        MOV      EBX, EAX
        CMP      [EAX].FTerminated, 0
        JNZ      @@1
        CALL     Terminate
        MOV      EAX, EBX
        CALL     WaitFor
@@1:    MOV      EAX, [EBX].FHandle
        INC      EAX
        JZ       @@2
        DEC      EAX
        PUSH     EAX
        CALL     CloseHandle
@@2:    POP      EAX
        XCHG     EBX, EAX
        JMP      TObj.Destroy
end;
{$ELSE ASM_VERSION} //Pascal
destructor TThread.Destroy;
begin
  if not FTerminated then
  begin
    Terminate;
    WaitFor;
  end;
  if (FHandle <> INVALID_HANDLE_VALUE) then
    CloseHandle(FHandle);
  inherited;
end;
{$ENDIF ASM_VERSION}

//*
//[function TThread.Execute]
function TThread.Execute: integer;
begin
  Result := 0;
  if Assigned( FOnExecute ) then
     Result := FOnExecute( Self );
  if F_AutoFree then
  begin
    FTerminated := TRUE; // fake thread object (to prevent terminating while freeing)
    Free;
  end;
end;

//*
//[function TThread.GetPriorityCls]
function TThread.GetPriorityCls: Integer;
begin
  Result := GetPriorityClass(FHandle);
end;

//*
//[function TThread.GetThrdPriority]
function TThread.GetThrdPriority: Integer;
begin
  Result := GetThreadPriority(FHandle);
end;

//*
//[procedure TThread.Resume]
procedure TThread.Resume;
begin
  FSuspended := False;
  if (ResumeThread(FHandle) > 1) then
    FSuspended := True
  else
  if Assigned(FOnResume) then
    FOnResume(Self);
end;

//*
//[procedure TThread.SetPriorityCls]
procedure TThread.SetPriorityCls(Value: Integer);
begin
  {$IFDEF DEBUG}
  if not SetPriorityClass(GetCurrentProcess, Value) then
  begin
    ShowMessage( SysErrorMessage( GetLastError ) );
  end;
  {$ELSE}
  SetPriorityClass(GetCurrentProcess, Value);
  {$ENDIF}
end;

//*
//[procedure TThread.SetThrdPriority]
procedure TThread.SetThrdPriority(Value: Integer);
begin
  SetThreadPriority(FHandle, Value);
end;

//*
//[procedure TThread.Suspend]
procedure TThread.Suspend;
begin
  FSuspended := TRUE;
  if Assigned(FOnSuspend) then
    Synchronize( FOnSuspend );
  SuspendThread(FHandle);
end;

//*
//[procedure CallSynchronized]
procedure CallSynchronized( Sender: PObj; Param: Pointer );
var Thread: PThread;
begin
  Thread := PThread( Sender );
  if Param <> nil then
    Thread.FMethodEx( Thread, Param )
  else
    Thread.FMethod( );
end;

//*
//[procedure TThread.Synchronize]
procedure TThread.Synchronize(Method: TThreadMethod);
begin
  Global_Synchronized := CallSynchronized;
  FMethod := Method;
  if Applet <> nil then
    SendMessage( Applet.fHandle, CM_EXECPROC, 0, Integer( Self ) );
end;

//[procedure TThread.SynchronizeEx]
procedure TThread.SynchronizeEx( Method: TThreadMethodEx; Param: Pointer );
begin
  Assert( Param <> nil, 'Parameter must not be NIL' );
  Global_Synchronized := CallSynchronized;
  FMethodEx := Method;
  SendMessage( Applet.fHandle, CM_EXECPROC, Integer( Param ), Integer( Self ) );
end;

//*
//[procedure TThread.Terminate]
procedure TThread.Terminate;
begin
  TerminateThread(FHandle,0);
  FTerminated := True;
end;

//*
//[function TThread.WaitFor]
function TThread.WaitFor: Integer;
begin
  RefInc;
  Result := -1;
  if FHandle = 0 then Exit;
  WaitForSingleObject(FHandle, INFINITE);
  GetExitCodeThread(FHandle, DWORD(Result));
  RefDec;
end;



{ TStream }

{* This part of the unit contains implementation of streams for KOL. Please note,
   that both stream types (file stream and memory stream) are incapsulated
   by a single object type TStream. To avoid including unnedeed code,
   use constructing functions NewReadFileStream and NewWriteFileStream
   to work with file streams, which do not require both types of operation. }

{* To create new type of stream, define your own methods, and in your
   constructing function, pass it to _NewStream function (through
   TStreamMethods record). In a field Custom, You can store a reference to
   your own data of any type (but do not forget to define correct releasing
   of such data in your fClose procedure). }

//[function TStream.GetPosition]
function TStream.GetPosition: DWord;
begin
  Result := Seek( 0, spCurrent );
end;

//[procedure TStream.SetPosition]
procedure TStream.SetPosition(Value: DWord);
begin
  Seek( Value, spBegin );
end;

{$IFDEF ASM_VERSION}
//[function TStream.GetSize]
function TStream.GetSize: DWord;
asm
        CALL     [EAX].fMethods.fGetSiz
end;
{$ELSE ASM_VERSION} //Pascal
function TStream.GetSize: DWord;
begin
  Result := fMethods.fGetSiz( Self );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TStream.SetSize]
procedure TStream.SetSize(NewSize: DWord);
asm
        CALL     [EAX].fMethods.fSetSiz
end;
{$ELSE ASM_VERSION} //Pascal
procedure TStream.SetSize(NewSize: DWord);
begin
  fMethods.fSetSiz( Self, NewSize );
end;
{$ENDIF ASM_VERSION}

//[function TStream.GetFileStreamHandle]
function TStream.GetFileStreamHandle: THandle;
begin
  Result := fData.fHandle;
end;

{$IFDEF ASM_VERSION}
//[function TStream.Read]
function TStream.Read(var Buffer; Count: DWord): DWord;
asm
        CALL     [EAX].fMethods.fRead
end;
{$ELSE ASM_VERSION} //Pascal
function TStream.Read(var Buffer; Count: DWord): DWord;
begin
  Result := fMethods.fRead( Self, Buffer, Count );
end;
{$ENDIF ASM_VERSION}

//[function TStream.GetCapacity]
function TStream.GetCapacity: DWORD;
begin
  Result := fData.fCapacity;
end;

//[procedure TStream.SetCapacity]
procedure TStream.SetCapacity(const Value: DWORD);
var OldSize: DWORD;
begin
  if fData.fCapacity >= Value then Exit;
  OldSize := Size;
  Size := Value;
  Size := OldSize;
end;

//[function TStream.Busy]
function TStream.Busy: Boolean;
begin
  Result := Assigned( fData.fThread );
end;

//[function TStream.DoAsyncRead]
function TStream.DoAsyncRead( Sender: PThread ): Integer;
begin
  Read( Pointer( fParam1 )^, fParam2 );
  fData.fThread := nil;
  Result := 0;
end;

//[procedure TStream.ReadAsync]
procedure TStream.ReadAsync(var Buffer; Count: DWord);
begin
  if Busy then Wait;
  fData.fThread := NewThreadAutoFree( nil );
  fData.fThread.OnExecute := DoAsyncRead;
  fParam1 := DWORD( @ Buffer );
  fParam2 := Count;
  fData.fThread.Resume;
end;

//[function TStream.DoAsyncSeek]
function TStream.DoAsyncSeek( Sender: PThread ): Integer;
begin
  Seek( fParam1, TMoveMethod( fParam2 ) );
  fData.fThread := nil;
  Result := 0;
end;

//[procedure TStream.SeekAsync]
procedure TStream.SeekAsync(MoveTo: Integer; MoveMethod: TMoveMethod);
begin
  if Busy then Wait;
  fData.fThread := NewThreadAutoFree( nil );
  fData.fThread.OnExecute := DoAsyncSeek;
  fParam1 := MoveTo;
  fParam2 := Ord( MoveMethod );
  fData.fThread.Resume;
end;

//[function TStream.DoAsyncWrite]
function TStream.DoAsyncWrite( Sender: PThread ): Integer;
begin
  Write( Pointer( fParam1 )^, fParam2 );
  fData.fThread := nil;
  Result := 0;
end;

//[procedure TStream.WriteAsync]
procedure TStream.WriteAsync(var Buffer; Count: DWord);
begin
  if Busy then Wait;
  fData.fThread := NewThreadAutoFree( nil );
  fData.fThread.OnExecute := DoAsyncWrite;
  fParam1 := DWORD( @ Buffer );
  fParam2 := Count;
  fData.fThread.Resume;
end;

//[procedure TStream.Wait]
procedure TStream.Wait;
begin
  if not Assigned( fData.fThread ) then Exit;
  if Assigned( fMethods.fWait ) then
    fMethods.fWait( Self )
  else
    fData.fThread.WaitFor;
end;

{$IFDEF ASM_VERSION}
//[function TStream.Write]
function TStream.Write(var Buffer; Count: DWord): DWord;
asm
        CALL     [EAX].fMethods.fWrite
end;
{$ELSE ASM_VERSION} //Pascal
function TStream.Write(var Buffer; Count: DWord): DWord;
begin
  Result := fMethods.fWrite( Self, Buffer, Count );
end;
{$ENDIF ASM_VERSION}

//[function TStream.WriteStr]
function TStream.WriteStr(S: String): DWORD;
begin
  if S <> '' then
    Result := fMethods.fWrite( Self, S[1], Length( S ) )
  else
    Result := 0;
end;

//[function TStream.ReadStrZ]
function TStream.ReadStrZ: String;
var C: Char;
begin
  Result := '';
  REPEAT
    C := #0;
    Read( C, 1 );
    if C <> #0 then Result := Result + C;
  UNTIL C = #0;
end;

//[function TStream.ReadStr]
function TStream.ReadStr: String;
var C: Char;
begin
  Result := '';
  REPEAT
    C := #0;
    Read( C, 1 );
    if C <> #0 then
    begin
      if C = #13 then
      begin
        C := #0;
        Read( C, 1 );
        if C <> #10 then Position := Position - 1;
        C := #13;
      end
        else
      if C = #10 then
        C := #13;
      if C <> #13 then
        Result := Result + C;
    end;
  UNTIL C in [ #13, #0 ];
end;

//[function TStream.WriteStrZ]
function TStream.WriteStrZ(S: String): DWORD;
var C: Char;
begin
  if S = '' then
    begin
      C := #0;
      Result := Write( C, 1 );
    end
  else
    Result := Write( S[ 1 ], Length( S ) + 1 );
end;

//[function TStream.WriteStrEx]
function TStream.WriteStrEx(S: String): DWord;
begin
  result:=length(s);
  fmethods.fwrite(Self,result,Sizeof(DWORD));
  if result<>0 then result:=fmethods.fwrite(Self,s[1],result);
end;

//[function TStream.ReadStrExVar]
function TStream.ReadStrExVar(var S: String): DWord;
begin
  fmethods.fread(Self,result,Sizeof(DWORD));
  setlength(s,result);
  if result<>0 then result:=fmethods.fread(Self,s[1],result);
end;

//[function TStream.ReadStrEx]
function TStream.ReadStrEx: String;
begin
  readstrexvar(result);
end;

{$IFDEF ASM_VERSION}
//[function TStream.Seek]
function TStream.Seek(MoveTo: integer; MoveMethod: TMoveMethod): DWord;
asm
        CALL     [EAX].fMethods.fSeek
end;
{$ELSE ASM_VERSION} //Pascal
function TStream.Seek(MoveTo: integer; MoveMethod: TMoveMethod): DWord;
begin
  Result := fMethods.fSeek( Self, MoveTo, MoveMethod );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[destructor TStream.Destroy]
destructor TStream.Destroy;
asm
        PUSH     EAX
        PUSH     [EAX].fData.fThread
        CALL     [EAX].fMethods.fClose
        POP      EAX
        CALL     TObj.Free
        POP      EAX
        CALL     TObj.Destroy
end;
{$ELSE ASM_VERSION} //Pascal
destructor TStream.Destroy;
begin
  fMethods.fClose( Self );
  fData.fThread.Free;
  inherited;
end;
{$ENDIF ASM_VERSION}

//+-
//[function _NewStream]
function _NewStream( const StreamMethods: TStreamMethods ): PStream;
begin
  Result := PStream.Create;
  Move( StreamMethods, Result.fMethods, Sizeof( TStreamMethods ) );
  Result.fPMethods := @Result.fMethods;
end;

//+
//[function SeekFileStream]
function SeekFileStream( Strm: PStream; MoveTo: Integer; MoveFrom: TMoveMethod ): DWORD;
begin
  Result := FileSeek( Strm.fData.fHandle, MoveTo, MoveFrom );
end;

//+
//[function GetSizeFileStream]
function GetSizeFileStream( Strm: PStream ): DWORD;
begin
  Result := GetFileSize( Strm.fData.fHandle, nil );
  if Result = DWORD( -1 ) then Result := 0;
end;

//[procedure DummySetSize]
procedure DummySetSize( Strm: PStream; Value: DWORD );
begin
end;

//[procedure DummyStreamProc]
procedure DummyStreamProc(Strm: PStream);
begin
end;

//[function DummyReadWrite]
function DummyReadWrite( Strm: PStream; var Buffer; Count: DWORD ): DWORD;
asm
  XOR EAX, EAX
end;

//[function ReadFileStream]
function ReadFileStream( Strm: PStream; var Buffer; Count: DWORD ): DWORD;
begin
  Result := FileRead( Strm.fData.fHandle, Buffer, Count );
end;

//[function WriteFileStream]
function WriteFileStream( Strm: PStream; var Buffer; Count: DWORD ): DWORD;
begin
  Result := FileWrite( Strm.fData.fHandle, Buffer, Count );
end;

//[FUNCTION WriteFileStreamEOF]
{$IFDEF ASM_VERSION}
function WriteFileStreamEOF( Strm: PStream; var Buffer; Count: DWORD ): DWORD;
asm
        PUSH     EBX
        PUSH     [EAX].TStream.fData.fHandle
        CALL     WriteFileStream
        XCHG     EBX, EAX
        CALL     SetEndOfFile
        XCHG     EAX, EBX
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function WriteFileStreamEOF( Strm: PStream; var Buffer; Count: DWORD ): DWORD;
begin
  Result := WriteFileStream( Strm, Buffer, Count );
  SetEndOfFile( Strm.fData.fHandle );
end;
{$ENDIF ASM_VERSION}
//[END WriteFileStreamEOF]

//[procedure CloseFileStream]
procedure CloseFileStream( Strm: PStream );
begin
  FileClose( Strm.fData.fHandle );
end;

//[FUNCTION SeekMemStream]
{$IFDEF ASM_VERSION}
function SeekMemStream( Strm: PStream; MoveTo: Integer; MoveFrom: TMoveMethod ): DWORD;
asm
        PUSH     EBX
        MOV      EBX, EDX
        AND      ECX, $FF
        LOOP     @@not_from_cur
        ADD      EBX, [EAX].TStream.fData.fPosition
@@not_from_cur:
        LOOP     @@not_from_end
        ADD      EBX, [EAX].TStream.fData.fSize
@@not_from_end:
        CMP      EBX, [EAX].TStream.fData.fSize
        JLE      @@space_ok
        PUSH     EAX
        MOV      EDX, EBX
        CALL     TStream.SetSize
        POP      EAX
@@space_ok:
        XCHG     EAX, EBX
        MOV      [EBX].TStream.fData.fPosition, EAX
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function SeekMemStream( Strm: PStream; MoveTo: Integer; MoveFrom: TMoveMethod ): DWORD;
var NewPos: DWORD;
begin
  case MoveFrom of
  spBegin: NewPos := MoveTo;
  spCurrent: NewPos := Strm.fData.fPosition + DWORD( MoveTo );
  else //spEnd:
       NewPos := Strm.fData.fSize + DWORD( MoveTo );
  end;
  if NewPos > Strm.fData.fSize then
    Strm.SetSize( NewPos );
  Strm.fData.fPosition := NewPos;
  Result := NewPos;
end;
{$ENDIF ASM_VERSION}
//[END SeekMemStream]

//[function GetSizeMemStream]
function GetSizeMemStream( Strm: PStream ): DWORD;
begin
  Result := Strm.fData.fSize;
end;

//[PROCEDURE SetSizeMemStream]
{$IFDEF ASM_VERSION}
procedure SetSizeMemStream( Strm: PStream; NewSize: DWORD );
asm
        CMP      [EAX].TStream.fData.fCapacity, EDX
        JGE      @@cap_ok
        PUSH     EDX
        PUSH     EAX
        MOV      ECX, [EAX].TStream.fMemory
        JECXZ    @@get_mem
        TEST     EDX, EDX
        JZ       @@free_mem
        LEA      EAX, [EAX].TStream.fMemory
        CALL     System.@ReallocMem
        JMP      @@1
@@get_mem:
        XCHG     EAX, EDX
        CALL     System.@GetMem
        XCHG     EDX, EAX
        POP      EAX
        MOV      [EAX].TStream.fMemory, EDX
        JMP      @@2
@@free_mem:
        XCHG     EDX, [EAX].TStream.fMemory
        XCHG     EAX, EDX
        CALL     System.@FreeMem
@@1:
        POP      EAX
@@2:
        POP      EDX

@@cap_ok:
        MOV      [EAX].TStream.fData.fSize, EDX
        CMP      [EAX].TStream.fData.fPosition, EDX
        JLE      @@exit
        MOV      [EAX].TStream.fData.fPosition, EDX
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure SetSizeMemStream( Strm: PStream; NewSize: DWORD );
var S: PStream;
begin
  S := Strm;
  if S.fData.fCapacity < NewSize then
  begin
    if S.fMemory = nil then
    begin
      if NewSize <> 0 then
         GetMem( S.fMemory, NewSize );
    end
      else
    if NewSize = 0 then
    begin
      FreeMem( S.fMemory );
      S.fMemory := nil;
    end
      else
      ReallocMem( S.fMemory, NewSize );
    S.fData.fCapacity := NewSize;
  end;
  S.fData.fSize := NewSize;
  if S.fData.fPosition > S.fData.fSize then
     S.fData.fPosition := S.fData.fSize;
end;
{$ENDIF ASM_VERSION}
//[END SetSizeMemStream]

//[FUNCTION ReadMemStream]
{$IFDEF ASM_VERSION}
function ReadMemStream( Strm: PStream; var Buffer; Count: DWORD ): DWORD;
asm
        PUSH     EBX
        XCHG     EBX, EAX
        MOV      EAX, [EBX].TStream.fData.fPosition
        ADD      EAX, ECX
        CMP      EAX, [EBX].TStream.fData.fSize
        JLE      @@count_ok
        MOV      ECX, [EBX].TStream.fData.fSize
        SUB      ECX, [EBX].TStream.fData.fPosition
@@count_ok:
        PUSH     ECX
        MOV      EAX, [EBX].TStream.fMemory
        ADD      EAX, [EBX].TStream.fData.fPosition
        CALL     System.Move
        POP      EAX
        ADD      [EBX].TStream.fData.fPosition, EAX
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function ReadMemStream( Strm: PStream; var Buffer; Count: DWORD ): DWORD;
var S: PStream;
begin
  S := Strm;
  if Count + S.fData.fPosition > S.fData.fSize then
     Count := S.fData.fSize - S.fData.fPosition;
  Result := Count;
  Move( Pointer( DWORD(S.fMemory) + S.fData.fPosition )^, Buffer, Result );
  Inc( S.fData.fPosition, Result );
end;
{$ENDIF ASM_VERSION}
//[END ReadMemStream]

//[FUNCTION WriteMemStream]
{$IFDEF ASM_VERSION}
function WriteMemStream( Strm: PStream; var Buffer; Count: DWORD ): DWORD;
asm
        PUSH     EBX
        XCHG     EBX, EAX
        MOV      EAX, [EBX].TStream.fData.fPosition
        ADD      EAX, ECX
        CMP      EAX, [EBX].TStream.fData.fSize
        PUSH     EDX
        PUSH     ECX
        JLE      @@count_ok
        XCHG     EDX, EAX
        MOV      EAX, EBX
        CALL     TStream.SetSize
@@count_ok:
        POP      ECX
        POP      EAX
        MOV      EDX, [EBX].TStream.fMemory
        ADD      EDX, [EBX].TStream.fData.fPosition
        PUSH     ECX
        CALL     System.Move
        POP      EAX
        ADD      [EBX].TStream.fData.fPosition, EAX
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function WriteMemStream( Strm: PStream; var Buffer; Count: DWORD ): DWORD;
var S: PStream;
begin
  S := Strm;
  if Count + S.fData.fPosition > S.fData.fSize then
     S.SetSize( S.fData.fPosition + Count );
  Result := Count;
  Move( Buffer, Pointer( DWORD(S.fMemory) + S.fData.fPosition )^, Result );
  Inc( S.fData.fPosition, Result );
end;
{$ENDIF ASM_VERSION}
//[END WriteMemStream]

//[PROCEDURE CloseMemStream]
{$IFDEF ASM_VERSION}
procedure CloseMemStream( Strm: PStream );
asm
        MOV      ECX, [EAX].TStream.fMemory
        JECXZ    @@exit
        XCHG     EAX, ECX
        CALL     System.@FreeMem
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure CloseMemStream( Strm: PStream );
var S: PStream;
begin
  S := Strm;
  if S.fMemory <> nil then
    FreeMem( S.fMemory );
end;
{$ENDIF ASM_VERSION}
//[END CloseMemStream]

const
  BaseFileMethods: TStreamMethods = (
    fSeek: SeekFileStream;
    fGetSiz: GetSizeFileStream;
    fSetSiz: DummySetSize;
    fRead: DummyReadWrite;
    fWrite: DummyReadWrite;
    fClose: CloseFileStream;
    fCustom: nil;
  );

  MemoryMethods: TStreamMethods = (
    fSeek: SeekMemStream;
    fGetSiz: GetSizeMemStream;
    fSetSiz: SetSizeMemStream;
    fRead: ReadMemStream;
    fWrite: WriteMemStream;
    fClose: CloseMemStream;
    fCustom: nil;
  );

// by Roman Vorobets:
//[procedure SetSizeFileStream]
procedure SetSizeFileStream( Strm: PStream; NewSize: DWORD );
var
  P: DWORD;
begin
  P:=Strm.Position;
  Strm.Position:=NewSize;
  SetEndOfFile(Strm.Handle);
  if P < NewSize then
    Strm.Position:=P;
end;

//[function NewFileStream]
function NewFileStream( const FileName: String; Options: DWORD ): PStream;
begin
  Result := _NewStream( BaseFileMethods );
  Result.fMethods.fRead := ReadFileStream;
  Result.fMethods.fWrite := WriteFileStream; // not WriteStreamEOF, Алексей Шувалов
  Result.fMethods.fSetSiz := SetSizeFileStream;
  Result.fData.fHandle := FileCreate( FileName, Options );
end;

//[FUNCTION NewReadFileStream]
{$IFDEF ASM_VERSION}
function NewReadFileStream( const FileName: String ): PStream;
asm
        PUSH     EBX
        XCHG     EBX, EAX
        MOV      EAX, offset[BaseFileMethods]
        CALL     _NewStream
        MOV      [EAX].TStream.fMethods.fRead, offset[ReadFileStream]
        XCHG     EBX, EAX
        MOV      EDX, ofOpenRead or ofOpenExisting or ofShareDenyWrite
        CALL     FileCreate
        MOV      [EBX].TStream.fData.fHandle, EAX
        XCHG     EAX, EBX
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function NewReadFileStream( const FileName: String ): PStream;
begin
  Result := _NewStream( BaseFileMethods );
  Result.fMethods.fRead := ReadFileStream;
  Result.fData.fHandle := FileCreate( FileName,
                                      ofOpenRead or ofShareDenyWrite or ofOpenExisting );
end;
{$ENDIF ASM_VERSION}
//[END NewReadFileStream]

//[FUNCTION NewWriteFileStream]
{$IFDEF ASM_VERSION}
function NewWriteFileStream( const FileName: String ): PStream;
asm
        PUSH     EBX
        XCHG     EBX, EAX
        MOV      EAX, offset[BaseFileMethods]
        CALL     _NewStream
        MOV      [EAX].TStream.fMethods.fWrite, offset[WriteFileStreamEOF]
        MOV      [EAX].TStream.fMethods.fSetSiz, offset[SetSizeFileStream]
        XCHG     EBX, EAX
        MOV      EDX, ofOpenWrite or ofOpenAlways or ofShareDenyWrite
        CALL     FileCreate
        MOV      [EBX].TStream.fData.fHandle, EAX
        XCHG     EAX, EBX
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function NewWriteFileStream( const FileName: String ): PStream;
begin
  Result := _NewStream( BaseFileMethods );
  Result.fMethods.fWrite := WriteFileStreamEOF;
  Result.fMethods.fSetSiz := SetSizeFileStream;
  Result.fData.fHandle := FileCreate( FileName,
                                      //ofOpenWrite or ofCreateAlways );
                                      ofOpenWrite or ofOpenAlways or ofShareDenyWrite );
end;
{$ENDIF ASM_VERSION}
//[END NewWriteFileStream]

//[FUNCTION NewReadWriteFileStream]
{$IFDEF ASM_noVERSION}
function NewReadWriteFileStream( const FileName: String ): PStream;
asm
        PUSH     EBX
        XCHG     EBX, EAX
        MOV      EAX, offset[BaseFileMethods]
        CALL     _NewStream
        MOV      [EAX].TStream.fMethods.fRead, offset[ReadFileStream]
        MOV      [EAX].TStream.fMethods.fWrite, offset[WriteFileStream]
        MOV      [EAX].TStream.fMethods.fSetSiz, offset[SetSizeFileStream]
        XCHG     EBX, EAX

        PUSH     EAX
        CALL     FileExists
        MOV      EDX, ofOpenReadWrite or ofCreateAlways or ofShareDenyWrite
        ADD      DH, AL // $200 (ofCreateAlways) -> $300 (ofCreateExisting)
        POP      EAX

        CALL     FileCreate
        MOV      [EBX].TStream.fData.fHandle, EAX
        XCHG     EAX, EBX
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function NewReadWriteFileStream( const FileName: String ): PStream;
var Creation: DWORD;
begin
  Result := _NewStream( BaseFileMethods );
  Result.fMethods.fRead := ReadFileStream;
  Result.fMethods.fWrite := WriteFileStream;
  Result.fMethods.fSetSiz := SetSizeFileStream;
  Creation := ofCreateAlways;
  if FileExists( FileName ) then Creation := ofOpenExisting;
  Result.fData.fHandle := FileCreate( FileName,
                          ofOpenReadWrite or Creation or ofShareDenyWrite );
end;
{$ENDIF ASM_VERSION}
//[END NewReadWriteFileStream]

//[function NewMemoryStream]
function NewMemoryStream: PStream;
begin
  Result := _NewStream( MemoryMethods );
end;

//[FUNCTION WriteExMemoryStream]
{$IFDEF ASM_VERSION}
function WriteExMemoryStream( Strm: PStream; var Buffer; Count: DWORD ): DWORD;
asm
        PUSH     EBX
        XCHG     EBX, EAX
        MOV      EAX, [EBX].TStream.fData.fSize
        SUB      EAX, [EBX].TStream.fData.fPosition
        CMP      EAX, ECX
        JGE      @@1
        XCHG     ECX, EAX
@@1:
        PUSH     EDX
        PUSH     ECX
        JLE      @@count_ok
        XCHG     EDX, EAX
        MOV      EAX, EBX
        CALL     TStream.SetSize
@@count_ok:
        POP      ECX
        POP      EAX
        MOV      EDX, [EBX].TStream.fMemory
        ADD      EDX, [EBX].TStream.fData.fPosition
        PUSH     ECX
        CALL     System.Move
        POP      EAX
        ADD      [EBX].TStream.fData.fPosition, EAX
        POP      EBX
end;
{$ELSE ASM_VERSION}
function WriteExMemoryStream( Strm: PStream; var Buffer; Count: DWORD ): DWORD;
var S: PStream;
begin
  S := Strm;
  if Count + S.fData.fPosition > S.fData.fSize then
    Count := S.fData.fSize - S.fData.fPosition;
  Result := Count;
  Move( Buffer, Pointer( DWORD(S.fMemory) + S.fData.fPosition )^, Result );
  Inc( S.fData.fPosition, Result );
end;
{$ENDIF ASM_VERSION}
//[END WriteExMemoryStream]

//[procedure DummyClose_ExMemStream]
procedure DummyClose_ExMemStream( Strm: PStream );
begin
  // nothing to do - ignore call (memory is not released by any way)
end;

//[function NewExMemoryStream]
function NewExMemoryStream( ExistingMem: Pointer; Size: DWORD ): PStream;
begin
  Result := NewMemoryStream;
  Result.fMemory := ExistingMem;
  Result.fData.fCapacity := Size;
  Result.fData.fSize := Size;
  Result.fMethods.fWrite := WriteExMemoryStream;
  Result.fMethods.fSetSiz := DummySetSize;
  Result.fMethods.fClose := DummyClose_ExMemStream;
end;

//*
//[function Stream2Stream]
function Stream2Stream( Dst, Src: PStream; Count: DWORD ): DWORD;
var Buf: Pointer;
begin
  if Src.fMemory <> nil then
  begin
     if Src.fData.fPosition + Count > Src.fData.fSize then
        Count := Src.fData.fSize - Src.fData.fPosition;
     Result := Dst.Write( Pointer(DWORD(Src.fMemory)+Src.fData.fPosition)^,
                   Count );
     Inc( Src.fData.fPosition, Result );
  end
     else
  if Dst.fMemory <> nil then
  begin
    if Dst.fData.fPosition + Count > Dst.fData.fSize then
       Dst.SetSize( Dst.fData.fPosition + Count );
    Result := Src.Read( Pointer( DWORD( Dst.fMemory ) + Dst.fData.fPosition )^,
                        Count );
    Inc( Dst.fData.fPosition, Result );
  end
     else
  begin
    GetMem( Buf, Count );
    Count := Src.Read( Buf^, Count );
    Result := Dst.Write( Buf^, Count );
    FreeMem( Buf );
  end;
end;

//[function Stream2StreamEx]
function Stream2StreamEx( Dst, Src: PStream; Count: DWORD ): DWORD;
begin
  Result := Stream2StreamExBufSz( Dst, Src, Count, 65536 );
end;

//[function Stream2StreamExBufSz]
function Stream2StreamExBufSz( Dst, Src: PStream; Count, BufSz: DWORD ): DWORD;
var
  buf:pointer;
  rd, wr:dword;
begin
  if count=0 then result:=0 else
  begin
    result:=0;
    BufSz := Min( BufSz, Count );
    if BufSz = 0 then BufSz := Count;
    getmem(buf,BufSz);
    repeat
      if count<BufSz then rd:=count else rd:=BufSz;
      rd:=src.read(buf^,rd);
      wr := dst.write(buf^,rd);
      inc(result,wr);
      dec(Count, rd);
    until (rd<>BufSz) or (Count=0);
    freemem(buf);
  end;
end;

//[FUNCTION Resource2Stream]
{$IFDEF ASM_VERSION}
function Resource2Stream( DestStrm : PStream; Inst : HInst;
                          ResName : PChar; ResType : PChar ): Integer;
asm
        PUSH     EBX
        PUSH     ESI
        MOV      EBX, EDX // EBX = Inst
        PUSH     EAX      // DestStrm
        PUSH     ResType
        PUSH     ECX
        PUSH     EDX
        CALL     FindResource
        TEST     EAX, EAX
        JZ       @@exit0

        PUSH     EAX
        PUSH     EBX
        PUSH     EAX
        PUSH     EBX
        CALL     SizeofResource
        XCHG     EBX, EAX
        CALL     LoadResource
        TEST     EAX, EAX
        JZ       @@exit0
        XCHG     ESI, EAX

        PUSH     ESI
        CALL     GlobalLock
        TEST     EAX, EAX
        JNZ      @@P_ok

        CALL     GetLastError
        CMP      EAX, ERROR_INVALID_HANDLE
        JNZ      @@exit_00
        MOV      EAX, ESI

@@P_ok:
        XCHG     EDX, EAX
        POP      EAX // DestStrm
        PUSH     EDX
        MOV      ECX, EBX
        CALL     TStream.Write

        //EAX = Result (length of written data)
        XCHG     EBX, EAX
        POP      EAX
        CMP      ESI, EAX
        JE       @@not_unlock

        PUSH     ESI
        CALL     GlobalUnlock
@@not_unlock:
        XCHG     EAX, EBX
        JMP      @@exit

@@exit_00:
        XOR      EAX, EAX
@@exit0:
        POP      ECX
@@exit:
        POP      ESI
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function Resource2Stream( DestStrm : PStream; Inst : HInst;
                          ResName : PChar; ResType : PChar ): Integer;
var R : HRSRC;
    G : HGlobal;
    P : PChar;
    Sz : DWORD;
    E : Integer;
begin
  Result := 0;
  R := FindResource( Inst, ResName, ResType );
  if R <> 0 then
  begin
    Sz := SizeofResource( Inst, R );
    G := LoadResource( Inst, R );
    if G <> 0 then
    begin
      P := GlobalLock( G );
      if P = nil then
      begin
        E := GetLastError;
        if E = ERROR_INVALID_HANDLE then
           P := Pointer( G )
        else
           Exit;
      end;
      Result := DestStrm.Write( P^, Sz );
      if P <> Pointer( G ) then
        GlobalUnlock( G );
      //FreeResource( G );
      { from Win32.hlp: "You do not need to call the FreeResource
        function to free a resource loaded by using the LoadResource
        function." }
    end;
  end;
end;
{$ENDIF ASM_VERSION}
//[END Resource2Stream]












///////////////////////////////////////////////////////////////////////////
//
//
//                        I  N  I  -  F  I  L  E  S
//
//
///////////////////////////////////////////////////////////////////////////


{ TIniFile }

{$IFDEF ASM_VERSION}
//[destructor TIniFile.Destroy]
destructor TIniFile.Destroy;
asm     //cmd    //opd
        PUSH     EAX
        LEA      EDX, [EAX].fFileName
        PUSH     EDX
        LEA      EAX, [EAX].fSection
        CALL     System.@LStrClr
        POP      EAX
        CALL     System.@LStrClr
        POP      EAX
        CALL     TObj.Destroy
end;
{$ELSE ASM_VERSION} //Pascal
destructor TIniFile.Destroy;
begin
  fFileName := '';
  fSection := '';
  inherited;
end;
{$ENDIF ASM_VERSION}

{$IFNDEF _D5orHigher}
// Place here correct definition for WritePrivateProfileStruct
// and GetPrivateProfileStruct (a bug in Delphi2, Delphi3 and Delphi4)
//[API WritePrivateProfileStruct]
function WritePrivateProfileStruct(lpszSection, lpszKey: PChar;
  lpStruct: Pointer; uSizeStruct: UINT; szFile: PChar): BOOL; stdcall;
  external kernel32 name 'WritePrivateProfileStructA';
//[API GetPrivateProfileStruct]
function GetPrivateProfileStruct(lpszSection, lpszKey: PAnsiChar;
  lpStruct: Pointer; uSizeStruct: UINT; szFile: PAnsiChar): BOOL; stdcall;
  external kernel32 name 'GetPrivateProfileStructA';

// + by Slava A. Gavrik:
////////////////////////////////////////////////////////////////////////////
//[function WritePrivateProfileSection]
function WritePrivateProfileSection(lpAppName, lpString,
  lpFileName: PChar): BOOL; stdcall;
  external kernel32 name 'WritePrivateProfileSectionA';
//[function GetPrivateProfileSection]
function GetPrivateProfileSection(lpAppName: PChar; lpReturnedString: PChar;
  nSize: DWORD; lpFileName: PChar): DWORD; stdcall;
  external kernel32 name 'GetPrivateProfileSectionA';

//[function GetPrivateProfileSectionNames]
function GetPrivateProfileSectionNames(lpszReturnBuffer: PChar; nSize:
DWORD;
  lpFileName: PChar): DWORD; stdcall;
  external kernel32 name 'GetPrivateProfileSectionNamesA';
////////////////////////////////////////////////////////////////////////////
{$ENDIF}


//[procedure TIniFile.ClearAll]
procedure TIniFile.ClearAll;
begin
  WritePrivateProfileString( nil, nil, nil,
                             PChar( fFileName ) );
end;

//[procedure TIniFile.ClearKey]
procedure TIniFile.ClearKey(const Key: String);
begin
  WritePrivateProfileString( PChar( fSection ), PChar( Key ), nil,
                             PChar( fFileName ) );
end;

//[procedure TIniFile.ClearSection]
procedure TIniFile.ClearSection;
begin
  WritePrivateProfileString( PChar( fSection ), nil, nil,
                             PChar( fFileName ) );
end;

//[function TIniFile.ValueBoolean]
function TIniFile.ValueBoolean(const Key: String; Value: Boolean): Boolean;
begin
  if fMode = ifmRead then
     Result := GetPrivateProfileInt( PChar( fSection ), PChar( Key ),
               Integer( Value ), PChar( fFileName ) ) <> 0
  else
  begin
    WritePrivateProfileString( PChar( fSection ), PChar( Key ),
              PChar( Int2Str( Integer( Value ) ) ), PChar( fFileName ) );
    Result := Value;
  end;
end;

//[function TIniFile.ValueData]
function TIniFile.ValueData(const Key: String; Value: Pointer;
  Count: Integer): Boolean;
begin
  if fMode = ifmRead then
     Result := GetPrivateProfileStruct( PChar( fSection ), PChar( Key ),
               Value, Count, PChar( fFileName ) )
  else
     Result := WritePrivateProfileStruct( PChar( fSection ), PChar( Key ),
               Value, Count, PChar( fFileName ) );
end;

//[function TIniFile.ValueInteger]
function TIniFile.ValueInteger(const Key: String; Value: Integer): Integer;
begin
  if fMode = ifmRead then
     Result := GetPrivateProfileInt( PChar( fSection ), PChar( Key ),
               Integer( Value ), PChar( fFileName ) )
  else
  begin
     Result := Value;
     WritePrivateProfileString( PChar( fSection ), PChar( Key ),
               PChar( Int2Str( Value ) ), PChar( fFileName ) );
  end;
end;

//[function TIniFile.ValueString]
function TIniFile.ValueString(const Key, Value: String): String;
var
  Buffer: array[0..2047] of Char;
begin
  if fMode = ifmRead then
  begin
    Buffer[ 0 ] := #0;
    GetPrivateProfileString(PChar(fSection),
         PChar(Key), PChar(Value), Buffer, SizeOf(Buffer), PChar(fFileName));
    Result := Buffer;
  end
    else
  begin
     Result := Value;
     WritePrivateProfileString( PChar( fSection ), PChar( Key ),
               PChar( Value ), PChar( fFileName ) );
  end;
end;

//[function OpenIniFile]
function OpenIniFile( const FileName: String ): PIniFile;
begin
  Result := PIniFile.Create;
  Result.fFileName := FileName;
end;

/////////////////////////////////////////////////// GetSectionNames, SectionData
// - by Vyacheslav A. Gavrik :

const
  IniBufferSize = 32767;
  IniBufferStrSize = IniBufferSize+4;         /// для махинаций :)

{$IFDEF ASM_VERSION}
//[procedure _FillStrList]
procedure _FillStrList;    // Эта часть кода общая для двух следующих процедур
asm
///////////////////////////////
        OR      EAX,0
        JE      @@EXIT                  //ERROR
//        LEA     EAX,[EAX-IniBufferSize]
//        JE      @@EXIT
//      возможна нехватка Буфера... в принципе не ошибка :)
//      возвращаем что влезло...
//////////////////////////////
@@LOOP:
        LEA     EAX,[ESI+4]
        CALL    StrLen
        MOV     [ESI],EAX
        LEA     EDX,[ESI+4]
        INC     EAX
        ADD     ESI,EAX

        MOV     EAX,EDI

        CALL    TStrList.ADD

        CMP     byte ptr [ESI+4],0
        JNE     @@LOOP

@@EXIT:
        POP     EAX
        CALL    System.@FreeMem


        POP     ECX
        POP     EBX
        POP     EDI
        POP     ESI
end;


//[procedure TIniFile.GetSectionNames]
procedure TIniFile.GetSectionNames(Names: PStrList);
asm
        PUSH    ESI
        PUSH    EDI
        PUSH    EBX
        PUSH    ECX

        MOV     EBX,EAX
        MOV     EAX, IniBufferStrSize
        MOV     EDI,EDX

        CALL    System.@GetMem
        MOV     ESI,EAX
        PUSH    EAX

        PUSH    [EBX].fFileName
        MOV     EAX,IniBufferSize
        PUSH    EAX

        LEA     EAX,[ESI+4]
        PUSH    EAX

        CALL    GetPrivateProfileSectionNames
        JMP     _FillStrList
end;

//[procedure TIniFile.SectionData]
procedure TIniFile.SectionData(Names: PStrList);
asm
        PUSH    ESI
        PUSH    EDI
        PUSH    EBX
        PUSH    ECX

        MOV     EBX,EAX
        MOV     EAX, IniBufferStrSize
        MOV     EDI,EDX

        CALL    System.@GetMem
        MOV     ESI,EAX
        PUSH    EAX

        OR     [EBX].fMode,0
        JNE     @@DOWrite

        PUSH    [EBX].fFileName
        MOV     EAX,IniBufferSize
        PUSH    EAX

        LEA     EAX,[ESI+4]
        PUSH    EAX
        PUSH    [EBX].fSection

        CALL    GetPrivateProfileSection
        JMP     _FillStrList

@@DOWrite:

        PUSH    EBX
        PUSH    ESI
        PUSH    EDX
        PUSH    EBP

        MOV     EDX,0
        MOV     EBP,[EDI].TStrList.fCount
        MOV     EBX,IniBufferSize-2 // оставим место для #0#0
@@LOOP:
        JE      @@ENDLOOP

        OR      EBX,EBX
        JE      @@ENDLOOP

        PUSH    EDX
        MOV     EAX,EDI
        CALL    TStrList.GetPChars

        PUSH    EAX
        CALL    StrLen
        POP     EAX

        XOR     ECX,-1
        MOV     EDX,ESI

        SUB     EBX,ECX
        JA      @@L1
        ADD     ECX,EBX
        XOR     EBX,EBX
@@L1:

        ADD     ESI,ECX

        CALL    MOVE
@@L2:
        POP     EDX
        INC     EDX
        DEC     EBP
        JMP     @@LOOP
@@ENDLOOP:
        MOV     WORD PTR [ESI],0

        POP     EBP
        POP     EDX
        POP     ESI
        POP     EBX
///////////////////////////////////
        MOV     EAX,EBX                 // нодо очищать
        CALL    ClearSection
//////////////////////////////////

        PUSH    [EBX].fFileName
        PUSH    ESI
        PUSH    [EBX].fSection

        CALL    WritePrivateProfileSection

        POP     EAX
        CALL    System.@FreeMem

        POP     ECX
        POP     EBX
        POP     EDI
        POP     ESI

end;
{$ELSE ASM_VERSION} //Pascal

//[procedure TIniFile.GetSectionNames]
procedure TIniFile.GetSectionNames(Names: PStrList);
var
  i:integer;
  Pc:PChar;
  PcEnd:PChar;
  Buffer:Pointer;
begin
  GetMem(Buffer,IniBufferSize);
  Pc:=Buffer;
  i := GetPrivateProfileSectionNames(Buffer, IniBufferSize, PChar(fFileName));
  PcEnd:=Pc+i;
  repeat
    Names.Add(Pc);
    Pc:=PC+Length(PC)+1;
  until PC>=PcEnd;
  FreeMem(Buffer);
end;

//[procedure TIniFile.SectionData]
procedure TIniFile.SectionData(Names: PStrList);
var
  i:integer;
  Pc:PChar;
  PcEnd:PChar;
  Buffer:Pointer;
begin
  GetMem(Buffer,IniBufferSize);
  Pc:=Buffer;
  if fMode = ifmRead then
  begin
    i:=GetPrivateProfileSection(PChar(fSection), Buffer, IniBufferSize, PChar(fFileName));
    PcEnd:=Pc+i;
    repeat
      Names.Add(Pc);
      Pc:=PC+Length(PC)+1;
    until PC>=PcEnd;
  end else
  begin
    for i:= 0 to Names.Count-1 do
    begin
      StrCopy(Pc,Names.ItemPtrs[i]);
      Pc:=PC+Length(PC)+1;
    end;
    Pc[0]:=#0;
    ClearSection;
    WritePrivateProfileSection(PChar(fSection), Buffer, PChar(fFileName));

  end;
  FreeMem(Buffer);
end;
{$ENDIF ASM_VERSION}

//////////////////////////////////////////////////////////////////////











/////////////////////////////////////////////////////////////////////////
//
//
//                                M  E  N  U
//
//
/////////////////////////////////////////////////////////////////////////

{ -- Menu implementation -- }

//[FUNCTION MakeAccelerator]
{$IFDEF ASM_VERSION}
function MakeAccelerator( fVirt: Byte; Key: Word ): TMenuAccelerator;
asm
        MOVZX    EAX, AL
        PUSH     EAX
        MOV      [ESP+1], DX
        POP      EAX
end;
{$ELSE ASM_VERSION} //Pascal
function MakeAccelerator( fVirt: Byte; Key: Word ): TMenuAccelerator;
begin
  Result.fVirt := fVirt;
  Result.Key := Key;
end;
{$ENDIF ASM_VERSION}
//[END MakeAccelerator]

const
  MIDATA_CHECKITEM = $40000000;
  MIDATA_RADIOITEM = $80000000;

//[function WndProcMenu]
function WndProcMenu( Sender: PControl; var Msg: TMsg; var Rslt: Integer): Boolean;
var M, M1: PMenu;
    Idx: Integer;
    Id: Integer;
begin
  Result := False;
  if Msg.message = WM_COMMAND then
  begin
     if (Msg.lParam = 0) and (HIWORD( Msg.wParam ) <= 1) then
     begin
       M := PMenu( Sender.fMenuObj );
       while M <> nil do
       begin
         Id := LoWord( Msg.wParam );
         M1 := M.Items[ Id ];
         if M1 <> nil then
         begin
           Result := True;
           Rslt := 0;
           Idx := M.IndexOf( M1 );
           M.fByAccel := HiWord( Msg.wParam ) <> 0;
           if M1.FRadioGroup <> 0 then
             M1.RadioCheckItem
           else
           if M1.FIsCheckItem then
             M1.Checked := not M1.Checked;
           if Assigned(M1.FOnMenuItem) then
             M1.FOnMenuItem( M, Idx )
           else if Assigned( M.FOnMenuItem ) then
             M.FOnMenuItem( M, Idx );
           //M.FProcessed := True;
           break;
         end;
         M := M.fNextMenu;
       end;
     end;
  end;
end;

var FDynamicMenuID: DWORD = $1000;

//[function NewMenu]
function NewMenu( AParent : PControl; MaxCmdReserve : DWORD; const Template : array of PChar;
                      aOnMenuItem: TOnMenuItem ): PMenu;
var M: PMenu;
begin
  Result := PMenu.Create;
  Result.FVisible := TRUE;
  Result.FPopupFlags := TPM_LEFTALIGN or TPM_LEFTBUTTON;
  Result.FItems := NewList;
  Result.FOnMenuItem := aOnMenuItem;
  if (High(Template)>=0) and (Template[0] <> nil) then
  begin
    if (AParent <> nil) and (AParent.fMenuObj = nil) and not AParent.fIsControl then
      Result.FHandle := CreateMenu
    else
      Result.FHandle := CreatePopupMenu;
    Result.FillMenuItems( Result.FHandle, 0, Template );
  end;
  if assigned( AParent ) then
  begin
    Result.FControl := AParent;
    if AParent.fMenuObj <> nil then
    begin
      // add popup menu to the end of menu chain
      M := PMenu( AParent.fMenuObj );
      while M.fNextMenu <> nil do
        M := M.fNextMenu;
      M.fNextMenu := Result;
    end
       else
    begin
      if not AParent.fIsControl then
        AParent.Menu := Result.FHandle;
      AParent.fMenuObj := Result;
      AParent.AttachProc( WndProcMenu );
    end;
  end;
end;
//[END NewMenu]

//[function NewMenuEx]
function NewMenuEx( AParent : PControl; FirstCmd : Integer; const Template : array of PChar;
                      aOnMenuItems: array of TOnMenuItem ): PMenu;
begin
  Result := NewMenu( AParent, FirstCmd, Template, nil );
  Result.AssignEvents( 0, aOnMenuItems );
end;
//[END NewMenuEx]

{ TMenu }

const
  Breaks: array[ TMenuBreak ] of DWORD = ( 0, MFT_MENUBREAK, MFT_MENUBARBREAK );

{ + by AK - Andrzej Kubaszek }
//[function MenuStructSize]
function MenuStructSize: Integer;
begin
  Result := 44;
  if not( WinVer in [wv31, wv95, wvNT] ) then
    Result := {48=} Sizeof( TMenuItemInfo );
end;

//[destructor TMenu.Destroy]
destructor TMenu.Destroy;
var Next, Prnt: PMenu;
begin
  if Count > 0 then
  begin
    FItems.ReleaseObjects;
    FItems := NewList;
  end;
  if FParent <> nil then
  begin
    Prnt := FParent;
    FParent := nil;
    Next := Prnt.RemoveSubMenu( FId );
    Prnt.FItems.Remove( Self );
    if Next = nil then Exit;
  end;
   if (FControl <> nil) and (FControl.fMenu = FHandle) and (FHandle <> 0) then
   begin
     //if FControl.fHandle <> 0 then
     begin
       Windows.SetMenu( FControl.fHandle, 0 );
       // this removes main menu from window, but does not destroy it
     end;
     FControl.fMenu := 0;
     Next := PMenu( FControl.fMenuObj );
     while Next <> nil  do
     begin
       if Next.fNextMenu = Self then
       begin
         Next.fNextMenu := fNextMenu;
         break;
       end;
       Next := Next.fNextMenu;
     end;
   end;
   Next := fNextMenu;
   if FHandle <> 0 then
     DestroyMenu( FHandle );
   FCaption := '';
   FItems.Free;
   inherited;
   Next.Free;
   // all later created (popup) menus (of the same control)
   // are destroyed too
end;

//[function TMenu.GetInfo]
function TMenu.GetInfo( var MII: TMenuItemInfo ): Boolean;
begin
  MII.cbSize := MenuStructSize;
  Result := GetMenuItemInfo( Parent.FHandle, FId, FALSE,
            Windows.PMenuitemInfo( @ MII )^ );
end;

//[procedure TMenu.RedrawFormMenuBar]
procedure TMenu.RedrawFormMenuBar;
var C: PControl;
begin
  C := TopParent.FControl;
  if not AppletTerminated then
  if (C <> nil) and (Pointer( C.fMenuObj ) = Pointer( TopParent )) then
    DrawMenuBar( C.FHandle );
end;

//[function TMenu.SetInfo]
function TMenu.SetInfo( var MII: TMenuItemInfo ): Boolean;
var H: THandle;
begin
  MII.cbSize := MenuStructSize;
  H := FHandle;
  if FParent <> nil then
    H := FParent.FHandle;
  Result := SetMenuItemInfo( H, FId, FALSE, Windows.PMenuitemInfo( @ MII )^ );
  if Result and ((FParent = nil) or (FParent.FParent = nil)) then {YS}
    RedrawFormMenuBar;
end;

//[function TMenu.SetTypeInfo]
function TMenu.SetTypeInfo( var MII: TMenuItemInfo ): Boolean;
begin
  if not FIsSeparator then
  begin
    if FBmpItem = 0 then
      MII.dwTypeData := PChar( FCaption )
    else
      MII.dwTypeData := Pointer( FBmpItem );
    MII.cch := Length( FCaption );
  end;
  Result := SetInfo( MII );
end;

//[function TMenu.GetTopParent]
function TMenu.GetTopParent: PMenu;
begin
  Result := Self;
  while Result.FParent <> nil do
    Result := Result.FParent;
end;

//[function TMenu.GetControl]
function TMenu.GetControl: PControl;
begin
  Result := TopParent.FControl;
end;

//[function TMenu.GetItems]
function TMenu.GetItems( Id: HMenu ): PMenu;
  function SearchItems( ParentMenu: PMenu; var FromIdx: Integer ): PMenu;
  var I: Integer;
  begin
    Result := ParentMenu;
    if Id = HMenu( FromIdx ) then Exit;
    if (Id >= 4096) and (DWORD( ParentMenu.FId ) = Id) then Exit;
    if ParentMenu.FItems = nil then Exit;
    for I := 0 to ParentMenu.FItems.FCount-1 do
    begin
      Inc( FromIdx );
      Result := SearchItems( ParentMenu.FItems.Items[ I ], FromIdx );
      if Result <> nil then Exit;
    end;
    Result := nil;
  end;
var I: Integer;
begin
  I := -1;
  Result := SearchItems( Self, I );
end;

//[function TMenu.GetCount]
function TMenu.GetCount: Integer;
var I: Integer;
    SubM: PMenu;
begin
  Result := FItems.FCount;
  for I := 0 to Result-1 do
  begin
    SubM := FItems.Items[ I ];
    Result := Result + SubM.Count;
  end;
end;

//[function TMenu.IndexOf]
function TMenu.IndexOf( Item: PMenu ): Integer;
  function SearchMenu( ParentMenu: PMenu; var FromIdx: Integer ): PMenu;
  var I: Integer;
  begin
    Result := ParentMenu;
    if Result = Item then Exit;
    for I := 0 to ParentMenu.FItems.FCount-1 do
    begin
      Inc( FromIdx );
      Result := SearchMenu( ParentMenu.FItems.Items[ I ], FromIdx );
      if Result <> nil then Exit;
    end;
    Result := nil;
  end;
begin
  Result := -1;
  if SearchMenu( Self, Result ) = nil then
    Result := -2;
end;

//[function TMenu.GetState]
function TMenu.GetState( const Index: Integer ): Boolean;
var MII: TMenuItemInfo;
begin
  if FVisible then
  begin
    MII.fMask := MIIM_STATE;
    if GetInfo( MII ) then
      FSavedState := MII.fState;
  end;
  Result := LongBool( FSavedState and Index );
  if Index < 0 then
    Result := not Result;
end;

//[procedure TMenu.SetState]
procedure TMenu.SetState( const Index: Integer; Value: Boolean );
var MII: TMenuItemInfo;
begin
  GetState( 0 );
  if Value xor (Index < 0) then
    FSavedState := FSavedState or DWORD( Index and $7FFFFFFF )
  else
    FSavedState := FSavedState and not DWORD( Index );
  if FVisible then
  begin
    MII.fMask := MIIM_STATE;
    if GetInfo( MII ) then
    begin
      MII.fState := FSavedState;
      SetInfo( MII );
    end;
  end;
end;

//[procedure TMenu.SetData]
procedure TMenu.SetData( Value: Pointer );
var MII: TMenuItemInfo;
begin
  MII.fMask := MIIM_DATA;
  MII.dwItemData := DWORD( Value );
  SetInfo( MII );
  FData := Value;
end;

//[procedure TMenu.ClearBitmaps]
procedure TMenu.ClearBitmaps;
begin
  if FBitmap <> 0 then
    DeleteObject( FBitmap );
  if FBmpChecked <> 0 then
    DeleteObject( FBmpChecked );
  if FBmpItem <> 0 then
    DeleteObject( FBmpItem );
end;

//[procedure TMenu.SetBitmap]
procedure TMenu.SetBitmap( Value: HBitmap );
var MII: TMenuItemInfo;
begin
  if not FClearBitmaps then
  begin
    FClearBitmaps := TRUE;
    Add2AutoFreeEx( ClearBitmaps );
  end;
  if Value = FBitmap then Exit;
  if FBitmap <> 0 then
    DeleteObject( FBitmap );
  FBitmap := Value;
  MII.fMask := MIIM_CHECKMARKS;
  MII.hbmpChecked := FBmpChecked;
  MII.hbmpUnchecked := FBitmap;
  SetInfo( MII );
end;

//[procedure TMenu.SetBmpChecked]
procedure TMenu.SetBmpChecked( Value: HBitmap );
var MII: TMenuItemInfo;
begin
  if not FClearBitmaps then
  begin
    FClearBitmaps := TRUE;
    Add2AutoFreeEx( ClearBitmaps );
  end;
  if Value = FBmpChecked then Exit;
  if FBmpChecked <> 0 then
    DeleteObject( FBmpChecked );
  FBmpChecked := Value;
  MII.fMask := MIIM_CHECKMARKS;
  MII.hbmpChecked := FBmpChecked;
  MII.hbmpUnchecked := FBitmap;
  SetInfo( MII );
end;

//[procedure TMenu.SetBmpItem]
procedure TMenu.SetBmpItem( Value: HBitmap );
var MII: TMenuItemInfo;
begin
  if not FClearBitmaps then
  begin
    FClearBitmaps := TRUE;
    Add2AutoFreeEx( ClearBitmaps );
  end;
  if Value = FBmpItem then Exit;
  if FBmpItem <> 0 then
    DeleteObject( FBmpItem );
  FBmpItem := Value;
  if WinVer >= wv98 then {AK}
  begin                                            {AK}
    MII.fMask := $80 {MIIM_BITMAP} ;               {AK}
    MII.hbmpItem:=Value;                           {AK}
  end                                              {AK}
  else                                             {AK}
  begin//I haven't possibility to test it in Win95 {AK}
    MII.fType := MFT_BITMAP;
    MII.dwItemData := Value;
  end;                                             {AK}
  SetInfo( MII );
end;

//[procedure TMenu.SetAccelerator]
procedure TMenu.SetAccelerator(const Value: TMenuAccelerator);
const MaxAccel = 1000;
type TAccTab = array[0..10000] of TAccel;
     PAccTab = ^TAccTab;
     //TSetAcceleratorProc = procedure( Self_: PMenu; Idx: Integer; const Value: TMenuAccelerator );
var AccTab: PAccTab;
    I, N : Integer;
    M, SubM: PMenu;
    C: PControl;
    Main: Boolean;
begin
  //SetAcceleratorProc := TSetAcceleratorProc( MakeMethod( nil, @TMenu.SetAccelerator ).Code );
  if (FAccelerator.fVirt = Value.fVirt) and (FAccelerator.Key = Value.Key) then Exit;
  FAccelerator := Value;
  C := TopParent.FControl;
  if C = nil then Exit;
  if C.fAccelTable <> 0 then
     DestroyAcceleratorTable( C.fAccelTable );
  C.fAccelTable := 0;
  GetMem( AccTab, sizeof( TAccel ) * MaxAccel );
  N := 0;
  M := PMenu( C.fMenuObj );
  Main := TRUE;
  while M <> nil do
  begin
    if Main or M.Visible then
    begin
      for I := 0 to MaxInt-1 do
      begin
        SubM := M.Items[ I ];
        if SubM = nil then break;
        if SubM.FVisible then
        if (SubM.FAccelerator.Key <> 0) or (SubM.FAccelerator.fVirt <> 0) then
        begin
          AccTab[ N ].fVirt := SubM.FAccelerator.fVirt;
          AccTab[ N ].key := SubM.FAccelerator.Key;
          AccTab[ N ].cmd := WORD( SubM.FId );
          Inc( N );
          if N > MaxAccel then break;
        end;
      end;
    end;
    if N > MaxAccel then break;
    M := M.fNextMenu;
  end;
  if N > 0 then
  begin
    C.fAccelTable := CreateAcceleratorTable( AccTab[ 0 ], N );
    C := C.ParentForm;
    if C <> nil then
      C.SupportMnemonics;
  end;
  FreeMem( AccTab );
end;

//[procedure TMenu.SetMenuItemCaption]
procedure TMenu.SetMenuItemCaption( const Value: String );
var MII: TMenuItemInfo;
begin
  FCaption := Value;
{AK}if not (WinVer in [wv95,wvNT]) then
{AK}  MII.fMask := $40 {MIIM_STRING}
{AK}else begin
  MII.fMask := MIIM_TYPE;
  MII.fType := MFT_STRING;
{AK}end;
  //+++++++++++++++++++ to fix turning radio mark to check mark in NT4
  MII.cch := 0;
  GetInfo( MII );
  //------------------------------------------------------------------
  MII.dwTypeData := PChar( Value );
  MII.cch := Length( Value );
  SetInfo( MII );
end;

//[procedure TMenu.SetMenuBreak]
procedure TMenu.SetMenuBreak( Value: TMenuBreak );
var MII: TMenuItemInfo;
begin
  if FId = 0 then Exit;
  if FMenuBreak = Value then Exit;
  FMenuBreak := Value;
  FillChar( MII, Sizeof( MII ), 0 );
  MII.fMask := MIIM_TYPE;
  MII.dwTypeData := nil;
  if GetInfo( MII ) then
  begin
    MII.fType := MII.fType and not( MFT_MENUBREAK or MFT_MENUBARBREAK ) or
                 Breaks[ Value ];
    SetTypeInfo( MII );
  end;
end;

//[procedure TMenu.SetVisible]
procedure TMenu.SetVisible( Value: Boolean );
var I, J: Integer;
    M: PMenu;
    Before: Integer;
    ByPosition: Boolean;
    MII: TMenuItemInfo;
begin
  if Value then
    if FParent <> nil then
      FParent.Visible := TRUE;
  if Value = FVisible then Exit;
  FVisible := Value;
  if (FControl <> nil) and (FControl.fMenuObj = Self) then
  begin
    FControl.GetWindowHandle;
    if Value then
      SetMenu( FControl.fHandle, FHandle )
    else
      SetMenu( FControl.fHandle, 0 );
    Exit;
  end;
  if FId = 0 then Exit;
  if FParent = nil then Exit;
  if Value then
  begin // show menu item inserting it again into appropriate position
    Before := -1;
    ByPosition := TRUE;
    I := FParent.FItems.IndexOf( Self );
    for J := I + 1 to FParent.FItems.FCount-1 do
    begin
      M := FParent.FItems.Items[ J ];
      if M.FVisible then
      begin
        Before := M.FId;
        ByPosition := FALSE;
        break;
      end;
    end;

    FillChar( MII, Sizeof( MII ), 0 );
    MII.cbSize := MenuStructSize;
    MII.fMask := MIIM_CHECKMARKS or MIIM_ID or MIIM_STATE or
                 MIIM_TYPE;
    MII.fType := Breaks[ FMenuBreak ];
    MII.fState := FSavedState;
    MII.wID := FId;
    MII.dwItemData := DWORD( FData );

    if not FIsSeparator then
    begin
      MII.fType := MII.fType or MFT_STRING;
      MII.dwTypeData := PChar( FCaption );
      MII.cch := Length( FCaption );
    end
      else
      MII.fType := MII.fType or MFT_SEPARATOR;

    if FRadioGroup <> 0 then
      MII.fType := MII.fType or MFT_RADIOCHECK;

    if FOwnerDraw then
      MII.fType := MII.fType or MFT_OWNERDRAW;

    if FBitmap <> 0 then
    begin
      MII.fMask := MII.fMask or MIIM_CHECKMARKS;
      MII.hbmpUnchecked := FBitmap;
    end;

    if FHandle <> 0 then
    begin
      MII.fMask := MII.fMask or MIIM_SUBMENU;
      MII.hSubMenu := FHandle;
    end;

    InsertMenuItem( FParent.FHandle, Before, ByPosition,
                    Windows.PMenuitemInfo( @ MII )^ );
  end
    else
  begin // hide menu item removing it
    GetState( 0 ); // store menu item state in FSavedState to allow
                   // changing its state while it is not attached to
                   // a menu
    RemoveMenu( TopParent.FHandle, FId, MF_BYCOMMAND );
  end;
  if (FControl <> nil) or (FParent <> nil) and (FParent.FControl <> nil) then
    RedrawFormMenuBar;
end;

//[procedure TMenu.RadioCheckItem]
procedure TMenu.RadioCheckItem;
var I, J: Integer;
    M, First, Last: PMenu;
begin
  if (FParent <> nil) and (FRadioGroup <> 0) then
  begin
    I := FParent.FItems.IndexOf( Self );
    if I >= 0 then
    begin
      First := Self;
      Last := Self;
      for J := I-1 downto 0 do
      begin
        M := FParent.FItems.Items[ J ];
        if M.FRadioGroup <> FRadioGroup then break;
        if M.FVisible then
          First := M;
      end;
      for J := I+1 to FParent.FItems.FCount-1 do
      begin
        M := FParent.FItems.Items[ J ];
        if M.FRadioGroup <> FRadioGroup then break;
        if M.FVisible then
          Last := M;
      end;
      if First <> Last then
      begin
        CheckMenuRadioItem( FParent.FHandle, First.FId, Last.FId,
                            FId, MF_BYCOMMAND or MF_CHECKED );
        Exit;
      end;
    end;
  end;
  Checked := TRUE;
end;

//[function TMenu.FillMenuItems]
function TMenu.FillMenuItems(AHandle: HMenu; StartIdx: Integer;
  const Template: array of PChar): Integer;
var S, S1: PChar;
    I: Integer;
    MII: TMenuItemInfo;
    Item, PrevItem: PMenu;
begin
  PrevItem := nil;
  I := StartIdx;
  while I <= High( Template ) do
  begin
    S := Template[ I ];
    if (S = nil) or (S^ = #0) then break;
    if S = {$IFDEF F_P}'' +{$ENDIF} ')' then
    begin
       Result := I + 1;
       Exit;
    end;

    Item := PMenu.Create;
    Item.FVisible := TRUE;
    Item.FParent := Self;
    Item.FItems := NewList;
    FItems.Add( Item );

    FillChar( MII, Sizeof( MII ), 0 );
    MII.cbSize := MenuStructSize;
    MII.fMask := MIIM_DATA or MIIM_ID or MIIM_STATE or MIIM_SUBMENU or MIIM_TYPE;
    if S <> {$IFDEF F_P}'' +{$ENDIF} '-' then
    begin
      if (S^ = {$IFDEF F_P}'' +{$ENDIF} '-') or
         (S^ = {$IFDEF F_P}'' +{$ENDIF} '+') then
      begin
        Item.FIsCheckItem := TRUE;
        MII.dwItemData := MIDATA_CHECKITEM;
        if S^ <> {$IFDEF F_P}'' +{$ENDIF} '-' then
          MII.fState := MII.fState or MFS_CHECKED;
        Inc( S );
        if S^ = {$IFDEF F_P}'' +{$ENDIF} '!' then
        begin
          MII.fType := MII.fType or MFT_RADIOCHECK;
          MII.dwItemData := MII.dwItemData or MIDATA_RADIOITEM;
          Inc( S );
          if PrevItem <> nil then
          begin
            if PrevItem.FRadioGroup <> 0 then
              Item.FRadioGroup := PrevItem.FRadioGroup;
          end;
          if Item.FRadioGroup = 0 then
            Inc( Item.FRadioGroup );
          if S^ = {$IFDEF F_P}'' +{$ENDIF} '!' then
          begin
            Inc( S );
            Inc( Item.FRadioGroup );
          end;
        end;
      end;
      Item.FCaption := S;
    end
      else
    begin
      Item.FIsSeparator := TRUE;
      MII.fType := MFT_SEPARATOR;
      MII.fState := MFS_GRAYED;
      MII.wID := 0;
    end;
    Item.FId := FDynamicMenuID;
    Inc( FDynamicMenuID );
    MII.wID := Item.FId;
    if I <> High( Template ) then            //YS
    begin                                    //YS
    S1 := Template[ I + 1 ];
    if S1 = {$IFDEF F_P}'' +{$ENDIF} '(' then Item.FHandle := CreatePopupMenu;
    end;                                     //YS
    MII.hSubMenu := Item.FHandle;
    MII.dwTypeData := PChar( S );
    MII.cch := StrLen( S );
    InsertMenuItem( AHandle, DWORD(-1), True, Windows.PMenuitemInfo( @ MII )^ );
    if Item.FHandle <> 0 then
      I := Item.FillMenuItems( Item.FHandle, I + 2, Template )
    else
      Inc( I );
    PrevItem := Item;
  end;
  Result := I;
end;

//[procedure TMenu.AssignEvents]
procedure TMenu.AssignEvents(StartIdx: Integer;
  Events: array of TOnMenuItem);
var I: Integer;
    M: PMenu;
begin
  for I := 0 to High(Events) do
  begin
    M := Items[ StartIdx ];
    if M = nil then break;
    M.FOnMenuItem := Events[ I ];
    Inc( StartIdx );
  end;
end;

//[procedure TMenu.Popup]
procedure TMenu.Popup(X, Y: Integer);
begin
  if Assigned( fOnPopup ) then fOnPopup( Self );
  TrackPopupMenu( FHandle, FPopupFlags,
                  X, Y, 0, FControl.Handle, nil );
end;

//[procedure TMenu.PopupEx]
procedure TMenu.PopupEx( X, Y: Integer );
var OldBounds: TRect;
    WasVisible: Boolean;
begin
  WasVisible := TRUE;
  if FControl <> nil then
  begin
    OldBounds := FControl.BoundsRect;
    if not FControl.fIsControl then
    begin
      WasVisible := FControl.Visible;
      if not WasVisible then
        FControl.Top := ScreenHeight + 50;
      FControl.Show;
    end;
  end;

  // -- by Martin Larsen: -----------------------\
  FControl.ProcessMessage; // specific for Win9x |
  //---------------------------------------------/

  Popup( X, Y );
  if FControl <> nil then
  begin
    if FControl.Top = ScreenHeight + 50 then
    begin
      if not WasVisible then
        FControl.Visible := FALSE;
      FControl.BoundsRect := OldBounds;
    end;
  end;
end;

//[function TMenu.GetItemChecked]
function TMenu.GetItemChecked( Item : Integer ) : Boolean;
begin
  Result := Items[ Item ].Checked;
end;

//[procedure TMenu.SetItemChecked]
procedure TMenu.SetItemChecked( Item : Integer; Value : Boolean );
begin
  Items[ Item ].Checked := Value;
end;

//[function TMenu.GetMenuItemHandle]
function TMenu.GetMenuItemHandle( Idx : Integer ): DWORD;
begin
  Result := Items[ Idx ].FId;
end;

//[procedure TMenu.RadioCheck]
procedure TMenu.RadioCheck( Idx : Integer );
begin
  Items[ Idx ].RadioCheckItem;
end;

//[function TMenu.GetItemBitmap]
function TMenu.GetItemBitmap(Idx: Integer): HBitmap;
begin
  Result := Items[ Idx ].Bitmap;
end;

//[procedure TMenu.SetItemBitmap]
procedure TMenu.SetItemBitmap(Idx: Integer; const Value: HBitmap);
begin
  Items[ Idx ].Bitmap := Value;
end;

//[procedure TMenu.AssignBitmaps]
procedure TMenu.AssignBitmaps(StartIdx: Integer; Bitmaps: array of HBitmap);
var I: Integer;
begin
  for I := 0 to High(Bitmaps) do
    ItemBitmap[ I + StartIdx ] := Bitmaps[ I ];
end;

//[function TMenu.GetItemText]
function TMenu.GetItemText(Idx: Integer): String;
begin
  Result := Items[ Idx ].FCaption;
end;

//[procedure TMenu.SetItemText]
procedure TMenu.SetItemText(Idx: Integer; const Value: String);
begin
  Items[ Idx ].Caption := Value;
end;

//[function TMenu.GetItemEnabled]
function TMenu.GetItemEnabled(Idx: Integer): Boolean;
begin
  Result := Items[ Idx ].Enabled;
end;

//[procedure TMenu.SetItemEnabled]
procedure TMenu.SetItemEnabled(Idx: Integer; const Value: Boolean);
begin
  Items[ Idx ].Enabled := Value;
end;

//[function TMenu.GetItemVisible]
function TMenu.GetItemVisible(Idx: Integer): Boolean;
begin
  Result := Items[ Idx ].Visible;
end;

//[procedure TMenu.SetItemVisible]
procedure TMenu.SetItemVisible(Idx: Integer; const Value: Boolean);
begin
  Items[ Idx ].Visible := Value;
end;

//[function TMenu.ParentItem]
function TMenu.ParentItem( Idx: Integer ): Integer;
begin
  Result := TopParent.IndexOf( Items[ Idx ].FParent );
end;

//[function TMenu.GetItemAccelerator]
function TMenu.GetItemAccelerator(Idx: Integer): TMenuAccelerator;
begin
  Result := Items[ Idx ].Accelerator;
end;

//[procedure TMenu.SetItemAccelerator]
procedure TMenu.SetItemAccelerator(Idx: Integer; const Value: TMenuAccelerator);
begin
  Items[ Idx ].Accelerator := Value;
end;

//[function TMenu.GetItemSubMenu]
function TMenu.GetItemSubMenu( Idx: Integer ): HMenu;
begin
  Result := Items[ Idx ].SubMenu;
end;

//[function WndProcHelp FORWARD DECLARATION]
function WndProcHelp( Sender: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
forward;

//[procedure TMenu.SetHelpContext]
procedure TMenu.SetHelpContext( Value: Integer );
var Form, C: PControl;
begin
  if TopParent <> Self then Exit;
  // Help context can not be associated with individual menu items
  FHelpContext := Value;
  C := FControl;
  if C = nil then Exit;
  Form := C.ParentForm;
  Form.AttachProc( WndProcHelp );
  SetMenuContextHelpID( FHandle, Value );
end;

//[procedure TMenu.SetSubmenu]
procedure TMenu.SetSubmenu( Value: HMenu );
var MII: TMenuItemInfo;
begin
  MII.fMask := MIIM_SUBMENU;
  MII.hSubMenu := Value;
  SetInfo( MII );
  FHandle := Value;
end;

//[function WndProcMeasureItem]
function WndProcMeasureItem( Sender: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var MIS: PMeasureItemStruct;
    M, SM: PMenu;
    H, I: Integer;
begin
  Result := FALSE;
  if (Msg.message = WM_MEASUREITEM) and (Msg.wParam = 0) then
  begin
    MIS := Pointer( Msg.lParam );
    if MIS.CtlType = ODT_MENU then
    begin
      M := Pointer( Sender.fMenuObj );
      while M <> nil do
      begin
        SM := M.Items[ MIS.itemID ];
        if SM <> nil then
        begin
          Sender.CallDefWndProc( Msg );
          I := M.IndexOf( SM );
          if Assigned( SM.OnMeasureItem ) then
            M := SM;
          if not Assigned( M.OnMeasureItem ) then
            Exit;
          H := M.OnMeasureItem( M, I );
          if HiWord( H ) <> 0 then
            MIS.itemWidth := HiWord( H );
          if LoWord( H ) <> 0 then
            MIS.itemHeight := LoWord( H );
          Rslt := 1;
          Result := TRUE;
          break;
        end;
        M := M.fNextMenu;
      end;
    end;
  end;
end;

//[procedure TMenu.SetOnMeasureItem]
procedure TMenu.SetOnMeasureItem( const Value: TOnMeasureItem );
var C: PControl;
begin
  FOnMeasureItem := Value;
  C := TopParent.FControl;
  if C <> nil then
    C.AttachProc( WndProcMeasureItem );
end;

//[function WndProcDrawItem]
function WndProcDrawItem( Sender: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
type PDrawAction = ^TDrawAction;
     PDrawState = ^TDrawState;
var DIS: PDrawItemStruct;
    M, SM: PMenu;
    I: Integer;
begin
  Result := FALSE;
  if (Msg.message = WM_DRAWITEM) and (Msg.wParam = 0) then
  begin
    DIS := Pointer( Msg.lParam );
    if DIS.CtlType = ODT_MENU then
    begin
      M := Pointer( Sender.fMenuObj );
      while M <> nil do
      begin
        SM := M.Items[ DIS.itemID ];
        if SM <> nil then
        begin
          I := M.IndexOf( SM );
          if Assigned( SM.OnDrawItem ) then
            M := SM;
          if Assigned( M.OnDrawItem ) then
          begin
            if not M.OnDrawItem( M, DIS.hDC, DIS.rcItem, I,
                          PDrawAction( @ DIS.itemAction )^,
                          PDrawState( @ DIS.itemState )^ ) then Exit;
          end
            else Exit;
          Rslt := 1;
          Result := TRUE;
          break;
        end;
        M := M.fNextMenu;
      end;
    end;
  end;
end;

//[procedure TMenu.SetOnDrawItem]
procedure TMenu.SetOnDrawItem( const Value: TOnDrawItem );
var C: PControl;
begin
  FOnDrawItem := Value;
  C := TopParent.FControl;
  if C <> nil then
    C.AttachProc( WndProcDrawItem );
end;

//[procedure TMenu.SetOwnerDraw]
procedure TMenu.SetOwnerDraw( Value: Boolean );
const Masks: array[ Boolean ] of DWORD = ( 0, $FFFFFFFF );
var MII: TMenuItemInfo;
begin
  FOwnerDraw := Value;
  FillChar( MII, Sizeof( MII ), 0 );
  MII.fMask := MIIM_TYPE;
  MII.dwTypeData := nil;
  if GetInfo( MII ) then
  begin
    MII.fType := MII.fType and not MFT_OWNERDRAW or
              (MFT_OWNERDRAW and Masks[ Value ]);
    SetTypeInfo( MII );
  end;
end;

//[function TMenu.Insert]
function TMenu.Insert(InsertBefore: Integer; ACaption: PChar; Event: TOnMenuItem;
             Options: TMenuOptions): PMenu;
const
  MenuStateFlags: array[TMenuOption] of Integer = (MFS_DEFAULT, MFS_DISABLED, MFS_CHECKED, 0, 0,
                  MFS_DISABLED, 0, 0, 0, 0);
  MenuTypeFlags: array[TMenuOption] of Integer =  (0, 0, 0, 0, MFT_RADIOCHECK, MFT_SEPARATOR, MFT_BITMAP, 0,
                 MFT_MENUBREAK, MFT_MENUBARBREAK);
var M: PMenu;
    MII: TMenuItemInfo;
begin
  Result := PMenu.Create;
  Result.FVisible := TRUE;
  Result.FParent := Self;
  Result.FItems := NewList;
  Result.FIsSeparator := moSeparator in Options;
  if FHandle = 0 then
    SetSubMenu( CreatePopupMenu );
  M := nil;
  if (InsertBefore >= 0) and (InsertBefore < 4096) then
  begin
    M := Items[ InsertBefore ];
    if M <> nil then
    begin
      InsertBefore := M.FId;
      M.Parent.FItems.Insert( M.Parent.FItems.IndexOf( M ), Result );
    end;
  end;
  if M = nil then
  begin
    InsertBefore := -1;
    FItems.Add( Result );
  end;
  Result.FOnMenuItem := Event;

  FillChar( MII, Sizeof( MII ), 0 );
  MII.cbSize := MenuStructSize;
  MII.fMask := MIIM_DATA or MIIM_ID or MIIM_STATE or MIIM_SUBMENU or MIIM_TYPE;

  MII.fState := MakeFlags( Pointer( @Options ), MenuStateFlags);
  MII.fType := MakeFlags( Pointer( @Options ), MenuTypeFlags);
  Result.FId := FDynamicMenuID;
  Inc( FDynamicMenuID );
  MII.wID := Result.FId;
  if moSubMenu in Options
  then begin
    Result.FHandle := CreatePopupMenu;
    MII.hSubMenu := Result.FHandle;
  end;
  MII.dwTypeData := ACaption;
  if not (moBitmap in Options) then MII.cch := StrLen( ACaption );
  InsertMenuItem( FHandle, InsertBefore, InsertBefore = -1,
                  Windows.PMenuItemInfo( @ MII )^ );
  if moBitmap in Options then
  begin
    Result.BitmapItem := DWORD( ACaption );
  end
  else
    Result.FCaption := ACaption;
  RedrawFormMenuBar;
end;

//[function TMenu.AddItem]
function TMenu.AddItem(ACaption: PChar; Event: TOnMenuItem; Options: TMenuOptions): Integer;
begin
  Result := InsertItem( -1, ACaption, Event, Options );
end;

//[function TMenu.InsertItem]
function TMenu.InsertItem( InsertBefore: Integer; ACaption: PChar; Event: TOnMenuItem;
  Options: TMenuOptions): Integer;
begin
  Result := InsertItemEx( InsertBefore, ACaption, Event, Options, FALSE );
end;

//[function TMenu.InsertItemEx]
function TMenu.InsertItemEx(InsertBefore: Integer; ACaption: PChar;
  Event: TOnMenuItem; Options: TMenuOptions; ByPosition: Boolean): Integer;
var M: PMenu;
begin
  M := Insert( InsertBefore, ACaption, Event, Options );
  Result := M.FId;
end;

//[procedure TMenu.InsertSubMenu]
procedure TMenu.InsertSubMenu( SubMenuToInsert: PMenu; InsertBefore: Integer );
var AFlags: DWORD;
    M: PMenu;
    MII: TMenuItemInfo;
begin
  if SubMenuToInsert.FParent <> nil then
    SubMenuToInsert := SubMenuToInsert.FParent.RemoveSubMenu( SubMenuToInsert.FId );
  if SubMenuToInsert = nil then Exit;

  AFlags := MF_BYPOSITION;
  M := nil;
  if (InsertBefore >= 0) and (InsertBefore < 4096) then
  begin
    M := Items[ InsertBefore ];
    if M = nil then
      InsertBefore := -1
    else
      InsertBefore := M.FId;
  end;
  if M = nil then
  begin
    FItems.Add( SubMenuToInsert );
    SubMenuToInsert.FParent := Self;
  end
    else
  begin
    M.FParent.FItems.Insert( M.FParent.FItems.IndexOf( M ), SubMenuToInsert );
    SubMenuToInsert.FParent := M.FParent;
  end;

  if InsertBefore > 0 then
    AFlags := MF_BYCOMMAND;
  if SubMenuToInsert.FBmpItem <> 0 then
    InsertMenu( FHandle, InsertBefore, AFlags or MF_BITMAP or MF_POPUP, SubMenuToInsert.FHandle,
                PChar( SubMenuToInsert.FBmpItem ) )
  else
    InsertMenu( FHandle, InsertBefore, AFlags or MF_STRING or MF_POPUP, SubMenuToInsert.FHandle,
                PChar( SubMenuToInsert.Caption ) );
  if SubMenuToInsert.FId = 0 then
  begin
    SubMenuToInsert.FId := FDynamicMenuID;
    Inc( FDynamicMenuID );
    MII.cbSize := MenuStructSize;
    MII.fMask := MIIM_ID;
    MII.wID := SubMenuToInsert.FId;
    SetMenuItemInfo( SubMenuToInsert.FParent.FHandle, SubMenuToInsert.FParent.FItems.IndexOf( SubMenuToInsert ),
                     TRUE, Windows.PMenuItemInfo( @ MII )^ );
  end;
  RedrawFormMenuBar;
end;

//[function TMenu.RemoveSubMenu]
function TMenu.RemoveSubMenu( ItemToRemove: Integer ): PMenu;
{$IFDEF DEBUG_MENU}var OK: Boolean; {$ENDIF}
begin
  Result := Items[ ItemToRemove ];
  if Result = nil then Exit;
  if Result.FParent <> nil then
    {$IFDEF DEBUG_MENU} OK := {$ENDIF}
    RemoveMenu( Result.FParent.FHandle, Result.FId, MF_BYCOMMAND )
  else
    {$IFDEF DEBUG_MENU} OK := {$ENDIF}
    RemoveMenu( FHandle, Result.FId, MF_BYCOMMAND );
  {$IFDEF DEBUG_MENU}
  if not OK then
    ShowMessage( 'Error removing menu: ' + Int2Str( GetLastError ) + ' - ' +
                 SysErrorMessage( GetLastError ) );
  {$ENDIF}
  if Count = 0 then
  begin
    Result.Free;
    Result := nil;
  end;
  RedrawFormMenuBar;
end;

//[procedure ClearText]
procedure ClearText( Sender: PControl );
begin
  Sender.Caption := '';
end;

//[procedure ClearListbox]
procedure ClearListbox( Sender: PControl );
begin
  Sender.Perform( LB_RESETCONTENT, 0, 0 );
end;

//[procedure ClearCombobox]
procedure ClearCombobox( Sender: PControl );
begin
  Sender.Perform( CB_RESETCONTENT, 0, 0 );
end;

//[procedure ClearListView]
procedure ClearListView( Sender: PControl );
begin
  Sender.Perform( LVM_DELETEALLITEMS, 0, 0 );
end;

//[procedure ClearToolbar]
procedure ClearToolbar( Sender: PControl );
begin
  while Sender.TBButtonCount > 0 do
    Sender.TBDeleteButton( Sender.TBIndex2Item( 0 ) );
  Sender.Perform( TB_SETBITMAPSIZE, 0, 0 );
end;

{ -- Constructor of canvas -- }
//[function NewCanvas]
function NewCanvas( DC: HDC ): PCanvas;
begin


  Result := PCanvas.Create;

  Result.ModeCopy := cmSrcCopy;
  if DC <> 0 then
  begin
    Result.SetHandle( DC );
    //Result.fIsPaintDC := True; // If Canvas will be destroyed, DC will not be deleted
  end;
end;
//[END NewCanvas]

{ -- Contructors of controls -- }

{$IFDEF ASM_VERSION}
//[FUNCTION _NewTControl]
function _NewTControl( AParent: PControl ): PControl;
begin
  New( Result, CreateParented( AParent ) );
end;
//[END _NewTControl]

//[function _NewWindowed]
function _NewWindowed( AParent: PControl; ControlClassName: PChar; Ctl3D: Boolean ): PControl;
asm
        PUSH     EBX
        PUSH     ESI
        PUSH     EDI

        PUSH     ECX // Ctl3D
        PUSH     EDX // ControlClassName

        MOV      ESI, EAX // ESI = AParent
        CALL     _NewTControl
        XCHG     EBX, EAX // EBX = Result
        POP      [EBX].TControl.fControlClassName
        INC      [EBX].TControl.fWindowed

        INC      EAX
        POP      EDX // DL = parameter Ctl3D
        TEST     ESI, ESI
        JZ       @@no_parent

        LEA      ESI, [ESI].TControl.fWndProcResizeFlicks
        LEA      EDI, [EBX].TControl.fWndProcResizeFlicks
        MOVSD    // fWndProcResizeFlicks
        MOVSD    // fGotoControl
        //MOVSW    // fDoubleBuffered, fTransparent
        LODSB    // fCtl3Dchild
        STOSB
        DEC      AL
        LODSB    // fCtl3D
        JZ       @@passed3D
        XOR      EDX, EDX
@@passed3D:
        XCHG     EAX, EDX
        STOSB    // fCtl3D

        MOVSD    // fTextColor
        LODSD
        XCHG     EDX, EAX
        XOR      EAX, EAX
        PUSH     EDX
        CALL     TGraphicTool.Assign
        STOSD    // fFont
        POP      EDX
        XCHG     ECX, EAX
        JECXZ    @@no_font
        MOV      [ECX].TGraphicTool.fParentGDITool, EDX
        MOV      [ECX].TGraphicTool.fOnChange.TMethod.Code, offset[TControl.FontChanged]
        MOV      [ECX].TGraphicTool.fOnChange.TMethod.Data, EBX
        MOV      EAX, EBX
        MOV      EDX, ECX
        CALL     TControl.FontChanged
@@no_font:

        MOVSD    // fColor
        LODSD
        XCHG     EDX, EAX
        XOR      EAX, EAX
        PUSH     EDX
        CALL     TGraphicTool.Assign
        STOSD    // fBrush
        POP      EDX
        XCHG     ECX, EAX
        JECXZ    @@no_brush
        MOV      [ECX].TGraphicTool.fParentGDITool, EDX
        MOV      [ECX].TGraphicTool.fOnChange.TMethod.Code, offset[TControl.BrushChanged]
        MOV      [ECX].TGraphicTool.fOnChange.TMethod.Data, EBX
        MOV      EAX, EBX
        MOV      EDX, ECX
        CALL     TControl.BrushChanged
@@no_brush:

        LODSD
        STOSD    // fMargin
        STOSD    // fBoundsRect.Left
        PUSH     EAX
        ADD      EAX, [ESI+16] // AParent.fClientTop
        STOSD    // fBoundsRect.Top
        POP      EAX
        ADD      EAX, 64
        STOSD    // fBoundsRect.Right
        STOSD    // fBoundsRect.Bottom

@@no_parent:
        XCHG     EAX, EBX
        //DEC      byte ptr [EAX].TControl.fAlphaBlend
        //INC      byte ptr [EAX].TControl.fEraseUpdRgn
        POP      EDI
        POP      ESI
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function _NewWindowed( AParent: PControl; ControlClassName: PChar; Ctl3D: Boolean ): PControl;
begin
  Result := PControl.CreateParented( AParent );
  Result.fControlClassName := ControlClassName;
  if AParent <> nil then
  begin
     Result.fWndProcResizeFlicks := AParent.fWndProcResizeFlicks;
     Result.fGotoControl := AParent.fGotoControl;
     //Result.fDoubleBuffered := AParent.fDoubleBuffered;
     //Result.fTransparent := AParent.fTransparent;
     Result.fCtl3Dchild := AParent.fCtl3Dchild;
     if AParent.fCtl3Dchild then
       Result.fCtl3D := Ctl3D
     else
       Result.fCtl3D := False;
     Result.fMargin := AParent.fMargin;
     with Result.fBoundsRect do
     begin
       Left := AParent.fMargin + AParent.fClientLeft;
       Top  := AParent.fMargin + AParent.fClientTop;
       Right := Left + 64;
       Bottom := Top + 64;
     end;
     Result.fTextColor := AParent.fTextColor;
     Result.fFont := Result.fFont.Assign( AParent.fFont );
     if Result.fFont <> nil then
     begin
       Result.fFont.fParentGDITool := AParent.fFont;
       Result.fFont.fOnChange := Result.FontChanged;
       Result.FontChanged( Result.fFont );
     end;
     Result.fColor := AParent.fColor;
     Result.fBrush := Result.fBrush.Assign( AParent.fBrush );
     if Result.fBrush <> nil then
     begin
       Result.fBrush.fParentGDITool := AParent.fBrush;
       Result.fBrush.fOnChange := Result.BrushChanged;
       Result.BrushChanged( Result.fBrush );
     end;
  end;
  //Result.fAlphaBlend := 255;
  //Result.fEraseUpdRgn := TRUE;
end;
//[END _NewWindowed]
{$ENDIF ASM_VERSION}

//===================== Form ========================//

{$IFDEF USE_CONSTRUCTORS}
//[function NewForm]
function NewForm( AParent: PControl; const Caption: String ): PControl;
begin
  new( Result, CreateForm( AParent, Caption ) );
end;
//[END NewForm]
{$ELSE not_USE_CONSTRUCTORS}

//[FUNCTION NewForm]
{$IFDEF ASM_VERSION}
function NewForm( AParent: PControl; const Caption: String ): PControl;
const FormClass: array[ 0..4 ] of Char = ( 'F', 'o', 'r', 'm', #0 );
asm
        PUSH     EBX
        PUSH     EDX
        MOV      EDX, offset[FormClass]
        MOV      CL, 1
        CALL     _NewWindowed
        MOV      EBX, EAX
        INC      [EBX].TControl.fSizeGrip
        OR       byte ptr [EBX].TControl.fClsStyle, CS_DBLCLKS
        MOV      EDX, offset[WndProcForm]
        CALL     TControl.AttachProc
        MOV      EDX, offset[WndProcDoEraseBkgnd]
        MOV      EAX, EBX
        CALL     TControl.AttachProc
        POP      EDX
        MOV      EAX, EBX
        CALL     TControl.SetCaption
        INC      [EBX].TControl.fSizeGrip
        INC      [EBX].TControl.fIsForm
        XCHG     EAX, EBX
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function NewForm( AParent: PControl; const Caption: String ): PControl;
begin
  Result := _NewWindowed( AParent, 'Form', True );
  Result.fClsStyle := Result.fClsStyle or CS_DBLCLKS;
  Result.AttachProc( WndProcForm );
  Result.AttachProc( WndProcDoEraseBkgnd );
  Result.Caption := Caption;
  Result.fSizeGrip := TRUE;
  Result.fIsForm := TRUE;
end;
{$ENDIF ASM_VERSION}
//[END NewForm]

{$ENDIF USE_CONSTRUCTORS}

//===================== Applet button ========================//

//{$DEFINE WNDPROCAPP_USED}
{$IFDEF WNDPROCAPP_USED}

//[FUNCTION WndProcApp]
{$IFDEF ASM_VERSION}
  {$IFDEF WNDPROCAPP_ASM_USED}
  function WndProcApp(Self_: PControl; var Msg: TMsg; var Rslt: Integer): Boolean;
  asm
          CMP      word ptr [EDX].TMsg.message, WM_SETFOCUS
          JNZ      @@chk_CLOSE
          MOV      ECX, [EAX].TControl.FCurrentControl
          JECXZ    @@ret_false
          XCHG     EAX, ECX
          PUSH     EAX
          CALL     CallTControlCreateWindow
          POP      EAX
          PUSH     [EAX].TControl.fHandle
          CALL     SetFocus
          MOV      AL, 1
          RET
  @@chk_CLOSE:
          CMP      word ptr [EDX].TMsg.message, WM_SYSCOMMAND
          JNZ      @@ret_false
          MOV      EDX, dword ptr [EDX].TMsg.wParam
          AND      DX, $FFF0
          CMP      DX, SC_CLOSE
          JNZ      @@ret_false
          PUSH     ECX
          MOV      ECX, [EAX].TControl.fChildren
          JECXZ    @@ret_false1
          XCHG     EAX, ECX
          MOV      ECX, [EAX].TList.fCount
          JECXZ    @@ret_false1
          MOV      EAX, [EAX].TList.fItems
          MOV      ECX, dword ptr [EAX]
          JECXZ    @@ret_false1
          XCHG     EAX, ECX
          PUSH     EAX
          CALL     TControl.IsMainWindow
          TEST     EAX, EAX
          POP      EAX
          JZ       @@ret_false1
          CALL     TControl.Close
          POP      ECX
          XOR      EAX, EAX
          MOV      dword ptr [ECX], EAX
          INC      EAX
          JMP      @@exit
  @@ret_false1:
          POP      ECX
  @@ret_false:
          XOR      EAX, EAX
  @@exit:
  end;
  {$ENDIF}
{$ELSE ASM_VERSION} //Pascal
function WndProcApp(Self_: PControl; var Msg: TMsg; var Rslt: Integer): Boolean;
begin
  Result := False;
  case Msg.message of
  WM_SETFOCUS:
    {$IFDEF NEW_MODAL}
    if fModalForm <> nil then
      SetFocus( fModalForm.fHandle )
    else
    if (Self_.FCurrentControl <> nil) and not(fCurrentControl.IsForm xor fIsApplet) then
    {$ELSE not_NEW_MODAL}
    if Self_.FCurrentControl <> nil then
    {$ENDIF not_NEW_MODAL}
    begin
      Self_.FCurrentControl.CreateWindow; //virtual!!!
      SetFocus( Self_.FCurrentControl.fHandle );
      Result := True;
    end;
  WM_SYSCOMMAND:
    if Msg.wParam and $FFF0 = SC_CLOSE then
    if (Self_.fChildren <> nil) and (Self_.fChildren.fCount > 0) and
       PControl( Self_.fChildren.fItems[ 0 ] ).IsMainWindow then
    begin
      PControl( Self_.fChildren.fItems[ 0 ] ).Close;
      Rslt := 0;
      Result := TRUE;
    end;
  end;
end;
{$ENDIF ASM_VERSION}
//[END WndProcApp]

{$ENDIF WNDPROCAPP_USED}

{$IFDEF USE_CONSTRUCTORS}
{$DEFINE CREATEAPPBUTTON_USED}
//[function NewApplet]
function NewApplet( const Caption: String ): PControl;
begin
  new( Result, CreateApplet( Caption ) );
end;
//[END NewApplet]
{$ELSE not_USE_CONSTRUCTORS}

//[FUNCTION NewApplet]
{$IFDEF ASM_VERSION}
function NewApplet( const Caption: String ): PControl;
const AppClass: array[ 0..3 ] of Char = ( 'A', 'p', 'p', #0 );
asm
        XOR      ECX, ECX
        INC      ECX
        MOV      [AppButtonUsed], CL
        PUSH     EAX
        MOV      EDX, offset[AppClass]
        XOR      EAX, EAX
        CALL     _NewWindowed
        INC      [EAX].TControl.FIsApplet
        MOV      word ptr [EAX].TControl.fStyle + 2, $90CA //WS_VISIBLE or WS_SYSMENU or WS_POPUP or WS_MINIMIZEBOX or WS_CAPTION
        MOV      byte ptr [EAX].TControl.fExStyle + 2, WS_EX_APPWINDOW shr 16 // WS_EX_APPWINDOW = $40000
        CALL     @@newapp1

        // BODY of CreateAppButton here:
        PUSH     ESI
        PUSH     0
        PUSH     [EAX].TControl.fHandle
        CALL     GetSystemMenu
        MOV      ESI, offset[DeleteMenu]

        XCHG     ECX, EAX
        MOV      EAX, SC_MAXIMIZE
        CDQ

        PUSH     EDX
        PUSH     EAX
        PUSH     ECX

        PUSH     EDX
        {$IFDEF PARANOIA}
        DB $2C, $20
        {$ELSE}
        SUB      AL, $20  // SC_MOVE
        {$ENDIF}
        PUSH     EAX
        PUSH     ECX

        PUSH     EDX
        {$IFDEF PARANOIA}
        DB $2C, $10
        {$ELSE}
        SUB      AL, $10  // SC_SIZE
        {$ENDIF}
        PUSH     EAX
        PUSH     ECX

        PUSH     1    // MF_GRAYED or MF_BYCOMMAND
        MOV      AX, SC_RESTORE
        PUSH     EAX
        PUSH     ECX

        CALL     EnableMenuItem
        CALL     ESI
        CALL     ESI
        CALL     ESI
        POP      ESI
@@ret_false:
        XOR      EAX, EAX
        RET

@@chk_CLOSE:
          CMP      word ptr [EDX].TMsg.message, WM_SYSCOMMAND
          JNZ      @@ret_false
          MOV      EDX, dword ptr [EDX].TMsg.wParam
          AND      DX, $FFF0
          CMP      DX, SC_CLOSE
          JNZ      @@ret_false
          PUSH     ECX
          MOV      ECX, [EAX].TControl.fChildren
          JECXZ    @@ret_false1
          XCHG     EAX, ECX
          MOV      ECX, [EAX].TList.fCount
          JECXZ    @@ret_false1
          MOV      EAX, [EAX].TList.fItems
          MOV      ECX, dword ptr [EAX]
          JECXZ    @@ret_false1
          XCHG     EAX, ECX
          PUSH     EAX
          CALL     TControl.IsMainWindow
          TEST     EAX, EAX
          POP      EAX
          JZ       @@ret_false1
          CALL     TControl.Close
          POP      ECX
          XOR      EAX, EAX
          MOV      dword ptr [ECX], EAX
          INC      EAX
          RET
  @@ret_false1:
          POP      ECX
          JMP      @@ret_false

@@newapp1:
        //MOV      [EAX].TControl.FCreateWndExt, offset[CreateAppButton]
        POP      [EAX].TControl.FCreateWndExt
        PUSH     EAX
        CALL     @@newapp2

        // BODY of WndProcApp here:
        CMP      word ptr [EDX].TMsg.message, WM_SETFOCUS
        JNZ      @@chk_CLOSE
        MOV      ECX, [EAX].TControl.FCurrentControl
        JECXZ    @@ret_false
        XCHG     EAX, ECX

        PUSH     EAX
        CALL     CallTControlCreateWindow
        POP      EAX
        PUSH     [EAX].TControl.fHandle

        CALL     SetFocus
        MOV      AL, 1
        RET

@@newapp2:
        POP      EDX
        CALL     TControl.AttachProc
        POP      EAX
        POP      EDX
        PUSH     EAX
        CALL     TControl.SetCaption
        POP      EAX
end;

{$ELSE ASM_VERSION} //Pascal

//[procedure CreateAppButton]
procedure CreateAppButton( App: PControl );
var M: HMenu;
begin
  M := GetSystemMenu( App.fHandle, False );
  DeleteMenu( M, SC_MAXIMIZE, MF_BYCOMMAND );
  DeleteMenu( M, SC_MOVE, MF_BYCOMMAND );
  DeleteMenu( M, SC_SIZE, MF_BYCOMMAND );
  EnableMenuItem( M, SC_RESTORE, MF_GRAYED or MF_BYCOMMAND );
end;

//[function NewApplet]
function NewApplet( const Caption: String ): PControl;
begin
  AppButtonUsed := True;
  Result := _NewWindowed( nil, 'App', True );
  Result.FIsApplet := TRUE;
  Result.fStyle := WS_VISIBLE or WS_SYSMENU or WS_POPUP or WS_MINIMIZEBOX or WS_CAPTION;
  Result.fExStyle := WS_EX_APPWINDOW;
  Result.FCreateWndExt := CreateAppButton;
  Result.AttachProc( WndProcApp );
  Result.Caption := Caption;
end;
{$ENDIF ASM_VERSION}
//[END NewApplet]
{$ENDIF USE_CONSTRUCTORS}

{$IFDEF CREATEAPPBUTTON_USED}
procedure CreateAppButton( App: PControl );
asm
  {$IFDEF F_P}
        MOV      EAX, [App]
  {$ENDIF F_P}
        PUSH     ESI
        PUSH     0
        PUSH     [EAX].TControl.fHandle
        CALL     GetSystemMenu
        MOV      ESI, offset[DeleteMenu]

        XCHG     ECX, EAX
        MOV      EAX, SC_MAXIMIZE
        CDQ

        PUSH     EDX
        PUSH     EAX
        PUSH     ECX

        PUSH     EDX
        {$IFDEF PARANOIA}
        DB $2C, $20
        {$ELSE}
        SUB      AL, $20  // SC_MOVE
        {$ENDIF}
        PUSH     EAX
        PUSH     ECX

        PUSH     EDX
        {$IFDEF PARANOIA}
        DB $2C, $10
        {$ELSE}
        SUB      AL, $10  // SC_SIZE
        {$ENDIF}
        PUSH     EAX
        PUSH     ECX

        PUSH     1    // MF_GRAYED or MF_BYCOMMAND
        MOV      AX, SC_RESTORE
        PUSH     EAX
        PUSH     ECX

        CALL     EnableMenuItem
        CALL     ESI
        CALL     ESI
        CALL     ESI
        POP      ESI
end {$IFDEF F_P} [ 'EAX', 'EDX', 'ECX' ] {$ENDIF};
{$ENDIF CREATEAPPBUTTON_USED}

var CtlIdCount: WORD = $8000;



{$IFDEF CREATEPARAMS2_USED} // seems not needed more
//[procedure CreateParams2]
procedure CreateParams2( Self_: PControl; var Params: TCreateParams);
begin
  Self_.CreateSubclass( Params, Self_.fControlClassName );
end;
{$ENDIF}

//[FUNCTION _NewControl]
{$IFDEF ASM_VERSION}
function _NewControl( AParent: PControl; ControlClassName: PChar;
                      Style: DWORD; Ctl3D: Boolean; Actions: PCommandActions ): PControl;
const szActions = sizeof(TCommandActions);
asm
        PUSH     EBX
        PUSH     EAX  // push AParent
        PUSH     ECX  // push Style
        MOVZX    ECX, Ctl3D
        CALL     _NewWindowed
        XCHG     EBX, EAX
        INC      [EBX].TControl.fIsControl
        INC      [EBX].TControl.fVerticalAlign
        MOV      EAX, Actions
        TEST     EAX, EAX
        JZ       @@noActions
        LEA      EDX, [EBX].TControl.fCommandActions
        XOR      ECX, ECX
        MOV      CL, szActions
        CALL     System.Move
@@noActions:
        POP      EDX  // pop Style
        OR       EDX, WS_CLIPSIBLINGS or WS_CLIPCHILDREN
        MOV      byte ptr [EBX].TControl.fLookTabKeys, $0F
        CMP      [EBX].TControl.fCtl3D, 0
        JZ       @@noCtl3D
        AND      EDX, not WS_BORDER
        OR       byte ptr [EBX].TControl.fExStyle + 1, WS_EX_CLIENTEDGE shr 8
@@noCtl3D:
        MOV      [EBX].TControl.fStyle, EDX
        TEST     EDX, WS_VISIBLE
        SETNZ    AL
        MOV      [EBX].TControl.fVisible, AL
        TEST     EDX, WS_TABSTOP
        POP      ECX // pop AParent
        PUSHFD
        JECXZ    @@noParent
        MOV      EAX, [ECX].TControl.fCursor
        MOV      [EBX].TControl.fCursor, EAX
        XCHG     EAX, ECX
        CALL     TControl.ParentForm
        XCHG     ECX, EAX
        JECXZ    @@noParent
        INC      [ECX].TControl.fTabOrder
        MOV      EDX, [ECX].TControl.fTabOrder
        MOV      [EBX].TControl.fTabOrder, EDX
@@noParent:
        POPFD
        JZ       @@noTabStop
        INC      [EBX].TControl.fTabstop
        JECXZ    @@noTabstop
        XCHG     EAX, ECX
        MOV      ECX, [EAX].TControl.FCurrentControl
        INC      ECX
        LOOP     @@noTabStop
        MOV      [EAX].TControl.FCurrentControl, EBX
@@noTabStop:
        MOVZX    EDX, [CtlIdCount]
        INC      [CtlIdCount]
        MOV      [EBX].TControl.fMenu, EDX
        MOV      EDX, offset[WndProcCtrl]
        MOV      EAX, EBX
        CALL     TControl.AttachProc
        XCHG     EAX, EBX
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function _NewControl( AParent: PControl; ControlClassName: PChar;
                      Style: DWORD; Ctl3D: Boolean; Actions: PCommandActions ): PControl;
var Form: PControl;
begin
  Result := _NewWindowed( AParent, ControlClassName, Ctl3D );
  if Actions <> nil then
    Result.fCommandActions := Actions^;
  Result.fIsControl := True;
  Result.fStyle := Style or WS_CLIPSIBLINGS or WS_CLIPCHILDREN;
  Result.fVerticalAlign := vaTop;
  Result.fVisible := (Style and WS_VISIBLE) <> 0;
  Result.fTabstop := (Style and WS_TABSTOP) <> 0;
  if (AParent <> nil) then
  begin
    Inc( AParent.ParentForm.fTabOrder );
    Result.fTabOrder := AParent.ParentForm.fTabOrder;
    Result.fCursor := AParent.fCursor;
  end;
  Result.fLookTabKeys := [ tkTab, tkLeftRight, tkUpDown, tkPageUpPageDn ];
  if Result.fCtl3D then
  begin
    Result.fStyle := Result.fStyle and not WS_BORDER;
    Result.fExStyle := Result.fExStyle or WS_EX_CLIENTEDGE;
  end;
  if (Style and WS_TABSTOP) <> 0 then
  begin
    Form := Result.ParentForm;
    if Form <> nil then
    if Form.FCurrentControl = nil then
       Form.FCurrentControl := Result;
  end;
  //Result.fCreateParamsExt := CreateParams2;
  Result.fMenu := CtlIdCount;
  Inc( CtlIdCount );
  Result.AttachProc( WndProcCtrl );
end;
{$ENDIF ASM_VERSION}
//[END _NewControl]

//===================== Button ========================//

//[function TControl.SetButtonIcon]
function TControl.SetButtonIcon(aIcon: HIcon): PControl;
var PrevImg: THandle;
begin
  Style := Style or BS_ICON;
  PrevImg := Perform( BM_SETIMAGE, IMAGE_ICON, aIcon );
  if PrevImg <> 0 then
    DeleteObject( PrevImg );
  Result := Self;
end;

//[function TControl.SetButtonBitmap]
function TControl.SetButtonBitmap(aBmp: HBitmap): PControl;
var PrevImg: THandle;
begin
  Style := Style or BS_BITMAP;
  PrevImg := Perform( BM_SETIMAGE, IMAGE_BITMAP, aBmp );
  if PrevImg <> 0 then
    DeleteObject( PrevImg );
  Result := Self;
end;

{$IFDEF ALL_BUTTONS_RESPOND_TO_ENTER}
//[function WndProcBtnReturnClick]
function WndProcBtnReturnClick( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
begin
  Result := FALSE;
  if ((Msg.message = WM_KEYDOWN) or (Msg.message = WM_KEYUP) or
      (Msg.message = WM_CHAR)) and (Msg.wParam = 13) then
    Msg.wParam := 32;
end;
{$ENDIF}

const
  ButtonActions: TCommandActions = (
    aClear: ClearText;
    aAddText: nil;
    aClick: BN_CLICKED;
    aEnter: BN_SETFOCUS;
    aLeave: BN_KILLFOCUS;
    aChange: 0; //BN_CLICKED;
    aSelChange: 0;
    aGetCount: 0;
    aSetCount: 0;
    aGetItemLength: 0;
    aGetItemText: 0;
    aSetItemText: 0;
    aGetItemData: 0;
    aSetItemData: 0;
    aAddItem: 0;
    aDeleteItem: 0;
    aInsertItem: 0;
    aFindItem: 0;
    aFindPartial: 0;
    aItem2Pos: 0;
    aPos2Item: 0;
    aGetSelCount: 0;
    aGetSelected: 0;
    aGetSelRange: 0;
    aExGetSelRange: 0;
    aGetCurrent: 0;
    aSetSelected: 0;
    aSetCurrent: 0;
    aSetSelRange: 0;
    aExSetSelRange: 0;
    aGetSelection: 0;
    aReplaceSel: 0;
    aTextAlignLeft: BS_LEFT;
    aTextAlignRight: BS_RIGHT;
    aTextAlignCenter: BS_CENTER;
    aTextAlignMask: 0;
    aVertAlignCenter: BS_VCENTER shr 8;
    aVertAlignTop: BS_TOP shr 8;
    aVertAlignBottom: BS_BOTTOM shr 8;
    aDir: 0;
    aSetLimit: 0;
    aSetImgList: 0;
    aAutoSzX: 14;
    aAutoSzY: 0;
    aSetBkColor: 0;
  );

{$IFDEF USE_CONSTRUCTORS}
//[function NewButton]
function NewButton( AParent: PControl; const Caption: String ): PControl;
begin
  new( Result, CreateButton( AParent, Caption ) );
end;
{$ELSE USE_CONSTRUCTORS}

{$IFDEF ASM_VERSION}
const ButtonClass: array[ 0..6 ] of Char = ( 'B','U','T','T','O','N',#0 );
{$ENDIF ASM_VERSION}

//[FUNCTION NewButton]
{$IFDEF ASM_VERSION}
function NewButton( AParent: PControl; const Caption: String ): PControl;
const szActions = sizeof(TCommandActions);
asm
        PUSH     EDX

        PUSH     0
        PUSH     offset[ButtonActions]

        MOV      EDX, offset[ButtonClass]
        MOV      ECX, WS_VISIBLE or WS_CHILD or BS_PUSHLIKE or WS_TABSTOP
        CALL     _NewControl
        INC      [EAX].TControl.fIgnoreDefault
        MOV      EDX, [EAX].TControl.fBoundsRect.Top
        ADD      EDX, 22
        MOV      [EAX].TControl.fBoundsRect.Bottom, EDX
        MOV      [EAX].TControl.fTextAlign, taCenter
        INC      [EAX].TControl.fIsButton

        POP      EDX
        PUSH     EAX
        CALL     TControl.SetCaption
        POP      EAX
        {$IFDEF ALL_BUTTONS_RESPOND_TO_ENTER}
        PUSH     EAX
        MOV      EDX, offset[WndProcBtnReturnClick]
        CALL     TControl.AttachProc
        POP      EAX
        {$ENDIF}
end;
{$ELSE ASM_VERSION} //Pascal
function NewButton( AParent: PControl; const Caption: String ): PControl;
begin
  Result := _NewControl( AParent, 'BUTTON',
            WS_VISIBLE or WS_CHILD or
            BS_PUSHLIKE or WS_TABSTOP, False, @ButtonActions );
  Result.fIgnoreDefault := TRUE;
  Result.fCtl3D := TRUE;
  with Result.fBoundsRect do
    Bottom := Top + 22;
  Result.fTextAlign := taCenter;
  Result.Caption := Caption;
  Result.fIsButton := TRUE;
  {$IFDEF ALL_BUTTONS_RESPOND_TO_ENTER}
  Result.AttachProc( WndProcBtnReturnClick );
  {$ENDIF}
end;
{$ENDIF ASM_VERSION}
//[END NewButton]

{$ENDIF USE_CONSTRUCTORS}

//----------------- BitBtn -----------------------

//[FUNCTION WndProc_DrawItem]
{$IFDEF ASM_VERSION}
function WndProc_DrawItem( Sender: PControl; var Msg: TMsg; var Rslt: Integer )
                          : Boolean;
asm     //cmd    //opd
       CMP       word ptr [EDX].TMsg.message, WM_DRAWITEM
       JNZ       @@ret_false
       MOV       EAX, [EDX].TMsg.lParam
       MOV       ECX, [EAX].TDrawItemStruct.hwndItem
       JECXZ     @@ret_false
       PUSH      EDX
       PUSH      offset[ID_SELF]
       PUSH      ECX
       CALL      GetProp
       POP       EDX
       TEST      EAX, EAX
       JZ        @@ret_false
       PUSH      [EDX].TMsg.lParam
       PUSH      [EDX].TMsg.wParam
       PUSH      CN_DRAWITEM
       PUSH      EAX
       CALL      TControl.Perform
       MOV       AL, 1
       RET
@@ret_false:
       XOR       EAX, EAX
end;
{$ELSE ASM_VERSION} //Pascal
function WndProc_DrawItem( Sender: PControl; var Msg: TMsg; var Rslt: Integer )
                          : Boolean;
var DI: PDrawItemStruct;
    Control: PControl;
begin
  Result := FALSE;
  if Msg.message = WM_DRAWITEM then
  begin
    DI := Pointer( Msg.lParam );
    Control := Pointer( GetProp( DI.hwndItem, ID_SELF ) );
    if Control <> nil then
    begin
      {Rslt := Integer(
      Control.OnDrawItem( Control, DI.hDC, DI.rcItem, DI.itemID,
                         TDrawAction( Byte( DI.itemAction ) ),
                         TDrawState( Word( DI.itemState ) ) ) );}
      Rslt := Control.Perform( CN_DRAWITEM, Msg.wParam, Msg.lParam );
      Result := TRUE;
    end;
      //else Rslt := 0;
  end;
end;
{$ENDIF ASM_VERSION}
//[END WndProc_DrawItem]

//[function ExcludeAmpersands]
function ExcludeAmpersands( Self_: PControl; const S: String ): String;
var I: Integer;
begin
  Result := S;
  if not Self_.FBitBtnDrawMnemonic then Exit;
  for I := Length( Result ) downto 1 do
  begin
    if Result[ I ] = '&' then
      Delete( Result, I, 1 );
  end;
end;

//[procedure BitBtnExtDraw]
procedure BitBtnExtDraw( Self_: PControl; DC: HDC; X, Y: Integer; const R: TRect;
          const CapText, CapTxtOrig: String; Color: TColor );
var I, J, W, H: Integer;
    Sz: TSize;
    Pen, OldPen: HPen;
begin
  if not Self_.FBitBtnDrawMnemonic then Exit;
  J := 0;
  for I := 1 to Length( CapTxtOrig ) do
  begin
    if CapTxtOrig[ I ] <> '&' then
      Inc( J )
    else
    begin
      Windows.GetTextExtentPoint32( DC, PChar( CapText ), J, Sz );
      W := Sz.cx;
      Windows.GetTextExtentPoint32( DC, '_', 1, Sz );
      H := Sz.cy - 1;
      Windows.GetTextExtentPoint32( DC, @ CapTxtOrig[ I + 1 ], 1, Sz );
      Windows.MoveToEx( DC, X + W, Y + H, nil );

      Pen := CreatePen( PS_SOLID, 0, Color2RGB( Color ) );
      OldPen := SelectObject( DC, Pen );

      Windows.LineTo( DC, X + W + Sz.cx, Y + H );

      SelectObject( DC, OldPen );
      DeleteObject( Pen );
    end;
  end;
end;

//[procedure TControl.SetBitBtnDrawMnemonic]
procedure TControl.SetBitBtnDrawMnemonic(const Value: Boolean);
begin
  FBitBtnDrawMnemonic := Value;
  FBitBtnGetCaption := ExcludeAmpersands;
  FBitBtnExtDraw := BitBtnExtDraw;
  Invalidate;
end;

//[function TControl.GetBitBtnImgIdx]
function TControl.GetBitBtnImgIdx: Integer;
begin
  Result := LoWord( fGlyphCount );
end;

//[procedure TControl.SetBitBtnImgIdx]
procedure TControl.SetBitBtnImgIdx(const Value: Integer);
begin
  if not( bboImageList in fBitBtnOptions ) then Exit;
  fGlyphCount := HiWord( fGlyphCount ) or (Value and $FFFF);
  Invalidate;
end;

//[function TControl.GetBitBtnImageList]
function TControl.GetBitBtnImageList: THandle;
begin
  Result := 0;
  if bboImageList in fBitBtnOptions then
    Result := fGlyphBitmap;
end;

//[procedure TControl.SetBitBtnImageList]
procedure TControl.SetBitBtnImageList(const Value: THandle);
begin
  fGlyphBitmap := Value;
  if Value <> 0 then
  begin
    fBitBtnOptions := fBitBtnOptions + [ bboImageList ];
    ImageList_GetIconSize( Value, fGlyphWidth, fGlyphHeight );
  end
  else
    fBitBtnOptions := fBitBtnOptions - [ bboImageList ];
  Invalidate;
end;

//[FUNCTION WndProcBitBtn]
{$IFDEF ASM_noVERSION} // remove &-s from view //+ TextShift & if Y < 0 then Y := 0; // + glyph + TextShift if not glyphOver
function WndProcBitBtn( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
const szBitmapInfo = sizeof(TBitmapInfo);
asm
        CMP      word ptr [EDX].TMsg.message, WM_LBUTTONDBLCLK
        JNZ      @@noWM_LBUTTONDBLCLK
        PUSH     ECX
        PUSH     [EDX].TMsg.wParam
        PUSH     [EDX].TMsg.lParam
        PUSH     WM_LBUTTONDOWN
        PUSH     EAX
        CALL     TControl.Perform
        POP      ECX
        MOV      [ECX], EAX
        MOV      AL, 1
        RET
@@noWM_LBUTTONDBLCLK:
        PUSH     EBX
        CMP      [EDX].TMsg.message, CN_DRAWITEM
        JNZ      @@noCN_DRAWITEM
        PUSH     EDI
        PUSH     ESI
        XCHG     EDI, EAX // EDI = Self
        MOV      dword ptr [ECX], 1
        MOV      ESI, [EDX].TMsg.lParam // ESI = DIS
        XOR      EBX, EBX // G = 0
        MOV      EAX, [ESI].TDrawItemStruct.itemState
        TEST     byte ptr [EDI].TControl.fBitBtnOptions, 8 //1 shl Ord(bboFixed)
        JNZ      @@fixed_in_options
        {$IFDEF PARANOIA}
        DB $A8, ODS_SELECTED
        {$ELSE}
        TEST     AL, ODS_SELECTED
        {$ENDIF}
        JZ       @@not1
        JMP      @@1
@@fixed_in_options:
        TEST     byte ptr [EDI].TControl.fChecked, 1
        JZ       @@not1
@@1:    INC      EBX
@@not1:
        {$IFDEF PARANOIA}
        DB $A8, ODS_DISABLED
        {$ELSE}
        TEST     AL, ODS_DISABLED
        {$ENDIF}
        JZ       @@not2
        MOV      BL, 2
@@not2: TEST     EBX, EBX
        JNZ      @@not3
        {$IFDEF PARANOIA}
        DB $A8, ODS_FOCUS
        {$ELSE}
        TEST     AL, ODS_FOCUS
        {$ENDIF}
        JZ       @@not3
        MOV      BL, 3
@@not3: CMP      [EDI].TControl.fMouseInControl, BH
        JZ       @@not4
        TEST     EBX, EBX
        JZ       @@4
        CMP      BL, 3
        JNZ      @@not4
@@4:    MOV      BL, 4
@@not4: MOV      ECX, [EDI].TControl.fOnBitBtnDraw.TMethod.Code
        TEST     ECX, ECX
        JZ       @@noOnBitBtnDraw
        //JECXZ    @@noOnBitBtnDraw
        MOV      EAX, [EDI].TControl.fCanvas
          PUSH     EAX
        TEST     EAX, EAX
        JZ       @@noCanvas
        MOV      EDX, [ESI].TDrawItemStruct.hDC
        CALL     TCanvas.SetHandle
@@noCanvas:
        MOV      EAX, [EDI].TControl.fOnBitBtnDraw.TMethod.Data
        MOV      EDX, EDI
        PUSH     EBX
        XCHG     ECX, EBX
        CALL     EBX
        POP      EBX
          POP      ECX // Canvas
        PUSH     EAX
        JECXZ    @@noCanvas2
        XCHG     EAX, ECX
        XOR      EDX, EDX
        CALL     TCanvas.SetHandle
@@noCanvas2:
        POP      EAX
        TEST     AL, AL
        JNZ      @@exit_draw
@@noOnBitBtnDraw:
        TEST     byte ptr [EDI].TControl.fBitBtnOptions, 2 //1 shl Ord(bboNoBorder)
        JNZ      @@noborder
        TEST     byte ptr [ESI].TDrawItemStruct.itemState, ODS_FOCUS
        JZ       @@noDefaultBorder
        PUSH     BLACK_BRUSH
        CALL     GetStockObject
        LEA      EDX, [ESI].TDrawItemStruct.rcItem
        OR       ECX, -1
        PUSH     ECX
        PUSH     ECX
        PUSH     EDX
        PUSH     EAX
        PUSH     EDX
        PUSH     [ESI].TDrawItemStruct.hDC
        CALL     Windows.FrameRect
        CALL     InflateRect
        XOR      ECX, ECX
        JMP      @@noFlat
@@noDefaultBorder:
        MOVZX    ECX, [EDI].TControl.fFlat
        JECXZ    @@noFlat
        AND      CL, [EDI].TControl.fMouseInControl
        JZ       @@noborder
@@noFlat:
        TEST     byte ptr [ESI].TDrawItemStruct.itemState, ODS_SELECTED
        MOV      CL, BDR_SUNKENOUTER or BDR_SUNKENINNER
        JNZ      @@border_sunken
        MOV      CL, BDR_RAISEDOUTER or BDR_RAISEDINNER
@@border_sunken:
        LEA      EDX, [ESI].TDrawItemStruct.rcItem
        OR       EAX, -1
        PUSH     EAX
        PUSH     EAX
        PUSH     EDX
        PUSH     BF_ADJUST or BF_RECT
        PUSH     ECX
        PUSH     EDX
        PUSH     [ESI].TDrawItemStruct.hDC
        CALL     DrawEdge
        CALL     InflateRect
@@noborder:
        PUSH     [ESI].TDrawItemStruct.rcItem.Bottom
        PUSH     [ESI].TDrawItemStruct.rcItem.Right
        PUSH     [ESI].TDrawItemStruct.rcItem.Top
        PUSH     [ESI].TDrawItemStruct.rcItem.Left
        MOV      EAX, [EDI].TControl.fGlyphWidth
        MOV      EDX, [EDI].TControl.fGlyphHeight
        TEST     EAX, EAX
        JLE      @@noglyph
        TEST     EDX, EDX
        JLE      @@noglyph
        PUSH     EBP
        MOV      EBP, ESP
        // [EBP+4] = TxRect

        PUSH     EDX // ImgH -> [EBP-4]
        PUSH     EAX // ImgW -> [EBP-8]
        PUSH     EDX // OutH -> [EBP-12]
        PUSH     EAX // OutW -> [EBP-16]
        MOV      EAX, [ESI].TDrawItemStruct.rcItem.Left // X = DIS.rcItem.Left
        MOV      EDX, [ESI].TDrawItemStruct.rcItem.Top  // Y = DIS.rcItem.Top
        MOV      ECX, [ESI].TDrawItemStruct.rcItem.Bottom
        SUB      ECX, EDX
        PUSH     ECX // H -> [EBP-20]
        MOV      ECX, [ESI].TDrawItemStruct.rcItem.Right
        SUB      ECX, EAX
        PUSH     ECX // W -> [EBP-24]
        MOVZX    ECX, [EDI].TControl.fGlyphLayout
        PUSH     EBX
        INC      ECX
        LOOP     @@noGlyphLeft
        MOV      EBX, EAX      // X
        ADD      EBX, [EBP-16] // +OutW
        MOV      [EBP+4].TRect.Left, EBX // TxRect.Left = X+OutW
        JMP      @@centerY
@@noGlyphLeft:
        LOOP     @@noGlyphTop
        MOV      EBX, EDX      // Y
        ADD      EBX, [EBP-12] // +OutH
        MOV      [EBP+4].TRect.Top, EBX // TxRect.Top = Y+OutH
        LOOP     @@centerX // always JMP, ECX := -1
@@noGlyphTop:
        LOOP     @@noGlyphRight
        MOV      EAX, [ESI].TDrawItemStruct.rcItem.Right
        SUB      EAX, [EBP-16] // -OutW -> X
        MOV      [EBP+4].TRect.Right, EAX
@@centerY:
        MOV      EBX, [EBP-20] // H
        SUB      EBX, [EBP-12] // -OutH
        JLE      @@noGlyphRight
        SAR      EBX, 1
        ADD      EDX, EBX      // Y = Y + (H-OutH)/2
@@noGlyphRight:
        LOOP     @@noGlyphBottom
        MOV      EDX, [ESI].TDrawItemStruct.rcItem.Bottom
        SUB      EDX, [EBP-12] // -OutH -> Y
        MOV      [EBP+4].TRect.Bottom, EDX
        LOOP     @@centerX // always JMP, ECX := -1
@@noGlyphBottom:
        LOOP     @@noGlyphOver
@@centerX:
        MOV      EBX, [EBP-24] // W
        SUB      EBX, [EBP-16] // -OutW
        SHR      EBX, 1        // /2
        ADD      EAX, EBX      // +EAX, X = X + (W-OutW)/2
        JECXZ    @@centerY
@@noGlyphOver:
        MOV      ECX, [ESI].TDrawItemStruct.rcItem.Left
        CMP      EAX, ECX
        JGE      @@ok1
        XCHG     EAX, ECX
@@ok1:  CMP      EDX, [ESI].TDrawItemStruct.rcItem.Top
        JGE      @@ok2
        MOV      EDX, [ESI].TDrawItemStruct.rcItem.Top
@@ok2:  MOV      ECX, [ESI].TDrawItemStruct.rcItem.Right
        SUB      ECX, EAX
        CMP      [EBP-16], ECX
        JLE      @@ok3
        MOV      [EBP-16], ECX // OutW := rcItem.Right - X;
@@ok3:  MOV      ECX, [ESI].TDrawItemStruct.rcItem.Bottom
        SUB      ECX, EDX
        CMP      ECX, [EBP-12]
        JGE      @@ok4
        MOV      [EBP-12], ECX // OutH := rcItem.Bottom - Y;
@@ok4:
        POP      EBX // EBX = G
        TEST     byte ptr [EDI].TControl.fBitBtnOptions, 1 //1 shl Ord(bboImageList)
        JZ       @@draw_bitmap
        MOVZX    ECX, word ptr [EDI].TControl.fGlyphCount
        CMP      word ptr [EDI].TControl.fGlyphCount + 2, BX
        JLE      @@no_add_glyphIdx
        ADD      ECX, EBX
@@no_add_glyphIdx:
        XOR      EBX, EBX
        PUSH     ILD_TRANSPARENT // Flags = 1 (ILD_TRANSPARENT)
        PUSH     EBX // Blend = 0
        PUSH     -1  // Bk = CLR_NONE
        PUSH     EBX // 0
        PUSH     EBX // 0
        PUSH     EDX
        PUSH     EAX
        PUSH     [ESI].TDrawItemStruct.hDC
        PUSH     ECX
        PUSH     [EDI].TControl.fGlyphBitmap
        CMP      [EDI].TControl.fTransparent, BL
        JNZ      @@imgl_transp
        MOV      EAX, [EDI].TControl.fColor
        CALL     Color2RGB
        MOV      [ESP+32], EAX // Bk = Color2RGB(fColor)
        MOV      [ESP+40], EBX // Flags = 0
@@imgl_transp:
        INC      EBX
        CMP      word ptr [EDI].TControl.fGlyphCount + 2, BX
        JNZ      @@draw_imagelist
        DEC      byte ptr [ESP+36+3] // $FF, CLR_DEFAULT = $FF000000
        TEST     byte ptr [ESI].TDrawItemStruct.itemState, ODS_FOCUS
        JZ       @@draw_imagelist
        OR       byte ptr [ESP+40], ILD_BLEND25 // Flags != 2
@@draw_imagelist:
        CALL     ImageList_DrawEx
        JMP      @@glyph_drawn

@@draw_bitmap:
        PUSH     EAX // PlaceHold for DC
        PUSH     EAX // PlaceHold for OldBmp
        PUSH     SRCCOPY
        PUSH     dword ptr [EBP-4] // ImgH
        PUSH     dword ptr [EBP-8] // ImgW
        PUSH     0
        PUSH     EAX // PlaceHold for I
        PUSH     EAX // PlaceHold for DC
        PUSH     dword ptr [EBP-12] // OutH
        PUSH     dword ptr [EBP-16] // OutW
        PUSH     EDX // Y
        PUSH     EAX // X
        PUSH     [ESI].TDrawItemStruct.hDC

        PUSH     0
        CALL     CreateCompatibleDC
        MOV      [ESP+48], EAX // save DC
        MOV      [ESP+20], EAX // place DC
        PUSH     [EDI].TControl.fGlyphBitmap
        PUSH     EAX
        CALL     SelectObject
        MOV      [ESP+44], EAX // save OldBitmap
        XOR      EAX, EAX
        CMP      [EDI].TControl.fGlyphCount, EBX
        JLE      @@no_incGlyIdx
        MOV      EAX, [EBP-8] // ImgW
        IMUL     EBX
@@no_incGlyIdx:
        MOV      [ESP+24], EAX // place I
        CALL     StretchBlt
        CALL     FinishDC

@@glyph_drawn:
        MOV      ESP, EBP
        POP      EBP

@@noglyph:
        TEST     byte ptr[EDI].TControl.fBitBtnOptions, 4 //1 shl Ord(bboNoCaption)
        JNZ      @@noCaption


        POP      EAX
        PUSH     EAX
        MOV      EDX, [ESP].TRect.Right
        CMP      EDX, EAX
        JLE      @@noCaption
        MOV      EDX, [ESP].TRect.Bottom
        CMP      EDX, [ESP].TRect.Top
        JLE      @@noCaption

        XOR      EBX, EBX
        PUSH     EBX                      // > CapText
        MOV      EDX, ESP
        MOV      EAX, EDI
        CALL     TControl.GetCaption
        PUSH     EBX                      // > Bk
        PUSH     EBX                      // > Blend
        CMP      [EDI].TControl.fTransparent, BL
        MOV      BL, ETO_CLIPPED
        JNZ      @@drwTxTransparent
        CMP      [EDI].TControl.fGlyphLayout, glyphOver
        JNZ      @@drwTxOpaque
@@drwTxTransparent:
        PUSH     TRANSPARENT
        PUSH     [ESI].TDrawItemStruct.hDC
        CALL     SetBkMode
        MOV      [ESP+4], EAX // Bk := SetBkMode( DIS.hDC, TRANSPARENT )
        JMP      @@drwTx1
@@drwTxOpaque:
        MOV      BL, ETO_CLIPPED or ETO_OPAQUE
        MOV      EAX, [EDI].TControl.fColor
        CALL     Color2RGB
        PUSH     EAX
        PUSH     [ESI].TDrawItemStruct.hDC
        CALL     SetBkColor
        POP      ECX
        PUSH     EAX // Blend := SetBkColor(DIS.hDC,fColor)
@@drwTx1:
        PUSH     0   // > OldFont
        PUSH     0   // > OldTextColor

        PUSH     0                 // push <nil>
        MOV      EDX, [ESP+20] // CapText
        CALL     EDX2PChar
        PUSH     dword ptr [EDX-4] // push Length(CapText)
        PUSH     EDX               // push PChar(CapText)
        LEA      EAX, [ESP+32]
        PUSH     EAX               // push @TxRect
        PUSH     EBX               // push Flags

        MOV      EBX, [ESI].TDrawItemStruct.hDC

        MOV      ECX, [EDI].TControl.fFont
        JECXZ    @@drwTx_noFont
        XCHG     EAX, ECX
        CALL     TGraphicTool.GetHandle
        PUSH     EAX
        PUSH     EBX
        CALL     SelectObject
        MOV      [ESP+24], EAX // OldFont := SelectObject...
@@drwTx_noFont:
        MOV      EAX, [EDI].TControl.fTextColor
        CALL     Color2RGB
        PUSH     EAX
        PUSH     EBX
        CALL     SetTextColor
        MOV      [ESP+20], EAX // OldTextColor := SetTextColor...

        PUSH     EAX
        PUSH     EAX
        PUSH     ESP
        MOV      ECX, [ESP+48] // ECX = CapText
        XOR      EAX, EAX
        JECXZ    @@drwTx0
        MOV      EAX, [ECX-4]  // EAX = Length(CapText)
@@drwTx0:
        PUSH     EAX
        PUSH     ECX
        PUSH     EBX
        CALL     GetTextExtentPoint32
        POP      ECX // ECX = TextSz.cx
        POP      EDX // EDX = TextSz.cy
        MOV      EAX, [ESP+40].TRect.Bottom
        SUB      EAX, [ESP+40].TRect.Top
        SUB      EAX, EDX
        JGE      @@yOk
        XOR      EAX, EAX
@@yOk:  SHR      EAX, 1
        ADD      EAX, [ESP+40].TRect.Top
        PUSH     EAX                      // push Y
        MOV      EDX, [ESP+44].TRect.Right
        MOV      EAX, [ESP+44].TRect.Left // EAX = TxRect.Left
        SUB      EDX, EAX // EDX = W
        PUSH     EAX
        CMP      [EDI].TControl.fTextAlign, taRight
        JL       @@chk_X
        JE       @@alignR
        SUB      ECX, EDX
        SAR      ECX, 1
        JMP      @@alignC
@@alignR:
        ADD      EAX, EDX
@@alignC:
        SUB      EAX, ECX
@@chk_X:POP      EDX
        CMP      EAX, EDX
        JGE      @@xOk
        XCHG     EAX, EDX
@@xOk:  PUSH     EAX                      // push X
        PUSH     EBX                      // push hDC
        CALL     ExtTextOut

        PUSH     EBX
        CALL     SetTextColor
        POP      ECX
        JECXZ    @@noRestoreFont
        PUSH     ECX
        PUSH     EBX
        CALL     SelectObject
@@noRestoreFont:
        POP      ECX // Blend
        JECXZ    @@restoreBk
        PUSH     ECX
        PUSH     EBX
        CALL     SetBkColor
        POP      ECX
        JMP      @@delCaption
@@restoreBk:
        PUSH     EBX
        CALL     SetBkMode
@@delCaption:
        CALL     RemoveStr

@@noCaption:
        ADD      ESP, 16

@@exit_draw:
        POP      ESI
        POP      EDI
        POP      EBX
        MOV      AL, 1
        RET

@@noCN_DRAWITEM:
        CMP      word ptr [EDX].TMsg.message, WM_LBUTTONDOWN
        JZ       @@doDown
        CMP      word ptr [EDX].TMsg.message, WM_KEYDOWN
        JNZ      @@noWM_LBUTTONDOWN
        CMP      [EDX].TMsg.wParam, 32
        JNZ      @@noWM_LBUTTONDOWN
@@doDown:
        PUSH     EDX
        XCHG     EBX, EAX

        CALL     @@fixed_proc
        MOV      ECX, [EBX].TControl.fRepeatInterval
        JECXZ    @@exit_LBUTTONDOWN
        //MOV      EAX, EBX
        //CALL     TControl.DoClick
        POP      EDX
        PUSH     EDX
        CMP      word ptr [EDX].TMsg.message, WM_KEYDOWN
        JZ       @@not_SetTimer
        PUSH     0
        PUSH     [EBX].TControl.fRepeatInterval
        PUSH     1
        PUSH     [EBX].TControl.fHandle
        CALL     SetTimer
@@exit_LBUTTONDOWN:
@@not_SetTimer:
        POP      EDX
        JMP      @@invalidate

@@noWM_LBUTTONDOWN:
        CMP      word ptr [EDX].TMsg.message, WM_TIMER
        JNZ      @@noWM_TIMER

        XCHG      EBX, EAX
        PUSH     0
        PUSH     0
        PUSH     BM_GETSTATE
        PUSH     EBX
        CALL     TControl.Perform
        {$IFDEF PARANOIA}
        DB $A8, 4
        {$ELSE}
        TEST AL, BST_PUSHED
        {$ENDIF}
        JNZ      @@pushed
        PUSH     1
        PUSH     [EBX].TControl.fHandle
        CALL     KillTimer
        CALL     ReleaseCapture
        JMP      @@noWM_TIMER
@@fixed_proc:
        TEST     byte ptr [EBX].TControl.fBitBtnOptions, 8 // bboFixed
        JZ       @@not_fixed
        XOR      [EBX].TControl.fChecked, 1
        MOV      ECX, [EBX].TControl.fOnChange.TMethod.Code
        JECXZ    @@not_fixed
        MOV      EAX, [EBX].TControl.fOnChange.TMethod.Data
        MOV      EDX, EBX
        JMP      ECX
@@pushed:
        CALL     @@fixed_proc
        MOV      EAX, EBX
        CALL     TControl.DoClick
@@invalidate:
        XCHG     EAX, EBX
        CALL     TControl.Invalidate
@@noWM_TIMER:
        XOR      EAX, EAX
        POP      EBX
@@not_fixed:
end;
{$ELSE ASM_VERSION} //Pascal
function WndProcBitBtn( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var DIS: PDrawItemStruct;
    IsDown, IsDefault, IsDisabled: Boolean;
    Flags: Integer;
    X, Y, W, H, ImgW, ImgH, OutW, OutH, I, G, Bk, Blend: Integer;
    //BI: TBitmapInfo;
    //Dib: TDibSection;
    TxRect: TRect;
    OldFont: HFont;
    OldTextColor: TColor;
    CapText, CapTxtOrig: String;
    TextSz: TSize;
    DC: HDC;
    OldBmp: HBitmap;
    Handled: Boolean;
    //Br: HBrush;
begin
  Result := False;
  if (Msg.message = WM_LBUTTONDBLCLK) then
  begin
    Rslt := Self_.Perform( WM_LBUTTONDOWN, Msg.wParam, Msg.lParam );
    Result := True;
    Exit;
  end;
  if (Msg.message = CN_DRAWITEM) then
  begin
    Result := True;
    Rslt := 1;
    DIS := Pointer( Msg.lParam );
    IsDown := DIS.itemState and ODS_SELECTED <> 0;
    IsDefault := DIS.itemState and ODS_FOCUS <> 0;
    IsDisabled := DIS.itemState and ODS_DISABLED <> 0;
    G := 0;
    if IsDown and not(bboFixed in Self_.fBitBtnOptions)
    or (bboFixed in Self_.fBitBtnOptions) and Self_.fChecked then
      G := 1;
    if IsDisabled then
      G := 2;
    if (G = 0) and IsDefault then
      G := 3;
    if ((G = 0) or (G = 3)) and Self_.MouseInControl then
      G := 4;
    if Assigned( Self_.fOnBitBtnDraw ) then
    begin
      if Assigned( Self_.fCanvas ) then
        Self_.fCanvas.SetHandle( DIS.hDC );
      Handled := Self_.fOnBitBtnDraw( Self_, G );
      if Assigned( Self_.fCanvas ) then
        Self_.fCanvas.SetHandle( 0 );
      if Handled then Exit;
    end;
    if not ( bboNoBorder in Self_.fBitBtnOptions ) then
    begin
      if IsDefault then
      begin
        Windows.FrameRect( DIS.hDC, DIS.rcItem, GetStockObject( BLACK_BRUSH ) );
        InflateRect( DIS.rcItem, -1, -1 );
      end;
      if not Self_.fFlat or Self_.fMouseInControl or IsDefault then
      begin
        if IsDown then
          Flags := BDR_SUNKENOUTER or BDR_SUNKENINNER
        else
          Flags := BDR_RAISEDOUTER or BDR_RAISEDINNER;
        DrawEdge( DIS.hDC, DIS.rcItem, Flags, BF_ADJUST or BF_RECT );
        InflateRect( DIS.rcItem, -1, -1 );
      end;
    end;
    TxRect := DIS.rcItem;
    if Self_.fGlyphBitmap <> 0 then
    begin
      ImgW := Self_.fGlyphWidth;
      ImgH := Self_.fGlyphHeight;
      if (ImgW > 0) and (ImgH > 0) then
      begin
        OutW := ImgW;
        OutH := ImgH;
        W := DIS.rcItem.Right - DIS.rcItem.Left;
        H := DIS.rcItem.Bottom - DIS.rcItem.Top;
        X := DIS.rcItem.Left;
        Y := DIS.rcItem.Top;
        if isDown and (Self_.fGlyphLayout <> glyphOver) then
        begin
          Inc( X, Self_.TextShiftX );
          Inc( Y, Self_.TextShiftY );
        end;
        case Self_.fGlyphLayout of
          glyphLeft:
            begin
              Y := Y + (H - OutH) div 2;
              TxRect.Left := X + OutW;
            end;
          glyphTop:
            begin
              X := X + (W - OutW) div 2;
              TxRect.Top := Y + OutH;
            end;
          glyphRight:
            begin
              X := DIS.rcItem.Right - OutW;
              TxRect.Right := X;
              Y := Y + (H - OutH) div 2;
            end;
          glyphBottom:
            begin
              Y := DIS.rcItem.Bottom - OutH;
              TxRect.Bottom := Y;
              X := X + (W - OutW) div 2;
            end;
          glyphOver:
            begin
              X := X + (W - OutW) div 2;
              Y := Y + (H - OutH) div 2;
            end;
        end;
        if X < DIS.rcItem.Left then
          X := DIS.rcItem.Left;
        if Y < DIS.rcItem.Top then
          Y := DIS.rcItem.Top;
        if X + OutW > DIS.rcItem.Right then
          OutW := DIS.rcItem.Right - X;
        if Y + OutH > DIS.rcItem.Bottom then
          OutH := DIS.rcItem.Bottom - Y;

        //Br := CreateSolidBrush( Color2RGB( Self_.fColor ) );
        //Windows.FillRect( DIS.hDC, MakeRect( X, DIS.rcItem.Top, X + OutW, DIS.rcItem.Bottom ), Br );
        //DeleteObject( Br );

        if bboImageList in Self_.fBitBtnOptions then
          begin
            I := LoWord( Self_.fGlyphCount );
            if //(HiWord( Self_.fGlyphCount ) > 1) and
               (HiWord( Self_.fGlyphCount ) > G) then
               I := I + G;
            Flags := 0; // ILD_NORMAL
            Blend := 0;
            if not Self_.fTransparent then
              Bk := Color2RGB( Self_.fColor )
            else
              begin
                Bk := Integer(CLR_NONE);
                Flags := ILD_TRANSPARENT;
              end;
            if HiWord( Self_.fGlyphCount ) = 1 then
            begin
              Blend := Integer(CLR_DEFAULT);
              if IsDefault then
                Flags := Flags or ILD_BLEND25;
            end;
            ImageList_DrawEx( Self_.fGlyphBitmap, I, DIS.hDC, X, Y, 0, 0,
              Bk, Blend, Flags );
          end
        else
          begin
            DC := CreateCompatibleDC( 0 );
            OldBmp := SelectObject( DC, Self_.fGlyphBitmap );

            I := 0;
            if Self_.fGlyphCount > G then
              I := I + G * ImgW;
            StretchBlt( DIS.hDC, X, Y, OutW, OutH, DC, I, 0, ImgW, ImgH, SRCCOPY );

            SelectObject( DC, OldBmp );
            DeleteDC( DC );
          end;
      end;
    end;
    if not (bboNoCaption in Self_.fBitBtnOptions) then
    //if (Self_.Text <> '') then
    if (TxRect.Right > TxRect.Left) and (TxRect.Bottom > TxRect.Top) then
    begin
      CapText := Self_.Caption;
      /////////////////////////////////////////////  added 19 Nov 2001
      CapTxtOrig := CapText;
      if Assigned( Self_.FBitBtnGetCaption ) then
        CapText := Self_.FBitBtnGetCaption( Self_, CapText );
      /////////////////////////////////////////////

      Bk := 0;
      Blend := 0;
      Flags := ETO_CLIPPED;
      if Self_.fTransparent or (Self_.fGlyphLayout = glyphOver) then
        Bk := SetBkMode( DIS.hDC, TRANSPARENT )
      else
      begin
        Flags := Flags or ETO_OPAQUE;
        Blend := SetBkColor( DIS.hDC, Color2RGB( Self_.fColor ) );
      end;
        // Returned previous BkMode is either OPAQUE=1 or TRANSPARENT=2

      OldFont := 0;
      if assigned( Self_.fFont ) then
        OldFont := SelectObject( DIS.hDC, Self_.fFont.Handle );
      OldTextColor := SetTextColor( DIS.hDC, Color2RGB( Self_.fTextColor ) );

      Windows.GetTextExtentPoint32( DIS.hDC, PChar( CapText ), Length( CapText ),
        TextSz );
      W := TxRect.Right - TxRect.Left;
      H := TxRect.Bottom - TxRect.Top;
      Y := TxRect.Top + (H - TextSz.cy) div 2;
      case Self_.fTextAlign of
        taLeft: X := TxRect.Left;
        taCenter: X := TxRect.Left + (W - TextSz.cx) div 2;
        else {taRight:} X := TxRect.Right - TextSz.cx;
      end;
      if isDown then
      begin
        Inc( X, Self_.TextShiftX );
        Inc( Y, Self_.TextShiftY );
      end;
      if Y < 0 then
        Y := 0;
      if X < TxRect.Left then
        X := TxRect.Left;

      Windows.ExtTextOut( DIS.hDC, X, Y, Flags, @TxRect,
        PChar( CapText ), Length( CapText ), nil );

      //////////////////////////////////////////////////////////////////////////
      //  added 19 Nov 2001 to provide underlying mnemonic characters
      if Assigned( Self_.FBitBtnExtDraw ) then
        Self_.FBitBtnExtDraw( Self_, DIS.hDC, X, Y, TxRect, CapText, CapTxtOrig,
                              OldTextColor );
      //////////////////////////////////////////////////////////////////////////

      SetTextColor( DIS.hDC, OldTextColor );
      if OldFont <> 0 then
        SelectObject( DIS.hDC, OldFont );

      if Blend = 0 then
        SetBkMode( DIS.hDC, Bk )
      else
        SetBkColor( DIS.hDC, Blend );
    end;
  end;
  if (Msg.message = WM_LBUTTONDOWN) or (Msg.message = WM_KEYDOWN) and (Msg.wParam = 32) then
  begin
    if bboFixed in Self_.fBitBtnOptions then
    begin
      Self_.fChecked := not Self_.fChecked;
      if Assigned( Self_.fOnChange ) then
        Self_.fOnChange( Self_ );
    end;
    if Self_.fRepeatInterval > 0 then
    begin
      //Self_.DoClick;
      if Msg.message <> WM_KEYDOWN then
        SetTimer( Self_.fHandle, 1, Self_.fRepeatInterval, nil );
      Self_.Invalidate;
    end;
  end;

  // added 15 Aug 2002 to repaint when focus lost:
  if Msg.message = WM_KILLFOCUS then
    Self_.Invalidate;

  if Msg.message = WM_TIMER then
  begin
    if Self_.Perform( BM_GETSTATE, 0, 0 ) and BST_PUSHED = 0 then
    begin
      KillTimer( Self_.fHandle, 1 );
      ReleaseCapture;
    end
       else
    begin
      if bboFixed in Self_.fBitBtnOptions then
      begin
        Self_.fChecked := not Self_.fChecked;
        if Assigned( Self_.fOnChange ) then
          Self_.fOnChange( Self_ );
      end;
      Self_.DoClick;
      Self_.Invalidate;
    end;
  end;
end;
{$ENDIF ASM_VERSION}
//[END WndProcBitBtn]

{$IFDEF USE_CONSTRUCTORS}
//[function NewBitBtn]
function NewBitBtn( AParent: PControl; const Caption: String;
         Options: TBitBtnOptions; Layout: TGlyphLayout; GlyphBitmap: HBitmap;
         GlyphCount: Integer ): PControl;
begin
  new( Result, CreateBitBtn( AParent, Caption, Options, Layout, GlyphBitmap, GlyphCount ) );
end;
//[END NewBitBtn]
{$ELSE not_USE_CONSTRUCTORS}

//[FUNCTION NewBitBtn]
{$IFDEF ASM_VERSION}
function NewBitBtn( AParent: PControl; const Caption: String;
         Options: TBitBtnOptions; Layout: TGlyphLayout; GlyphBitmap: HBitmap; GlyphCount: Integer ): PControl;
const szBitmapInfo = sizeof(TBitmapInfo);
asm
        PUSH     EBX
        PUSH     EDX
        PUSH     ECX

        PUSH     0
        PUSH     offset[ButtonActions]
        MOV      EDX, offset[ButtonClass]
        MOV      ECX, WS_VISIBLE or WS_CHILD or WS_TABSTOP or BS_OWNERDRAW
        CALL     _NewControl
        XCHG     EBX, EAX
        INC      [EBX].TControl.fIgnoreDefault
        INC      [EBX].TControl.fIsButton
        MOV      byte ptr [EBX].TControl.fCommandActions.aAutoSzX, 8
        MOV      byte ptr [EBX].TControl.fCommandActions.aAutoSzY, 8
        POP      EAX
        MOV      [EBX].TControl.fBitBtnOptions, AL
        MOVZX    EDX, Layout
        MOV      [EBX].TControl.fGlyphLayout, DL
        MOV      ECX, GlyphBitmap
        MOV      [EBX].TControl.fGlyphBitmap, ECX
        MOV      EDX, [EBX].TControl.fBoundsRect.Top
        ADD      EDX, 22
        MOV      [EBX].TControl.fBoundsRect.Bottom, EDX
        TEST     ECX, ECX
        JZ       @@noGlyphWH
        {$IFDEF PARANOIA}
        DB $A8, 01
        {$ELSE}
        TEST AL, bboImageList
        {$ENDIF}
        JZ       @@getBmpWH
        PUSH     EAX
        MOV      EAX, ESP
        PUSH     EAX
        MOV      EDX, ESP
        PUSH     EAX
        PUSH     EDX
        PUSH     ECX
        CALL     ImageList_GetIconSize
        POP      EAX
        POP      EDX
        MOV      ECX, GlyphCount
        JMP      @@WHready
@@getBmpWH:
        ADD      ESP, -szBitmapInfo
        PUSH     ESP
        PUSH     szBitmapInfo
        PUSH     ECX
        CALL     GetObject
        XCHG     ECX, EAX
        POP      EAX
        POP      EAX
        POP      EDX
        ADD      ESP, szBitmapInfo-12
        TEST     ECX, ECX
        JZ       @@noGlyphWH
        MOV      ECX, GlyphCount
        INC      ECX
        LOOP     @@GlyphCountOK
        PUSH     EAX
        PUSH     EDX
        XCHG     EDX, ECX
        DIV      ECX
        XCHG     ECX, EAX
        POP      EDX
        POP      EAX
@@GlyphCountOK:
        CMP      ECX, 1
        JLE      @@WHReady
        PUSH     EDX
        CDQ
        IDIV     ECX
        POP      EDX
@@WHReady:
        MOV      [EBX].TControl.fGlyphWidth, EAX
        MOV      [EBX].TControl.fGlyphHeight, EDX
        MOV      [EBX].TControl.fGlyphCount, ECX
        POP      ECX     // ECX = @ Caption[ 1 ]
        PUSH     ECX
        PUSH     EDX
        PUSH     EAX
        TEST     EAX, EAX
        JLE      @@noWidthResize
        JECXZ    @@addWLeft
        CMP      [Layout], glyphOver
        JE       @@addWLeft
        MOVZX    ECX, byte ptr[ECX]
        JECXZ    @@addWLeft
        // else
        CMP      [Layout], glyphLeft
        JZ       @@addWRight
        CMP      [Layout], glyphRight
        JNZ      @@noWidthResize
@@addWRight:
        ADD      [EBX].TControl.fBoundsRect.Right, EAX
        ADD      [EBX].TControl.fCommandActions.aAutoSzX, AX
        JMP      @@noWidthResize
@@addWLeft:
        // then
        ADD      EAX, [EBX].TControl.fBoundsRect.Left
        MOV      [EBX].TControl.fBoundsRect.Right, EAX
        MOV      byte ptr [EBX].TControl.fCommandActions.aAutoSzX, 0
@@noWidthResize:
        TEST     EDX, EDX
        JLE      @@noHeightResize
        CMP      [Layout], glyphTop
        JE       @@addHBottom
        CMP      [Layout], glyphBottom
        JNE      @@addHTop
@@addHBottom:
        ADD      [EBX].TControl.fBoundsRect.Bottom, EDX
        ADD      [EBX].TControl.fCommandActions.aAutoSzY, DX
        JMP      @@noHeightResize
@@addHTop:
        ADD      EDX, [EBX].TControl.fBoundsRect.Top
        MOV      [EBX].TControl.fBoundsRect.Bottom, EDX
        MOV      [EBX].TControl.fCommandActions.aAutoSzY, 0
@@noHeightResize:
        POP      ECX
        POP      EAX
        CDQ
        MOV      DL, 4
        TEST     [EBX].TControl.fBitBtnOptions, 2 //1 shl bboNoBorder
        JNZ      @@noBorderResize
        JECXZ    @@noBorderWinc
        ADD      [EBX].TControl.fBoundsRect.Right, EDX
        CMP      [EBX].TControl.fCommandActions.aAutoSzX, 0
        JZ       @@noBorderWinc
        ADD      [EBX].TControl.fCommandActions.aAutoSzX, DX
@@noBorderWinc:
        TEST     EAX, EAX
        JLE      @@noBorderResize
        ADD      [EBX].TControl.fBoundsRect.Bottom, EDX
        CMP      [EBX].TControl.fCommandActions.aAutoSzY, 0
        JZ       @@noBorderResize
        ADD      [EBX].TControl.fCommandActions.aAutoSzY, DX
@@noBorderResize:
@@noGlyphWH:
        MOV      ECX, [EBX].TControl.fParent
        JECXZ    @@notAttach2Parent
        XCHG     EAX, ECX
        MOV      EDX, offset[WndProc_DrawItem]
        CALL     TControl.AttachProc
@@notAttach2Parent:
        MOV      EAX, EBX
        MOV      EDX, offset[WndProcBitBtn]
        CALL     TControl.AttachProc
        MOV      EAX, EBX
        POP      EDX
        CALL     TControl.SetCaption
        MOV      [EBX].TControl.fTextAlign, taCenter
        {$IFDEF ALL_BUTTONS_RESPOND_TO_ENTER}
        MOV      EAX, EBX
        MOV      EDX, offset[WndProcBtnReturnClick]
        CALL     TControl.AttachProc
        {$ENDIF}
        XCHG     EAX, EBX
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function NewBitBtn( AParent: PControl; const Caption: String;
         Options: TBitBtnOptions; Layout: TGlyphLayout; GlyphBitmap: HBitmap;
         GlyphCount: Integer ): PControl;
var
    B: TBitmapInfo;
    W, H: Integer;
begin
  Result := _NewControl( AParent, 'BUTTON', WS_VISIBLE or WS_CHILD or
            WS_TABSTOP or BS_OWNERDRAW, False, @ButtonActions );
  Result.fIgnoreDefault := TRUE;
  Result.fIsButton := TRUE;
  Result.fCommandActions.aAutoSzX := 8;
  Result.fCommandActions.aAutoSzY := 8;
  //Result.fExStyle := Result.fExStyle and not WS_EX_CONTROLPARENT;
  Result.fBitBtnOptions := Options;
  Result.fGlyphLayout := Layout;
  Result.fGlyphBitmap := GlyphBitmap;
  with Result.fBoundsRect do
  begin
    Bottom := Top + 22;
    W := 0; H := 0;
    if GlyphBitmap <> 0 then
    begin
      if bboImageList in Options then
        ImageList_GetIconSize( GlyphBitmap, W, H )
      else
        begin
          if GetObject( GlyphBitmap, Sizeof(B), @B ) > 0 then
          begin
            W := B.bmiHeader.biWidth;
            H := B.bmiHeader.biHeight;
            if GlyphCount = 0 then
              GlyphCount := W div H;
            if GlyphCount > 1 then
              W := W div GlyphCount;
          end;
        end;
      if W > 0 then
      begin
        if (Caption = '') or (Layout = glyphOver) then
        begin
          Right := Left + W;
          Result.fCommandActions.aAutoSzX := 0;
        end
          else
        if Layout in [ glyphLeft, glyphRight ] then
        begin
          Right := Right + W;
          Inc( Result.fCommandActions.aAutoSzX, W );
        end;
      end;
      if H > 0 then
      begin
        if Layout in [ glyphTop, glyphBottom ] then
        begin
          Bottom := Bottom + H;
          Inc( Result.fCommandActions.aAutoSzY, H );
        end
          else
        begin
          Bottom := Top + H;
          Result.fCommandActions.aAutoSzY := 0;
        end;
      end;
      if not ( bboNoBorder in Options ) then
      begin
        if W > 0 then
        begin
          Inc( Right, 4 );
          if Result.fCommandActions.aAutoSzX > 0 then
            Inc( Result.fCommandActions.aAutoSzX, 4 );
        end;
        if H > 0 then
        begin
          Inc( Bottom, 4 );
          if Result.fCommandActions.aAutoSzY > 0 then
            Inc( Result.fCommandActions.aAutoSzY, 4 );
        end;
      end;
    end;
    Result.fGlyphWidth := W;
    Result.fGlyphHeight := H;
  end;
  Result.fGlyphCount := GlyphCount;
  if AParent <> nil then
    AParent.AttachProc( WndProc_DrawItem );
  Result.AttachProc( WndProcBitBtn );
  //Result.AttachProc( WndProcDoEraseBkgnd );
  Result.fTextAlign := taCenter;
  Result.Caption := Caption;
  {$IFDEF ALL_BUTTONS_RESPOND_TO_ENTER}
  Result.AttachProc( WndProcBtnReturnClick );
  {$ENDIF}
end;
{$ENDIF ASM_VERSION}
//[END NewBitBtn]

{$ENDIF USE_CONSTRUCTORS}

//===================== Check box ========================//

{$IFDEF USE_CONSTRUCTORS}
//[function NewCheckbox]
function NewCheckbox( AParent: PControl; const Caption: String ): PControl;
begin
  new( Result, CreateCheckbox( AParent, Caption ) );
end;
//[END NewCheckbox]
{$ELSE not_USE_CONSTRUCTORS}

//[FUNCTION NewCheckbox]
{$IFDEF ASM_VERSION}
function NewCheckbox( AParent: PControl; const Caption: String ): PControl;
asm
        CALL     NewButton
        MOV      EDX, [EAX].TControl.fBoundsRect.Left
        ADD      EDX, 72
        MOV      [EAX].TControl.fBoundsRect.Right, EDX
        MOV      [EAX].TControl.fStyle, WS_VISIBLE or WS_CHILD or BS_AUTOCHECKBOX or WS_TABSTOP
        MOV      [EAX].TControl.fCommandActions.aAutoSzX, 24
end;
{$ELSE ASM_VERSION} //Pascal
function NewCheckbox( AParent: PControl; const Caption: String ): PControl;
begin
  Result := NewButton( AParent, Caption );
  with Result.fBoundsRect do
  begin
    Right := Left + 72;
  end;
  Result.fStyle := WS_VISIBLE or WS_CHILD or
            BS_AUTOCHECKBOX or WS_TABSTOP;
  Result.fCommandActions.aAutoSzX := 24;
end;
{$ENDIF ASM_VERSION}
//[END NewCheckbox]

{$ENDIF USE_CONSTRUCTORS}

//[function NewCheckBox3State]
function NewCheckBox3State( AParent: PControl; const Caption: String ): PControl;
begin
  Result := NewCheckbox( AParent, Caption );
  Result.fStyle := Result.fStyle and not BS_AUTOCHECKBOX or BS_AUTO3STATE;
end;

//===================== Radiobox ========================//

//[FUNCTION ClickRadio]
{$IFDEF ASM_VERSION}
procedure ClickRadio( Sender:PObj );
asm
        MOV      ECX, [EAX].TControl.fParent
        JECXZ    @@exit
        PUSH     [EAX].TControl.fMenu
        PUSH     [ECX].TControl.fRadioLast
        PUSH     [ECX].TControl.fRadio1st
        PUSH     [ECX].TControl.fHandle
        CALL     CheckRadioButton
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure ClickRadio( Sender:PObj );
var Self_:PControl;
begin
  Self_ := PControl( Sender );
  if Self_.FParent <> nil then
    CheckRadioButton( Self_.fParent.fHandle,
                      Self_.fParent.fRadio1st,
                      Self_.fParent.fRadioLast,
                      Self_.fMenu );
end;
{$ENDIF ASM_VERSION}
//[END ClickRadio]

{$IFDEF USE_CONSTRUCTORS}
//[function NewRadiobox]
function NewRadiobox( AParent: PControl; const Caption: String ): PControl;
begin
  new( Result, CreateRadiobox( AParent, Caption ) );
end;
//[END NewRadiobox]
{$ELSE not_USE_CONSTRUCTORS}

//[FUNCTION NewRadiobox]
{$IFDEF ASM_VERSION}
function NewRadiobox( AParent: PControl; const Caption: String ): PControl;
const
  RadioboxStyles = WS_VISIBLE or WS_CHILD or BS_RADIOBUTTON or
                   WS_TABSTOP or WS_GROUP or BS_NOTIFY;
asm
        PUSH     EBX
        PUSH     EAX
        CALL     NewCheckbox
        XCHG     EBX, EAX
        MOV      [EBX].TControl.fStyle, RadioboxStyles
        MOV      [EBX].TControl.fControlClick, offset[ClickRadio]
        POP      ECX
        JECXZ    @@exit
        MOV      EDX, [EBX].TControl.fMenu
        MOV      [ECX].TControl.fRadioLast, EDX
        MOV      EAX, [ECX].TControl.fRadio1st
        TEST     EAX, EAX
        JNZ      @@exit
        MOV      [ECX].TControl.fRadio1st, EDX
        MOV      EAX, EBX
        CALL     TControl.SetRadioChecked
@@exit: XCHG     EAX, EBX
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function NewRadiobox( AParent: PControl; const Caption: String ): PControl;
begin
  Result := NewCheckbox( AParent, Caption );
  Result.fStyle := WS_VISIBLE or WS_CHILD or
            BS_RADIOBUTTON or WS_TABSTOP or WS_GROUP or BS_NOTIFY;
  Result.fControlClick := ClickRadio;
  if AParent <> nil then
  begin
    AParent.fRadioLast := Result.fMenu;
    if AParent.fRadio1st = 0 then
    begin
       AParent.fRadio1st := Result.fMenu;
       Result.SetRadioChecked;
    end;
  end;
end;
{$ENDIF ASM_VERSION}
//[END NewRadiobox]

{$ENDIF USE_CONSTRUCTORS}

//===================== Label ========================//

const
  LabelActions: TCommandActions = (
    aClear: ClearText;
    aAddText: nil;
    aClick: 0;
    aEnter: 0;
    aLeave: 0;
    aChange: 0;
    aSelChange: 0;
    aGetCount: 0;
    aSetCount: 0;
    aGetItemLength: 0;
    aGetItemText: 0;
    aSetItemText: 0;
    aGetItemData: 0;
    aSetItemData: 0;
    aAddItem: 0;
    aDeleteItem: 0;
    aInsertItem: 0;
    aFindItem: 0;
    aFindPartial: 0;
    aItem2Pos: 0;
    aPos2Item: 0;
    aGetSelCount: 0;
    aGetSelected: 0;
    aGetSelRange: 0;
    aExGetSelRange: 0;
    aGetCurrent: 0;
    aSetSelected: 0;
    aSetCurrent: 0;
    aSetSelRange: 0;
    aExSetSelRange: 0;
    aGetSelection: 0;
    aReplaceSel: 0;
    aTextAlignLeft: SS_LEFT;
    aTextAlignRight: SS_RIGHT;
    aTextAlignCenter: SS_CENTER;
    aTextAlignMask: SS_LEFTNOWORDWRAP;
    aVertAlignCenter: SS_CENTERIMAGE shr 8;
    aVertAlignTop: 0;
    aVertAlignBottom: 0;
    aDir: 0;
    aSetLimit: 0;
    aSetImgList: 0;
    aAutoSzX: 1;
    aAutoSzY: 1;
    aSetBkColor: 0;
  );

{$IFNDEF USE_CONSTRUCTORS}
{$IFDEF ASM_VERSION}
const StaticClass: array[0..6]of Char=('S','T','A','T','I','C',#0);
{$ENDIF ASM_VERSION}
{$ENDIF USE_CONSTRUCTORS}

{$IFDEF USE_CONSTRUCTORS}
//[function NewLabel]
function NewLabel( AParent: PControl; const Caption: String ): PControl;
begin
  new( Result, CreateLabel( AParent, Caption ) );
end;
//[END NewLabel]
{$ELSE not_USE_CONSTRUCTORS}

//[FUNCTION NewLabel]
{$IFDEF ASM_VERSION}
function NewLabel( AParent: PControl; const Caption: String ): PControl;
asm
        PUSH     EDX

        PUSH     0
        PUSH     offset[LabelActions]
        MOV      ECX, WS_VISIBLE or WS_CHILD or SS_LEFTNOWORDWRAP or SS_NOPREFIX or SS_NOTIFY
        MOV      EDX, offset[StaticClass]
        CALL     _NewControl
        INC      [EAX].TControl.fIsStaticControl
        INC      [EAX].TControl.fSizeRedraw
        MOV      EDX, [EAX].TControl.fBoundsRect.Top
        ADD      EDX, 22
        MOV      [EAX].TControl.fBoundsRect.Bottom, EDX
        POP      EDX
        PUSH     EAX
        CALL     TControl.SetCaption
        POP      EAX
end;
{$ELSE ASM_VERSION} //Pascal
function NewLabel( AParent: PControl; const Caption: String ): PControl;
begin
  Result := _NewControl( AParent, 'STATIC', WS_VISIBLE or WS_CHILD or
                         SS_LEFTNOWORDWRAP or SS_NOPREFIX or SS_NOTIFY,
                         False, @LabelActions );
  Result.fIsStaticControl := True;
  Result.fSizeRedraw := True;
  with Result.fBoundsRect do
  begin
    //Right := Left + 64;
    Bottom := Top + 22;
  end;
  Result.Caption := Caption;
end;
{$ENDIF ASM_VERSION}
//[END NewLabel]

{$ENDIF USE_CONSTRUCTORS}

//===================== word wrap Label ========================//

{$IFDEF USE_CONSTRUCTORS}
//[function NewWordWrapLabel]
function NewWordWrapLabel( AParent: PControl; const Caption: String ): PControl;
begin
  new( Result, CreateWordWrapLabel( AParent, Caption ) );
end;
//[END NewWordWrapLabel]
{$ELSE not_USE_CONSTRUCTORS}

//[FUNCTION NewWordWrapLabel]
{$IFDEF ASM_VERSION}
function NewWordWrapLabel( AParent: PControl; const Caption: String ): PControl;
asm
        CALL     NewLabel
        MOV      EDX, [EAX].TControl.fBoundsRect.Top
        ADD      EDX, 44
        MOV      [EAX].TControl.fBoundsRect.Bottom, EDX
        INC      [EAX].TControl.fWordWrap
        AND      byte ptr [EAX].TControl.fStyle, not SS_LEFTNOWORDWRAP
end;
{$ELSE ASM_VERSION} //Pascal
function NewWordWrapLabel( AParent: PControl; const Caption: String ): PControl;
begin
  Result := NewLabel( AParent, Caption );
  Result.fWordWrap := TRUE;
  with Result.fBoundsRect do
  begin
    Bottom := Top + 44;
  end;
  Result.fStyle := Result.fStyle and not SS_LEFTNOWORDWRAP;
end;
{$ENDIF ASM_VERSION}
//[END NewWordWrapLabel]

{$ENDIF USE_CONSTRUCTORS}

//===================== Label Effect ========================//

{$IFDEF USE_CONSTRUCTORS}
function NewLabelEffect( AParent: PControl; const Caption: String; ShadowDeep: Integer ): PControl;
begin
  new( Result, CreateLabelEffect( AParent, Caption, ShadowDeep ) );
end;
{$ELSE not_USE_CONSTRUCTORS}

//[FUNCTION NewLabelEffect]
{$IFDEF ASM_VERSION}
function NewLabelEffect( AParent: PControl; const Caption: String; ShadowDeep: Integer ): PControl;
asm
        PUSH     EBX

        PUSH     ECX
        PUSH     EDX
        XOR      EDX, EDX
        CALL     NewLabel
        MOV      EBX, EAX
        DEC      [EBX].TControl.fIsStaticControl
        MOV      EDX, offset[WndProcLabelEffect]
        CALL     TControl.AttachProc

        MOV      EAX, EBX
        CALL     TControl.GetWindowHandle

        POP      EDX
        MOV      EAX, EBX
        CALL     TControl.SetCaption

        MOV      EDX, offset[WndProcDoEraseBkgnd]
        MOV      EAX,EBX
        CALL     TControl.AttachProc
        MOV      [EBX].TControl.fTextAlign, taCenter
        MOV      [EBX].TControl.fTextColor, clWindowText
        POP      [EBX].TControl.fShadowDeep
        INC      [EBX].TControl.fIgnoreWndCaption
        ADD      [EBX].TControl.fBoundsRect.Bottom, 40 - 22
        MOV      [EBX].TControl.fColor2, clNone

        XCHG     EAX, EBX
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function NewLabelEffect( AParent: PControl; const Caption: String; ShadowDeep: Integer ): PControl;
begin
  Result := NewLabel( AParent, '' );
  Result.fIsStaticControl := False;
  Result.AttachProc( WndProcLabelEffect );
  Result.GetWindowHandle;
  Result.Caption := Caption;
  Result.AttachProc( WndProcDoEraseBkgnd );
  Result.fTextAlign := taCenter;
  Result.fTextColor := clWindowText;
  Result.fShadowDeep := ShadowDeep;
  Result.fIgnoreWndCaption := True;
  with Result.fBoundsRect do
  begin
    Bottom := Top + 40;
  end;
  Result.fColor2 := clNone;
end;
{$ENDIF ASM_VERSION}
//[END NewLabelEffect]

{$ENDIF USE_CONSTRUCTORS}

//===================== Paint box ========================//

{$IFDEF USE_CONSTRUCTORS}
//[function NewPaintbox]
function NewPaintbox( AParent: PControl ): PControl;
begin
  new( Result, CreatePaintBox( AParent ) );
end;
{$ELSE not_USE_CONSTRUCTORS}

//[FUNCTION NewPaintbox]
{$IFDEF ASM_VERSION}
function NewPaintbox( AParent: PControl ): PControl;
asm
        XOR      EDX, EDX
        CALL     NewLabel
        //PUSH     EAX
        //MOV      EDX, offset[WndProcPaintBox]
        //CALL     TControl.AttachProc
        //POP      EAX
        ADD      [EAX].TControl.fBoundsRect.Right, 40-64
        ADD      [EAX].TControl.fBoundsRect.Bottom, 40-22
end;
{$ELSE ASM_VERSION} //Pascal
function NewPaintbox( AParent: PControl ): PControl;
begin
  Result := NewLabel( AParent, '' );
  //Result.AttachProc( WndProcPaintBox );
  with Result.fBoundsRect do
  begin
    Right := Left + 40;
    Bottom := Top + 40;
  end;
end;
{$ENDIF ASM_VERSION}
//[END NewPaintbox]

{$ENDIF USE_CONSTRUCTORS}

{$IFDEF _D2}
//[API SetBrushOrgEx]
function SetBrushOrgEx(DC: HDC; X, Y: Integer; PrevPt: PPoint): BOOL; stdcall;
external gdi32 name 'SetBrushOrgEx';
{$ENDIF}

//[FUNCTION WndProcDoEraseBkgnd]
{$IFDEF ASM_VERSION}
function WndProcDoEraseBkgnd( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
asm     //        //
        CMP       word ptr [EDX].TMsg.message, WM_ERASEBKGND
        JNE       @@ret_false
        MOV       byte ptr [ECX], 1
        PUSH      EBX
        PUSH      EDI
        MOV       EBX, EAX
        MOV       EDI, [EDX].TMsg.wParam

        CALL      TControl.CreateChildWindows
        CMP       [EBX].TControl.fTransparent, 0
        JNE       @@exit

        PUSH      OPAQUE
        PUSH      EDI
        CALL      SetBkMode
        MOV       EAX, [EBX].TControl.fColor
        CALL      Color2RGB
        PUSH      EAX
        PUSH      EDI
        CALL      SetBkColor
        XOR       EAX, EAX
        PUSH      EAX
        PUSH      EAX
        PUSH      EAX
        PUSH      EDI
        CALL      SetBrushOrgEx
        SUB       ESP, 16
        PUSH      ESP
        PUSH      [EBX].TControl.fHandle
        CALL      GetClientRect
        MOV       EAX, EBX
        CALL      dword ptr[Global_GetCtlBrushHandle]
        MOV       EDX, ESP
        PUSH      EAX
        PUSH      EDX
        PUSH      EDI
        CALL      Windows.FillRect
        ADD       ESP, 16
@@exit: POP       EDI
        POP       EBX
@@ret_false:
        XOR       EAX, EAX
end;
{$ELSE ASM_VERSION PAS_VERSION}
function WndProcDoEraseBkgnd( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var DC: HDC;
    R: TRect;
begin
  Result := FALSE;
  if Msg.message = WM_ERASEBKGND then
  begin
    Self_.CreateChildWindows;
    if Self_.Transparent then Exit;
    DC := Msg.wParam;
    SetBkMode( DC, OPAQUE );
    SetBkColor( DC, Color2RGB( Self_.fColor ) );
    SetBrushOrgEx( DC, 0, 0, nil );
    GetClientRect( Self_.fHandle, R );
    Windows.FillRect( DC, R, Global_GetCtlBrushHandle( Self_ ) );
    Rslt := 1;
  end;
end;
{$ENDIF ASM_VERSION}
//[END WndProcDoEraseBkgnd]

//[function WndProcImageShow]
function WndProcImageShow( Sender: PControl; var Msg: TMsg;
         var Rslt: Integer ): Boolean;
var PaintStruct: TPaintStruct;
    IL: PImageList;
    OldPaintDC: HDC;
begin
  Result := FALSE;
  if (Msg.message = WM_PAINT) or (Msg.message = WM_PRINT) then
  begin
    OldPaintDC := Sender.fPaintDC;
    Sender.fPaintDC := Msg.wParam;
    if Sender.fPaintDC = 0 then
      Sender.fPaintDC := BeginPaint( Sender.fHandle, PaintStruct );
    //fOnPaint( Self_, fPaintDC );
    IL := Sender.ImageListNormal;
    if IL <> nil then
    begin
      IL.Draw( Sender.fCurIndex, Sender.fPaintDC, 0, 0 );
      Result := TRUE;
    end;
    if Msg.wParam = 0 then
      EndPaint( Sender.fHandle, PaintStruct );
    Sender.fPaintDC := OldPaintDC;
    Rslt := 0;
    //Result := True;
    Exit;
  end;
end;

//[function NewImageShow]
function NewImageShow( AParent: PControl; AImgList: PImageList;
         ImgIdx: Integer ): PControl;
var W, H: Integer;
begin
  Result := NewLabel( AParent, '' );
  Result.ImageListNormal := AImgList;
  Result.AttachProc( WndProcImageShow );
  Result.AttachProc( WndProcDoEraseBkgnd );
  W := 32; H := 32;
  if AImgList <> nil then
  begin
    W := AImgList.ImgWidth;
    H := AImgList.ImgHeight;
  end;
  with Result.fBoundsRect do
  begin
    Right := Left + W;
    Bottom := Top + H;
  end;
end;
//[END NewImageShow]

//===================== Scrollbox ========================//
//[function NewScrollBar]
function NewScrollBar( AParent: PControl; BarSide: TScrollerBar ): PControl;
const SBS_Directions: array[ TScrollerBar ] of DWORD = ( SBS_HORZ or SBS_BOTTOMALIGN,
      SBS_VERT or SBS_RIGHTALIGN );
begin
  {Result := _NewControl( AParent, 'SCROLLBAR', WS_VISIBLE or WS_CHILD or
         SBS_Directions[ BarSide ], FALSE, nil );}
  //Result.fBoundsRect := MakeRect( 0, 0, 0, 0 );
  Result := _NewWindowed( AParent, 'SCROLLBAR', FALSE );
  Result.fStyle := WS_VISIBLE or WS_CHILD or SBS_Directions[ BarSide ];

  {if BarSide = sbHorizontal then
    Result.fAlign := caBottom
  else
    Result.fAlign := caRight;}
  //Result.fNotUseAlign := TRUE;
  with Result.fBoundsRect do
  begin
    if BarSide = sbVertical then
      Right := Left + GetSystemMetrics( SM_CXVSCROLL )
    else
      Bottom := Top + GetSystemMetrics( SM_CXHSCROLL );
  end;
end;
//[END NewScrollBar]

//===================== Scrollbox ========================//
//[function WndProcScrollBox]
function WndProcScrollBox( Sender: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var Bar: DWORD;
    SI: TScrollInfo;
    OldNotifyProc: pointer;
begin

  case Msg.message of
  WM_HSCROLL: Bar := SB_HORZ;
  WM_VSCROLL: Bar := SB_VERT;
  WM_SIZE: begin
              if Assigned( Sender.fNotifyChild ) then
                Sender.fNotifyChild( Sender, nil );
              Result := FALSE;
              Exit;
           end;
  else begin
         Result := FALSE;
         Exit;
       end;
  end;

  SI.cbSize := Sizeof( SI );
  SI.fMask := SIF_RANGE or SIF_POS or SIF_PAGE or
              {$IFDEF F_P}$10{$ELSE}SIF_TRACKPOS{$ENDIF};
  GetScrollInfo( Sender.fHandle, Bar, SI );
  SI.fMask := SIF_POS;
  case LoWord( Msg.wParam ) of
  SB_BOTTOM:    SI.nPos := SI.nMax;
  SB_TOP:       SI.nPos := SI.nMin;
  SB_LINEDOWN:  Inc( SI.nPos, Sender.FScrollLineDist[ Bar ] );
  SB_LINEUP:    Dec( SI.nPos, Sender.FScrollLineDist[ Bar ] );
  SB_PAGEDOWN:  Inc( SI.nPos, Max( SI.nPage, 1 ) );
  SB_PAGEUP:    Dec( SI.nPos, Max( SI.nPage, 1 ) );
  SB_THUMBTRACK:SI.nPos := SI.nTrackPos;
  end;
  if SI.nPos > SI.nMax { - Integer( SI.nPage ) } then
    SI.nPos := SI.nMax { - Integer( SI.nPage ) };
  if SI.nPos < SI.nMin then
    SI.nPos := SI.nMin;
  SetScrollInfo( Sender.fHandle, Bar, SI, TRUE );

  if Assigned( Sender.fScrollChildren ) then
  begin
    OldNotifyProc := @ Sender.fNotifyChild;
    Sender.fNotifyChild := nil;
    Sender.fScrollChildren( Sender );
    Sender.fNotifyChild := OldNotifyProc;
  end;

  SetScrollInfo( Sender.fHandle, Bar, SI, TRUE );
  Result := FALSE;
end;
//[END WndProcScrollBox]

//[function NewScrollBox]
function NewScrollBox( AParent: PControl; EdgeStyle: TEdgeStyle;
         Bars: TScrollerBars ): PControl;
const Edgestyles: array[ TEdgeStyle ] of DWORD = ( WS_DLGFRAME, SS_SUNKEN, 0 );
var SBFlag: Integer;
begin
  SBFlag := EdgeStyles[ EdgeStyle ];
  if sbHorizontal in Bars then
    SBFlag := SBFlag or WS_HSCROLL;
  if sbVertical in Bars then
    SBFlag := SBFlag or WS_VSCROLL;

  Result := _NewControl( AParent, 'ScrollBox', WS_VISIBLE or WS_CHILD or
         SBFlag, EdgeStyle = esLowered, nil );
  Result.AttachProc( WndProcForm ); //!!!
  Result.AttachProc( WndProcScrollBox );
  Result.AttachProc( WndProcDoEraseBkgnd );
  Result.fIsControl := TRUE;
end;
//[END NewScrollBox]

//[function WndProcNotifyParentAboutResize]
function WndProcNotifyParentAboutResize( Sender: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var P: PControl;
begin
  if (Msg.message = WM_SIZE) or (Msg.message = WM_MOVE) or (Msg.message = CM_SHOW) then
  begin
    P := Sender.Parent;
    if P <> nil then
      if Assigned( P.fNotifyChild ) then
        P.fNotifyChild( P, nil );
  end
    else
  if Msg.message = WM_SHOWWINDOW then
    PostMessage( Sender.fHandle, CM_SHOW, 0, 0 );
  Result := FALSE;
end;

//[procedure CalcMinMaxChildren]
procedure CalcMinMaxChildren( Self_: PControl; var SzR: TRect );
var I: Integer;
    C: PControl;
    R: TRect;
begin
  Szr := MakeRect( 0, 0, 0, 0 );
  for I := 0 to Self_.fChildren.fCount - 1 do
  begin
    C := Self_.fChildren.fItems[ I ];
    if C.ToBeVisible then
    begin
      R := C.BoundsRect;
      if (SzR.Left = SzR.Right) or (R.Left < SzR.Left) or (R.Right > SzR.Right) then
      begin
        if SzR.Left = SzR.Right then
        begin
          SzR.Left := R.Left;
          SzR.Right := R.Right;
        end
          else
        begin
          if R.Left < SzR.Left then SzR.Left := R.Left;
          if R.Right > SzR.Right then SzR.Right := R.Right;
        end;
      end;
      if (SzR.Top = SzR.Bottom) or (R.Top < SzR.Top) or (R.Bottom > SzR.Bottom) then
      begin
        if SzR.Top = SzR.Bottom then
        begin
          SzR.Top := R.Top;
          SzR.Bottom := R.Bottom;
        end
          else
        begin
          if R.Top < SzR.Top then SzR.Top := R.Top;
          if R.Bottom > SzR.Bottom then SzR.Bottom := R.Bottom;
        end;
      end;
    end;
  end;
  Dec( SzR.Left, Self_.Border );
  Inc( SzR.Right, Self_.Border - 1 );
  Dec( SzR.Top, Self_.Border );
  Inc( SzR.Bottom, Self_.Border - 1 );
end;

//[procedure NotifyScrollBox]
procedure NotifyScrollBox( Self_, Child: PControl );
var SI: TScrollInfo;

    procedure GetSetScrollInfo( SBar: DWORD; WH, R_RightBottom, SzR_LeftTop, SzR_RightBottom: Integer );
    var OldPos: Double;
    begin
      OldPos := 0;
      if not GetScrollInfo( Self_.fHandle, SBar, SI ) then
      begin
        SI.nMin := 0;
        SI.nMax := Max( R_RightBottom - 1, SzR_RightBottom - 1 );
      end
        else
      begin
        if SI.nMax > SI.nMin then
        begin
          OldPos := (SI.nPos - SI.nMin) / (SI.nMax - SI.nMin);
          SI.nMin := 0;
          SI.nMax := Max( R_RightBottom - 1, SzR_RightBottom - 1 );
          if SzR_LeftTop < 0 then
            SI.nMax := Max( R_RightBottom - SzR_LeftTop - 1, WH - 1 );
        end
          else
        begin
          SI.nMin := 0;
          SI.nMax := Max( R_RightBottom - 1, SzR_RightBottom - 1 );
        end;
      end;
      SI.nPos := SI.nMin + Round( (SI.nMax - SI.nMin) * OldPos );
      SI.nPage := R_RightBottom;
      SetScrollInfo( Self_.fHandle, SBar, SI, TRUE );
    end;

var W, H: Integer;
    SzR: TRect;
    R: TRect;
begin
  if Assigned( Child ) then
  begin
    Child.AttachProc( WndProcNotifyParentAboutResize );
    Exit;
  end;
  CalcMinMaxChildren( Self_, SzR );
  W := SzR.Right - SzR.Left;
  H := SzR.Bottom - SzR.Top;

  R := Self_.ClientRect;
  if (R.Right = 0) or (R.Bottom = 0) then Exit; // for case when form is minimized
  SI.cbSize := sizeof( SI );
  SI.fMask := SIF_RANGE or SIF_PAGE or SIF_POS;

  GetSetScrollInfo( SB_HORZ, W, R.Right, SzR.Left, SzR.Right );
  GetSetScrollInfo( SB_VERT, H, R.Bottom, SzR.Top, SzR.Bottom );

end;

//[procedure ScrollChildren]
procedure ScrollChildren( _Self_: PControl );
var SzR, R: TRect;
    I, Xpos, Ypos: Integer;
    OldNotifyProc: Pointer;
    C: PControl;
    DeltaX, DeltaY: Integer;

begin

  CalcMinMaxChildren( _Self_, SzR );
  Xpos := GetScrollPos( _Self_.fHandle, SB_HORZ );
  Ypos := GetScrollPos( _Self_.fHandle, SB_VERT );

  DeltaX := -Xpos - SzR.Left;
  DeltaY := -Ypos - SzR.Top;

  if (DeltaX <> 0) or (DeltaY <> 0) then
  begin

    OldNotifyProc := @ _Self_.fNotifyChild;
    _Self_.fNotifyChild := nil;

    for I := 0 to _Self_.fChildren.fCount - 1 do
    begin
      C := _Self_.fChildren.fItems[ I ];
      R := C.BoundsRect;
      OffsetRect( R, DeltaX, DeltaY  );
      C.BoundsRect := R;
    end;

    _Self_.fNotifyChild := OldNotifyProc;
    CalcMinMaxChildren( _Self_, R );
    if //(SzR.Left <> R.Left) or (SzR.Top <> R.Top) or
       //(Szr.Right <> R.Right) or (SzR.Bottom <> R.Bottom)
       ((SzR.Right - SzR.Left) <> (R.Right - R.Left)) or
       ((SzR.Bottom - SzR.Top) <> (R.Bottom - R.Top))
       then
    if Assigned( _Self_.fNotifyChild ) then
      _Self_.fNotifyChild( _Self_, nil );

  end;

end;

//[function NewScrollBoxEx]
function NewScrollBoxEx( AParent: PControl; EdgeStyle: TEdgeStyle ): PControl;
begin
  Result := NewScrollBox( AParent, EdgeStyle, [ ] );
  Result.fNotifyChild := NotifyScrollBox;
  Result.fScrollChildren := ScrollChildren;
  Result.FScrollLineDist[ 0 ] := 16;
  Result.FScrollLineDist[ 1 ] := 16;
end;

//[function WndProcOnScroll]
function WndProcOnScroll( Sender: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var Bar: TScrollerBar;
begin
  Bar := sbHorizontal; //0
  if Msg.message = WM_VSCROLL then
    Bar := sbVertical
  else
  if Msg.message <> WM_HSCROLL then
  begin
    Result := FALSE;
    Exit;
  end;

  if Assigned( Sender.OnScroll ) then
    Sender.OnScroll( Sender, Bar, LoWord( Msg.wParam ), HiWord( Msg.wParam ) );
  Result := FALSE;
end;

//[procedure TControl.SetOnScroll]
procedure TControl.SetOnScroll(const Value: TOnScroll);
begin
  FOnScroll := Value;
  AttachProc( @ WndProcOnScroll );
end;

//===================== Groupbox ========================//

{$IFDEF USE_CONSTRUCTORS}
//[function NewGroupbox]
function NewGroupbox( AParent: PControl; const Caption: String ): PControl;
begin
  new( Result, CreateGroupbox( AParent, Caption ) );
end;
//[END NewGroupbox]
{$ELSE not_USE_CONSTRUCTORS}

//[FUNCTION NewGroupbox]
{$IFDEF ASM_VERSION}
function NewGroupbox( AParent: PControl; const Caption: String ): PControl;
asm
        PUSH     EDX
        PUSH     0
        PUSH     offset[ButtonActions]
        MOV      EDX, offset[ButtonClass]
        MOV      ECX, WS_VISIBLE or WS_CHILD or BS_GROUPBOX or WS_TABSTOP or WS_CLIPCHILDREN or WS_CLIPSIBLINGS or WS_GROUP
        CALL     _NewControl
        OR       [EAX].TControl.fExStyle, WS_EX_CONTROLPARENT
        ADD      [EAX].TControl.fBoundsRect.Right, 100-64
        ADD      [EAX].TControl.fBoundsRect.Bottom, 100-22
        ADD      [EAX].TControl.fClientTop, 22
        XOR      EDX, EDX
        MOV      [EAX].TControl.fTabstop, DL
        MOV      DL, 2
        ADD      [EAX].TControl.fClientBottom, EDX
        ADD      [EAX].TControl.fClientLeft, EDX
        ADD      [EAX].TControl.fClientRight, EDX
        POP      EDX
        PUSH     EAX
        CALL     TControl.SetCaption
        POP      EAX
        PUSH     EAX
        MOV      EDX, offset[WndProcDoEraseBkgnd]
        CALL     TControl.AttachProc
        POP      EAX
end;
{$ELSE ASM_VERSION} //Pascal
function NewGroupbox( AParent: PControl; const Caption: String ): PControl;
begin
  Result := _NewControl( AParent, 'BUTTON',
                   WS_CHILD or
                   WS_CLIPSIBLINGS or
                   WS_CLIPCHILDREN or
                   WS_TABSTOP or
                   WS_VISIBLE or
                   BS_NOTIFY or
                   BS_GROUPBOX
                   or WS_GROUP,
                   FALSE, @ ButtonActions );
  Result.fExStyle := Result.fExStyle or WS_EX_CONTROLPARENT;
  Result.Caption := Caption;
  with Result.fBoundsRect do
  begin
    Right := Left + 100;
    Bottom := Top + 100;
  end;
  Result.fClientTop := 22;
  Result.fClientBottom := 2;
  Result.fClientLeft := 2;
  Result.fClientRight := 2;
  Result.fTabstop := False;
  Result.AttachProc( WndProcDoEraseBkgnd );
end;
{$ENDIF ASM_VERSION}
//[END NewGroupbox]

{$ENDIF USE_CONSTRUCTORS}

//===================== Panel ========================//

{$IFDEF USE_CONSTRUCTORS}
//[function NewPanel]
function NewPanel( AParent: PControl; EdgeStyle: TEdgeStyle ): PControl;
begin
  new( Result, CreatePanel( AParent, EdgeStyle ) );
end;
//[END NewPanel]
{$ELSE not_USE_CONSTRUCTORS}

//[FUNCTION NewPanel]
{$IFDEF ASM_VERSION}
function NewPanel( AParent: PControl; EdgeStyle: TEdgeStyle ): PControl;
asm
        PUSH     EDX
        MOV      EDX, offset[StaticClass]
        MOV      ECX, WS_VISIBLE or WS_CHILD or SS_LEFTNOWORDWRAP or SS_NOPREFIX or SS_NOTIFY
        PUSH     0
        PUSH     offset[LabelActions]
        CALL     _NewControl
        ADD      [EAX].TControl.fBoundsRect.Right, 100-64
        ADD      [EAX].TControl.fBoundsRect.Bottom, 100-64
        OR       byte ptr [EAX].TControl.fExStyle+2, 1
        POP      ECX
        CMP      CL, 1
        JG       @@exit
        JE       @@sunken
        OR       byte ptr [EAX].TControl.fStyle+2, $40
        RET
@@sunken:
        OR       byte ptr [EAX].TControl.fStyle+1, $10
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
function NewPanel( AParent: PControl; EdgeStyle: TEdgeStyle ): PControl;
const Edgestyles: array[ TEdgeStyle ] of DWORD = ( WS_DLGFRAME, SS_SUNKEN, 0 );
begin
  Result := _NewControl( AParent, 'STATIC', WS_VISIBLE or WS_CHILD or SS_NOTIFY or
                         SS_LEFTNOWORDWRAP or SS_NOPREFIX, False, @LabelActions );
  with Result.fBoundsRect do
  begin
    Right := Left + 100;
    Bottom := Top + 100;
  end;
  Result.Style := Result.Style or Edgestyles[ EdgeStyle ];
  Result.ExStyle := Result.fExStyle or WS_EX_CONTROLPARENT;
  Result.fVerticalAlign := vaTop;
end;
{$ENDIF ASM_VERSION}
//[END NewPanel]

{$ENDIF USE_CONSTRUCTORS}

//===================== Splitter ==============================//

//{$DEFINE USE_ASM_DODRAG}

       {$IFNDEF USE_ASM_DODRAG}
         {$DEFINE USE_PAS_DODRAG}
       {$ENDIF}
       {$IFNDEF ASM_VERSION}
         {$DEFINE USE_PAS_DODRAG}
       {$ENDIF}
{$IFDEF USE_PAS_DODRAG}
//[procedure DoDrag]
procedure DoDrag( Self_: PControl; Cancel: Boolean );
var NewSize1, NewSize2: Integer;
    MousePos: TPoint;
    R: TRect;
    Prev: PControl;
    I, M : Integer;
begin
  if Self_.fDragging then
  begin
    I := Self_.fParent.fChildren.IndexOf( Self_ );
    Prev := Self_;
    if I > 0 then
      Prev := Self_.FParent.fChildren.fItems[ I - 1 ];
    GetCursorPos( MousePos );
    if Cancel then
      MousePos := Self_.fSplitStartPos;
    M := 1;
    if Self_.FAlign in [ caRight, caBottom ] then
      M := -1;
    if Self_.FAlign in [ caTop, caBottom ] then
    begin
      NewSize1 := (MousePos.y - Self_.fSplitStartPos.y)* M
                + Self_.fSplitStartSize;
      NewSize2 := Self_.fParent.ClientHeight - NewSize1
                - Self_.fBoundsRect.Bottom + Self_.fBoundsRect.Top
                - Self_.fParent.fMargin * 4;
      if Self_.fSecondControl <> nil then
      begin
        NewSize2 := Self_.fSecondControl.fBoundsRect.Bottom
                  - Self_.fSecondControl.fBoundsRect.Top;
        if Self_.fSecondControl.FAlign = caClient then
          NewSize2 := Self_.fSplitStartPos2.y
                    - (MousePos.y - Self_.fSplitStartPos.y)* M
                    - Self_.fParent.fMargin * 4;
      end;
    end
       else
    begin
      NewSize1 := (MousePos.x - Self_.fSplitStartPos.x)* M
                + Self_.fSplitStartSize;
      NewSize2 := Self_.fParent.ClientWidth - NewSize1
                - Self_.fBoundsRect.Right + Self_.fBoundsRect.Left
                - Self_.fParent.fMargin * 4;
      if Self_.fSecondControl <> nil then
      begin
        NewSize2 := Self_.fSecondControl.fBoundsRect.Right
                  - Self_.fSecondControl.fBoundsRect.Left;
        if Self_.fSecondControl.FAlign = caClient then
          NewSize2 := Self_.fSplitStartPos2.x
                    - (MousePos.x - Self_.fSplitStartPos.x)* M
                    - Self_.fParent.Margin * 4;
      end;
    end;
    if {(Self_.fSplitMinSize1 <> 0) and} (NewSize1 < Self_.fSplitMinSize1) then
    begin
      Dec( NewSize2, Self_.fSplitMinSize1 - NewSize1 );
      NewSize1 := Self_.fSplitMinSize1;
    end;
    if {(Self_.fSplitMinSize2 <> 0) and} (NewSize2 < Self_.fSplitMinSize2) then
    begin
      Dec( NewSize1, Self_.fSplitMinSize2 - NewSize2 );
      NewSize2 := Self_.fSplitMinSize2;
    end;
    //if Self_.fSplitMinSize1 <> 0 then
      if NewSize1 < Self_.fSplitMinSize1 then Exit;
    //if Self_.fSplitMinSize2 <> 0 then
      if NewSize2 < Self_.fSplitMinSize2 then Exit;
    if assigned( Self_.fOnSplit ) then
      if not Self_.fOnSplit( Self_, NewSize1, NewSize2 ) then Exit;
    R := Prev.BoundsRect;
    case Self_.FAlign of
    caTop: R.Bottom := R.Top + NewSize1;
    caBottom: R.Top := R.Bottom - NewSize1;
    caRight: R.Left := R.Right - NewSize1;
    else R.Right := R.Left + NewSize1;
    end;
    Prev.BoundsRect := R;
    Global_Align( Self_.fParent );
  end;
end;
{$ENDIF}

const
  chkLeft=2;
  chkTop=4;
  chkRight=8;
  chkBott=16;

{$DEFINE USE!_ASM_DODRAG}

//[FUNCTION WndProcSplitter]
{$IFDEF ASM_VERSION}
function WndProcSplitter( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
asm
        CMP      word ptr [EDX].TMsg.message, WM_NCHITTEST
        JNE      @@noWM_NCHITTEST
        PUSH     ECX
        PUSH     [EDX].TMsg.lParam
        PUSH     [EDX].TMsg.wParam
        PUSH     [EDX].TMsg.message
        PUSH     [EAX].TControl.fHandle
        CALL     DefWindowProc
        TEST     EAX, EAX
        JLE      @@htReady
        XOR      EAX, EAX
        INC      EAX
@@htReady:
        POP      ECX
        MOV      [ECX], EAX
        MOV      AL, 1
        RET

@@noWM_NCHITTEST:
        PUSH     EBX
        XCHG     EBX, EAX
        CMP      word ptr [EDX].TMsg.message, WM_MOUSEMOVE
        JNE      @@noWM_MOUSEMOVE

        PUSH     [EBX].TControl.fCursor
        CALL     Windows.SetCursor

        XOR      EDX, EDX

        {$IFDEF USE_ASM_DODRAG}
        CALL     @@DoDrag
        {$ELSE}
        MOV      EAX, EBX
        CALL     DoDrag
        {$ENDIF}

        POP      EBX
        RET

{$IFDEF USE_ASM_DODRAG}
@@DoDrag:
        PUSHAD
        MOVZX    EDI, DL // EDI = 1 if Cancel, 0 otherwise
        CMP      [EBX].TControl.fDragging, 0
        JZ       @@e_DoDrag
        MOV      EAX, [EBX].TControl.fParent
        MOV      EAX, [EAX].TControl.fChildren
        PUSH     EAX
        MOV      EDX, EBX
        CALL     TList.IndexOf
        POP      EDX // EDX = Self_.fParent.fChildren:PList
        MOV      EBP, EBX  // Prev := Self_;
        TEST     EAX, EAX
        JLE      @@noPrev
        MOV      EDX, [EDX].TList.fItems
        MOV      EBP, [EDX+EAX*4-4] // Prev = Self_.fParent.fChildren.fItems[I-1]
        PUSH     EBP  // push Prev
@@noPrev:
        PUSH     EDX
        PUSH     EDX
        PUSH     ESP
        CALL     GetCursorPos
        DEC      EDI
        JNZ      @@noCancel
        POP      EDX
        POP      EDX
        PUSH     [EBX].TControl.fSplitStartPos.y
        PUSH     [EBX].TControl.fSplitStartPos.x
@@noCancel:
        OR       EDI, -1
        MOV      CL, [EBX].TControl.fAlign
        MOV      AL, 1
        SHL      EAX, CL
        {$IFDEF PARANOIA}
        DB $A8, chkRight or chkBott
        {$ELSE}
        TEST AL, chkRight or chkBott //fAlign in [ caRight, caBottom ] ?
        {$ENDIF}
        JNZ      @@mReady
        INC      EDI
        INC      EDI
@@mReady:
        MOV      EDX, [EBX].TControl.fParent
        MOV      EBP, [EDX].TControl.fMargin
        NEG      EBP
        {$IFDEF PARANOIA}
        DB $A8, chkTop or chkBott
        {$ELSE}
        TEST AL, chkTop or chkBott // fAlign in [ caTop, caBottom ] ?
        {$ENDIF}
        XCHG     EAX, EDX
        JZ       @@noTopBottom

        CALL     TControl.GetClientHeight
        XCHG     EDX, EAX

        POP      EAX
        POP      ESI // MousePos.y
        MOV      EAX, ESI
        PUSH     EDX // Self_.fParent.ClientHeight
        SUB      EAX, [EBX].TControl.fSplitStartPos.y
        IMUL     EAX, EDI
        ADD      EAX, [EBX].TControl.fSplitStartSize // EAX = NewSize1

        POP      EDX
        SUB      EDX, EAX
        SUB      EDX, [EBX].TControl.fBoundsRect.Bottom
        ADD      EDX, [EBX].TControl.fBoundsRect.Top
        LEA      EDX, [EDX+EBP*4]

        MOV      ECX, [EBX].TControl.fSecondControl
        JECXZ    @@noSecondControl
        MOV      EDX, [ECX].TControl.fBoundsRect.Bottom
        SUB      EDX, [ECX].TControl.fBoundsRect.Top
        CMP      [ECX].TControl.fAlign, caClient
        JNZ      @@noSecondControl

        PUSH     EAX
        MOV      EAX, [EBX].TControl.fSplitStartPos.y
        SUB      EAX, ESI
        IMUL     EAX, EDI
        ADD      EAX, [EBX].TControl.fSplitStartPos2.y
        LEA      EDX, [EAX+EBP*4]
        POP      EAX

@@noSecondControl:
        JMP      @@newSizesReady

@@noTopBottom:
        CALL     TControl.GetClientWidth
        XCHG     EDX, EAX

        POP      ESI // MousePos.x
        POP      ECX
        MOV      EAX, ESI
        PUSH     EDX // Self_.fParent.ClientWidth
        SUB      EAX, [EBX].TControl.fSplitStartPos.x
        IMUL     EAX, EDI
        ADD      EAX, [EBX].TControl.fSplitStartSize // EAX = NewSize1

        POP      EDX
        SUB      EDX, EAX
        SUB      EDX, [EBX].TControl.fBoundsRect.Right
        ADD      EDX, [EBX].TControl.fBoundsRect.Left
        LEA      EDX, [EDX+EBP*4]

        MOV      ECX, [EBX].TControl.fSecondControl
        JECXZ    @@newSizesReady
        MOV      EDX, [ECX].TControl.fBoundsRect.Right
        SUB      EDX, [ECX].TControl.fBoundsRect.Left
        CMP      [ECX].TControl.fAlign, caClient
        JNZ      @@noSecondControl

        PUSH     EAX
        MOV      EAX, [EBX].TControl.fSplitStartPos.x
        SUB      EAX, ESI
        IMUL     EAX, EDI
        ADD      EAX, [EBX].TControl.fSplitStartPos2.x
        LEA      EDX, [EAX+EBP*4]
        POP      EAX

@@newSizesReady:
        MOV      ECX, [EBX].TControl.fSplitMinSize1
        //JECXZ    @@noCheckMinSize1
        SUB      ECX, EAX
        JLE      @@noCheckMinSize1
        SUB      EDX, ECX
        ADD      EAX, ECX

@@noCheckMinSize1:
        MOV      ECX, [EBX].TControl.fSplitMinSize2
        //JECXZ    @@noCheckMinSize2
        SUB      ECX, EDX
        JLE      @@noCheckMinSize2
        SUB      EAX, ECX
        ADD      EDX, ECX

@@noCheckMinSize2:
        MOV      ECX, [EBX].TControl.fOnSplit.TMethod.Code
        JECXZ    @@noOnSplit
        PUSHAD
        PUSH     EDX
        MOV      ESI, ECX
        XCHG     ECX, EAX
        MOV      EDX, EBX
        MOV      EAX, [EBX].TControl.fOnSplit.TMethod.Data
        CALL     ESI
        TEST     AL, AL
        POPAD
        JZ       @@e_DoDrag

@@noOnSplit:
        XCHG     ESI, EAX // NewSize1 -> ESI
        //MOV      EDI, EDX // NewSize2 -> EDI
        POP      EBP
        ADD      ESP, -16
        MOV      EAX, EBP
        MOV      EDX, ESP
        CALL     TControl.GetBoundsRect
        MOVZX    ECX, [EBX].TControl.fAlign
        LOOP     @@noPrev_caLeft
        ADD      ESI, [ESP].TRect.Left
        MOV      [ESP].TRect.Right, ESI
@@noPrev_caLeft:
        LOOP     @@noPrev_caTop
        ADD      ESI, [ESP].TRect.Top
        MOV      [ESP].TRect.Bottom, ESI
@@noPrev_caTop:
        LOOP     @@noPrev_caRight
        MOV      EAX, [ESP].TRect.Right
        SUB      EAX, ESI
        MOV      [ESP].TRect.Left, EAX
@@noPrev_caRight:
        LOOP     @@noPrev_caBottom
        MOV      EAX, [ESP].TRect.Bottom
        SUB      EAX, ESI
        MOV      [ESP].TRect.Top, EAX
@@noPrev_caBottom:
        MOV       EAX, EBP
        MOV       EDX, ESP
        CALL      TControl.SetBoundsRect
        ADD       ESP, 16
        MOV       EAX, [EBX].TControl.fParent
        //PUSH      EAX
        CALL      dword ptr[Global_Align]
        //POP       EAX
        //CALL      TControl.Update

@@e_DoDrag:
        POPAD
        RET
{$ENDIF USE_ASM_DODRAG}

@@noWM_MOUSEMOVE:
        CMP      word ptr [EDX].TMsg.message, WM_LBUTTONDOWN
        JNE      @@noWM_LBUTTONDOWN
        MOV      ECX, [EBX].TControl.fParent
        TEST     ECX, ECX
        JZ       @@noWM_LBUTTONDOWN
        //JECXZ    @@noWM_LBUTTONDOWN

        MOV      EAX, [ECX].TControl.fChildren
        PUSH     EAX
        MOV      EDX, EBX
        CALL     TList.IndexOf
        POP      ECX
        MOV      EDX, EBX
        TEST     EAX, EAX
        JLE      @@noParent1
        MOV      ECX, [ECX].TList.fItems
        MOV      EDX, [ECX+EAX*4-4]
@@noParent1:

        MOV      CL, [EBX].TControl.fAlign
        MOV      AL, 1
        SHL      EAX, CL
        {$IFDEF PARANOIA}
        DB $A8, chkTop or chkBott
        {$ELSE}
        TEST AL, chkTop or chkBott // fAlign in [caTop,caBottom] ?
        {$ENDIF}
        XCHG     EAX, EDX
        JZ       @@no_caTop_caBottom
        CALL     TControl.GetHeight
        JMP      @@caTop_caBottom
@@no_caTop_caBottom:
        CALL     TControl.GetWidth
@@caTop_caBottom:
        MOV      [EBX].TControl.fSplitStartSize, EAX
        MOV      ECX, [EBX].TControl.fSecondControl
        JECXZ    @@noSecondControl1
        XCHG     EAX, ECX
        PUSH     EAX
        CALL     TControl.GetWidth
        MOV      [EBX].TControl.fSplitStartPos2.x, EAX
        POP      EAX
        CALL     TControl.GetHeight
        MOV      [EBX].TControl.fSplitStartPos2.y, EAX
@@noSecondControl1:
        PUSH     [EBX].TControl.fHandle
        CALL     SetCapture
        OR       [EBX].TControl.fDragging, 1
        PUSH     0
        PUSH     100
        PUSH     $7B
        PUSH     [EBX].TControl.fHandle
        CALL     SetTimer
        LEA      EAX, [EBX].TControl.fSplitStartPos
        PUSH     EAX
        CALL     GetCursorPos
        JMP      @@exit

@@noWM_LBUTTONDOWN:
        CMP      word ptr [EDX].TMsg.message, WM_LBUTTONUP
        JNE      @@noWM_LBUTTONUP
        XOR      EDX, EDX

        {$IFDEF USE_ASM_DODRAG}
        CALL     @@DoDrag
        {$ELSE}
        MOV      EAX, EBX
        CALL     DoDrag
        {$ENDIF}

        JMP      @@killtimer

@@noWM_LBUTTONUP:
        CMP      word ptr[EDX].TMsg.message, WM_TIMER
        JNE      @@exit
        CMP      [EBX].TControl.fDragging, 0
        JE       @@exit
        PUSH     VK_ESCAPE
        CALL     GetAsyncKeyState
        TEST     EAX, EAX
        JGE      @@exit

        MOV      DL, 1

        {$IFDEF USE_ASM_DODRAG}
        CALL     @@DoDrag
        {$ELSE}
        MOV      EAX, EBX
        CALL     DoDrag
        {$ENDIF}

@@killtimer:
        MOV      [EBX].TControl.fDragging, 0
        PUSH     $7B
        PUSH     [EBX].TControl.fHandle
        CALL     KillTimer
        CALL     ReleaseCapture

@@exit:
        POP      EBX
        XOR      EAX, EAX
end;
{$ELSE ASM_VERSION} //Pascal
function WndProcSplitter( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var I: Integer;
    Prev: PControl;

    procedure FinDrag;
    begin
      KillTimer( Self_.fHandle, $7B );
      Self_.fDragging := False;
      ReleaseCapture;
    end;
begin
  case Msg.message of
  WM_NCHITTEST:
    begin
        Rslt := DefWindowProc( Self_.fHandle, Msg.message, Msg.wParam, Msg.lParam );
        if Rslt > 0 then
          Rslt := HTCLIENT;
        Result := True;
        Exit;
    end;
  WM_MOUSEMOVE:
    begin
      Windows.SetCursor( Self_.fCursor );
      DoDrag( Self_, False );
    end;
  WM_LBUTTONDOWN:
    begin
      if Self_.fParent <> nil then
      begin
        I := Self_.fParent.fChildren.IndexOf( Self_ );
        Prev := Self_;
        if I > 0 then
          Prev := Self_.FParent.fChildren.fItems[ I - 1 ];
        if Self_.fAlign in [ caTop, caBottom ] then
          Self_.fSplitStartSize := Prev.Height
        else
          Self_.fSplitStartSize := Prev.Width;
        if Self_.fSecondControl <> nil then
          Self_.fSplitStartPos2 :=
            MakePoint( Self_.fSecondControl.Width, Self_.fSecondControl.Height );
        SetCapture( Self_.fHandle );
        Self_.fDragging := True;
        SetTimer( Self_.fHandle, $7B, 100, nil );
        GetCursorPos( Self_.fSplitStartPos );
      end;
    end;
  WM_LBUTTONUP:
    begin
      DoDrag( Self_, False );
      FinDrag;
    end;
  WM_TIMER:
    if Self_.fDragging and (GetAsyncKeyState( VK_ESCAPE ) < 0) then
    begin
      DoDrag( Self_, True );
      FinDrag;
    end;
  end;
  Result := False;
end;
{$ENDIF ASM_VERSION}
//[END WndProcSplitter]

//[function NewSplitter]
function NewSplitter( AParent: PControl; MinSizePrev, MinSizeNext: Integer ): PControl;
begin
  Result := NewSplitterEx( AParent, MinSizePrev, MinSizeNext, esLowered );
end;
//[END NewSplitter]

{$IFDEF USE_CONSTRUCTORS}
//[function NewSplitterEx]
function NewSplitterEx( AParent: PControl; MinSizePrev, MinSizeNext: Integer;
         EdgeStyle: TEdgeStyle ): PControl;
begin
  new( Result, CreateSplitter( AParent, MinSizePrev, MinSizeNext, EdgeStyle ) );
end;
//[END NewSplitterEx]
{$ELSE not_USE_CONSTRUCTORS}

//[FUNCTION NewSplitterEx]
{$IFDEF ASM_VERSION}
function NewSplitterEx( AParent: PControl; MinSizePrev, MinSizeNext: Integer;
         EdgeStyle: TEdgeStyle ): PControl;
const int_IDC_SIZEWE = integer( IDC_SIZEWE );
asm
        PUSH     EBX
        PUSH     EAX  // AParent
        PUSH     ECX  // MinSizePrev
        PUSH     EDX  // MinSizeNext
        MOV      DL, EdgeStyle
        CALL     NewPanel
        XCHG     EBX, EAX
        POP      [EBX].TControl.fSplitMinSize1
        POP      [EBX].TControl.fSplitMinSize2
        XOR      EDX, EDX
        MOV      DL, 4
        MOV      EAX, [EBX].TControl.fBoundsRect.Left
        ADD      EAX, EDX
        MOV      [EBX].TControl.fBoundsRect.Right, EAX
        ADD      EDX, [EBX].TControl.fBoundsRect.Top
        MOV      [EBX].TControl.fBoundsRect.Bottom, EDX

        POP      ECX  // ECX = AParent
        JECXZ    @@noParent2
        MOV      EAX, [ECX].TControl.fChildren
        MOV      ECX, [EAX].TList.fCount
        CMP      ECX, 1
        JLE      @@noParent2

        MOV      EAX, [EAX].TList.fItems
        MOV      EAX, [EAX+ECX*4-8]
        MOV      CL, [EAX].TControl.fAlign
        PUSH     ECX
        MOV      AL, 1
        SHL      EAX, CL
        {$IFDEF PARANOIA}
        DB $A8, chkTop or chkBott
        {$ELSE}
        TEST     AL, chkTop or chkBott
        {$ENDIF}
        MOV      EAX, int_IDC_SIZEWE
        JZ       @@TopBottom
        INC      EAX
@@TopBottom:
        PUSH     EAX
        PUSH     0
        CALL     LoadCursor
        MOV      [EBX].TControl.fCursor, EAX
        POP      EDX
        MOV      EAX, EBX
        CALL     TControl.SetAlign

@@noParent2:
        MOV      EAX, EBX
        MOV      EDX, offset[WndProcSplitter]
        CALL     TControl.AttachProc
        XCHG     EAX, EBX
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function NewSplitterEx( AParent: PControl; MinSizePrev, MinSizeNext: Integer;
         EdgeStyle: TEdgeStyle ): PControl;
var PrevCtrl: PControl;
    Sz0: Integer;
begin
  Result := NewPanel( AParent, EdgeStyle );
  Result.fSplitMinSize1 := MinSizePrev;
  Result.fSplitMinSize2 := MinSizeNext;
  Sz0 := 4;
  with Result.fBoundsRect do
  begin
    Right := Left + Sz0;
    Bottom := Top + Sz0;
  end;
  if AParent <> nil then
  begin
    if AParent.fChildren.fCount > 1 then
    begin
      PrevCtrl := AParent.fChildren.fItems[ AParent.fChildren.fCount - 2 ];
      case PrevCtrl.FAlign of
      caLeft, caRight:
        begin
          Result.fCursor := LoadCursor( 0, IDC_SIZEWE );
        end;
      caTop, caBottom:
        begin
          Result.fCursor := LoadCursor( 0, IDC_SIZENS );
        end;
      end;
      Result.Align := PrevCtrl.FAlign;
    end;
  end;
  Result.AttachProc( WndProcSplitter );
end;
{$ENDIF ASM_VERSION}
//[END NewSplitterEx]

{$ENDIF USE_CONSTRUCTORS}

//===================== MDI client window control =============//

//[procedure DestroyMDIChildren]
procedure DestroyMDIChildren( Form: PControl );
var MDIClient: PControl;
    I: Integer;
    Ch: PControl;
begin
  //Form.fDefWndProc := nil;
  MDIClient := Form.fMDIClient;
  MDIClient.fMDIDestroying := TRUE;
  if MDIClient = nil then Exit;
  if MDIClient.fMDIChildren <> nil then
  for I := MDIClient.fMDIChildren.Count - 1 downto 0 do
  begin
    Ch := MDIClient.fMDIChildren.fItems[ I ];
    if Ch.fHandle <> 0 then
      MDIClient.Perform( WM_MDIDESTROY, Ch.fHandle, 0 );
  end;
  MDIClient.fMDIChildren.Free;
  MDIClient.fMDIChildren := nil;
  if Form.fMenu <> 0 then
  begin
    MDIClient.Perform( WM_MDISETMENU, 0, 0 );
    MDIClient.Perform( WM_MDIREFRESHMENU, 0, 0 );
    DrawMenuBar( Form.fHandle );
    Form.fMenuObj.Free;
    Form.fMenuObj := nil;
  end;
  Form.fMDIClient := nil;
  MDIClient.Free;
end;

//[function ProcMDIAccel]
function ProcMDIAccel( Applet: PControl; var Msg: TMsg ): Boolean;
var Form: PControl;
begin
  Result := FALSE;
  if (Msg.message >= WM_KEYFIRST) and (Msg.message <= WM_KEYLAST) then
  begin
    Form := Applet.ActiveControl;
    if Form <> nil then
    begin
      if Form.IsMDIChild then
        Form := Form.Parent;
      Form := Form.ParentForm;
      if (Form <> nil) and (Form.MDIClient <> nil) then
        Result := TranslateMDISysAccel( Form.MDIClient.fHandle, Msg );
    end;
  end;
end;

//[function CallDefFrameProc]
function CallDefFrameProc( Wnd: HWnd; Msg: Integer; wParam, lParam: Integer ): Integer;
stdcall;
var Form: PControl;
begin
  Form := Pointer( GetProp( Wnd, ID_SELF ) );
  if Form <> nil then
    Form := Form.ParentForm;
  if (Form <> nil) and (Form.fMDIClient <> nil) then
    Result := DefFrameProc( Wnd, Form.fMDIClient.fHandle, Msg, wParam, lParam )
  else
    Result := DefWindowProc( Wnd, Msg, wParam, lParam );
end;

//[function WndFuncMDIClient]
function WndFuncMDIClient( Wnd: HWnd; Msg, wParam, lParam: Integer ): Integer;
stdcall;
var C: PControl;
    M: TMsg;
begin
  C := Pointer( GetProp( Wnd, ID_SELF ) );
  if C <> nil then
  begin
    M.hwnd := Wnd;
    M.message := Msg;
    M.wParam := wParam;
    M.lParam := lParam;
    Result := C.WndProc( M );
  end
    else
    Result := DefWindowProc( Wnd, Msg, wParam, lParam );
end;

//[function ShowMDIClientEdge]
function ShowMDIClientEdge( MDIClient: PControl ): Boolean;
var ShowEdge: Boolean;
    I: Integer;
    Ch: PControl;
    ExStyle: Integer;
begin
  Result := FALSE;
  ShowEdge := TRUE;
  if MDIClient.fMDIChildren.Count > 0 then
    for I := 0 to MDIClient.fMDIChildren.Count-1 do
    begin
      Ch := MDIClient.fMDIChildren.fItems[ I ];
      if IsZoomed( Ch.fHandle ) then
      begin
        ShowEdge := FALSE;
        break;
      end;
    end;
  ExStyle := MDIClient.ExStyle;
  if ShowEdge then
    if ExStyle and WS_EX_CLIENTEDGE = 0 then
      ExStyle := ExStyle or WS_EX_CLIENTEDGE
    else
      Exit
  else if ExStyle and WS_EX_CLIENTEDGE <> 0 then
    ExStyle := ExStyle and not WS_EX_CLIENTEDGE
  else
    Exit;
  MDIClient.ExStyle := ExStyle;
  Result := TRUE;
end;

//[function WndProcMDIClient]
function WndProcMDIClient( MDIClient: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
{var I: Integer;
    Ch: PControl;}
begin
  if not MDIClient.fMDIDestroying then
  case Msg.message of
  $3f:
      begin
        PostMessage( MDIClient.fHandle, CM_MDIClientShowEdge, 0, 0 );
      end;
  CM_MDIClientShowEdge:
      begin
        ShowMDIClientEdge( MDIClient );
      end;
  WM_NCHITTEST: // not necessary though
      begin
        Rslt := DefWindowProc( MDIClient.fHandle, WM_NCHITTEST, Msg.wParam, Msg.lParam );
        if Rslt = HTCLIENT then Rslt := HTTRANSPARENT;
      end;
  WM_WINDOWPOSCHANGING:
      begin
        MDIClient.Perform( WM_SETREDRAW, 0, 0 );
      end;
  WM_WINDOWPOSCHANGED:
      begin
        Global_Align( MDIClient.Parent );
        MDIClient.Invalidate;
        MDIClient.Parent.Invalidate;
        MDIClient.Perform( WM_SETREDRAW, 1, 0 );
        PostMessage( MDIClient.fHandle, CM_INVALIDATE, 0, 0 );
      end;
  CM_INVALIDATE:
      begin
        MDIClient.InvalidateNC( TRUE );
        MDIClient.InvalidateEx;
        {for I := 0 to MDIClient.fMDIChildren.Count-1 do
        begin
          Ch := MDIClient.fMDIChildren.fItems[ I ];
          Ch.InvalidateEx;
          Ch.Perform( WM_NCPAINT, 1, 0 );
        end;}
      end;
  end;
  Result := FALSE;
end;

// function added by Thaddy de Koning to fix MDI behaviour
//[function WndProcParentNotifyMouseLDown]
function WndProcParentNotifyMouseLDown( Sender: PControl; var Msg: TMsg;
var Rslt: Integer ): Boolean;
begin
  Result := FALSE;
  if (Sender.IsMDIChild) and (Msg.message = WM_PARENTNOTIFY) and
     (LOWORD(msg.wparam)=WM_LBUTTONDOWN) then
     BringWindowToTop( Sender.Handle );
end;

//[function NewMDIClient]
function NewMDIClient( AParent: PControl; WindowMenu: THandle ): PControl;
var F: PControl;
    CCS: TClientCreateStruct;
    PrntWin: HWnd;
begin
  F := nil;
  PrntWin := 0;
  if AParent <> nil then
  begin
    F := AParent.ParentForm;
    if F <> nil then
    begin
      F.Add2AutoFreeEx( TObjectMethod( MakeMethod( F, @ DestroyMDIChildren ) ) );
      F.GetWindowHandle; // must be created before MDI client creation
      F.fDefWndProc := @CallDefFrameProc;
    end;
    PrntWin := AParent.GetWindowHandle;
  end;
  Applet.fExMsgProc := ProcMDIAccel;
  Result := _NewControl( AParent, 'MDICLIENT',
         WS_CHILD or WS_CLIPCHILDREN or WS_VSCROLL or WS_HSCROLL or
         WS_VISIBLE or WS_TABSTOP or MDIS_ALLCHILDSTYLES, TRUE, nil );
  {Result.fBoundsRect.Right := Result.fBoundsRect.Left + 300;
  Result.fBoundsRect.Bottom := Result.fBoundsRect.Top + 200;}
  Result.fMDIChildren := NewList;
  Result.fExStyle := WS_EX_CLIENTEDGE;

  CCS.hWindowMenu := WindowMenu;
  CCS.idFirstChild := $FF00;
  Result.fHandle := CreateWindowEx( WS_EX_CLIENTEDGE, 'MDICLIENT', nil,
                 WS_CHILD or WS_CLIPCHILDREN or WS_VSCROLL or WS_HSCROLL or
                 WS_VISIBLE or WS_TABSTOP,
                 //or WS_SYSMENU or WS_MINIMIZEBOX or WS_MAXIMIZEBOX,
                 0, 0, 0, 0, PrntWin, 0, hInstance, @ CCS );
  Result.fDefWndProc := Pointer( GetWindowLong( Result.fHandle, GWL_WNDPROC ) );
  SetWindowLong( Result.fHandle, GWL_WNDPROC, Integer( @WndFuncMDIClient ) );
  SetProp( Result.fHandle, ID_SELF, Integer( Result ) );
  if F <> nil then
    F.fMDIClient := Result;
  Result.AttachProc( WndProcMDIClient );
  Result.GetWindowHandle;

  Applet.AttachProc( WndProcParentNotifyMouseLDown );
end;

//===================== MDI child window object ==============//
//[function MDIChildFunc]
function MDIChildFunc( Wnd: HWnd; Msg: DWord; wParam, lParam: Integer ): Integer;
stdcall;
var C: PControl;
    M: TMsg;
begin
  C := Pointer( GetProp( Wnd, ID_SELF ) );
  if C <> nil then
  begin
    M.hwnd := Wnd;
    M.message := Msg;
    M.wParam := wParam;
    M.lParam := lParam;
    Result := C.WndProc( M );
  end
    else
    Result := DefMDIChildProc( Wnd, Msg, wParam, lParam );
end;

//[function Pass2DefMDIChildProc]
function Pass2DefMDIChildProc( Sender_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
begin
  Result := FALSE;
  if Sender_ = nil then Exit;
  if Sender_.Parent = nil then Exit;
  if Sender_.Parent.fDestroying then Exit;
  if (Msg.message = WM_SYSCOMMAND) or (Msg.message = WM_CHILDACTIVATE) or
     (Msg.message = WM_SETFOCUS) or (Msg.message = WM_SIZE) or
     (Msg.message = WM_MOVE) or (Msg.message = WM_MENUCHAR) or
     (Msg.message = WM_GETMINMAXINFO) {and IsZoomed( Sender_.fHandle ) {and (Msg.hwnd = Sender_.fHandle) { -- doesn't work -- } then
  begin
    {if Msg.message = WM_GETMINMAXINFO then
      Rslt := DefWindowProc( Msg.hwnd, Msg.message, Msg.lParam, Msg.wParam )
    else}
    Rslt := DefMDIChildProc( Msg.hwnd, Msg.message, Msg.lParam, Msg.wParam );
    Result := TRUE;
  end;
end;

//[function WndProcMDIChild]
function WndProcMDIChild( MDIChild: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var ClientWnd: HWnd;
    MDIClient: PControl;
    MDIForm: PControl;
begin
  Result := FALSE;
  MDIClient := MDIChild.Parent;
  if MDIClient = nil then Exit;
  ClientWnd := MDIClient.fHandle;
  if ClientWnd = 0 then Exit;
  case Msg.message of
  WM_DESTROY:
    begin
      MDIClient.fMDIChildren.Remove( MDIChild );
      MDIForm := MDIClient.ParentForm;
      if MDIForm <> nil then
      if MDIForm.fHandle <> 0 then
        DrawMenuBar( MDIForm.fHandle );
      MDIChild.Free;
      Result := TRUE;
      Exit;
    end;
  end;
  if MDIChild.fNotAvailable then
  begin
    MDIChild.fNotAvailable := FALSE;
    MDIChild.Invalidate;
  end;
end;

//[procedure CreateMDIChildExt]
procedure CreateMDIChildExt( Sender: PControl );
var F: PControl;
begin
  F := Sender.Parent;
  if F <> nil then
    F := F.ParentForm;
  if F <> nil then
    DrawMenuBar( F.fHandle );
end;

//[function NewMDIChild]
function NewMDIChild( AParent: PControl; const ACaption: String ): PControl;
var MDIClient: PControl;
begin
  Assert( (AParent <> nil) and (AParent.ParentForm <> nil) and
          (AParent.ParentForm.fMDIClient <> nil), 'Error creating MDI child' );
  MDIClient := AParent.ParentForm.fMDIClient;
  Result := NewForm( MDIClient, ACaption );
  Result.fIsMDIChild := TRUE;
  Result.fMenu := CtlIdCount;
  Inc( CtlIdCount );
  MDIClient.fMDIChildren.Add( Result );
  Result.fExStyle := Result.fExStyle or WS_EX_MDICHILD;
  Result.fWndFunc := @ MDIChildFunc;
  Result.fDefWndProc := @DefMDIChildProc;
  Result.fPass2DefProc := Pass2DefMDIChildProc;
  Result.AttachProc( WndProcMDIChild );

  Result.SubClassName := 'MDI_chld';
  Result.fNotAvailable := TRUE;
  Result.fCreateWndExt := CreateMDIChildExt;

end;

//===================== Gradient panel ========================//

{$IFDEF USE_CONSTRUCTORS}
//[function NewGradientPanel]
function NewGradientPanel( AParent: PControl; Color1, Color2: TColor ): PControl;
begin
  new( Result, CreateGradientPanel( AParent, Color1, Color2 ) );
end;
//[END NewGradientPanel]
{$ELSE not_USE_CONSTRUCTORS}

//[FUNCTION NewGradientPanel]
{$IFDEF ASM_VERSION}
function NewGradientPanel( AParent: PControl; Color1, Color2: TColor ): PControl;
asm
        PUSH     ECX
        PUSH     EDX
        XOR      EDX, EDX
        CALL     NewLabel
        PUSH     EAX
        MOV      EDX, offset[WndProcGradient]
        CALL     TControl.AttachProc
        POP      EAX
        POP      [EAX].TControl.fColor1
        POP      [EAX].TControl.fColor2
        ADD      [EAX].TControl.fBoundsRect.Right, 40-64
        ADD      [EAX].TControl.fBoundsRect.Bottom, 40 - 22
end;
{$ELSE ASM_VERSION} //Pascal
function NewGradientPanel( AParent: PControl; Color1, Color2: TColor ): PControl;
begin
  Result := NewLabel( AParent, '' );
  Result.AttachProc( WndProcGradient );
  Result.fColor2 := Color2;
  Result.fColor1 := Color1;
  with Result.fBoundsRect do
  begin
    Right := Left + 40;
    Bottom := Top + 40;
  end;
end;
{$ENDIF ASM_VERSION}
//[END NewGradientPanel]

{$ENDIF USE_CONSTRUCTORS}

{$IFDEF USE_CONSTRUCTORS}
//[function NewGradientPanelEx]
function NewGradientPanelEx( AParent: PControl; Color1, Color2: TColor;
                             Style: TGradientStyle; Layout: TGradientLayout ): PControl;
begin
  new( Result, CreateGradientPanelEx( AParent, Color1, Color2,
                             Style, Layout ) );
end;
//[END NewGradientPanelEx]
{$ELSE not_USE_CONSTRUCTORS}

//[FUNCTION NewGradientPanelEx]
{$IFDEF ASM_VERSION}
function NewGradientPanelEx( AParent: PControl; Color1, Color2: TColor;
                             Style: TGradientStyle; Layout: TGradientLayout ): PControl;
asm
        PUSH     ECX
        PUSH     EDX
        XOR      EDX, EDX
        CALL     NewLabel
        PUSH     EAX
        MOV      EDX, offset[WndProcGradientEx]
        CALL     TControl.AttachProc
        POP      EAX
        POP      [EAX].TControl.fColor1
        POP      [EAX].TControl.fColor2
        ADD      [EAX].TControl.fBoundsRect.Right, 40-100
        ADD      [EAX].TControl.fBoundsRect.Bottom, 40 - 22
        MOV      DL, Style
        MOV      [EAX].TControl.fGradientStyle, DL
        MOV      DL, Layout
        MOV      [EAX].TControl.fGradientLayout, DL
end;
{$ELSE ASM_VERSION} //Pascal
function NewGradientPanelEx( AParent: PControl; Color1, Color2: TColor;
                             Style: TGradientStyle; Layout: TGradientLayout ): PControl;
begin
  Result := NewLabel( AParent, '' );
  Result.AttachProc( WndProcGradientEx );
  Result.fColor2 := Color2;
  Result.fColor1 := Color1;
  Result.fGradientStyle := Style;
  Result.fGradientLayout := Layout;
  with Result.fBoundsRect do
  begin
    Right := Left + 40;
    Bottom := Top + 40;
  end;
end;
{$ENDIF ASM_VERSION}
//[END NewGradientPanelEx]

{$ENDIF USE_CONSTRUCTORS}

//===================== Edit box ========================//

const
  EN_LINK                             = $070b;
  EditActions: TCommandActions = (
    aClear: ClearText;
    aAddText: nil;
    aClick: 0;
    aEnter: EN_SETFOCUS;
    aLeave: EN_KILLFOCUS;
    aChange: EN_CHANGE;
    aSelChange: 0;
    aGetCount: EM_GETLINECOUNT;
    aSetCount: 0;
    aGetItemLength: EM_LINELENGTH;
    aGetItemText: EM_GETLINE;
    aSetItemText: EM_REPLACESEL;
    aGetItemData: 0;
    aSetItemData: 0;
    aAddItem: 0;
    aDeleteItem: 0;
    aInsertItem: 0;
    aFindItem: 0;
    aFindPartial: 0;
    aItem2Pos: EM_LINEINDEX;
    aPos2Item: EM_LINEFROMCHAR;
    aGetSelCount: EM_GETSEL;
    aGetSelected: 0;
    aGetSelRange: EM_GETSEL;
    aExGetSelRange: 0;
    aGetCurrent: EM_LINEINDEX;
    aSetSelected: 0;
    aSetCurrent: 0;
    aSetSelRange: EM_SETSEL;
    aExSetSelRange: 0;
    aGetSelection: 0;
    aReplaceSel: EM_REPLACESEL;
    aTextAlignLeft: ES_LEFT;
    aTextAlignRight: ES_RIGHT;
    aTextAlignCenter: ES_CENTER;
    aTextAlignMask: 0;
    aVertAlignCenter: 0;
    aVertAlignTop: 0;
    aVertAlignBottom: 0;
    aDir: 0;
    aSetLimit: EM_SETLIMITTEXT;
    aSetImgList: 0;
    aAutoSzX: 0;
    aAutoSzY: 6;
    aSetBkColor: 0;
  );

const Editflags: array [ TEditOption ] of Integer = (
                  not (ES_AUTOHSCROLL or WS_HSCROLL),
                  not (es_AutoVScroll or WS_VSCROLL),
                  es_Lowercase, es_Multiline,
                  es_NoHideSel, es_OemConvert, es_Password, es_Readonly,
                  es_UpperCase, es_WantReturn, 0, es_Number );

{$IFDEF USE_CONSTRUCTORS}
//[function NewEditbox]
function NewEditbox( AParent: PControl; Options: TEditOptions ) : PControl;
begin
  new( Result, CreateEditbox( AParent, Options ) );
end;
//[END NewEditbox]
{$ELSE not_USE_CONSTRUCTORS}

//[FUNCTION NewEditBox]
{$IFDEF ASM_VERSION}
const EditClass: array[0..4] of Char = ( 'E','D','I','T',#0 );
function NewEditbox( AParent: PControl; Options: TEditOptions ) : PControl;
const int_IDC_IBEAM = integer( IDC_IBEAM );
const WS_flags = integer( WS_VISIBLE or WS_CHILD or WS_TABSTOP or WS_BORDER );
const WS_clear = integer( not(WS_VSCROLL or WS_HSCROLL) );
asm
        PUSH     EBX
        XCHG     EBX, EAX // EBX=AParent
        PUSH     EDX
        MOV      EAX, ESP
        XOR      ECX, ECX
        MOV      CL, 11
        MOV      EDX, offset [EditFlags]
        CALL     MakeFlags
        XCHG     ECX, EAX // ECX = Flags
        POP      EAX  // Options
        PUSH     EAX
        {$IFDEF PARANOIA}
        DB $A8, 8
        {$ELSE}
        TEST     AL, 8
        {$ENDIF}
        JNZ      @@1
        AND      ECX, WS_clear
@@1:    OR       ECX, WS_flags
        PUSH     1
        PUSH     offset [EditActions]
        MOV      EDX, offset [EditClass]
        XCHG     EAX, EBX
        CALL     _NewControl
        XCHG     EBX, EAX
{ //YS
        PUSH     int_IDC_IBEAM
        PUSH     0
        CALL     LoadCursor
        MOV      [EBX].TControl.fCursor, EAX
}
        LEA      ECX, [EBX].TControl.fBoundsRect
        MOV      EDX, [ECX].TRect.Left
        ADD      EDX, 100
        MOV      [ECX].TRect.Right, EDX
        MOV      EDX, [ECX].TRect.Top
        ADD      EDX, 22
        MOV      [ECX].TRect.Bottom, EDX
        POP      EAX // Options
        {$IFDEF PARANOIA}
        DB $A8, 8
        {$ELSE}
        TEST     AL, 8
        {$ENDIF}
        MOV      DL, $0D
        JZ       @@2
        ADD      [ECX].TRect.Right, 100
        ADD      [ECX].TRect.Bottom, 200 - 22
        MOV      DL, 1
        INC      [EBX].TControl.fIgnoreDefault
@@2:    //MOV      [EBX].TControl.fColor, clWindow
        TEST     AH, 4
        JZ       @@3
        AND      DL, $FE
@@3:    MOV      [EBX].TControl.fLookTabKeys, DL
        XCHG     EAX, EBX
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function NewEditbox( AParent: PControl; Options: TEditOptions ) : PControl;
var Flags: Integer;
begin
  Flags := MakeFlags( @Options, EditFlags );
  if not(eoMultiline in Options) then
     Flags := Flags and not(WS_HSCROLL or WS_VSCROLL);
  Result := _NewControl( AParent, 'EDIT', WS_VISIBLE or WS_CHILD or WS_TABSTOP
                         or WS_BORDER or Flags, True, @EditActions );
//  Result.fCursor := LoadCursor( 0, IDC_IBEAM ); {YS}
  with Result.fBoundsRect do
  begin
    Right := Left + 100;
    Bottom := Top + 22;
    if eoMultiline in Options then
    begin
       Right := Right + 100;
       Bottom := Top + 200;
       Result.fIgnoreDefault := TRUE;
    end;
  end;
  Result.fLookTabKeys := [ tkTab, tkUpDown, tkPageUpPageDn ];
  if eoMultiline in Options then
     Result.fLookTabKeys := [ tkTab ];
  if eoWantTab in Options then
     Result.fLookTabKeys := Result.fLookTabKeys - [ tkTab ];
end;
{$ENDIF ASM_VERSION}
//[END NewEditBox]

{$ENDIF USE_CONSTRUCTORS}

//===================== List box ========================//

const
  ListActions: TCommandActions = (
    aClear: ClearListbox;
    aAddText: nil;
    aClick: LBN_DBLCLK;
    aEnter: LBN_SETFOCUS;
    aLeave: LBN_KILLFOCUS;
    aChange: 0;
    aSelChange: LBN_SELCHANGE;
    aGetCount: LB_GETCOUNT;
    aSetCount: LB_SETCOUNT;
    aGetItemLength: LB_GETTEXTLEN;
    aGetItemText: LB_GETTEXT;
    aSetItemText: 0;
    aGetItemData: LB_GETITEMDATA;
    aSetItemData: LB_SETITEMDATA;
    aAddItem: LB_ADDSTRING;
    aDeleteItem: LB_DELETESTRING;
    aInsertItem: LB_INSERTSTRING;
    aFindItem: LB_FINDSTRINGEXACT;
    aFindPartial: LB_FINDSTRING;
    aItem2Pos: 0;
    aPos2Item: 0;
    aGetSelCount: LB_GETSELCOUNT;
    aGetSelected: LB_GETSEL;
    aGetSelRange: 0;
    aExGetSelRange: 0;
    aGetCurrent: LB_GETCURSEL;
    aSetSelected: LB_SETSEL;
    aSetCurrent: LB_SETCURSEL;
    aSetSelRange: 0;
    aExSetSelRange: 0;
    aGetSelection: 0;
    aReplaceSel: 0;
    aTextAlignLeft: 0;
    aTextAlignRight: 0;
    aTextAlignCenter: 0;
    aTextAlignMask: 0;
    aVertAlignCenter: 0;
    aVertAlignTop: 0;
    aVertAlignBottom: 0;
    aDir: LB_DIR;
    aSetLimit: 0;
    aSetImgList: 0;
    aAutoSzX: 0;
    aAutoSzY: 0;
    aSetBkColor: 0;
  );

const ListFlags: array[TListOption] of Integer = (
                  LBS_DISABLENOScroll, not LBS_ExtendedSel,
                  LBS_MultiColumn or WS_HSCROLL,
                  LBS_MultiPLESel,
                  LBS_NoIntegralHeight, LBS_NoSel, LBS_Sort, LBS_USETabstops,
                  not LBS_HASSTRINGS, LBS_NODATA, LBS_OWNERDRAWFIXED, LBS_OWNERDRAWVARIABLE );

{$IFDEF USE_CONSTRUCTORS}
//[function NewListbox]
function NewListbox( AParent: PControl; Options: TListOptions ): PControl;
begin
  new( Result, CreateListbox( AParent, Options ) );
end;
//[END NewListbox]
{$ELSE not_USE_CONSTRUCTORS}

//[FUNCTION NewListbox]
{$IFDEF ASM_VERSION}
const ListBoxClass : array[ 0..7 ] of Char = ( 'L','I','S','T','B','O','X',#0 );
function NewListbox( AParent: PControl; Options: TListOptions ): PControl;
asm
        PUSH     EAX
        PUSH     EDX
        MOV      EAX, ESP
        MOV      EDX, offset[ListFlags]
        XOR      ECX, ECX
        MOV      CL, 11
        CALL     MakeFlags
        POP      EDX
        OR       EAX, WS_VISIBLE or WS_CHILD or WS_TABSTOP or WS_BORDER or WS_VSCROLL or LBS_NOTIFY
        XCHG     ECX, EAX
        POP      EAX
        PUSH     1
        PUSH     offset[ListActions]
        MOV      EDX, offset[ListBoxClass]
        CALL     _NewControl
        ADD      [EAX].TControl.fBoundsRect.Right, 100
        ADD      [EAX].TControl.fBoundsRect.Bottom, 200-64
        MOV      [EAX].TControl.fColor, clWindow
        MOV      [EAX].TControl.fLookTabKeys, 3
end;
{$ELSE ASM_VERSION} //Pascal
function NewListbox( AParent: PControl; Options: TListOptions ): PControl;
var Flags: Integer;
begin
  Flags := MakeFlags( @Options, ListFlags );
  Result := _NewControl( AParent, 'LISTBOX', WS_VISIBLE or WS_CHILD or WS_TABSTOP
                         or WS_BORDER or WS_VSCROLL
                         or LBS_NOTIFY or Flags, True, @ListActions );
  with Result.fBoundsRect do
  begin
    Right := Right + 100;
    Bottom := Top + 200;
  end;
  Result.fColor := clWindow;
  Result.fLookTabKeys := [ tkTab, tkLeftRight ];
end;
{$ENDIF ASM_VERSION}
//[END NewListbox]

{$ENDIF USE_CONSTRUCTORS}

//===================== Combo box ========================//

const
  ComboActions: TCommandActions = (
    aClear: ClearCombobox;
    aAddText: nil;
    aClick: CBN_DBLCLK;
    aEnter: CBN_SETFOCUS;
    aLeave: CBN_KILLFOCUS;
    aChange: CBN_EDITCHANGE;
    aSelChange: CM_CBN_SELCHANGE; // CBN_SELCHANGE;
    aGetCount: CB_GETCOUNT;
    aSetCount: 0;
    aGetItemLength: CB_GETLBTEXTLEN;
    aGetItemText: CB_GETLBTEXT;
    aSetItemText: 0;
    aGetItemData: CB_GETITEMDATA;
    aSetItemData: CB_SETITEMDATA;
    aAddItem: CB_ADDSTRING;
    aDeleteItem: CB_DELETESTRING;
    aInsertItem: CB_INSERTSTRING;
    aFindItem: CB_FINDSTRINGEXACT;
    aFindPartial: CB_FINDSTRING;
    aItem2Pos: 0;
    aPos2Item: 0;
    aGetSelCount: 0;
    aGetSelected: CB_GETCURSEL;
    aGetSelRange: 0;
    aExGetSelRange: 0;
    aGetCurrent: CB_GETCURSEL;
    aSetSelected: 0;
    aSetCurrent: CB_SETCURSEL;
    aSetSelRange: 0;
    aExSetSelRange: 0;
    aGetSelection: 0;
    aReplaceSel: 0;
    aTextAlignLeft: 0; //ES_LEFT;
    aTextAlignRight: 0; //ES_RIGHT;
    aTextAlignCenter: 0; //ES_CENTER;
    aTextAlignMask: 0;
    aVertAlignCenter: 0;
    aVertAlignTop: 0;
    aVertAlignBottom: 0;
    aDir: CB_DIR;
    aSetLimit: 0;
    aSetImgList: 0;
    aAutoSzX: 0;
    aAutoSzY: 6;
    aSetBkColor: 0;
  );

//[FUNCTION ComboboxDropDown]
{$IFDEF ASM_VERSION}
procedure ComboboxDropDown( Sender: PObj );
asm
        PUSH     EBX
        PUSH     ESI
        MOV      EBX, EAX
        CALL     TControl.GetItemsCount
        CMP      EAX, 1
        JGE      @@1
        XOR      EAX, EAX
        INC      EAX
@@1:    CMP      EAX, 8
        JLE      @@2
        XOR      EAX, EAX
        MOV      AL, 8
@@2:    XOR      ESI, ESI
        PUSH     SWP_NOMOVE or SWP_NOSIZE or SWP_NOZORDER or SWP_NOACTIVATE or SWP_NOREDRAW or SWP_SHOWWINDOW
        PUSH     ESI
        PUSH     ESI
        PUSH     SWP_NOMOVE or SWP_NOZORDER or SWP_NOACTIVATE or SWP_NOREDRAW or SWP_HIDEWINDOW
        PUSH     EAX
        MOV      EAX, EBX
        CALL     TControl.GetHeight
        POP      ECX
        INC      ECX
        IMUL     ECX
        INC      EAX
        INC      EAX
        PUSH     EAX
        MOV      EAX, EBX
        CALL     TControl.GetWidth
        PUSH     EAX
        INC      ESI
@@3:    XOR      EDX, EDX
        PUSH     EDX
        PUSH     EDX
        PUSH     EDX
        PUSH     [EBX].TControl.fHandle
        CALL     SetWindowPos
        DEC      ESI
        JZ       @@3
        MOV      ECX, [EBX].TControl.fOnDropDown.TMethod.Code
        JECXZ    @@exit
        MOV      EAX, [EBX].TControl.fOnDropDown.TMethod.Data
        MOV      EDX, EBX
        CALL     ECX
@@exit: POP      ESI
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure ComboboxDropDown( Sender: PObj );
var
  CB: PControl;
  IC: Integer;
begin
  CB := PControl( Sender );
  IC := CB.Count;
  if IC > 8 then IC := 8;
  if IC < 1 then IC := 1;

  SetWindowPos( CB.Handle, 0, 0, 0, CB.Width, CB.Height * (IC + 1) + 2,
                SWP_NOMOVE + SWP_NOZORDER + SWP_NOACTIVATE + SWP_NOREDRAW +
                SWP_HIDEWINDOW);

  SetWindowPos( CB.Handle, 0, 0, 0, 0, 0, SWP_NOMOVE + SWP_NOSIZE
                + SWP_NOZORDER + SWP_NOACTIVATE
                + SWP_NOREDRAW + SWP_SHOWWINDOW);

  if assigned( CB.fOnDropDown ) then
    CB.fOnDropDown( CB );

end;
{$ENDIF ASM_VERSION}
//[END ComboboxDropDown]

//[function WndFuncCombo]
function WndFuncCombo( W: HWnd; Msg: Cardinal; wParam, lParam: Integer )
                                   : Integer; stdcall;
var Combo, Form: PControl;
    ParentWnd : HWnd;
    MsgStruct: TMsg;
//********************************************************** Added By M.Gerasimov
//*
    PrevProc:Pointer;
//*
//********************************************************** Added By M.Gerasimov
begin
   Combo := nil;

   ParentWnd := GetParent( W );
   if ParentWnd <> 0 then
     Combo := Pointer( GetProp( ParentWnd, ID_SELF ) );

   if Combo <> nil then
   begin
      MsgStruct.hwnd := Combo.fHandle;
      MsgStruct.message := Msg;
      MsgStruct.wParam := wParam;
      MsgStruct.lParam := lParam;
      Form := Combo.ParentForm;
      if fGlobalProcKeybd( Combo, MsgStruct, Result ) then Exit;
      if W <> Combo.FHandle then
      begin
        if Assigned( Applet ) and Assigned( Applet.OnMessage ) then
          if Applet.OnMessage( MsgStruct, Result ) then Exit;
        if (Applet <> Form) and (Form <> nil) then
        if Assigned( Form.OnMessage ) then
          if Form.OnMessage( MsgStruct, Result ) then Exit;
      end;
      if //(GetFocus = W) and
         (Msg = WM_KEYDOWN) or (Msg = WM_KEYUP) or (Msg = WM_CHAR) then
      begin
        Result := 0;
        if (wParam = VK_TAB) then
        begin
          case Msg of
          WM_KEYDOWN:
            if Assigned( Combo.fGotoControl ) and
               Combo.fGotoControl( Combo, wParam, FALSE ) then Exit;
          else Exit;
          end;
        end
          else
        if (Msg = WM_CHAR) and ((wParam = VK_ESCAPE) or (wParam = VK_RETURN)) then
        begin
          if Combo.Perform( CB_GETDROPPEDSTATE, 0, 0 ) <> 0 then
          begin
            Combo.Perform( CB_SHOWDROPDOWN, 0, 0 );
            if wParam = VK_ESCAPE then
              Combo.Perform( CB_SETCURSEL, Combo.fCurIdxAtDrop, 0 );
            Combo.fWndProcKeybd( Combo, MsgStruct, Result );
            Exit;
          end
          {$IFDEF ESC_CLOSE_DIALOGS}
              //---------------------------------Babenko Alexey--------------------------
              else
              if (wparam = VK_ESCAPE)  then
                if (combo.ParentForm.ExStyle and WS_EX_DLGMODALFRAME) <> 0 then begin
                SendMessage(combo.ParentForm.Handle, WM_CLOSE, 0, 0);
                exit;
              end;
              //---------------------------------Babenko Alexey--------------------------
          {$ENDIF}
        end;
        Combo.fWndProcKeybd( Combo, MsgStruct, Result );
      end
        else
      if Msg = WM_SETFOCUS then
      begin
        if Form <> nil then Form.fCurrentControl := Combo;
      end;
      MsgStruct.hwnd := W;
//********************************************************** Added By M.Gerasimov
//*
      PrevProc:=Pointer(GetProp( W, ID_PREVPROC ));
      if PrevProc <> Nil then
       Result := CallWindowProc( PrevProc , W, Msg, wParam, lParam )
      else
       Result:=0;
//*
//********************************************************** Added By M.Gerasimov
//     Result := CallWindowProc( //Combo.fPrevWndProc
//           Pointer( GetProp( W, 'PREV_PROC' ) )
//           , W, Msg, wParam, lParam );
//**********************************************************
   end
      else
      Result := DefWindowProc( W, Msg, wParam, lParam );
end;

//[PROCEDURE CreateComboboxWnd]
{$IFDEF ASM_VERSION}
procedure CreateComboboxWnd( Combo: PControl );
//********************************************************** Remarked By M.Gerasimov
//const PrevProcStr: PChar = 'PREV_PROC';
//********************************************************** Remarked By M.Gerasimov
asm
        PUSH     EDI
        PUSH     EBX
        XCHG     EBX, EAX
        PUSH     GW_CHILD
        PUSH     [EBX].TControl.fHandle
        //XOR      EDI, EDI
@@getwindow:
        CALL     GetWindow
        TEST     EAX, EAX
        JZ       @@fin
        {TEST     EDI, EDI
        XCHG     EDI, EAX
        JZ       @@2getnext}
        PUSH     offset[WndFuncCombo]
        PUSH     GWL_WNDPROC
        PUSH     EAX
        XCHG     EDI, EAX
        CALL     SetWindowLong
        PUSH     EAX
//********************************************* By M.Gerasimov
//      PUSH     [PrevProcStr]
//************************************************************
        PUSH     offset [ID_PREVPROC]                       //
//************************************************************
        PUSH     EDI
        CALL     SetProp
@@2getnext:
        PUSH     GW_HWNDNEXT
        PUSH     EDI
        JMP      @@getwindow
@@fin:  POP      EBX
        POP      EDI
end;
{$ELSE ASM_VERSION} //Pascal
procedure CreateComboboxWnd( Combo: PControl );
var W : HWND;
    PrevProc: DWORD;
begin
   W := GetWindow( Combo.fHandle, GW_CHILD );
   {if W <> 0 then
     W := GetWindow( W, GW_HWNDNEXT );}
   while W <> 0 do
   begin
     PrevProc :=
       SetWindowLong( W, GWL_WNDPROC, Longint( @WndFuncCombo ) );
//********************************************* By M.Gerasimov
//   SetProp( W, 'PREV_PROC', PrevProc );
//************************************************************
     SetProp( W, ID_PREVPROC, PrevProc );                   //
//************************************************************
     W := GetWindow( W, GW_HWNDNEXT );
   end;
end;
{$ENDIF ASM_VERSION}
//[END CreateComboboxWnd]

//[procedure RemoveChldPrevProc]
procedure RemoveChldPrevProc( fHandle: HWnd );
var Chld: HWnd;
begin
  Chld := GetWindow( fHandle, GW_CHILD );
  while Chld <> 0 do
  begin
    if GetProp( Chld, ID_PREVPROC ) <> 0 then
      RemoveProp(Chld, ID_PREVPROC);
    Chld := GetWindow( Chld, GW_HWNDNEXT );
  end;
end;

//[function WndProcCombo]
function WndProcCombo( Sender: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
begin
  Result := FALSE;
  if (Msg.message >= WM_CTLCOLORMSGBOX) and (Msg.message <= WM_CTLCOLORSTATIC) then
  begin
    Rslt := Sender.Perform( Msg.message + CN_BASE, Msg.wParam, Msg.lParam );
    Result := TRUE;
  end
    else
  if //(Msg.message = CN_CTLCOLOREDIT)
     (Msg.message >= CN_CTLCOLORMSGBOX) and (Msg.message <= CN_CTLCOLORSTATIC)
     {and not AppletTerminated} then
  begin
    if Sender.fTransparent then
    case Msg.message of
    CN_CTLCOLORLISTBOX:
      begin
        SetBkMode( Msg.wParam, Windows.OPAQUE );
        SetBkColor(Msg.WParam, Color2RGB( Sender.fColor ) );
        Rslt := Global_GetCtlBrushHandle( Sender );
        Result := TRUE;
      end;
//********************************************************** Added By M.Gerasimov
//*
     WM_DESTROY:
       RemoveChldPrevProc( Sender.Handle );
//*
//********************************************************** Added By M.Gerasimov
    else
    if not Sender.DblBufTopParent.fDblBufPainting then
      Sender.Invalidate;
    end;
    //Result := FALSE;
  end
    else
  if Msg.message = CM_COMMAND then
  begin
    case HiWord( Msg.wParam ) of
    CBN_DROPDOWN:
         begin
           Sender.fDropped := True;
           Sender.fCurIdxAtDrop := Sender.CurIndex;
           Sender.fDropDownProc( Sender );
         end;
    CBN_CLOSEUP:
         begin
           Sender.fDropped := False;
           if Assigned( Sender.fOnCloseUp ) then Sender.fOnCloseUp( Sender );
         end;
    CBN_SELCHANGE:
         begin
           PostMessage( Sender.fHandle, CM_COMMAND, CM_CBN_SELCHANGE shl 16, 0 );
         end;
    end;
  end;
end;

const ComboFlags: array[ TComboOption ] of Integer = (
      CBS_DROPDOWNLIST, not CBS_AUTOHScroll,
      CBS_DISABLENOSCROLL, CBS_LowerCase, CBS_NoIntegralHeight,
      CBS_OemConvert, CBS_Sort, CBS_UpperCase,
      CBS_OWNERDRAWFIXED, CBS_OWNERDRAWVARIABLE, CBS_SIMPLE );

{$IFDEF USE_CONSTRUCTORS}
//[function NewCombobox]
function NewCombobox( AParent: PControl; Options: TComboOptions ): PControl;
begin
  new( Result, CreateCombobox( AParent, Options ) );
end;
{$ELSE not_USE_CONSTRUCTORS}

//[FUNCTION NewCombobox]
{$IFDEF ASM_VERSION}
const ComboboxClass: array[0..8] of Char = ('C','O','M','B','O','B','O','X',#0 );
function NewCombobox( AParent: PControl; Options: TComboOptions ): PControl;
asm
        PUSH     EDX
        PUSH     EAX
        PUSH     EDX
        MOV      EAX, ESP
        MOV      EDX, offset[ComboFlags]
        XOR      ECX, ECX
        MOV      CL, 10
        CALL     MakeFlags
        POP      EDX
        XCHG     ECX, EAX
        POP      EAX
        PUSH     1
        PUSH     offset[ComboActions]
        MOV      EDX, offset[ComboboxClass]
        OR       ECX, WS_VISIBLE or WS_CHILD or WS_VSCROLL or CBS_HASSTRINGS or WS_TABSTOP
        TEST     ECX, CBS_SIMPLE
        JNZ      @@O
        OR       ECX, CBS_DROPDOWN
@@O:
        CALL     _NewControl
        MOV      [EAX].TControl.fCreateWndExt, offset[CreateComboboxWnd]
        MOV      [EAX].TControl.fDropDownProc, offset[ComboboxDropDown]
        OR       byte ptr [EAX].TControl.fClsStyle, CS_DBLCLKS
        ADD      [EAX].TControl.fBoundsRect.Right, 100-64
        ADD      [EAX].TControl.fBoundsRect.Bottom, 22-64
        //MOV      [EAX].TControl.fColor, clWindow
        MOV      CL, 1
        POP      EDX
        TEST     DL, 1
        JZ       @@exit
        MOV      CL, 3
@@exit:
        MOV      [EAX].TControl.fLookTabKeys, CL
        PUSH     EAX
        MOV      EDX, offset[ WndProcCombo ]
        CALL     TControl.AttachProc
        POP      EAX
end;
{$ELSE ASM_VERSION} //Pascal
function NewCombobox( AParent: PControl; Options: TComboOptions ): PControl;
var Flags: Integer;
begin
  Flags := MakeFlags( @Options, ComboFlags );
  if not LongBool( Flags and CBS_SIMPLE ) then
    Flags := Flags or CBS_DROPDOWN;
  Result := _NewControl( AParent, 'COMBOBOX',
                         WS_VISIBLE
                         or WS_CHILD
                         or WS_VSCROLL
                         or CBS_HASSTRINGS or WS_TABSTOP
                         or Flags
                         , True, @ComboActions );
  //Result.fCannotDoubleBuf := TRUE;
  Result.fCreateWndExt := CreateComboboxWnd;
  Result.fDropDownProc := ComboboxDropDown;
  Result.fClsStyle := Result.fClsStyle or CS_DBLCLKS;
  with Result.fBoundsRect do
  begin
    Right := Left + 100;
    Bottom := Top + 22;
  end;
  Result.fLookTabKeys := [ tkTab ];
  if coReadOnly in Options then
    Result.fLookTabKeys := [ tkTab, tkLeftRight ];
  Result.AttachProc( @ WndProcCombo );
end;
{$ENDIF ASM_VERSION}
//[END NewCombobox]

{$ENDIF USE_CONSTRUCTORS}

//[FUNCTION WndProcResiz]
{$IFDEF ASM_VERSION}
function WndProcResize(Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
asm
        PUSH     ESI
        CMP      word ptr [EDX].TMsg.message, WM_SIZE
        JNZ      @@exit

        MOV      ESI, [EAX].TControl.fChildren
        MOV      ECX, [ESI].TList.fCount
        JECXZ    @@exit
        MOV      ESI, [ESI].TList.fItems
@@loo:  PUSH     ECX
        LODSD
        PUSH     EAX
        PUSH     EAX
        PUSH     CM_SIZE
        PUSH     EAX
        CALL     TControl.Perform
        POP      ECX
        LOOP     @@loo

@@exit: XOR      EAX, EAX
        POP      ESI
end;
{$ELSE ASM_VERSION} //Pascal
function WndProcResize(Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var I: Integer;
    C: PControl;
begin
  if Msg.message = WM_SIZE then
  begin
    for I:= 0 to Self_.fChildren.fCount - 1 do
    begin
      C := Self_.fChildren.fItems[ I ];
      C.Perform( CM_SIZE, 0, 0 );
    end;
  end;
  Result := False; // don't stop further processing
end;
{$ENDIF ASM_VERSION}
//[END WndProcResiz]

//[FUNCTION WndProcParentResize]
{$IFDEF ASM_VERSION}
function WndProcParentResize( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
asm
        CMP      word ptr [EDX].TMsg.message, CM_SIZE
        JNZ      @@exit
        PUSH     0
        PUSH     0
        PUSH     WM_SIZE
        PUSH     EAX
        CALL     TControl.Perform
@@exit: XOR      EAX, EAX
end;
{$ELSE ASM_VERSION} //Pascal
function WndProcParentResize(Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
begin
  Result := False;
  case Msg.message of
  CM_SIZE:
    begin
      Self_.Perform( WM_SIZE, 0, 0 );
    end;
  end;
end;
{$ENDIF ASM_VERSION}
//[END WndProcParentResize]

//[procedure InitCommonControlCommonNotify]
procedure InitCommonControlCommonNotify( Ctrl: PControl );
var AParent: PControl;
begin
  Ctrl.fIsCommonControl := True;
  AParent := Ctrl.Parent;
  if AParent <> nil then
  begin
    Ctrl.AttachProc( WndProcCommonNotify );
    AParent.AttachProc( WndProcNotify );
  end;
end;

//[procedure InitCommonControlSizeNotify]
procedure InitCommonControlSizeNotify( Ctrl: PControl );
var AParent: PControl;
begin
  AParent := Ctrl.Parent;
  if AParent <> nil then
  begin
    Ctrl.AttachProc( WndProcParentResize );
    AParent.AttachProc( WndProcResize );
  end;
end;

//[function _NewCommonControl]
function _NewCommonControl( AParent: PControl; ClassName: PChar; Style: DWORD;
                            Ctl3D: Boolean; Actions: PCommandActions ): PControl;
begin
  {*************} DoInitCommonControls( ICC_WIN95_CLASSES );
  Result := _NewControl( AParent, ClassName, Style, Ctl3D, Actions );
  //InitCommonControlSizeNotify( Result );
  InitCommonControlCommonNotify( Result );
end;

//==================== Progress bar ======================//

{$IFDEF USE_CONSTRUCTORS}
//[function NewProgressbar]
function NewProgressbar( AParent: PControl ): PControl;
begin
  new( Result, CreateProgressbar( AParent ) );
end;
//[END NewProgressbar]
{$ELSE not_USE_CONSTRUCTORS}

//[FUNCTION NewProgressbar]
{$IFDEF ASM_VERSION}
function NewProgressbar( AParent: PControl ): PControl;
asm
        PUSH     1
        PUSH     0
        MOV      EDX, offset[Progress_class]
        MOV      ECX, WS_CHILD or WS_VISIBLE
        CALL     _NewCommonControl
        LEA      EDX, [EAX].TControl.fBoundsRect
        MOV      ECX, [EDX].TRect.Left
        ADD      ECX, 300
        MOV      [EDX].TRect.Right, ECX
        MOV      ECX, [EDX].TRect.Top
        ADD      ECX, 20
        MOV      [EDX].TRect.Bottom, ECX
        XOR      EDX, EDX
        MOV      [EAX].TControl.fMenu, EDX
        MOV      [EAX].TControl.fTextColor, clHighlight
        MOV      [EAX].TControl.fCommandActions.aSetBkColor, PBM_SETBKCOLOR
end;
{$ELSE ASM_VERSION} //Pascal
function NewProgressbar( AParent: PControl ): PControl;
begin
  Result := _NewCommonControl( AParent, PROGRESS_CLASS,
            WS_CHILD or WS_VISIBLE, True, nil );
  with Result.fBoundsRect do
  begin
    Right := Left + 300;
    Bottom := Top + 20;
  end;
  Result.fMenu := 0;
  Result.fTextColor := clHighlight;
  Result.fCommandActions.aSetBkColor := PBM_SETBKCOLOR;
end;
{$ENDIF ASM_VERSION}
//[END NewProgressbar]

{$ENDIF USE_CONSTRUCTORS}

{$IFDEF USE_CONSTRUCTORS}
//[function NewProgressbarEx]
function NewProgressbarEx( AParent: PControl; Options: TProgressbarOptions ): PControl;
begin
  new( Result, CreateProgressbarEx( AParent, Options ) );
end;
//[END NewProgressbarEx]
{$ELSE not_USE_CONSTRUCTORS}

//[FUNCTION NewProgressbarEx]
{$IFDEF ASM_VERSION}
function NewProgressbarEx( AParent: PControl; Options: TProgressbarOptions ): PControl;
asm
        PUSH     EDX
        CALL     NewProgressbar
        POP      ECX
        XOR      EDX, EDX
        SHR      ECX, 1
        JNC      @@notVert
        MOV      DL, 4
@@notVert:
        SHR      ECX, 1
        JNC      @@notSmooth
        INC      EDX
@@notSmooth:
        OR       [EAX].TControl.fStyle, EDX
end;
{$ELSE ASM_VERSION} //Pascal
function NewProgressbarEx( AParent: PControl; Options: TProgressbarOptions ): PControl;
const ProgressBarFlags: array[ TProgressbarOption ] of Integer =
      (PBS_VERTICAL, PBS_SMOOTH );
begin
  Result := NewProgressbar( AParent );
  Result.fStyle := Result.fStyle or DWORD( MakeFlags( @Options, ProgressBarFlags ) );
end;
{$ENDIF ASM_VERSION}
//[END NewProgressbarEx]

{$ENDIF USE_CONSTRUCTORS}

//===================== List view ========================//

//[FUNCTION WndProcNotify]
{$IFDEF ASM_VERSION}
function WndProcNotify( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
asm
        CMP      word ptr [EDX].TMsg.message, WM_NOTIFY
        JNE      @@ret_false
        PUSH     ECX
        PUSH     EDX
        PUSH     offset[ID_SELF]
        MOV      ECX, [EDX].TMsg.lParam
        PUSH     [ECX].TNMHdr.hwndFrom
        CALL     GetProp
        POP      EDX
        TEST     EAX, EAX
        JZ       @@ret_false_ECX
        MOV      ECX, [EAX].TControl.fHandle
        MOV      [EDX].TMsg.hwnd, ECX
        POP      ECX
        JMP      TControl.EnumDynHandlers
@@ret_false_ECX:
        POP      ECX
@@ret_false:
        XOR      EAX, EAX
end;
{$ELSE ASM_VERSION} //Pascal
function WndProcNotify( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var NMhdr: PNMHdr;
    Child: PControl;
begin
  Result := False;
  if Msg.message = WM_NOTIFY then
  begin
    NMhdr := Pointer( Msg.lParam );
    Child := Pointer( GetProp( NMhdr.hwndFrom, ID_SELF ) );
    if Child <> nil then
    begin
      Msg.hwnd := Child.fHandle;
      Result := EnumDynHandlers( Child, Msg, Rslt );
    end;
  end;
end;
{$ENDIF ASM_VERSION}
//[END WndProcNotify]

//[FUNCTION WndProcCommonNotify]
{$IFDEF ASM_VERSION}
function WndProcCommonNotify( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
asm
        CMP      word ptr [EDX].TMsg.message, WM_NOTIFY
        JNE      @@ret_false
        PUSH     EBX
        MOV      EBX, [EDX].TMsg.lParam
        MOV      EDX, [EBX].TNMHdr.code

@@chk_nm_click:
        XOR      ECX, ECX
        CMP      EDX, NM_CLICK
        JZ       @@click
        CMP      EDX, NM_RCLICK
        JNE      @@chk_killfocus
        INC      ECX
@@click:
        MOV      [EAX].TControl.fRightClick, CL

        MOV      ECX, [EAX].TControl.fOnClick.TMethod.Code
        JECXZ    @@fin_false
        MOV      EDX, [EAX].TControl.fOnClick.TMethod.Data
        JMP      @@fin_event

@@fin_false:
        POP      EBX
@@ret_false:
        XOR      EAX, EAX
        RET

@@chk_killfocus:
        CMP      EDX, NM_KILLFOCUS
        JNE      @@chk_setfocus
        MOV      ECX, [EAX].TControl.fOnLeave.TMethod.Code
        JECXZ    @@fin_false
        MOV      EDX, [EAX].TControl.fOnLeave.TMethod.Data
        JMP      @@fin_event
@@chk_setfocus:
        CMP      EDX, NM_RETURN
        JE       @@set_focus
        CMP      EDX, NM_SETFOCUS
        JNE      @@fin_false

@@set_focus:
        MOV      ECX, [EAX].TControl.fOnEnter.TMethod.Code
        JECXZ    @@fin_false
        MOV      EDX, [EAX].TControl.fOnEnter.TMethod.Data

@@fin_event:
        XCHG     EAX, EDX
        CALL     ECX
        POP      EBX
        MOV      AL, 1
end;
{$ELSE ASM_VERSION} //Pascal
function WndProcCommonNotify( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var NMhdr: PNMHdr;
begin
  Result := False;
  if Msg.message = WM_NOTIFY then
  begin
    NMHdr := Pointer( Msg.lParam );
    case NMHdr.code of
      NM_RCLICK,
      NM_CLICK:  if assigned( Self_.fOnClick ) then
                 begin
                    Self_.fRightClick := NMHdr.code=NM_RCLICK;
                    Self_.fOnClick( Self_ );
                    Result := TRUE;
                 end;
      NM_KILLFOCUS: if assigned( Self_.fOnLeave ) then
                    Self_.fOnLeave( Self_ );
      NM_RETURN,
      NM_SETFOCUS: if assigned( Self_.fOnEnter ) then
                    Self_.fOnEnter( Self_ );
    end;
  end;
end;
{$ENDIF ASM_VERSION}
//[END WndProcCommonNotify]

const ListViewStyles: array[ TListViewStyle ] of DWORD = ( LVS_ICON, LVS_SMALLICON,
                      LVS_LIST, LVS_REPORT, LVS_REPORT or LVS_NOCOLUMNHEADER );
      ListViewFlags: array[ TListViewOption ] of Integer = ( LVS_ALIGNLEFT, LVS_AUTOARRANGE,
                      $400 {LVS_BUTTON}, LVS_EDITLABELS, LVS_NOLABELWRAP,
                      LVS_NOSCROLL, LVS_NOSORTHEADER,
                      not LVS_SHOWSELALWAYS, not LVS_SINGLESEL, LVS_SORTASCENDING,
                      LVS_SORTDESCENDING, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                      LVS_OWNERDATA, LVS_OWNERDRAWFIXED );

      ListViewExFlags: array[ TListViewOption ] of Integer = ( 0, 0,
                      0, 0, 0, 0, 0, 0, 0, 0, 0, LVS_EX_GRIDLINES,
                      LVS_EX_SUBITEMIMAGES, LVS_EX_CHECKBOXES, LVS_EX_TRACKSELECT,
                      LVS_EX_HEADERDRAGDROP, LVS_EX_FULLROWSELECT, LVS_EX_ONECLICKACTIVATE,
                      LVS_EX_TWOCLICKACTIVATE, LVS_EX_FLATSB, LVS_EX_REGIONAL,
                      LVS_EX_INFOTIP, LVS_EX_UNDERLINEHOT, LVS_EX_MULTIWORKAREAS, 0, 0 );


//[FUNCTION ApplyImageLists2Control]
{$IFDEF ASM_VERSION}
procedure ApplyImageLists2Control( Sender: PControl );
asm
        PUSHAD
        XCHG     ESI, EAX
        MOVZX    ECX, [ESI].TControl.fCommandActions.aSetImgList
        JECXZ    @@fin
        MOV      EBP, ECX
        XOR      EBX, EBX
        MOV      BL, 32
        XOR      EDI, EDI
@@loo:
        MOV      EAX, ESI
        MOV      EDX, EBX
        CALL     TControl.GetImgListIdx
        TEST     EAX, EAX
        JZ       @@nx
        CALL     TImageList.GetHandle
        PUSH     EAX
        PUSH     EDI
        PUSH     EBP
        PUSH     ESI
        CALL     TControl.Perform
@@nx:
        INC      EDI
        SHR      EBX, 1
        JZ       @@fin
        CMP      BL, 16
        JGE      @@loo
        XOR      EBX, EBX
        JMP      @@loo
@@fin:
        POPAD
end;
{$ELSE ASM_VERSION} //Pascal
procedure ApplyImageLists2Control( Sender: PControl );
var IL: PImageList;
begin
  if Sender.fCommandActions.aSetImgList = 0 then Exit;
  IL := Sender.ImageListNormal;
  if IL <> nil then
    Sender.Perform( Sender.fCommandActions.aSetImgList, LVSIL_NORMAL, IL.Handle );
  IL := Sender.ImageListSmall;
  if IL <> nil then
    Sender.Perform( Sender.fCommandActions.aSetImgList, LVSIL_SMALL, IL.Handle );
  IL := Sender.ImageListState;
  if IL <> nil then
    Sender.Perform( Sender.fCommandActions.aSetImgList, LVSIL_STATE, IL.Handle );
end;
{$ENDIF ASM_VERSION}
//[END ApplyImageLists2Control]

//[FUNCTION ApplyImageLists2ListView]
{$IFDEF ASM_VERSION}
procedure ApplyImageLists2ListView( Sender: PControl );
asm
        PUSHAD

        XCHG     ESI, EAX
        PUSH     dword ptr [ESI].TControl.fLVOptions
        MOV      EAX, ESP
        MOV      EDX, offset[ListViewFlags]
        XOR      ECX, ECX
        MOV      CL, 25
        CALL     MakeFlags
        POP      ECX
        PUSH     ECX

        MOV      EDX, [ESI].TControl.fStyle
        //AND      DH, 3
        AND      DX, not $403F
        OR       EDX, EAX

        MOVZX    EAX, [ESI].TControl.fLVStyle
        OR       EDX, [EAX*4 + offset ListViewStyles]

        MOV      EAX, ESI
        CALL     TControl.SetStyle

        MOV      EAX, ESP
        MOV      EDX, offset[ListViewExFlags]
        XOR      ECX, ECX
        MOV      CL, 23
        CALL     MakeFlags
        POP      EDX
        PUSH     EAX
        PUSH     $3FFF
        PUSH     LVM_SETEXTENDEDLISTVIEWSTYLE
        PUSH     ESI
        CALL     TControl.Perform

        POPAD
        CALL     ApplyImageLists2Control
end;
{$ELSE ASM_VERSION} //Pascal
procedure ApplyImageLists2ListView( Sender: PControl );
var Flags: DWORD;
begin
  Flags := MakeFlags( @Sender.fLVOptions, ListViewFlags );
  Sender.Style := Sender.Style and not $403F
                  or Flags or ListViewStyles[ Sender.fLVStyle ];
  Flags := MakeFlags( @Sender.fLVOptions, ListViewExFlags );
  Sender.Perform( LVM_SETEXTENDEDLISTVIEWSTYLE, $3FFF, Flags );
  ApplyImageLists2Control( Sender );
end;
{$ENDIF ASM_VERSION}
//[END ApplyImageLists2ListView]

const
  ListViewActions: TCommandActions = (
    aClear: ClearListView;
    aAddText: nil;
    aClick: 0;
    aEnter: 0;
    aLeave: 0;
    aChange: LVN_ITEMCHANGED;
    aSelChange: 0;
    aGetCount: LVM_GETITEMCOUNT;
    aSetCount: LVM_SETITEMCOUNT;
    aGetItemLength: 0;
    aGetItemText: 0;
    aSetItemText: 0;
    aGetItemData: 0;
    aSetItemData: 0;
    aAddItem: 0;
    aDeleteItem: 0;
    aInsertItem: 0;
    aFindItem: 0;
    aFindPartial: 0;
    aItem2Pos: 0;
    aPos2Item: 0;
    aGetSelCount: $8000 or LVM_GETSELECTEDCOUNT;
    aGetSelected: 0;
    aGetSelRange: 0;
    aExGetSelRange: 0;
    aGetCurrent: LVM_GETNEXTITEM;
    aSetSelected: 0;
    aSetCurrent: 0;
    aSetSelRange: 0;
    aExSetSelRange: 0;
    aGetSelection: 0;
    aReplaceSel: 0;
    aTextAlignLeft: 0;
    aTextAlignRight: 0;
    aTextAlignCenter: 0;
    aTextAlignMask: 0;
    aVertAlignCenter: 0;
    aVertAlignTop: 0;
    aVertAlignBottom: 0;
    aDir: 0;
    aSetLimit: 0;
    aSetImgList: LVM_SETIMAGELIST;
    aAutoSzX: 0;
    aAutoSzY: 0;
    aSetBkColor: LVM_SETBKCOLOR;
  );

{$IFDEF USE_CONSTRUCTORS}
//[function NewListView]
function NewListView( AParent: PControl; Style: TListViewStyle; Options: TListViewOptions;
                      ImageListSmall, ImageListNormal, ImageListState: PImageList ): PControl;
begin
  new( Result, CreateListView( AParent, Style, Options, ImageListSmall,
               ImageListNormal, ImageListState ) );
end;
//[END NewListView]
{$ELSE not_USE_CONSTRUCTORS}

//[FUNCTION NewListView]
{$IFDEF ASM_VERSION}
function NewListView( AParent: PControl; Style: TListViewStyle; Options: TListViewOptions;
                      ImageListSmall, ImageListNormal, ImageListState: PImageList ): PControl;
asm
        PUSH     EDX
        PUSH     ECX
        MOVZX    EDX, DL
        MOV      ECX, [EDX*4 + offset ListViewStyles]
        OR       ECX, LVS_SHAREIMAGELISTS or WS_CHILD or WS_VISIBLE or WS_TABSTOP
        MOV      EDX, offset[WC_LISTVIEW]
        PUSH     1
        PUSH     offset[ListViewActions]
        CALL     _NewCommonControl

        MOV      EDX, ESP
        PUSH     EAX
        XCHG     EAX, EDX
        MOV      EDX, offset ListViewFlags
        XOR      ECX, ECX
        MOV      CL, 25
        CALL     MakeFlags
        XCHG     EDX, EAX
        POP      EAX
        MOV      ECX, [EAX].TControl.fStyle
        AND      ECX, not LVS_TYPESTYLEMASK
        OR       EDX, ECX
        MOV      [EAX].TControl.fStyle, EDX

        POP      [EAX].TControl.fLVOptions
        POP      EDX
        MOV      [EAX].TControl.fLVStyle, DL
        MOV      [EAX].TControl.fCreateWndExt, offset[ApplyImageLists2ListView]
        ADD      [EAX].TControl.fBoundsRect.Right, 200-64
        ADD      [EAX].TControl.fBoundsRect.Bottom, 150-64
        MOV      ECX, [ImageListState]
        XOR      EDX, EDX
        PUSHAD
        CALL     TControl.SetImgListIdx
        POPAD
        MOV      ECX, [ImageListSmall]
        MOV      DL, 16
        PUSHAD
        CALL     TControl.SetImgListIdx
        POPAD
        MOV      ECX, [ImageListNormal]
        ADD      EDX, EDX
        PUSH     EAX
        CALL     TControl.SetImgListIdx
        POP      EAX
        MOV      [EAX].TControl.fLVTextBkColor, clWindow
        XOR      EDX, EDX
        //MOV      [EAX].TControl.fMargin, EDX
        INC      EDX
        MOV      [EAX].TControl.fLookTabKeys, DL
end;
{$ELSE ASM_VERSION} //Pascal
function NewListView( AParent: PControl; Style: TListViewStyle; Options: TListViewOptions;
                      ImageListSmall, ImageListNormal, ImageListState: PImageList ): PControl;
begin
  Result := _NewCommonControl( AParent, WC_LISTVIEW, ListViewStyles[ Style ] or
                               LVS_SHAREIMAGELISTS or WS_CHILD or WS_VISIBLE or WS_TABSTOP or WS_CLIPCHILDREN,
                               True, @ListViewActions );

  Result.fLVOptions := Options;
  Result.fLVStyle := Style;
  Result.fStyle := Result.fStyle and not LVS_TYPESTYLEMASK
                  or DWORD( MakeFlags( @Options, ListViewFlags ) );
  Result.fCreateWndExt := ApplyImageLists2ListView;
  with Result.fBoundsRect do
  begin
    Right := Left + 200;
    Bottom := Top + 150;
  end;
  Result.ImageListSmall := ImageListSmall;
  Result.ImageListNormal := ImageListNormal;
  Result.ImageListState := ImageListState;
  Result.fLVTextBkColor := clWindow;
  Result.fLookTabKeys := [ tkTab ];
  //Result.fMargin := 0;
end;
{$ENDIF ASM_VERSION}
//[END NewListView]

{$ENDIF USE_CONSTRUCTORS}

//=====================  Tree view  ========================//

//[FUNCTION WndProcTreeView]
{$IFDEF ASM_VERSION}
function WndProcTreeView( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
asm     //cmd    //opd
        CMP      word ptr [EDX].TMsg.message, WM_NOTIFY
        JNZ      @@ret_false
        PUSH     EBX
        XCHG     EBX, EAX
        MOV      EDX, [EDX].TMsg.lParam
        LEA      EAX, [EBX].TControl.fOnTVBeginDrag
        CMP      word ptr [EDX].TNMTreeView.hdr.code, NM_RCLICK
        JNE      @@chk_TVN_BEGINDRAG
        PUSH     ECX
        PUSH     ECX
        PUSH     ESP
        CALL     GetCursorPos
        MOV      EAX, EBX
        MOV      EDX, ESP
        MOV      ECX, EDX
        CALL     TControl.Screen2Client
        POP      EAX
        AND      EAX, $FFFF
        POP      EDX
        SHL      EDX, 16
        OR       EAX, EDX
        PUSH     EAX
        CALL     GetShiftState
        PUSH     EAX
        PUSH     WM_RBUTTONUP
        PUSH     [EBX].TControl.fHandle
        CALL     PostMessage
        JMP      @@2fin_false1

@@chk_TVN_BEGINDRAG:
        {$IFDEF UNICODE_CTRLS}
        CMP      word ptr [EDX].TNMTreeView.hdr.code, TVN_BEGINDRAGW
        JZ       @@event_drag
        CMP      word ptr [EDX].TNMTreeView.hdr.code, TVN_BEGINRDRAGW
        JZ       @@event_drag
        {$ENDIF UNICODE_CTRLS}
        CMP      word ptr [EDX].TNMTreeView.hdr.code, TVN_BEGINDRAG
        JZ       @@event_drag
        CMP      word ptr [EDX].TNMTreeView.hdr.code, TVN_BEGINRDRAG
        JNZ      @@chk_BEGINLABELEDIT
@@event_drag:
        MOV      EDX, [EDX].TNMTreeView.itemNew.hItem
@@event_call:
        MOV      ECX, [EAX].TMethod.Code
        JECXZ    @@2fin_false1
        MOV      EAX, [EAX].TMethod.Data
        XCHG     EBX, ECX
        XCHG     EDX, ECX
        CALL     EBX
@@2fin_false1:   JMP      @@fin_false
@@chk_BEGINLABELEDIT:
        LEA      EAX, [EBX].TControl.fOnTVBeginEdit
        {$IFDEF UNICODE_CTRLS}
        CMP      word ptr [EDX].TNMTreeView.hdr.code, TVN_BEGINLABELEDITW
        JZ       @@beginlabeledit
        {$ENDIF UNICODE_CTRLS}
        CMP      word ptr [EDX].TNMTreeView.hdr.code, TVN_BEGINLABELEDIT
        JNZ      @@chk_ITEMEXPANDED //@@chk_DELETEITEM
@@beginlabeledit:

        CMP      [EBX].TControl.fDragging, 0
        JZ       @@allow_LABELEDIT
        XOR      EAX, EAX
        INC      EAX
        MOV      [ECX], EAX
        JMP      @@ret_true

@@allow_LABELEDIT:
        PUSH     ECX // @Rslt

        MOV      ECX, [EAX].TMethod.Code
        JECXZ    @@2fin_false1
        PUSH     EBX
        XCHG     EBX, ECX
        MOV      EDX, [EDX].TTVDispInfo.item.hItem
        XCHG     EDX, ECX
        MOV      EAX, [EAX].TMethod.Data
        CALL     EBX
        TEST     AL, AL
        SETZ     AL        // Rslt := not event result;
        POP      EBX
        JZ       @@ret_EAX
        INC      [EBX].TControl.fEditing
        JMP      @@ret_EAX

@@call_EBX:
        CALL     EBX
@@2fin_false:
        JMP      @@fin_false
@@chk_ITEMEXPANDED:
        LEA      EAX, [EBX].TControl.fOnTVExpanded
        {$IFDEF UNICODE_CTRLS}
        CMP      word ptr [EDX].TNMTreeView.hdr.code, TVN_ITEMEXPANDEDW
        JZ       @@itemexpanded
        {$ENDIF UNICODE_CTRLS}
        CMP      word ptr [EDX].TNMTreeView.hdr.code, TVN_ITEMEXPANDED
        JNZ      @@chk_SELCHANGING
@@itemexpanded:
        MOV      ECX, [EAX].TMethod.Code
        JECXZ    @@2fin_false
        CMP      [EDX].TNMTreeView.action, TVE_EXPAND
        PUSH     ECX
        SETZ     CL
        XCHG     ECX, [ESP]
        JMP      @@event_drag
@@chk_SELCHANGING:
        CMP      word ptr [EDX].TNMTreeView.hdr.code, TVN_SELCHANGING
        JNE      @@chk_ITEMEXPANDING
        XCHG     EAX, ECX
        MOV      ECX, [EBX].TControl.fOnTVSelChanging.TMethod.Code
@@2fin_false2:
        JECXZ    @@2fin_false
        PUSH     EAX  //@Rslt
        PUSH     [EDX].TNMTreeView.itemNew.hItem
        XCHG     ECX, EBX //EBX=OnTVSelChanging.Code ECX=Sender
        XCHG     ECX, EDX //EDX=Sender ECX=Msg
        MOV      ECX, [ECX].TNMTreeView.itemOld.hItem
        MOV      EAX, [EDX].TControl.fOnTVSelChanging.TMethod.Data
        JMP      @@111

@@chk_ITEMEXPANDING:
        {$IFDEF UNICODE_CTRLS}
        CMP      word ptr [EDX].TNMTreeView.hdr.code, TVN_ITEMEXPANDINGW
        JZ       @@itemexpanding
        {$ENDIF UNICODE_CTRLS}
        CMP      word ptr [EDX].TNMTreeView.hdr.code, TVN_ITEMEXPANDING
        JNE      @@chk_ENDLABELEDIT
@@itemexpanding:
        XCHG     EAX, ECX
        MOV      ECX, [EBX].TControl.fOnTVExpanding.TMethod.Code
        JECXZ    @@2fin_false2
        PUSH     EAX // @Rslt
        CMP      [EDX].TNMTreeView.action, TVE_EXPAND
        PUSH     ECX
        SETZ     CL
        XCHG     ECX, [ESP]
        XCHG     ECX, EBX  //EBX=OnTVExpanding.Code ECX=Seneder
        XCHG     EDX, ECX  //ECX=Msg EDX=Sender
        MOV      ECX, [ECX].TNMTreeView.itemNew.hItem //ECX=Item
        MOV      EAX, [EDX].TControl.fOnTVExpanding.TMethod.Data //EAX=object
@@111:
        CALL     EBX
        TEST     EAX, EAX
        SETZ     AL        // Rslt := not event result;
@@ret_EAX:
        POP      EDX //EDX=@Rslt
        MOVZX    EAX, AL
        NEG      EAX
        MOV      [EDX], EAX
@@ret_true:
        MOV      AL, 1
        POP      EBX
        RET
@@chk_ENDLABELEDIT:
        {$IFDEF UNICODE_CTRLS}
        CMP      word ptr [EDX].TNMTreeView.hdr.code, TVN_ENDLABELEDITW
        JZ       @@endlabeledit
        {$ENDIF UNICODE_CTRLS}
        CMP      word ptr [EDX].TNMTreeView.hdr.code, TVN_ENDLABELEDIT
        JNZ      @@chk_SELCHANGED
@@endlabeledit:
        MOV      [EBX].TControl.fEditing, 0
        XCHG     EAX, ECX
        MOV      ECX, [EBX].TControl.fOnTVEndEdit.TMethod.Code
        JECXZ    @@ret_1
        PUSH     EAX
        PUSH     EBX
        PUSH     0

        XCHG     EDX, EBX
        MOV      EAX, [EBX].TTVDispInfo.item.pszText
        PUSH     EDX
        PUSH     ECX
        XCHG     EAX, EDX
        {$IFDEF UNICODE_CTRLS}
        CMP      [EBX].TNMTreeView.hdr.code, TVN_ENDLABELEDITW
        JNZ      @@endlabeleditA
        CALL     TControl.TVGetItemTextW
        JMP      @@NewTxt_ready
@@endlabeleditA:
        {$ENDIF UNICODE_CTRLS}
        TEST     EDX, EDX
        JNZ      @@prepare_NewTxt
        // NewTxt := [EDX].TControl.TVItemText[ hItem ]
        LEA      ECX, [ESP + 8]
        MOV      EDX, [EBX].TTVDispInfo.item.hItem
        CALL     TControl.TVGetItemText
        JMP      @@NewTxt_ready
@@prepare_NewTxt:
        LEA      EAX, [ESP+8]
        CALL     System.@LStrFromPChar
@@NewTxt_ready:
        POP      ECX
        POP      EDX
        POP      EAX
        PUSH     EAX
        PUSH     EAX
        MOV      EAX, [EDX].TControl.fOnTVEndEdit.TMethod.Data
        MOV      EBX, [EBX].TTVDispInfo.item.hItem
        XCHG     ECX, EBX
        CALL     EBX
        XCHG     EBX, EAX
        CALL     RemoveStr
        XCHG     EAX, EBX
        POP      EBX
        JMP      @@ret_EAX
@@ret_1:
        INC      ECX
        MOV      [EAX], ECX
        JMP      @@ret_true

@@chk_SELCHANGED:
        {$IFDEF UNICODE_CTRLS}
        CMP      word ptr [EDX].TNMTreeView.hdr.code, TVN_SELCHANGEDW
        JZ       @@selchanged
        {$ENDIF UNICODE_CTRLS}
        CMP      word ptr [EDX].TNMTreeView.hdr.code, TVN_SELCHANGED
        JNZ      @@fin_false
@@selchanged:
        XCHG     EAX, EBX
        CALL     TControl.DoSelChange

@@fin_false:
        POP      EBX
@@ret_false:
        XOR      EAX, EAX
end;
{$ELSE ASM_VERSION} //Pascal
function WndProcTreeView( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var NM: PNMTreeView;
    DI: PTVDispInfo;
    P: TPoint;
    S: String;
begin
  if Msg.message = WM_NOTIFY then
  begin
    NM := Pointer( Msg.lParam );
    case NM.hdr.code of
      NM_RCLICK:
        begin
          GetCursorPos( P );
          P := Self_.Screen2Client( P );
          PostMessage( Self_.fHandle, WM_RBUTTONUP, MK_RBUTTON or GetShiftState,
                       (P.x and $FFFF) or (P.y shl 16) );
        end;

      {$IFDEF UNICODE_CTRLS}
               TVN_BEGINDRAGW, TVN_BEGINRDRAGW,
      {$ENDIF} TVN_BEGINDRAG, TVN_BEGINRDRAG:
        if Assigned( Self_.fOnTVBeginDrag ) then
          Self_.fOnTVBeginDrag( Self_, NM.itemNew.hItem );
      TVN_BEGINLABELEDIT {$IFDEF UNICODE_CTRLS}, TVN_BEGINLABELEDITW{$ENDIF}:
      begin
        if Self_.fDragging then
        begin
          Rslt := 1; // do not allow edit while dragging
          Result := TRUE;
          Exit;
        end;
        DI := Pointer( NM );
        if Assigned( Self_.fOnTVBeginEdit ) then
        begin
          Rslt := Integer( not Self_.fOnTVBeginEdit( Self_, DI.item.hItem ) );
          if Rslt = 0 then
            Self_.fEditing := TRUE;
          Result := TRUE;
          Exit;
        end;
      end;
      TVN_ENDLABELEDIT {$IFDEF UNICODE_CTRLS}, TVN_ENDLABELEDITW {$ENDIF}:
      begin
        DI := Pointer( NM );
        if Assigned( Self_.fOnTVEndEdit ) then
        begin
          S := DI.item.pszText;
          if DI.item.pszText = nil then
          begin
            {$IFDEF UNICODE_CTRLS}
            if NM.hdr.code = TVN_ENDLABELEDITW then
              S := Self_.TVItemTextW[ DI.item.hItem ]
            else
            {$ENDIF UNICODE_CTRLS}
              S := Self_.TVItemText[ DI.item.hItem ];
          end;
          if Self_.fOnTVEndEdit( Self_, DI.item.hItem, S )
            then Rslt := 1
            else Rslt := 0;
        end
        else
          Rslt := 1;
        Self_.fEditing := FALSE;
        Result := True;
        Exit;
      end;
      TVN_ITEMEXPANDING {$IFDEF UNICODE_CTRLS}, TVN_ITEMEXPANDINGW {$ENDIF}:
      begin
        if Assigned( Self_.fOnTVExpanding ) then
        begin
          Rslt := Integer( not Self_.fOnTVExpanding( Self_, NM.itemNew.hItem,
                               NM.action = TVE_EXPAND ) );
          Result := TRUE;
          Exit;
        end;
      end;
      TVN_ITEMEXPANDED {$IFDEF UNICODE_CTRLS}, TVN_ITEMEXPANDEDW {$ENDIF}:
        if Assigned( Self_.fOnTVExpanded ) then
          Self_.fOnTVExpanded( Self_, NM.itemNew.hItem, NM.action=TVE_EXPAND );
      {TVN_DELETEITEM:
        if Assigned( Self_.fOnTVDelete ) then
          Self_.fOnTVDelete( Self_, NM.itemOld.hItem );}
      //------------------ by Sergey Shisminzev:
      TVN_SELCHANGING {$IFDEF UNICODE_CTRLS}, TVN_SELCHANGINGW {$ENDIF}:
        begin
          if Assigned( Self_.fOnTVSelChanging ) then
          begin
            Rslt := Integer( not Self_.fOnTVSelChanging( Self_, NM.itemOld.hItem, NM.itemNew.hItem ) );
            Result := TRUE;
            Exit;
          end;
        end;
      //----------------------------------------
      TVN_SELCHANGED {$IFDEF UNICODE_CTRLS}, TVN_SELCHANGEDW {$ENDIF}:
        Self_.DoSelChange;
    end;
  end;
  Result := False;
end;
{$ENDIF ASM_VERSION}
//[END WndProcTreeView]

//[function ProcTVDeleteItem]
function ProcTVDeleteItem( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var NM: PNMTreeView;
begin
  if Msg.message = WM_NOTIFY then
  begin
    NM := Pointer( Msg.lParam );
    case NM.hdr.code of
    TVN_DELETEITEM:
        if Assigned( Self_.fOnTVDelete ) then
          Self_.fOnTVDelete( Self_, NM.itemOld.hItem );
    end;
  end;
  Result := FALSE;
end;

//[procedure ClearTreeView]
procedure ClearTreeView( TV: PControl );
begin
  TV.TVDelete( TVI_ROOT );
end;

const
  TreeViewActions: TCommandActions = (
    aClear: ClearTreeView;
    aAddText: nil;
    aClick: 0;
    aEnter: 0;
    aLeave: 0;
    aChange: TVN_ENDLABELEDIT;
    aSelChange: TVN_SELCHANGED;
    aGetCount: TVM_GETCOUNT;
    aSetCount: 0;
    aGetItemLength: 0;
    aGetItemText: 0;
    aSetItemText: 0;
    aGetItemData: 0;
    aSetItemData: 0;
    aAddItem: 0;
    aDeleteItem: 0;
    aInsertItem: 0;
    aFindItem: 0;
    aFindPartial: 0;
    aItem2Pos: 0;
    aPos2Item: 0;
    aGetSelCount: 0;
    aGetSelected: 0;
    aGetSelRange: 0;
    aExGetSelRange: 0;
    aGetCurrent: 0;
    aSetSelected: 0;
    aSetCurrent: 0;
    aSetSelRange: 0;
    aExSetSelRange: 0;
    aGetSelection: 0;
    aReplaceSel: 0;
    aTextAlignLeft: 0;
    aTextAlignRight: 0;
    aTextAlignCenter: 0;
    aTextAlignMask: 0;
    aVertAlignCenter: 0;
    aVertAlignTop: 0;
    aVertAlignBottom: 0;
    aDir: CB_DIR;
    aSetLimit: 0;
    aSetImgList: TVM_SETIMAGELIST;
    aAutoSzX: 0;
    aAutoSzY: 0;
    aSetBkColor: TVM_SETBKCOLOR;
  );

const
  TreeViewFlags: array[ TTreeViewOption ] of Integer = ( not TVS_HASLINES, TVS_LINESATROOT,
                 not TVS_HASBUTTONS, TVS_EDITLABELS, not TVS_SHOWSELALWAYS,
                  not TVS_DISABLEDRAGDROP, TVS_NOTOOLTIPS, TVS_CHECKBOXES,
                  TVS_TRACKSELECT, TVS_SINGLEEXPAND, TVS_INFOTIP,
                  TVS_FULLROWSELECT, TVS_NOSCROLL, TVS_NONEVENHEIGHT );

{$IFDEF USE_CONSTRUCTORS}
//[function NewTreeView]
function NewTreeView( AParent: PControl; Options: TTreeViewOptions;
                      ImgListNormal, ImgListState: PImageList ): PControl;
begin
  new( Result, CreateTreeView( AParent, Options, ImgListNormal, ImgListState ) );
end;
{$ELSE not_USE_CONSTRUCTORS}

//[FUNCTION NewTreeView]
{$IFDEF ASM_VERSION}
function NewTreeView( AParent: PControl; Options: TTreeViewOptions;
                      ImgListNormal, ImgListState: PImageList ): PControl;
asm     //cmd    //opd
        PUSH     EBX
        PUSH     ECX
        PUSH     EAX
        PUSH     EDX
        MOV      EAX, ESP
        MOV      EDX, offset[TreeViewFlags]
        XOR      ECX, ECX
        MOV      CL, 13
        CALL     MakeFlags
        POP      EDX
        OR       EAX, WS_VISIBLE or WS_CHILD or WS_TABSTOP
        XCHG     ECX, EAX
        POP      EAX
        MOV      EDX, offset[WC_TREEVIEW]
        PUSH     1
        PUSH     offset[TreeViewActions]
        CALL     _NewCommonControl
        MOV      EBX, EAX
        MOV      [EBX].TControl.fCreateWndExt, offset[ApplyImageLists2Control]
        MOV      [EBX].TControl.fColor, clWindow
        MOV      EDX, offset[WndProcTreeView]
        CALL     TControl.AttachProc
        ADD      [EBX].TControl.fBoundsRect.Right, 150-64
        ADD      [EBX].TControl.fBoundsRect.Bottom, 200-64
        MOV      EAX, EBX
        XOR      EDX, EDX
        MOV      DL, 32
        POP      ECX // ImageListNormal
        CALL     TControl.SetImgListIdx
        MOV      EAX, EBX
        XOR      EDX, EDX
        MOV      ECX, [ImgListState]
        CALL     TControl.SetImgListIdx
        MOV      byte ptr [EBX].TControl.fLookTabKeys, 1
        XCHG     EAX, EBX
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function NewTreeView( AParent: PControl; Options: TTreeViewOptions;
                      ImgListNormal, ImgListState: PImageList ): PControl;
var Flags: Integer;
begin
  Flags := MakeFlags( @Options, TreeViewFlags );
  Result := _NewCommonControl( AParent, WC_TREEVIEW, Flags or WS_VISIBLE or
            WS_CHILD or WS_TABSTOP, True, @TreeViewActions );
  Result.fCreateWndExt := ApplyImageLists2Control;
  Result.fColor := clWindow;
  Result.AttachProc( WndProcTreeView );
  with Result.fBoundsRect do
  begin
    Right := Left + 150;
    Bottom := Top + 200;
  end;
  Result.ImageListNormal := ImgListNormal;
  Result.ImageListState := ImgListState;
  //Result.fLVTextBkColor := clWindow;
  Result.fLookTabKeys := [ tkTab ];
end;
{$ENDIF ASM_VERSION}
//[END NewTreeView]

{$ENDIF USE_CONSTRUCTORS}

//===================== Tab Control ========================//

//[FUNCTION WndProcTabControl]
{$IFDEF ASM_VERSION}
function WndProcTabControl( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
asm     //cmd    //opd
        PUSH     EBP
        PUSH     EBX
        PUSH     ESI
        PUSH     EDI
        MOV      EBX, EAX
        CMP      word ptr [EDX].TMsg.message, WM_NOTIFY
        JNZ      @@chk_WM_SIZE
        MOV      EDX, [EDX].TMsg.lParam
        CMP      word ptr [EDX].TNMHdr.code, TCN_SELCHANGE
        JNZ      @@ret_false

        CALL     TControl.GetCurIndex
        XCHG     EDI, EAX
        CMP      EDI, [EBX].TControl.fCurIndex
        PUSHFD   // WasActive = ZF

        MOV      [EBX].TControl.FCurIndex, EDI

        MOV      EAX, EBX
        CALL     TControl.GetItemsCount
        XCHG     ESI, EAX // ESI := Self_.Count

@@loo:  DEC      ESI
        JS       @@e_loo
        MOV      EDX, ESI
        MOV      EAX, EBX
        CALL     TControl.GetPages

        CMP      ESI, EDI
        PUSH     EAX
        SETZ     DL
        CALL     TControl.SetVisible
        POP      EAX
        CMP      ESI, EDI
        JNE      @@nx_loo
        CALL     TControl.BringToFront
@@nx_loo:
        JMP      @@loo
@@e_loo:
        MOV      EAX, EBX
        CALL     TControl.ParentForm
        TEST     EAX, EAX
        JZ       @@1
        MOV      ECX, [EAX].TControl.fCurrentControl
        JECXZ    @@1
        MOV      EAX, EBX
        MOV      DL, 1
        CALL     TControl.SetFocused
        MOV      EAX, EBX
        CALL     TControl.Invalidate
        TEST     byte ptr [EBX].TControl.fStyle+1, $10
        JNZ      @@1
        MOV      EAX, EBX
        XOR      EDX, EDX
        MOV      DL, VK_TAB
        CALL     TControl.GotoControl
@@1:
        POPFD
        JZ       @@ret_false

        MOV      ECX, [EBX].TControl.fOnSelChange.TMethod.Code
        JECXZ    @@ret_false
        MOV      EDX, EBX
        MOV      EAX, [EBX].TControl.fOnSelChange.TMethod.Data
        CALL     ECX
        JMP      @@ret_false
@@chk_WM_SIZE:
        CMP      word ptr [EDX].TMsg.message, WM_SIZE
        JNE      @@ret_false
        ADD      ESP, -16
        PUSH     ESP
        PUSH     [EBX].TControl.fHandle
        CALL     Windows.GetClientRect
        PUSH     ESP
        PUSH     0
        PUSH     TCM_ADJUSTRECT
        PUSH     EBX
        CALL     TControl.Perform
        MOV      EAX, EBX
        CALL     TControl.GetItemsCount
        XCHG     ESI, EAX
@@loo2:
        DEC      ESI
        JS       @@e_loo2
        MOV      EDX, ESI
        MOV      EAX, EBX
        CALL     TControl.GetPages
        MOV      EDX, ESP
        CALL     TControl.SetBoundsRect
        JMP      @@loo2
@@e_loo2:
        ADD      ESP, 16
@@ret_false:
        XOR      EAX, EAX
        POP      EDI
        POP      ESI
        POP      EBX
        POP      EBP
end;
{$ELSE ASM_VERSION} //Pascal
function WndProcTabControl( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var Hdr: PNMHdr;
    Page: PControl;
    I, A: Integer;
    R: TRect;
    Form: PControl;
    WasActive: Boolean;
begin
  case Msg.message of
    WM_NOTIFY:
      begin
        Hdr := Pointer( Msg.lParam );
        case Hdr.code of
        TCN_SELCHANGE:
          begin
            A := Self_.Perform( TCM_GETCURSEL, 0, 0 );
            WasActive := Self_.fCurIndex = A;
            Self_.fCurIndex := A;
            for I := 0 to Self_.Count - 1 do
            begin
              Page := Self_.Pages[ I ];
              Page.Visible := A = I;
              if A = I then
                Page.BringToFront;
            end;
            Form := Self_.ParentForm;
            if Form <> nil then
            begin
              if Form.fCurrentControl <> nil then
              begin
                Self_.Focused := True;
                Self_.Invalidate;
                if not Longbool( Self_.fStyle and TCS_FOCUSONBUTTONDOWN ) then
                  Self_.GotoControl( VK_TAB );
              end;
            end;
            if not WasActive then
            if Assigned( Self_.fOnSelChange ) then
              Self_.fOnSelChange( Self_ );
            //Result := True;
          end;
        end;
      end;
    WM_SIZE:
      begin
        GetClientRect( Self_.fHandle, R );
        Self_.Perform( TCM_ADJUSTRECT, 0, Integer( @R ) );
        for I := 0 to Self_.Count - 1 do
        begin
          Page := Self_.Pages[ I ];
          Page.BoundsRect := R;
        end;
      end;
  end;
  Result := False;
end;
{$ENDIF ASM_VERSION}
//[END WndProcTabControl]

const
  TabControlActions: TCommandActions = (
    aClear: ClearText;
    aAddText: nil;
    aClick: 0;
    aEnter: 0;
    aLeave: 0;
    aChange: TCN_SELCHANGE;
    aSelChange: TCN_SELCHANGE;
    aGetCount: TCM_GETITEMCOUNT;
    aSetCount: 0;
    aGetItemLength: 0;
    aGetItemText: 0;
    aSetItemText: 0;
    aGetItemData: 0;
    aSetItemData: 0;
    aAddItem: 0;
    aDeleteItem: 0;
    aInsertItem: 0;
    aFindItem: 0;
    aFindPartial: 0;
    aItem2Pos: 0;
    aPos2Item: 0;
    aGetSelCount: 0;
    aGetSelected: 0;
    aGetSelRange: 0;
    aExGetSelRange: 0;
    aGetCurrent: TCM_GETCURSEL;
    aSetSelected: 0;
    aSetCurrent: TCM_SETCURSEL; //TCM_SETCURFOCUS;
    aSetSelRange: 0;
    aExSetSelRange: 0;
    aGetSelection: 0;
    aReplaceSel: 0;
    aTextAlignLeft: 0;
    aTextAlignRight: 0;
    aTextAlignCenter: 0;
    aTextAlignMask: 0;
    aVertAlignCenter: 0;
    aVertAlignTop: 0;
    aVertAlignBottom: 0;
    aDir: CB_DIR;
    aSetLimit: 0;
    aSetImgList: TCM_SETIMAGELIST;
    aAutoSzX: 0;
    aAutoSzY: 0;
    aSetBkColor: 0;
  );

const TabControlFlags: array[ TTabControlOption ] of Integer = ( TCS_BUTTONS,
           TCS_FIXEDWIDTH, not TCS_FOCUSNEVER,
           TCS_FIXEDWIDTH or TCS_FORCEICONLEFT, TCS_FIXEDWIDTH or TCS_FORCELABELLEFT,
           TCS_MULTILINE, TCS_MULTISELECT, TCS_RIGHTJUSTIFY, TCS_SCROLLOPPOSITE,
           TCS_BOTTOM, TCS_VERTICAL, TCS_FLATBUTTONS, TCS_HOTTRACK, 0, TCS_OWNERDRAWFIXED );

{$IFDEF USE_CONSTRUCTORS}
//[function NewTabControl]
function NewTabControl( AParent: PControl; Tabs: array of String; Options: TTabControlOptions;
         ImgList: PImageList; ImgList1stIdx: Integer ): PControl;
begin
  new( Result, CreateTabControl( AParent, Tabs, Options, ImgList, ImgList1stIdx ) );
end;
//[END NewTabControl]
{$ELSE not_USE_CONSTRUCTORS}

//[FUNCTION NewTabControl]
{$IFDEF ASM_VERSION}
function NewTabControl( AParent: PControl; Tabs: array of String; Options: TTabControlOptions;
         ImgList: PImageList; ImgList1stIdx: Integer ): PControl;
asm     //cmd    //opd
        PUSH     EBX
        PUSH     ESI
        PUSH     EDI
        XCHG     EBX, EAX
        PUSH     EDX
        PUSH     ECX
        LEA      EAX, [Options]
        MOV      EDX, offset[TabControlFlags]
        XOR      ECX, ECX
        MOV      CL, 13
        CALL     MakeFlags
        TEST     byte ptr [Options], 4
        JZ       @@0
        OR       EAX, WS_TABSTOP or TCS_FOCUSONBUTTONDOWN
@@0:    OR       EAX, WS_CHILD or WS_CLIPSIBLINGS or WS_CLIPCHILDREN or WS_VISIBLE
        XCHG     ECX, EAX
        XCHG     EAX, EBX
        MOV      EDX, offset[WC_TABCONTROL]
        PUSH     1
        PUSH     offset[TabControlActions]
        CALL     _NewCommonControl
        MOV      EBX, EAX
        TEST     [Options], 2 shl (tcoBorder - 1)
        JNZ      @@borderfixed
        AND      [EBX].TControl.fExStyle, not WS_EX_CLIENTEDGE
@@borderfixed:
        MOV      EDX, offset[WndProcTabControl]
        CALL     TControl.AttachProc
        ADD      [EBX].TControl.fBoundsRect.Right, 100-64
        ADD      [EBX].TControl.fBoundsRect.Bottom, 100-64
        MOV      ECX, [ImgList]
        JECXZ    @@2
        XCHG     EAX, ECX
        CALL     TImageList.GetHandle
        PUSH     EAX
        PUSH     0
        PUSH     TCM_SETIMAGELIST
        PUSH     EBX
        CALL     TControl.Perform
@@2:
        POP      EDI // EDI = High(Tabs)
        POP      ESI // ESI = Tabs
        XOR      EDX, EDX // EBP := 0 (=I)
        MOV      EAX, [ImgList1stIdx] //(=II)
@@loop:
        CMP      EDX, EDI
        JG       @@e_loop
        PUSH     EAX
        PUSH     EDX
        PUSH     EAX
        LODSD
        XCHG     ECX, EAX
        MOV      EAX, EBX
        CALL     TControl.TC_Insert
        POP      EDX
        POP      EAX
        INC      EAX
        INC      EDX
        JMP      @@loop
@@e_loop:
        MOV      byte ptr [EBX].TControl.fLookTabKeys, 1
        XCHG     EAX, EBX
        POP      EDI
        POP      ESI
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function NewTabControl( AParent: PControl; Tabs: array of String; Options: TTabControlOptions;
         ImgList: PImageList; ImgList1stIdx: Integer ): PControl;
var I, II : Integer;
    Flags: Integer;
begin
  Flags := MakeFlags( @Options, TabControlFlags );
  if tcoFocusTabs in Options then
    Flags := Flags or (WS_TABSTOP or TCS_FOCUSONBUTTONDOWN);
  Result := _NewCommonControl( AParent, WC_TABCONTROL,
            Flags or (WS_CHILD or WS_CLIPSIBLINGS or WS_CLIPCHILDREN or WS_VISIBLE), True,
            @TabControlActions );
  //***
  if not( tcoBorder in Options ) then
  begin
    Result.fExStyle := Result.fExStyle and not WS_EX_CLIENTEDGE;
  end;
  Result.AttachProc( WndProcTabControl );
  with Result.fBoundsRect do
  begin
    Right := Left + 100;
    Bottom := Top + 100;
  end;
  if ImgList <> nil then
    Result.Perform( TCM_SETIMAGELIST, 0, ImgList.Handle );
  II := ImgList1stIdx;
  for I := 0 to High( Tabs ) do
  begin
    Result.TC_Insert( I, Tabs[ I ], II );
    Inc( II );
  end;
  Result.fLookTabKeys := [ tkTab ];
end;
{$ENDIF ASM_VERSION}
//[END NewTabControl]

{$ENDIF USE_CONSTRUCTORS}

//===================== Tool bar ========================//

//[FUNCTION WndProcToolbarCtr]
{$IFDEF ASM_noVERSION} //TTN_NEEDTEXTW
function WndProcToolbarCtrl(Self_: PControl; var Msg: TMsg; var Rslt: Integer): Boolean;
asm
        CMP      word ptr [EDX].TMsg.message, WM_WINDOWPOSCHANGED
        JNE      @@chk_CM_COMMAND
        MOV      dword ptr [ECX], 0 // Rslt := 0
        MOV      ECX, [EAX].TControl.fOnResize.TMethod.Code
        JECXZ    @@ret_true
        XCHG     EDX, EAX           // Sender := Self_
        MOV      EAX, [EDX].TControl.fOnResize.TMethod.Data
        CALL     ECX                // Self_.fOnResize
@@ret_true:
        MOV      AL, 1              // Result := TRUE
        RET
@@chk_CM_COMMAND:
        CMP      word ptr [EDX].TMsg.message, CM_COMMAND
        JNE      @@chk_WM_NOTIFY
        MOVZX    ECX, word ptr [EDX].TMsg.wParam
        MOV      [EAX].TControl.fCurItem, ECX
        PUSH     EAX
        PUSH     0
        PUSH     ECX
        PUSH     TB_COMMANDTOINDEX
        PUSH     EAX
        CALL     TControl.Perform
        PUSH     EAX

        PUSH     VK_RETURN
        CALL     GetKeyState
        TEST     EAX, EAX
        SETL     DL
        POP      ECX
        POP      EAX
        MOV      [EAX].TControl.fCurIndex, ECX
        MOV      [EAX].TControl.fRightClick, DL
@@ret_false:
        XOR      EAX, EAX
        RET

@@chk_WM_NOTIFY:
        CMP      word ptr [EDX].TMsg.message, WM_NOTIFY
        JNE      @@ret_false
        MOV      EDX, [EDX].TMsg.lParam
        MOV      ECX, [EDX].TTooltipText.hdr.code
        CMP      ECX, TTN_NEEDTEXT
        JNE      @@chk_NM_RCLICK
        PUSH     EAX
        PUSH     EDX
        MOV      EDX, [EDX].TTooltipText.hdr.idFrom
        MOV      ECX, [EAX].TControl.fTBttCmd
        OR       EAX, -1
        JECXZ    @@idxReady
        XCHG     EAX, ECX
        CALL     TList.IndexOf
@@idxReady: // EAX = -1 or index of button tooltip
        TEST     EAX, EAX
        POP      EDX
        LEA      EDX, [EDX].TTooltipText.szText
        MOV      byte ptr [EDX], 0
        POP      ECX
        JL       @@ret_true
        MOV      ECX, [ECX].TControl.fTBttTxt
        MOV      ECX, [ECX].TStrList.fList
        MOV      ECX, [ECX].TList.fItems
        MOV      EAX, [ECX+EAX*4]
        XCHG     EAX, EDX
        XOR      ECX, ECX
        MOV      CL, 79
        CALL     StrLCopy
        JMP      @@ret_true
@@chk_NM_RCLICK:
        CMP      ECX, NM_RCLICK
        JNE      @@chk_NM_CLICK
        OR       [EAX].TControl.fRightClick, 1
        MOV      ECX, [EDX].TNMMouse.dwItemSpec
        MOV      [EAX].TControl.fCurItem, -1
        PUSH     EAX
        PUSH     0
        PUSH     ECX
        PUSH     TB_COMMANDTOINDEX
        PUSH     EAX
        CALL     TControl.Perform
        POP      EDX
        MOV      [EDX].TControl.fCurIndex, EAX
        XOR      EAX, EAX
        RET
@@chk_NM_CLICK:
        CMP      ECX, NM_CLICK
        JNE      @@chk_TBN_DROPDOWN
        MOV      [EAX].TControl.fRightClick, 0
        OR       [EAX].TControl.fCurItem, -1
        OR       [EAX].TControl.fCurIndex, -1
        CMP      [EDX].TTBNotify.iItem, -1
        SETNZ    AL
        RET
@@chk_TBN_DROPDOWN:
        CMP      ECX, TBN_DROPDOWN
        JNE      @@ret_false
        MOV      EDX, [EDX].TTBNotify.iItem
        MOV      [EAX].TControl.fCurItem, EDX
        PUSH     EAX
        CALL     TControl.TBItem2Index
        POP      EDX
        MOV      [EDX].TControl.fCurIndex, EAX
        MOV      ECX, [EDX].TControl.fOnDropDown.TMethod.Code
        JECXZ    @@ret_z
        MOV      EAX, [EDX].TControl.fOnDropDown.TMethod.Data
        CALL     ECX
@@ret_z:
        XOR      EAX, EAX
end;
{$ELSE ASM_VERSION} //Pascal
function WndProcToolbarCtrl(Self_: PControl; var Msg: TMsg; var Rslt: Integer): Boolean;
var lpttt: PTooltipText;
    idBtn, Idx: Integer;
var Notify: PTBNotify;
    Mouse: PNMMouse;
{$IFNDEF _FPC}
{$IFNDEF _D2}
var Wstr: WideString;
{$ENDIF _D2}
{$ENDIF _FPC}
begin
  Result := False;
  if Msg.message = WM_WINDOWPOSCHANGED then
  begin
    if Assigned( Self_.fOnResize ) then
      Self_.fOnResize( Self_ );
    Result := TRUE;
    Rslt := 0;
  end
  else if Msg.message = CM_COMMAND then
  begin
    Self_.fCurItem := Loword( Msg.wParam );
    Self_.fCurIndex := Self_.Perform( TB_COMMANDTOINDEX, Loword( Msg.wParam ), 0 );
    Self_.fRightClick := GetKeyState( VK_RBUTTON ) < 0;
  end
  else if Msg.message = WM_NOTIFY then
  begin
    lpttt := Pointer( Msg.lParam );
    Notify := Pointer( Msg.lParam );
    case lpttt.hdr.code of
    TTN_NEEDTEXT:
        begin
          Result := True;
          idBtn := lpttt.hdr.idFrom;
          Idx := -1;
          if Self_.fTBttCmd <> nil then
            Idx := Self_.fTBttCmd.IndexOf( Pointer( idBtn ) );
          lpttt.szText[ 0 ] := #0;
          if Idx >= 0 then
            StrLCopy( lpttt.szText, Self_.fTBttTxt.fList.fItems[ Idx ], 79 );
          Exit;
        end;
      // for Windows XP
      {$IFNDEF _FPC}
      {$IFNDEF _D2}
      TTN_NEEDTEXTW:
          begin
            Result := True;
            idBtn := lpttt.hdr.idFrom;
            Idx := -1;
            if Self_.fTBttCmd <> nil then
              Idx := Self_.fTBttCmd.IndexOf( Pointer( idBtn ) );
            FillChar( lpttt.szText[ 0 ], 160, 0 );
            if Idx >= 0 then
            begin
              WStr := Self_.fTBttTxt.Items[ Idx ];
              if WStr <> '' then
                Move( Wstr[ 1 ], lpttt.szText, Min( 158, (Length( WStr ) + 1) * 2 ) );
            end;
            Exit;
          end;
    {$ENDIF _D2}
    {$ENDIF _FPC}
    NM_RCLICK:
        begin
          Mouse := Pointer( Msg.lParam );
          Self_.fCurItem := Mouse.dwItemSpec;
          Self_.fCurIndex := Self_.Perform( TB_COMMANDTOINDEX, Mouse.dwItemSpec, 0 );
          Self_.fRightClick := GetKeyState( VK_RBUTTON ) < 0;
          Self_.fRightClick := True;
        end;
    NM_CLICK:
        begin
          Self_.fCurItem := -1; // return CurItem = -1
          Self_.fCurIndex := -1;
          Self_.fRightClick := False;
          Result := Notify.iItem <> -1;
                   // do not handle - if it will be handled in WM_COMMAND
          Exit;
        end;
    TBN_DROPDOWN:
        begin
          Self_.fCurItem := Notify.iItem;
          Self_.fCurIndex := Self_.TBItem2Index( Self_.fCurItem );
          if assigned( Self_.fOnDropDown ) then
            Self_.fOnDropDown( Self_ );
        end;
    end;
  end;
end;
{$ENDIF ASM_VERSION}
//[END WndProcToolbarCtr]

const ToolbarAligns: array[ TControlAlign ] of DWORD =
      ( CCS_NOPARENTALIGN {or CCS_NOMOVEY} {or CCS_NORESIZE} or CCS_NODIVIDER, CCS_TOP or CCS_VERT, CCS_TOP, CCS_BOTTOM or CCS_VERT, CCS_BOTTOM,
        CCS_TOP );
      ToolbarOptions: array[ TToolbarOption ] of Integer = ( TBSTYLE_LIST, not TBSTYLE_LIST,
                     TBSTYLE_FLAT, TBSTYLE_TRANSPARENT, TBSTYLE_WRAPABLE, CCS_NODIVIDER, 0 );

{$IFDEF USE_CONSTRUCTORS}
//[function NewToolbar]
function NewToolbar( AParent: PControl; Align: TControlAlign; Options: TToolbarOptions;
                     Bitmap: HBitmap; Buttons: array of PChar;
                     BtnImgIdxArray: array of Integer ) : PControl;
begin
  new( Result, CreateToolbar( AParent, Align, Options, Bitmap, Buttons, BtnImgIdxArray ) );
end;
//[END NewToolbar]
{$ELSE not_USE_CONSTRUCTORS}

//[FUNCTION NewToolbar]
{$IFDEF ASM_VERSION}
function NewToolbar( AParent: PControl; Align: TControlAlign; Options: TToolbarOptions;
                     Bitmap: HBitmap; Buttons: array of PChar;
                     BtnImgIdxArray: array of Integer ) : PControl;
const szTBButton = Sizeof( TTBButton );
      Option3DBorder = 1 shl Ord( tbo3DBorder );
asm
        MOVZX    EDX, DL
        PUSH     EDX // Align
        PUSH     EAX // AParent

        XOR      EAX, EAX
        TEST     CL, Option3DBorder
        SETNZ    AL
        PUSH     EAX

        PUSH     ECX // Options

        MOV      AL, ICC_BAR_CLASSES
        CALL     DoInitCommonControls

        MOV      EAX, ESP
        MOV      EDX, offset[ToolbarOptions]
        XOR      ECX, ECX
        MOV      CL, 5
        CALL     MakeFlags
        POP      EDX

        PUSH     0
        XCHG     ECX, EAX // ECX = MakeFlags(...)
        MOV      EAX, [ESP+8] // EAX = AParent
        MOV      EDX, [ESP+12] // EDX = Align
        OR       ECX, [EDX*4+offset ToolbarAligns]
        OR       ECX, WS_CHILD or WS_VISIBLE or TBSTYLE_TOOLTIPS
        MOV      EDX, offset[ TOOLBARCLASSNAME ]
        CALL     _NewCommonControl
        MOV      [EAX].TControl.fCommandActions.aClear, offset[ClearToolbar]
        MOV      [EAX].TControl.fCommandActions.aGetCount, TB_BUTTONCOUNT
        INC      [EAX].TControl.fIsButton
        POP      EDX // pop AParent
        POP      EDX // EDX = Align
        PUSH     EDX
        TEST     EDX, EDX
        JE       @@zero_bounds
        ADD      [EAX].TControl.fBoundsRect.Bottom, 26-64
        ADD      [EAX].TControl.fBoundsRect.Right, 1000-64
        JMP      @@bounds_ready
@@zero_bounds:
        MOV      [EAX].TControl.fBoundsRect.Left, EDX
        MOV      [EAX].TControl.fBoundsRect.Top, EDX
        MOV      [EAX].TControl.fBoundsRect.Right, EDX
        MOV      [EAX].TControl.fBoundsRect.Bottom, EDX
@@bounds_ready:
        PUSH     EBX
        PUSH     ESI
        XCHG     EBX, EAX
        MOV      ESI, offset[TControl.Perform]
        PUSH     0
        PUSH     0
        PUSH     TB_GETEXTENDEDSTYLE
        PUSH     EBX
        CALL     ESI
        OR       EAX, TBSTYLE_EX_DRAWDDARROWS
        PUSH     EAX
        PUSH     0
        PUSH     TB_SETEXTENDEDSTYLE
        PUSH     EBX
        CALL     ESI
        MOV      EDX, offset[WndProcToolbarCtrl]
        MOV      EAX, EBX
        CALL     TControl.AttachProc
        MOV      EDX, offset[WndProcDoEraseBkgnd]
        MOV      EAX, EBX
        CALL     TControl.AttachProc
        PUSH     0
        PUSH     szTBButton
        PUSH     TB_BUTTONSTRUCTSIZE
        PUSH     EBX
        CALL     ESI
        PUSH     0
        PUSH     [EBX].TControl.fMargin
        PUSH     TB_SETINDENT
        PUSH     EBX
        CALL     ESI
        MOV      EAX, [ESP+8] // Align
        {$IFDEF PARANOIA}
        DB $2C,  1
        {$ELSE}
        SUB AL, 1
        {$ENDIF}
        JL       @@bounds_correct
        JE       @@corr_right
        {$IFDEF PARANOIA}
        DB $2C,  2
        {$ELSE}
        SUB AL, 2
        {$ENDIF}
        JNE      @@corr_bottom
@@corr_right:
        MOV      EDX, [EBX].TControl.fBoundsRect.Left
        ADD      EDX, 24
        MOV      [EBX].TControl.fBoundsRect.Right, EDX
        JMP      @@bounds_correct
@@corr_bottom:
        MOV      EDX, [EBX].TControl.fBoundsRect.Top
        ADD      EDX, 22
        MOV      [EBX].TControl.fBoundsrect.Bottom, EDX
@@bounds_correct:
        MOV      EDX, [Bitmap]
        TEST     EDX, EDX
        JZ       @@bitmap_added
        MOV      EAX, EBX
        CALL     TControl.TBAddBitmap
@@bitmap_added:

        PUSH     dword ptr [BtnImgIdxArray]
        PUSH     dword ptr [BtnImgIdxArray-4]
        MOV      ECX, [Buttons-4]
        MOV      EDX, [Buttons]
        MOV      EAX, EBX
        CALL     TControl.TBAddButtons

        PUSH     0
        PUSH     0
        PUSH     WM_SIZE
        PUSH     EBX
        CALL     ESI

        XCHG     EAX, EBX
        POP      ESI
        POP      EBX
        ///POP      EDX  ///!!! next command is MOV ESP,EBP
end;
{$ELSE ASM_VERSION} //Pascal
function NewToolbar( AParent: PControl; Align: TControlAlign; Options: TToolbarOptions;
                     Bitmap: HBitmap; Buttons: array of PChar;
                     BtnImgIdxArray: array of Integer ) : PControl;
var Flags: DWORD;
begin
  if not( tboTextBottom in Options ) then
    Options := Options + [ tboTextRight ];
  if tboTextRight in Options then
    Options := Options - [ tboTextBottom ];
  Flags := MakeFlags( @Options, ToolbarOptions );
  DoInitCommonControls( ICC_BAR_CLASSES );
  Result := _NewCommonControl( AParent, TOOLBARCLASSNAME,
         (ToolbarAligns[ Align ] or WS_CHILD or WS_VISIBLE or TBSTYLE_TOOLTIPS or Flags),
         //(not (Align in [caNone])) and not (tboNoDivider in Options),  nil );
         tbo3DBorder in Options,  nil );
  Result.fCommandActions.aClear := ClearToolbar;
  Result.fCommandActions.aGetCount := TB_BUTTONCOUNT;
  Result.fIsButton := TRUE;
  with Result.fBoundsRect do
  begin
    if Align in [ caNone ] then
    begin
      Bottom := Top + 26;
      Right := Left + 1000;
    end
       else
    begin
      Left := 0; Right := 0;
      Top := 0; Bottom := 0;
    end;
  end;
  Result.AttachProc( WndProcToolbarCtrl );
  Result.AttachProc( WndProcDoEraseBkgnd );
  Result.Perform(TB_SETEXTENDEDSTYLE, 0, Result.Perform(TB_GETEXTENDEDSTYLE, 0, 0) or
      TBSTYLE_EX_DRAWDDARROWS);

  Result.Perform( TB_BUTTONSTRUCTSIZE, Sizeof( TTBButton ), 0 );
  Result.Perform( TB_SETINDENT, Result.fMargin, 0 );
  with Result.fBoundsRect do
  begin
    if Align in [ caLeft, caRight ] then
      Right := Left + 24
    else if not (Align in [caNone]) then
      Bottom := Top + 22;
  end;
  if Bitmap <> 0 then
    Result.TBAddBitmap( Bitmap );
  Result.TBAddButtons( Buttons, BtnImgIdxArray );
  Result.Perform( WM_SIZE, 0, 0 );
end;
{$ENDIF ASM_VERSION}
//[END NewToolbar]

{$ENDIF USE_CONSTRUCTORS}

//===================== RichEdit ========================//

type PENLink = ^TENLink;
     TENLink = packed record
       hdr: TNMHDR;
       msg: DWORD;
       wParam: Integer;
       lParam: Integer;
       chrg: TCHARRANGE;
     end;
  TEXTRANGEA = packed record
    chrg: TCharRange;
    lpstrText: PAnsiChar;
  end;

//[FUNCTION WndProc_RE_LinkNotify]
{$IFDEF ASM_VERSION}
function WndProc_RE_LinkNotify( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
asm
        CMP      word ptr [EDX].TMsg.message, WM_NOTIFY
        JNE      @@ret_false
        MOV      EDX, [EDX].TMsg.lParam
        CMP      [EDX].TNMHdr.code, EN_LINK
        JNE      @@ret_false
        PUSH     EBX
        PUSH     EDX
        XCHG     EBX, EAX
        XOR      EAX, EAX
        MOV      [ECX], EAX
        ADD      ESP, -1020
        PUSH     EAX
        PUSH     ESP
        PUSH     [EDX].TENLink.chrg.cpMax
        PUSH     [EDX].TENLink.chrg.cpMin
        PUSH     ESP
        PUSH     0
        PUSH     EM_GETTEXTRANGE
        PUSH     EBX
        CALL     TControl.Perform
        ADD      ESP, 12
        MOV      EDX, ESP
        LEA      EAX, [EBX].TControl.fREUrl
        CALL     System.@LStrFromPChar
        ADD      ESP, 1024
        POP      EDX
        MOV      ECX, [EDX].TENLink.msg
        LEA      EAX, [EBX].TControl.fOnREOverURL
        CMP      ECX, WM_MOUSEMOVE
        JE       @@Url_event
        LEA      EAX, [EBX].TControl.fOnREUrlClick
        CMP      ECX, WM_LBUTTONDOWN
        JE       @@Url_Event
        CMP      ECX, WM_RBUTTONDOWN
        JNE      @@after_Url_event
@@Url_event:
        MOV      ECX, [EAX].TMethod.Code
        JECXZ    @@after_Url_event
        MOV      EDX, EBX
        MOV      EAX, [EAX].TMethod.Data
        CALL     ECX
@@after_Url_event:
        POP      EBX
        MOV      AL, 1
        RET
@@ret_false:
        XOR      EAX, EAX
end;
{$ELSE ASM_VERSION} //Pascal
function WndProc_RE_LinkNotify( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var Link: PENLink;
    Range: TextRangeA;
    Buffer: array[ 0..1023 ] of Char;
begin
  Result := False;
  if (Msg.message = WM_NOTIFY) and (PNMHdr( Msg.lParam ).code = EN_LINK) then
  begin
    Link := Pointer( Msg.lParam );
    Range.chrg := Link.chrg;
    Range.lpstrText := @Buffer[ 0 ]; //Pchar( @Buffer[ 0 ] );
    Buffer[ 0 ] := #0;
    Self_.Perform( EM_GETTEXTRANGE, 0, Integer( @Range ) );
    Self_.fREUrl := Buffer;
    case Link.msg of
    WM_MOUSEMOVE:
      if assigned( Self_.fOnREOverURL ) then
        Self_.fOnREOverURL( Self_ );
    WM_LBUTTONDOWN, WM_RBUTTONDOWN:
      if assigned( Self_.fOnREUrlClick ) then
        Self_.fOnREUrlClick( Self_ );
    end;
    Rslt := 0;
    Result := TRUE;
  end;
end;
{$ENDIF ASM_VERSION}
//[END WndProc_RE_LinkNotify]

var Global_DisableParentCursor: Boolean;

//[FUNCTION WndProcRichEditNotify]
{$IFDEF ASM_noVERSION}
function WndProcRichEditNotify( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
const int_IDC_ARROW = integer( IDC_ARROW );
asm
        CMP      word ptr [EDX].TMsg.message, WM_NOTIFY
        JNE      @@ret_false                           {YS}
//        JNE      @@chk_WM_SETCURSOR                  {YS}
        MOV      EDX, [EDX].TMsg.lParam
        CMP      [EDX].TNMHdr.code, EN_SELCHANGE
        JNE      @@ret_false
        //PUSH     EAX
        CALL     TControl.DoSelChange
        //POP      EAX
        {CMP      [EAX].TControl.fTransparent, 0
        JZ       @@ret_false
        CALL     TControl.Invalidate}
@@ret_false:
        XOR      EAX, EAX
        RET
{ //YS
@@chk_WM_SETCURSOR:
        CMP      word ptr [EDX].TMsg.message, WM_SETCURSOR
        JNE      @@ret_false
        PUSH     EBX
        MOV      EBX, EAX
        PUSH     ECX
        PUSH     EDX
        INC      [Global_DisableParentCursor]
        CALL     TControl.CallDefWndProc
        DEC      [Global_DisableParentCursor]
        POP      EDX
        MOVZX    EDX, word ptr [EDX].TMsg.lParam
        POP      ECX
        MOV      [ECX], EAX
        TEST     EAX, EAX
        MOV      EAX, [EBX].TControl.fCursor
        POP      EBX
        JNZ      @@ret_true
        INC      dword ptr [ECX]
        CMP      EDX, HTCLIENT
        JE       @@set_cursor
        CMP      EDX, HTVSCROLL
        JE       @@set_arrow_cursor
        CMP      EDX, HTHSCROLL
        JNE      @@ret_false
@@set_arrow_cursor:
        PUSH     int_IDC_ARROW
        PUSH     0
        CALL     LoadCursor
@@set_cursor:
        PUSH     EAX
        CALL     Windows.SetCursor
@@ret_true:
        MOV      AL, 1
}
end;
{$ELSE ASM_VERSION} //Pascal
function WndProcRichEditNotify( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var NMhdr: PNMHdr;
//    TestCode: Integer;
    {FR: TFormatRange;
    I: Integer;
    R: TRect;
    LogX, LogY: Integer;}
begin
  Result := False;
  if Msg.message = WM_NOTIFY then
  begin
    NMHdr := Pointer( Msg.lParam );
    case NMHdr.code of
    EN_SELCHANGE:
      begin
        Self_.DoSelChange;
        if Self_.fTransparent then
          Self_.Invalidate;
      end;
    end;
  end
{ // YS
     else
  if Msg.message = WM_SETCURSOR then
  begin
    Result := True;
    TestCode := LoWord( Msg.lParam );
    Global_DisableParentCursor := True;
    Rslt := Self_.CallDefWndProc( Msg );
    Global_DisableParentCursor := False;
    if Rslt = 0 then
    begin
      Rslt := 1;
      case TestCode of
      HTVSCROLL, HTHSCROLL: Windows.SetCursor( LoadCursor( 0, IDC_ARROW ) );
      HTCLIENT: Windows.SetCursor( Self_.fCursor );
      else Result := False;
      end;
    end;
  end;
}
end;
{$ENDIF ASM_VERSION}
//[END WndProcRichEditNotify]

const
  RichEditActions: TCommandActions = (
    aClear: ClearText;
    aAddText: nil;
    aClick: 0;
    aEnter: EN_SETFOCUS;
    aLeave: EN_KILLFOCUS;
    aChange: EN_CHANGE;
    aSelChange: EN_SELCHANGE;
    aGetCount: EM_GETLINECOUNT;
    aSetCount: 0;
    aGetItemLength: EM_LINELENGTH;
    aGetItemText: EM_GETLINE;
    aSetItemText: EM_REPLACESEL;
    aGetItemData: 0;
    aSetItemData: 0;
    aAddItem: 0;
    aDeleteItem: 0;
    aInsertItem: 0;
    aFindItem: 0;
    aFindPartial: 0;
    aItem2Pos: EM_LINEINDEX;
    aPos2Item: EM_LINEFROMCHAR;
    aGetSelCount: 0; //EM_EXGETSEL;
    aGetSelected: 0;
    aGetSelRange: 0;
    aExGetSelRange: EM_EXGETSEL;
    aGetCurrent: EM_LINEINDEX;
    aSetSelected: 0;
    aSetCurrent: 0;
    aSetSelRange: 0;
    aExSetSelRange: EM_EXSETSEL;
    aGetSelection: EM_GETSELTEXT;
    aReplaceSel: EM_REPLACESEL;
    aTextAlignLeft: ES_LEFT;
    aTextAlignRight: ES_RIGHT;
    aTextAlignCenter: ES_CENTER;
    aTextAlignMask: 0;
    aVertAlignCenter: 0;
    aVertAlignTop: 0;
    aVertAlignBottom: 0;
    aDir: 0;
    aSetLimit: EM_EXLIMITTEXT;
    aSetImgList: 0;
    aAutoSzX: 0;
    aAutoSzY: 0;
    aSetBkColor: EM_SETBKGNDCOLOR;
  );

var FRichEditModule: Integer;
    RichEditClass: PChar = 'RichEdit20A';
    RichEditLib: PChar = 'RICHED32.DLL';

const RichEditLibnames: array[ 0..2 ] of PChar =
      ( 'RICHED20.DLL', 'RICHED32.DLL', 'RICHED.DLL' );
const RichEditflags: array [ TEditOption ] of Integer = (
                  not (es_AutoHScroll or WS_HSCROLL),
                  not (es_AutoVScroll or WS_VSCROLL),
                  0 {es_Lowercase - not supported},
                  0 {es_Multiline - RichEdit always multiline},
                  es_NoHideSel,
                  0 {es_OemConvert - not suppoted},
                  0 {es_Password - not supported},
                  es_Readonly,
                  0 {es_UpperCase - not supported},
                  es_WantReturn, 0, es_Number );

{$IFDEF USE_CONSTRUCTORS}
//[function NewRichEdit1]
function NewRichEdit1( AParent: PControl; Options: TEditOptions ): PControl;
begin
  new( Result, CreateRichEdit1( AParent, Options ) );
end;
//[END NewRichEdit1]
{$ELSE not_USE_CONSTRUCTORS}

//[FUNCTION NewRichEdit1]
{$IFDEF ASM_VERSION}
const RichEditClass10: array[0..8] of Char = ('R','i','c','h','E','d','i','t',#0);
function NewRichEdit1( AParent: PControl; Options: TEditOptions ): PControl;
asm
        PUSH     EDX

        MOV      ECX, [FRichEditModule]
        INC      ECX
        LOOP     @@loaded
        PUSHAD
        MOV      BL, 3
        LEA      ESI, [RichEditLibNames]
@@loo:
        LODSD
        PUSH     EAX
        CALL     LoadLibrary
        CMP      EAX, HINSTANCE_ERROR
        JG       @@break
        MOV      [RichEditClass], offset[RichEditClass10]
        DEC      BL
        JNZ      @@loo
        JMP      @@fault
@@break:
        MOV      [FRichEditModule], EAX
@@fault:
        POPAD
@@loaded:
        PUSH     EAX
        PUSH     EDX
        MOV      EAX, ESP
        MOV      EDX, offset[RichEditFlags]
        XOR      ECX, ECX
        MOV      CL, 10
        CALL     MakeFlags
        XCHG     ECX, EAX
        POP      EDX
        POP      EAX
        PUSH     1
        PUSH     offset[RichEditActions]
        MOV      EDX, [RichEditClass]
        OR       ECX, WS_VISIBLE or WS_CHILD or WS_TABSTOP or WS_BORDER or ES_MULTILINE
        CALL     _NewCommonControl
        INC      [EAX].TControl.fIgnoreDefault
        POP      EDX
        TEST     DH, 4 // is eoWantTab in Options ?
        SETZ     DL
        MOV      [EAX].TControl.fLookTabKeys, DL
        PUSH     EBX
        MOV      EBX, EAX
        MOV      EDX, offset[WndProcRichEditNotify]
        CALL     TControl.AttachProc
        MOV      [EBX].TControl.fDoubleBuffered, 0
        INC      [EBX].TControl.fCannotDoubleBuf
        ADD      [EBX].TControl.fBoundsRect.Right, 100-64
        ADD      [EBX].TControl.fBoundsRect.Bottom, 200-64
        PUSH     ENM_CHANGE or ENM_SELCHANGE or ENM_REQUESTRESIZE or ENM_PROTECTED or $04000000
        PUSH     0
        PUSH     EM_SETEVENTMASK
        PUSH     EBX
        CALL     TControl.Perform
        MOV      EAX, clWindow
        MOV      [EBX].TControl.fColor, EAX
        CALL     Color2RGB
        PUSH     EAX
        PUSH     0
        PUSH     EM_SETBKGNDCOLOR
        PUSH     EBX
        CALL     TControl.Perform
        XCHG     EAX, EBX
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function NewRichEdit1( AParent: PControl; Options: TEditOptions ): PControl;
var Flags, I: Integer;
begin
  if FRichEditModule = 0 then
  begin
    for I := 0 to 2 do
    begin
      FRichEditModule := LoadLibrary( RichEditLibnames[ I ] );
      if FRichEditModule > HINSTANCE_ERROR then break;
      RichEditClass := 'RichEdit';
    end;
    if FRichEditModule <= HINSTANCE_ERROR then
      FRichEditModule := 0;
  end;
  Flags := MakeFlags( @Options, RichEditFlags );
  Result := _NewCommonControl( AParent, RichEditClass, WS_VISIBLE or WS_CHILD
                         or WS_TABSTOP or WS_BORDER or ES_MULTILINE or Flags,
                         True, @RichEditActions );
  Result.fIgnoreDefault := TRUE;
  Result.fLookTabKeys := [ tkTab ];
  if eoWantTab in Options then
     Result.fLookTabKeys := [ ];

  Result.AttachProc( WndProcRichEditNotify );
  Result.fDoubleBuffered := False;
  Result.fCannotDoubleBuf := True;
  with Result.fBoundsRect do
  begin
    Right := Right + 100;
    Bottom := Top + 200;
  end;
  Result.Perform( EM_SETEVENTMASK, 0,
    ENM_CHANGE or ENM_SELCHANGE or ENM_REQUESTRESIZE or
    ENM_PROTECTED or $04000000 {ENM_LINK} or ENM_KEYEVENTS {or ENM_MOUSEEVENTS} );
  Result.fColor := clWindow;
  Result.Perform( EM_SETBKGNDCOLOR, 0, Color2RGB(Result.fColor));
  //Result.Perform( WM_SIZE, 0, 0 );
end;
{$ENDIF ASM_VERSION}
//[END NewRichEdit1]

{$ENDIF USE_CONSTRUCTORS}

//[API OleInitialize]
function OleInitialize(pwReserved: Pointer): HResult; stdcall;
  external 'ole32.dll' name 'OleInitialize';
procedure OleUninitialize; stdcall;
  external 'ole32.dll' name 'OleUninitialize';

//[FUNCTION OleInit]
{$IFDEF ASM_VERSION}
function OleInit: Boolean;
asm
        MOV      ECX, [OleInitCount]
        INC      ECX
        LOOP     @@init1
        PUSH     ECX
        CALL     OleInitialize
        TEST     EAX, EAX
        MOV      AL, 0
        JNZ      @@exit
@@init1:
        INC      [OleInitCount]
        MOV      AL, 1
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
function OleInit: Boolean;
begin
  if OleInitCount = 0 then
  begin
    Result := False;
    if OleInitialize( nil ) <> 0 then Exit;
  end;
  Inc( OleInitCount );
  Result := True;
end;
{$ENDIF ASM_VERSION}
//[END OleInit]

//[PROCEDURE OleUnInit]
{$IFDEF ASM_VERSION}
procedure OleUnInit;
asm
        MOV      ECX, [OleInitCount]
        JECXZ    @@exit
        DEC      [OleInitCount]
        JNZ      @@exit
        CALL     OleUninitialize
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure OleUnInit;
begin
  if OleInitCount > 0 then
  begin
    Dec( OleInitCount );
    if OleInitCount = 0 then
      OleUninitialize;
  end;
end;
{$ENDIF ASM_VERSION}
//[END OleUnInit]

//[API SysAllocStringLen]
function SysAllocStringLen;
         external 'oleaut32.dll' name 'SysAllocStringLen';
procedure SysFreeString( psz: PWideChar ); stdcall;
         external 'oleaut32.dll' name 'SysFreeString';



{$IFDEF USE_CONSTRUCTORS}
//[function NewRichEdit]
function NewRichEdit( AParent: PControl; Options: TEditOptions ): PControl;
begin
  new( Result, CreateRichEdit( AParent, Options ) );
end;
//[END NewRichEdit]
{$ELSE not_USE_CONSTRUCTORS}

//[FUNCTION NewRichEdit]
{$IFDEF ASM_VERSION}
const RichEdit20A: array[0..11] of Char = ('R','i','c','h','E','d','i','t','2','0','A',#0 );
      RichEd20_DLL: array[ 0..12] of Char = ('R','I','C','H','E','D','2','0','.','D','L','L',#0 );
function NewRichEdit( AParent: PControl; Options: TEditOptions ): PControl;
const deltaChr = 24; // sizeof( TCharFormat2 ) - sizeof( RichEdit.TCharFormat );
      deltaPar = sizeof( TParaFormat2 ) - sizeof( RichEdit.TParaFormat );
asm
        PUSHAD
        CALL     OleInit
        TEST     EAX, EAX
        POPAD
        JZ       @@new1
        PUSH     [RichEditClass]
        MOV      [RichEditClass], offset[RichEdit20A]
        PUSH     [RichEditLib]
        MOV      [RichEditLib], offset[RichEd20_DLL]
        CALL     NewRichEdit1
        POP      [RichEditLib]
        POP      [RichEditClass]
        MOV      byte ptr [EAX].TControl.fCharFmtDeltaSz, deltaChr
        MOV      byte ptr [EAX].TControl.fParaFmtDeltaSz, deltaPar
        RET
@@new1: CALL     NewRichEdit1
end;
{$ELSE ASM_VERSION} //Pascal
function NewRichEdit( AParent: PControl; Options: TEditOptions ): PControl;
var OldRichEditClass, OldRichEditLib: PChar;
begin
  if OleInit then
  begin
    OldRichEditClass := RichEditClass;
    RichEditClass := 'RichEdit20A';
    OldRichEditLib := RichEditLib;
    RichEditLib := 'RICHED20.DLL';
    Result := NewRichEdit1( AParent, Options );
    Result.fCharFmtDeltaSz := 24; //sizeof( TCharFormat2 ) - sizeof( RichEdit.TCharFormat );
                           // sizeof( TCharFormat2 ) is calculated incorrectly
    Result.fParaFmtDeltaSz := sizeof( TParaFormat2 ) - sizeof( RichEdit.TParaFormat );
    RichEditClass := OldRichEditClass;
    RichEditLib := OldRichEditLib;
  end
     else
    Result := NewRichEdit1( AParent, Options );
end;
{$ENDIF ASM_VERSION}
//[END NewRichEdit]

{$ENDIF USE_CONSTRUCTORS}

//=====================================================================//




















{ TControl }

{$IFDEF ASM_VERSION}
//[procedure TControl.Init]
procedure TControl.Init;
const
  IniStyle = WS_VISIBLE or WS_CLIPCHILDREN or WS_CLIPSIBLINGS or
            WS_CAPTION or WS_SYSMENU or WS_MINIMIZEBOX or WS_MAXIMIZEBOX or
            WS_BORDER or WS_THICKFRAME;
asm     //cmd    //opd
        PUSH     EBX
        MOV      EBX, EAX
        CALL     TObj.Init
        MOV      EDX, offset WndProcDummy
        MOV      [EBX].fOnDynHandlers, EDX
        MOV      [EBX].fWndProcKeybd, EDX
        MOV      [EBX].fWndProcResizeFlicks, EDX
        MOV      [EBX].fPass2DefProc, EDX
//****        MOV      [EBX].fDefWndProc, offset DefWindowProc
        MOV      [EBX].fWndFunc, offset WndFunc
        MOV      EDX, offset ClearText
        MOV      [EBX].fCommandActions.aClear, EDX
        INC      dword ptr [EBX].fWindowed
        MOV      EDX, offset DummyObjProc
        MOV      [EBX].fControlClick, EDX
        MOV      EDX, clBtnFace
        MOV      [EBX].fColor, EDX
        MOV      DL, clWindowText and $FF
        MOV      [EBX].fTextColor, EDX
        MOV      byte ptr [EBX].fMargin, 2
        INC      dword ptr [EBX].fCtl3D
        INC      dword ptr [EBX].fCtl3Dchild
        DEC      byte ptr [EBX].fAlphaBlend
        CALL     NewList
        MOV      [EBX].fChildren, EAX
        MOV      byte ptr[EBX].fClsStyle, CS_OWNDC
        MOV      [EBX].fStyle, IniStyle
        INC      dword ptr[EBX].fExStyle+2
        INC      dword ptr[EBX].fVisible
        INC      dword ptr[EBX].fEnabled
        CALL     NewList
        MOV      [EBX].fDynHandlers, EAX
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.Init;
begin
  inherited;
  fOnDynHandlers := WndProcDummy;
  fWndProcKeybd := WndProcDummy;
  fWndProcResizeFlicks := WndProcDummy;
  fPass2DefProc := WndProcDummy;
//****  fDefWndProc := @DefWindowProc;
  fWndFunc := @ WndFunc;
  fCommandActions.aClear := ClearText;
  fWindowed := True;
  fControlClick := DummyObjProc;
  fColor := clBtnFace;
  fTextColor := clWindowText;
  fMargin := 2;
  fCtl3D := True;
  fCtl3Dchild := True;
  fAlphaBlend := 255;
  fChildren := NewList;
  fClsStyle := CS_OWNDC;
  fStyle := WS_VISIBLE or WS_CLIPCHILDREN or WS_CLIPSIBLINGS or
            WS_CAPTION or WS_SYSMENU or WS_MINIMIZEBOX or WS_MAXIMIZEBOX or
            WS_BORDER or WS_THICKFRAME;
  fExStyle := WS_EX_CONTROLPARENT;
  fVisible := True;
  fEnabled := True;
  fDynHandlers := NewList;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[PROCEDURE CallTControlInit]
procedure CallTControlInit( Ctl: PControl );
begin
  Ctl.Init;
end;
//[END CallTControlInit]

//[procedure TControl.InitParented]
procedure TControl.InitParented( AParent: PControl );
const IStyle = WS_VISIBLE or WS_CLIPCHILDREN or WS_CLIPSIBLINGS or
            WS_CAPTION or WS_SYSMENU or WS_MINIMIZEBOX or WS_MAXIMIZEBOX or
            WS_BORDER or WS_THICKFRAME;
      IExStyle = WS_EX_CONTROLPARENT;
      IClsStyle = CS_OWNDC;
      int_IDC_ARROW = integer( IDC_ARROW );
asm
        PUSH      EAX
        PUSH      EDX
        CALL      CallTControlInit
        POP       EDX
        POP       EAX
        TEST      EDX, EDX
        JZ        @@0
        MOV       ECX, [EDX].fColor
        MOV       [EAX].fColor, ECX
@@0:
//        PUSH      EAX             //YS

        CALL      SetParent
{ //YS
        PUSH      int_IDC_ARROW
        PUSH      0
        CALL      LoadCursor

        POP       EDX
        MOV       [EDX].fCursor, EAX
}
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.InitParented( AParent: PControl );
begin
  Init;
  Parent := AParent;
  if AParent <> nil then
     fColor := AParent.fColor;
//  fCursor := LoadCursor( 0, IDC_ARROW );    //YS
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[destructor TControl.Destroy]
destructor TControl.Destroy;
asm
        PUSH     EBX
        MOV      EBX, EAX
        CALL     TControl.ParentForm
        TEST     EAX, EAX
        JZ       @@cur_ctl_removed
        CMP      [EAX].TControl.fCurrentControl, EBX
        JNE      @@cur_ctl_removed
        XOR      EDX, EDX
        MOV      [EAX].TControl.fCurrentControl, EDX
@@cur_ctl_removed:

        MOV      ECX, [EBX].fHandle
        JECXZ    @@wndhidden
        PUSH     SW_HIDE
        PUSH     ECX
        CALL     ShowWindow
@@wndhidden:

        MOV      EAX, EBX
        CALL     Final
        MOV      EAX, EBX
        CALL     DestroyChildren

        XOR      ECX, ECX
        CMP      [EBX].fDestroying, CL
        JNZ      @@destroyed

        XCHG     CL, [EBX].fCtlClsNameChg
        JECXZ    @@skip_free_clsname
        MOV      EAX, [EBX].fControlClassName
        CALL     System.@FreeMem
@@skip_free_clsname:

        INC      [EBX].fDestroying
        MOV      EAX, [EBX].fFont
        CALL     TObj.Free
        MOV      EAX, [EBX].fBrush
        CALL     TObj.Free
        MOV      EAX, [EBX].fCanvas
        CALL     TObj.Free

        XOR      ECX, ECX

        MOV      [EBX].fFont, ECX        // +YS
        MOV      [EBX].fBrush, ECX       // +YS
        MOV      [EBX].fCanvas, ECX      // +YS

        XCHG     ECX, [EBX].fCustomData
        JECXZ    @@custfree
        XCHG     EAX, ECX
        CALL     System.@FreeMem
@@custfree:
        MOV      EAX, [EBX].fCustomObj
        CALL     TObj.Free

        MOV      EAX, [EBX].fHandle
        TEST     EAX, EAX
        JZ       @@free_fields

        XOR      ECX, ECX
        XCHG     ECX, [EBX].fAccelTable
        JECXZ    @@accelTable_destroyed
        PUSH     ECX
        CALL     DestroyAcceleratorTable
@@accelTable_destroyed:
        MOV      EAX, [EBX].fMenuObj
        CALL     TObj.Free
@@destroy_img_list:
        MOV      EAX, [EBX].fImageList
        TEST     EAX, EAX
        JZ       @@img_list_destroyed
        CALL     TObj.Free
        JMP      @@destroy_img_list
@@img_list_destroyed:

        PUSH     [EBX].fHandle
        CALL     IsWindow
        TEST     EAX, EAX
        JZ       @@destroy2

        PUSH     EAX
        PUSH     1
        PUSH     WM_SETICON
        PUSH     [EBX].fHandle
        CALL     SendMessage
        TEST     EAX, EAX
        JZ       @@icoremoved
        CMP      [EBX].fIconShared, 0
        JNZ      @@icoremoved
        PUSH     EAX
        CALL     DestroyIcon
@@icoremoved:
//********************************************************** Remarked By M.Gerasimov
//      PUSH     offset[ID_SELF]
//      PUSH     [EBX].fHandle
//      CALL     RemoveProp
//********************************************************** Remarked By M.Gerasimov
        CMP      [EBX].fNCDestroyed, 0
        JNZ      @@destroy2
        PUSH     [EBX].fHandle
        CALL     DestroyWindow
@@destroy2:
        XOR      EAX, EAX
        MOV      [EBX].fHandle, EAX

@@free_fields:
        MOV      EAX, [EBX].fCaption
        TEST     EAX, EAX
        JZ       @@caption_freed
        CALL     System.@FreeMem
@@caption_freed:
        MOV      EAX, [EBX].fStatusTxt
        TEST     EAX, EAX
        JZ       @@statusTxt_freed
        CALL     System.@FreeMem
@@statusTxt_freed:
        MOV      ECX, [EBX].fParent
        JECXZ    @@removed_from_parent
        CMP      [ECX].fCurrentControl, EBX
        JNE      @@removefromParent
        XOR      EAX, EAX
        MOV      [ECX].fCurrentControl, EAX
@@removefromParent:
        MOV      EAX, [ECX].fChildren
        //PUSH     EAX
        MOV      EDX, EBX
        {CALL     TList.IndexOf
        TEST     EAX, EAX
        POP      EDX
        JL       @@removed_from_parent
        XCHG     EAX, EDX
        CALL     TList.Delete}
        CALL     TList.Remove
@@removed_from_parent:
        MOV      ECX, [EBX].fTmpBrush
        JECXZ    @@tmpBrush_deleted
        PUSH     ECX
        CALL     DeleteObject
@@tmpBrush_deleted:

        PUSH     EBX
        PUSH     [EBX].fChildren
        PUSH     [EBX].fTBttCmd
        PUSH     [EBX].fTBttTxt
        PUSH     [EBX].fTmpFont
        PUSH     [EBX].fDynHandlers
        MOV      BL, 5
@@freeloo:
        POP      EAX
        CALL     TObj.Free
        DEC      BL
        JNZ      @@freeloo
        POP      EBX
        LEA      EAX, [EBX].fREUrl
        CALL     System.@LStrClr
        XCHG     EAX, EBX
        CALL     TObj.Destroy
@@destroyed:
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
destructor TControl.Destroy;
var I: Integer;
    F: PControl;
    Ico: HIcon;
begin
   {$IFDEF USE_MHTOOLTIP}
   {$DEFINE destroy}
   {$I KOLMHToolTip}
   {$UNDEF destroy}
   {$ENDIF USE_MHTOOLTIP}
   F := ParentForm; // or Applet - for form ???
   if F <> nil then
   if F.FCurrentControl = Self then
      F.FCurrentControl := nil;

   if FHandle <> 0 then
      ShowWindow( fHandle, SW_HIDE );

   Final;
   DestroyChildren;

   if not fDestroying then
   begin
     fDestroying := True;

      if fCtlClsNameChg then
      begin
        FreeMem( fControlClassName );
        fCtlClsNameChg := FALSE;
      end;

     fFont.Free;
     fFont := nil;
     fBrush.Free;
     fBrush := nil;
     fCanvas.Free;
     fCanvas := nil;

     if fCustomData <> nil then
       FreeMem( fCustomData );
     fCustomData := nil;
     fCustomObj.Free;
     fCustomObj := nil;

     if fHandle <> 0 then
     begin
       if fAccelTable <> 0 then
       begin
         DestroyAcceleratorTable( fAccelTable );
         fAccelTable := 0;
       end;
       fMenuObj.Free;
       while fImageList <> nil do
         fImageList.Free;
       I := fHandle;
       if IsWindow( I ) then
       begin
         Ico := SendMessage( I, WM_SETICON, 1, 0 );
         if Ico <> 0 then
         if not fIconShared then
           DestroyIcon( Ico );
//********************************************************** Remarked By M.Gerasimov
//       RemoveProp( I, ID_SELF );
//********************************************************** Remarked By M.Gerasimov
         if not fNCDestroyed then
         begin
           {$IFDEF DEBUG_ENDSESSION}
           if EndSession_Initiated then
             LogFileOutput( GetStartDir + 'es_debug.txt',
                            'DESTROYING HWND:' + Int2Str( I ) );
           {$ENDIF}
           DestroyWindow( I );
         end;
       end
       {$IFDEF TEST_CLOSE}
         else
         asm
           int 3
         end;
       {$ENDIF}
       ;
       fHandle := 0;
     end;

     if fTmpBrush <> 0 then
        DeleteObject( fTmpBrush );
     fTmpBrush := 0;

     if FCaption <> nil then
        FreeMem( FCaption );
     if fStatusTxt <> nil then
        FreeMem( fStatusTxt );

     if fParent <> nil then
     begin
        {I := fParent.fChildren.IndexOf( Self );
        if I >= 0 then
           fParent.fChildren.Delete( I );}
        fParent.fChildren.Remove( Self );
        if fParent.fCurrentControl = Self then
          fParent.fCurrentControl := nil;
     end;

     fChildren.Free;
     fTBttCmd.Free;
     fTBttTxt.Free;
     fTmpFont.Free;
     fDynHandlers.Free;
     fREUrl := '';
     inherited;
   end;
end;
{$ENDIF ASM_VERSION}

   {$IFDEF USE_MHTOOLTIP}
   {$DEFINE code}
   {$I KOLMHToolTip}
   {$UNDEF code}
   {$ENDIF}

{$IFDEF ASM_VERSION}
//[procedure TControl.SetEnabled]
procedure TControl.SetEnabled( Value: Boolean );
asm
        PUSH     EBX
        MOV      EBX, EAX
        MOVZX    EDX, DL
        PUSH     EDX
        CALL     GetEnabled
        POP      EDX
        CMP      AL, DL
        JZ       @@exit
        MOV      [EBX].fEnabled, DL
        TEST     EDX, EDX
        JNZ      @@andnot
        OR       byte ptr [EBX].fStyle + 3, 8
        JMP      @@1
@@andnot:
        AND      byte ptr [EBX].fStyle + 3, $F7
@@1:
        MOV      ECX, [EBX].fHandle
        JECXZ    @@exit

        PUSH     EDX
        PUSH     ECX
        CALL     EnableWindow

@@exit:
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.SetEnabled( Value: Boolean );
begin
   if GetEnabled = Value then Exit;
   fEnabled := Value;
   if Value then
      fStyle := fStyle and not WS_DISABLED
   else
      fStyle := fStyle or WS_DISABLED;
   if fHandle <> 0 then
      EnableWindow( fHandle, fEnabled );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.GetParentWindow]
function TControl.GetParentWindow: HWnd;
asm
        MOV       EAX, [EAX].fParent
        TEST      EAX, EAX
        {
        JZ        @@exit

        CALL      TControl.GetWindowHandle
@@exit: --- replaced with following (6 bytes instead of 7):
        }
        JNZ       TControl.GetWindowHandle
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.GetParentWindow: HWnd;
begin
   Result := 0;
   if fParent = nil then Exit;
   Result := fParent.GetWindowHandle;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
function TControl.GetWindowHandle: HWnd;
asm
         MOV      ECX, [EAX].fHandle
         JECXZ    @@1
         XCHG     EAX, ECX
         RET
@@1:
         CMP      [EAX].fCreateVisible, 0
         JNZ      @@2

         PUSH     EAX
         XOR      EDX, EDX
         CALL     TControl.Set_Visible
         POP      EAX
         PUSH     EAX
         //CALL     TControl.CreateWindow
         CALL     CallTControlCreateWindow
         { This is a call to Pascal piece of code, which
           calls virtual method TControl.CreateWindow }
         POP      EAX

         INC      [EAX].fCreateHidden
         JMP      @@0

@@2:     PUSH     EAX
         //CALL     TControl.CreateWindow
         CALL     CallTControlCreateWindow
         POP      EAX
@@0:
         MOV      EAX, [EAX].fHandle
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.GetWindowHandle: HWnd;
begin
   if fHandle = 0 then
   begin
     if not fCreateVisible then
     begin
       Set_Visible( False );
       CreateWindow; //virtual!!!
       fCreateHidden := True;
     end
        else
     CreateWindow; //virtual!!!
   end;
   Result := fHandle;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.CreateWindow]
function TControl.CreateWindow: Boolean;
const
  CS_OFF = CS_OWNDC or CS_CLASSDC or CS_PARENTDC or CS_GLOBALCLASS;
  CS_ON = 0; //CS_VREDRAW or CS_HREDRAW;
  szWndClass = sizeof( TWndClass );
  int_IDC_ARROW = integer( IDC_ARROW );
asm
        PUSH     EBX
        XCHG     EBX, EAX
        MOV      ECX, [EBX].fParent
        JECXZ    @@chk_handle
        XCHG     EAX, ECX
        CALL     GetWindowHandle
        TEST     EAX, EAX
        JZ       @@ret_false
@@chk_handle:
        MOV      ECX, [EBX].fHandle
        JECXZ    @@prepare_Params
        MOV      DL, 0
        MOV      EAX, EBX
        CMP      [EBX].fCreateHidden, DL
        JZ       @@create_children
        CALL     CreateChildWindows
        MOV      EAX, EBX
        MOV      DL, 1
        CALL     Set_Visible
        MOV      [EBX].fCreateHidden, 0
        JMP      @@ret_true
@@create_children:
        CALL     CreateChildWindows
@@ret_true:
        MOV      AL, 1
        POP      EBX
        RET
@@prepare_params:
        PUSH     EBP
        MOV      EBP, ESP

        PUSH     ECX        // Params.WindowClass.lpszClassName := nil
        PUSH     ECX        // Params.WindowClass.lpszMenuName := nil
        PUSH     ECX        // Params.WindowClass.hbrBackground := 0
        PUSH     int_IDC_ARROW
        PUSH     ECX
        CALL     LoadCursor
        PUSH     EAX        // Params.WindowClass.hCursor := LoadCursor( 0, IDC_ARROW )
        XOR      ECX, ECX
        PUSH     ECX        // Params.WindowClass.hIcon := 0
        PUSH     [hInstance]// Params.WindowClass.hInstance := hInstance
        PUSH     ECX        // Params.WindowClass.cbWndExtra := 0
        PUSH     ECX        // Params.WindowClass.cbClsExtra := 0
        //PUSH     offset DefWindowProc // Params.WindowClass.lpfnWndProc := @DefWindowProc
        PUSH     [EBX].fDefWndProc     // Params.WindowClass.lpfnWndProc := fDefWndProc
        PUSH     [EBX].fClsStyle       // Params.WindowClass.style := fStyle
        ADD      ESP, -64
        PUSH     ECX
        MOV      EAX, EBX
        MOV      EDX, ESP
        CALL     get_ClassName
        POP      EDX
        MOV      EAX, ESP
        PUSH     EDX
        //CALL     StrPCopy    // StrPCopy( Params.WinClsNamBuf, ClassName )
        CALL     StrCopy
        CALL     RemoveStr
        PUSH     0           // Params.Param := nil
        PUSH     [hInstance] // Params.Inst := fInstance
        PUSH     [EBX].fMenu // Params.Menu := fMenu
        MOV      DL, 1
        MOV      EAX, EBX
        CALL     GetParentWnd
        PUSH     EAX         // Params.WndParent := GetParentWnd( True )

        MOV      ECX, CW_USEDEFAULT
        MOV      EAX, [EBX].fBoundsRect.Bottom
        MOV      EDX, [EBX].fBoundsRect.Top
        SUB      EAX, EDX
        JNZ      @@1
        MOV      EAX, ECX
@@1:    PUSH     EAX         // Params.Height := Height | CW_UseDefault
        MOV      EAX, [EBX].fBoundsRect.Right
        SUB      EAX, [EBX].fBoundsRect.Left
        JNZ      @@2
        MOV      EAX, ECX
@@2:    PUSH     EAX         // Params.Width := Width | CW_UseDefault
        MOV      EAX, [EBX].fBoundsRect.Left
        CMP      [EBX].fIsControl, CL
        JNZ      @@3
        TEST     byte ptr [EBX].fChangedPosSz, 3
        JNZ      @@3
        MOV      EDX, ECX
        XCHG     EAX, ECX
@@3:    PUSH     EDX         // Params.Y := Top | CW_UseDefault
        PUSH     EAX         // Params.X := Left | CW_UseDefault
        PUSH     [EBX].fStyle    // Params.Style := fStyle
        PUSH     [EBX].fCaption  // Params.Caption := fCaption
        LEA      EAX, [ESP+40]
        PUSH     EAX         // Params.WinClassName := @Params.WinClsNamBuf
        PUSH     [EBX].fExStyle  // Params.ExStyle := fExStyle

        MOV      ECX, [EBX].fControlClassName
        JECXZ    @@registerClass
        LEA      EAX, [ESP].TCreateWndParams.WindowClass
        PUSH     EAX           // @Params.WindowClass
        PUSH     ECX           // fControlClassName
        PUSH     [hInstance]   // hInstance
        CALL     GetClassInfo
        MOV      EAX, [ESP].TCreateWndParams.Inst
        MOV      [ESP].TCreateWndParams.WindowClass.hInstance, EAX
        AND      [ESP].TCreateWndParams.WindowClass.style, not CS_OFF
@@registerClass:
        CMP      [EBX].fDefWndProc, 0
        JNE      @@fDefWndProc_ready
        MOV      EAX, [ESP].TCreateWndParams.WindowClass.lpfnWndProc
        MOV      [EBX].fDefWndProc, EAX
@@fDefWndProc_ready:
        MOV      ECX, [ESP].TCreateWndParams.WndParent
        INC      ECX
        LOOP     @@registerClass1
        TEST     byte ptr [ESP].TCreateWndParams.Style+3, $40
        XCHG     EAX, ECX
        JNZ      @@fin
@@registerClass1:
        MOV      EAX, [ESP].TCreateWndParams.WinClassName
        MOV      EDX, [ESP].TCreateWndParams.WindowClass.hInstance
        ADD      ESP, -szWndClass
        PUSH     ESP
        PUSH     EAX
        PUSH     EDX
        CALL     GetClassInfo
        ADD      ESP, szWndClass
        TEST     EAX, EAX
        JNZ      @@registered
        MOV      EAX, [ESP].TCreateWndParams.WinClassName
        MOV      [ESP].TCreateWndParams.WindowClass.lpszClassName, EAX
        MOV      [ESP].TCreateWndParams.WindowClass.lpfnWndProc, offset WndFunc
        LEA      EAX, [ESP].TCreateWndParams.WindowClass
        PUSH     EAX
        CALL     RegisterClass
        TEST     EAX, EAX
        JZ       @@fin
@@registered:
        MOV      [CreatingWindow], EBX
        CALL     CreateWindowEx
        MOV      [EBX].fHandle, EAX
        TEST     EAX, EAX
        JZ       @@fin
        PUSH     EAX
        PUSH     offset ID_SELF
        PUSH     EAX

   //SendMessage(fHandle,WM_UPDATEUISTATE,UIS_CLEAR or (UISF_HIDEFOCUS shl 16),0);
        PUSH     0
        PUSH     $10002 //UIS_CLEAR or (UISF_HIDEFOCUS shl 16)
        PUSH     $0128  //WM_UPDATEUISTATE
        PUSH     EAX
        CALL     SendMessage

        CALL     GetProp
        XCHG     ECX, EAX
        POP      EAX
        INC      ECX
        LOOP     @@propSet
        MOV      [CreatingWindow], ECX
        PUSH     EBX
        PUSH     offset ID_SELF
        PUSH     EAX
        CALL     SetProp
@@propSet:
        CMP      [EBX].fIsControl, 0
        JNZ      @@iconSet
        MOV      EAX, EBX
        CALL     GetIcon
        PUSH     EAX
        PUSH     1
        PUSH     WM_SETICON
        PUSH     EBX
        CALL     Perform
@@iconSet:
        MOV      ECX, [EBX].fCreateWndExt
        JECXZ    @@dblbufcreate
        MOV      EAX, EBX
        CALL     ECX
@@dblbufcreate:
        MOV      EAX, EBX
        CALL     Dword Ptr [ Global_DblBufCreateWnd ]
@@applyfont:
        MOV      EAX, EBX
        CALL     ApplyFont2Wnd
        MOV      EAX, EBX
        CALL     ApplyFont2Wnd
        XCHG     EAX, EBX
        CALL     CreateChildWindows
        MOV      AL, 1
@@fin:
        MOV      ESP, EBP
        POP      EBP
@@ret_false:
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.CreateWindow: Boolean;
const
  CS_OFF = CS_OWNDC or CS_CLASSDC or CS_PARENTDC or CS_GLOBALCLASS;
  CS_ON = 0; //CS_VREDRAW or CS_HREDRAW;
var TempClass: TWndClass;
    Params: TCreateWndParams;
    ClassRegistered: Boolean;
    {$IFDEF _FPC}
    SClassName: String;
    {$ENDIF ASM_VERSION}
begin
   {$IFDEF DEBUG_CREATEWINDOW}
   LogFileOutput( GetStartDir + 'Session.log', 'TControl.CreateWindow, ' +
                  ' Self = ' + Int2Str( Integer( Self ) ) +
                  ' Caption = ' + fCaption +
                  ' fChildren = ' + Int2Hex( Integer( fChildren ), 4 ) +
                  ' ChildCount = ' + Int2Str( ChildCount ) );
   {$ENDIF DEBUG_CREATEWINDOW}
   Result := False;
   if fParent <> nil then
     if fParent.GetWindowHandle = 0 then
       Exit;
   if fHandle <> 0 then
   begin
     if fCreateHidden then
     begin
       CreateChildWindows;
       Set_Visible( True );
       fCreateHidden := False;
     end
        else
     begin
       CreateChildWindows;
     end;
     Result := True;
     Exit;
   end;

   FillChar( Params, Sizeof( Params ), 0 );
   Params.Caption := PChar( FCaption );
   Params.Style := FStyle;
   if not fEnabled then
      Params.Style := Params.Style or WS_DISABLED;
   Params.ExStyle := FExStyle;
   Params.WindowClass.style := FClsStyle;
   {Params.WindowClass.lpfnWndProc := @ DefWindowProc;
   if fDefWndProc <> nil then} //+-+
     Params.WindowClass.lpfnWndProc := FDefWndProc;
   Params.WindowClass.hCursor := LoadCursor( 0, IDC_ARROW );
   Params.WindowClass.hInstance := hInstance;
   Params.Inst := hInstance;
   {$IFDEF _FPC}
   SClassName := SubClassName;
   StrCopy( Params.WinClsNamBuf, @ SClassName[ 1 ] );
   {$ELSE}
   StrCopy( Params.WinClsNamBuf, @ SubClassName[ 1 ] );
   {$ENDIF}
   Params.WinClassName := @Params.WinClsNamBuf[ 0 ];
   Params.WndParent := GetParentWnd( True );
   Params.Menu := fMenu;
   Params.X := fBoundsRect.Left;
   Params.Y := fBoundsRect.Top;
   Params.Width := fBoundsRect.Right - fBoundsRect.Left;
   if Params.Width = 0 then
     Params.Width := CW_UseDefault;
   Params.Height := fBoundsRect.Bottom - fBoundsRect.Top;
   if Params.Height = 0 then
     Params.Height := CW_UseDefault;
   if not fIsControl then
   begin
     if not LongBool( fChangedPosSz and 3 ) then
     begin
       Params.X := CW_UseDefault;
       Params.Y := CW_UseDefault;
     end;
   end;

    if fControlClassName <> nil then
    begin // SUBCLASSING WINDOW
      GetClassInfo( Params.WindowClass.hInstance, fControlClassName,
                    Params.WindowClass);
      Params.WindowClass.hInstance := Params.Inst;
      Params.WindowClass.style := Params.WindowClass.style
                               and not CS_OFF or CS_ON;
    end;

   if FDefWndProc = nil then //+
   {$IFDEF F_P}
      Move( Params.WindowClass.lpfnWndProc, FDefWndProc, Sizeof( Pointer ) );
   {$ELSE}
      FDefWndProc := Params.WindowClass.lpfnWndProc;
   {$ENDIF}
   if (Params.WndParent = 0) and (Params.Style and WS_CHILD <> 0) then Exit;
   ClassRegistered := GetClassInfo( Params.WindowClass.hInstance,
                      Params.WinClassName, TempClass );
   if not ClassRegistered then
   begin
      Params.WindowClass.lpszClassName := Params.WinClassName;
      Params.WindowClass.lpfnWndProc := fWndFunc;
      if RegisterClass( Params.WindowClass ) = 0 then Exit;
   end;
   {$IFDEF DEBUG_CREATEWINDOW}
   LogFileOutput( GetStartDir + 'Session.log',
                  ' ExStyle=' + Int2Hex( Params.ExStyle, 4 ) +
                  ' WinClassName=' + Params.WinClassName +
                  ' Caption=' + Params.Caption +
                  ' Style=' + Int2Hex( Params.Style, 4 ) +
                  ' X=' + Int2Str( Params.X ) +
                  ' Y=' + Int2Str( Params.Y ) +
                  ' Width=' + Int2Str( Params.Width ) +
                  ' Height=' + Int2Str( Params.Height ) +
                  ' WndParent=' + Int2Str( Params.WndParent ) +
                  ' Menu=' + Int2Str( Params.Menu ) +
                  ' hInstance=' + Int2Str( Params.WindowClass.hInstance ) +
                  ' Param=' + Int2Str( Integer( Params.Param ) )
                   );
   {$ENDIF}
   CreatingWindow := Self;
   fHandle := CreateWindowEx( Params.ExStyle, Params.WinClassName,
                              Params.Caption, Params.Style, Params.X, Params.Y,
                              Params.Width, Params.Height, Params.WndParent,
                              Params.Menu, Params.WindowClass.hInstance,
                              Params.Param );
   if fHandle = 0 then Exit;
   SendMessage( fHandle, $0128 {WM_UPDATEUISTATE},
                2 {UIS_CLEAR} or (1 {UISF_HIDEFOCUS} shl 16),0);
   if GetProp(FHandle,ID_SELF) = 0 then
   begin
      CreatingWindow := nil;
      SetProp(FHandle, ID_SELF, THandle(Self));
   end;
   //***
   if not fIsControl then
     SendMessage( fHandle, WM_SETICON, 1 {ICON_BIG}, GetIcon );
   if Assigned( FCreateWndExt ) then
      FCreateWndExt( Self );
   Global_DblBufCreateWnd( Self );
   ApplyFont2Wnd;
   ApplyFont2Wnd;

   CreateChildWindows;
   Result := True;
end;
{$ENDIF}

//-
//[procedure TControl.CreateSubclass]
procedure TControl.CreateSubclass(var Params: TCreateParams;
  ControlClassName: PChar);
const
  CS_OFF = CS_OWNDC or CS_CLASSDC or CS_PARENTDC or CS_GLOBALCLASS;
  CS_ON = 0; //CS_VREDRAW or CS_HREDRAW;
var
  SaveInstance: THandle;
begin
  if fControlClassName <> nil then
    with Params do
    begin
      SaveInstance := WindowClass.hInstance;
      if not GetClassInfo(HInstance, fControlClassName, WindowClass) and
        not GetClassInfo(0, fControlClassName, WindowClass) and
        not GetClassInfo(HInstance {MainInstance}, fControlClassName, WindowClass) then
        GetClassInfo(WindowClass.hInstance, fControlClassName, WindowClass);
      WindowClass.hInstance := SaveInstance;
      WindowClass.style := WindowClass.style and not CS_OFF or CS_ON;
    end;
end;

//[FUNCTION WndProcMous]
{$IFDEF ASM_VERSION}
function WndProcMouse(Self_: PControl; var Msg: TMsg; var Rslt: Integer): Boolean;
asm
         PUSH      EBX
         PUSH      ESI
         XCHG      EBX, EAX

         XOR       ECX, ECX // Rslt not used. ECX <= Result = 0
         MOV       EAX, [EDX].TMsg.message
         SUB       AH, WM_MOUSEFIRST shr 8
         CMP       EAX, $20A - WM_MOUSEFIRST //WM_MOUSELAST - WM_MOUSEFIRST
         JA        @@exit

         PUSH      dword ptr [EDX].TMsg.lParam // prepare X, Y

         PUSHAD

           PUSH      VK_MENU
           CALL      GetKeyState
           ADD       EAX, EAX
         POPAD
         XCHG        EAX, EDX
           MOV       EAX, [EAX].TMsg.wParam

           JNC       @@noset_MKALT
           {$IFDEF PARANOIA}
           DB $0C, MK_ALT
           {$ELSE}
           OR        AL, MK_ALT
           {$ENDIF}
@@noset_MKALT:

         PUSH      EAX             // prepare Shift

         LEA       ESI, [EBX].TControl.fOnMouseDown
         CALL      dword ptr [EDX*4 + @@jump_table]

@@call_evnt:
         PUSH      ECX             // prepare Button, StopHandling
         MOV       ECX, ESP        // ECX = @MouseData

         CMP       word ptr [ESI].TMethod.Code+2, 0
         JZ        @@after_call

         MOV       EDX, EBX        // EDX = Self_
         MOV       EAX, [ESI].TMethod.Data      // EAX = Target_
         CALL      dword ptr [ESI].TMethod.Code

@@after_call:
         POP       ECX
         POP       EDX
         POP       EDX
         MOV       CL, CH           // Result := StopHandling

@@exit:
         XCHG      EAX, ECX
         POP       ESI
         POP       EBX
         RET

@@jump_table:
         DD Offset[@@MMove],Offset[@@LDown],Offset[@@LUp],Offset[@@LDblClk]
         DD Offset[@@RDown],Offset[@@RUp],Offset[@@RDblClk]
         DD Offset[@@MDown],Offset[@@MUp],Offset[@@MDblClk],Offset[@@MWheel]

@@MDown: INC       ECX
@@RDown: INC       ECX
@@LDown: INC       ECX
         //LEA       ESI, [EBX].TControl.fOnMouseDown
         RET

@@MUp:   INC       ECX
@@RUp:   INC       ECX
@@LUp:   INC       ECX
         //LEA       ESI, [EBX].TControl.fOnMouseUp
         LODSD
         LODSD
         RET

@@MMove: LEA       ESI, [EBX].TControl.fOnMouseMove
         //ADD       ESI, 16
         RET

@@MDblClk: INC     ECX
@@RDblClk: INC     ECX
@@LDblClk: INC     ECX
         LEA       ESI, [EBX].TControl.fOnMouseDblClk
         //ADD       ESI, 24
         RET

@@MWheel:LEA       ESI, [EBX].TControl.fOnMouseWheel
         //ADD       ESI, 32
         //RET
end;
{$ELSE ASM_VERSION} //Pascal
function WndProcMouse(Self_: PControl; var Msg: TMsg; var Rslt: Integer): Boolean;
var MouseData: TMouseEventData;
begin
  Result := False;
  if (Msg.message >= WM_MOUSEFIRST) and (Msg.message <= $20A {WM_MOUSELAST}) and
     (Msg.hwnd = Self_.fHandle) then
  with MouseData do
  begin
    Shift := Msg.wParam;
    if GetKeyState( VK_MENU ) < 0 then
       Shift := Shift or MK_ALT;
    X := LoWord( Msg.lParam );
    Y := HiWord( Msg.lParam );
    Button := mbNone;
    StopHandling := FALSE;
    Rslt := 0; // needed ?
    case Msg.message of
    WM_LBUTTONDOWN:
      if Assigned( Self_.OnMouseDown ) then
      begin
         Button := mbLeft;
         Self_.OnMouseDown( Self_, MouseData );
      end;
    WM_RBUTTONDOWN:
      if Assigned( Self_.OnMouseDown ) then
      begin
         Button := mbRight;
         Self_.OnMouseDown( Self_, MouseData );
      end;
    WM_MBUTTONDOWN:
      if Assigned( Self_.OnMouseDown ) then
      begin
         Button := mbMiddle;
         Self_.OnMouseDown( Self_, MouseData );
      end;
    WM_LBUTTONUP:
      if Assigned( Self_.OnMouseUp ) then
      begin
         Button := mbLeft;
         Self_.OnMouseUp( Self_, MouseData );
      end;
    WM_RBUTTONUP:
      if Assigned( Self_.OnMouseUp ) then
      begin
         Button := mbRight;
         Self_.OnMouseUp( Self_, MouseData );
      end;
    WM_MBUTTONUP:
      if Assigned( Self_.OnMouseUp ) then
      begin
         Button := mbMiddle;
         Self_.OnMouseUp( Self_, MouseData );
      end;
    WM_MOUSEMOVE:
      if Assigned( Self_.OnMouseMove ) then
         Self_.OnMouseMove( Self_, MouseData );
    WM_LBUTTONDBLCLK:
      if Assigned( Self_.OnMouseDblClk ) then
      begin
         Button := mbLeft;
         Self_.OnMouseDblClk( Self_, MouseData );
      end;
    WM_RBUTTONDBLCLK:
      if Assigned( Self_.OnMouseDblClk ) then
      begin
         Button := mbRight;
         Self_.OnMouseDblClk( Self_, MouseData );
      end;
    WM_MBUTTONDBLCLK:
      if Assigned( Self_.OnMouseDblClk ) then
      begin
         Button := mbMiddle;
         Self_.OnMouseDblClk( Self_, MouseData );
      end;
    $020A {WM_MOUSEWHEEL}:
      if Assigned( Self_.OnMouseWheel ) then
         Self_.OnMouseWheel( Self_, MouseData );
    else
      Exit; //Result := False;
    end;
    Result := StopHandling;
  end;
end;
{$ENDIF ASM_VERSION}
//[END WndProcMous]

//[FUNCTION WndProcKeybd]
{$IFDEF ASM_VERSION}
function WndProcKeybd( Self_: PControl; var Msg: TMsg; var Rslt: Integer): Boolean;
asm
        PUSH     EBX
        MOV      ECX, [EDX].TMsg.message
        SUB      CX, $100
        CMP      ECX, 5
        JA       @@fin_false
        XCHG     EBX, EAX   // EBX = Self
        XCHG     EAX, ECX   // EAX = message - WM_KEYFIRST
        LEA      ECX, [EBX].TControl.fOnKeyUp
        JZ       @@event
        {$IFDEF PARANOIA}
        DB $34, 1
        {$ELSE}
        XOR      AL, 1
        {$ENDIF}
        JZ       @@event
        LEA      ECX, [EBX].TControl.fOnKeyDown
        {$IFDEF PARANOIA}
        DB $34, 1
        {$ELSE}
        XOR      AL, 1
        {$ENDIF}
        JZ       @@event
        {$IFDEF PARANOIA}
        DB $34, 4
        {$ELSE}
        XOR      AL, 4
        {$ENDIF}
        JZ       @@event
        LEA      ECX, [EBX].TControl.fOnChar
        {$IFDEF PARANOIA}
        DB $34, 6
        {$ELSE}
        XOR      AL, 2 xor 4
        {$ENDIF}
        JZ       @@event
        {$IFDEF PARANOIA}
        DB $34, 4
        {$ELSE}
        XOR      AL, 6 xor 2
        {$ENDIF}
        JNZ      @@fin_false
@@event:
        CMP      word ptr [ECX].TMethod.Code+2, 0
        JZ       @@fin_false
        PUSH     EDX
        PUSH     ECX
        LEA      ECX, [EDX].TMsg.wParam
        PUSH     ECX
        CALL     GetShiftState
        POP      ECX         // @wParam
        XCHG     EAX, [ESP]  // ShiftState; EAX=@event
        MOV      EDX, EBX    // Self
        MOV      EBX, [EAX].TMethod.Code
        MOV      EAX, [EAX].TMethod.Data
        CALL     EBX

        POP      EDX
        MOV      ECX, [EDX].TMsg.wParam
        JECXZ    @@fin_true

@@fin_false:
        XOR      EAX, EAX
        POP      EBX
        RET

@@fin_true:
        MOV      AL, 1
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function WndProcKeybd(Self_: PControl; var Msg: TMsg; var Rslt: Integer): Boolean;
var C : Char;
begin
  Result := True;
  case Msg.message of
    WM_KEYDOWN, WM_SYSKEYDOWN:
      if assigned( Self_.fOnKeyDown ) then
         Self_.fOnKeyDown( Self_, Msg.wParam, GetShiftState );
    WM_KEYUP, WM_SYSKEYUP:
      if assigned( Self_.fOnKeyUp ) then
         Self_.fOnKeyUp( Self_, Msg.wParam, GetShiftState );
    WM_CHAR, WM_SYSCHAR:
      if assigned( Self_.fOnChar ) then
      begin
         C := Char( Msg.wParam );
         Self_.fOnChar( Self_, C, GetShiftState );
         Msg.wParam := Integer( C );
      end;
    else begin
           Result := False;
           Exit;
         end;
  end;
  if Msg.wParam <> 0 then
    Result := False;
end;
{$ENDIF ASM_VERSION}
//[END WndProcKeybd]

//[function WndProcDummy]
function WndProcDummy(Self_: PControl; var Msg: TMsg; var Rslt: Integer): Boolean;
begin
  Result := False;
end;

//[procedure ExcludeCtlsWhichCannotDblBuf]
procedure ExcludeCtlsWhichCannotDblBuf( Sender, ParentCtl: PControl; DC: HDC );
var I: Integer;
    C: PControl;
    R, R1: TRect;
begin
  for I := 0 to ParentCtl.fChildren.Count-1 do
  begin
    C := ParentCtl.fChildren.Items[ I ];
    if C.fCannotDoubleBuf then
    begin
      GetWindowRect( Sender.fHandle, R );
      GetWindowRect( C.fHandle, R1 );
      OffsetRect( R1, -R.Left, -R.Top );
      ExcludeClipRect(DC, R1.Left, R1.Top, R1.Right, R1.Bottom);
    end
      else
      ExcludeCtlsWhichCannotDblBuf( Sender, C, DC );
  end;
end;

//[procedure DoReleaseDblBufBmp]
procedure DoReleaseDblBufBmp( Sender: PControl );
begin
  if Sender.fDblBufBmp <> 0 then
    DeleteObject( Sender.fDblBufBmp );
end;

//[procedure DoDrawChildrenDblBuffered]
procedure DoDrawChildrenDblBuffered( DC: HDC; WndParent: HWnd; const RectParent: TRect;
          W: HWnd );
var R, CR: TRect;
    Save: Integer;
    P, P0: TPoint;
begin
  while W <> 0 do
  begin
    if IsWindowVisible( W ) then
    begin
      Save := SaveDC( DC );
      GetWindowRect( W, R );
      GetWindowOrgEx( DC, P );
      SetWindowOrgEx( DC, P.x - ( R.Left - RectParent.Left ), P.y - ( R.Top - RectParent.Top ), nil );
      IntersectClipRect( DC, 0, 0, R.Right - R.Left, R.Bottom - R.Top );
      SendMessage( W, WM_PRINT, DC, PRF_NONCLIENT );
      GetClientRect( W, CR );
      P0.x := 0; P0.y := 0;
      ClientToScreen( W, P0 );
      OffsetRect( CR, P0.x, P0.y );
      SetWindowOrgEx( DC, P.x - (CR.Left - RectParent.Left), P.y - (CR.Top - RectParent.Top), nil );
      IntersectClipRect( DC, 0, 0, CR.Right - CR.Left, CR.Bottom - CR.Top );
      SendMessage( W, WM_ERASEBKGND, DC, 0 );
      SendMessage( W, WM_PAINT, DC, 0 );
      DoDrawChildrenDblBuffered( DC, W, CR, GetWindow( W, GW_CHILD ) );
      RestoreDC( DC, Save );
    end;
    W := GetWindow( W, GW_HWNDNEXT );
  end;
end;

//[procedure DoDrawDblBuffered]
procedure DoDrawDblBuffered( Sender: PControl );
var R: TRect;
    DC0, DC1, DC2: HDC;
    OldBmp: HBitmap;
    R2: TRect;
    P1, P2: TPoint;
    ClientOnly: Boolean;
    OldPaintDC: HDC;
{$IFDEF DEBUGDBLBUFF}
Tmp: PBitmap;
{$ENDIF}
begin
  if not GetUpdateRect( Sender.fHandle, R, FALSE ) then
    Exit; // nothing to paint

  Sender.fDblBufPainting := TRUE;

  ClientOnly := Sender.fIsForm {and (WinVer < wvNT)};
  if ClientOnly then
    GetClientRect( Sender.fHandle, R )
  else
  begin
    GetWindowRect( Sender.fHandle, R );
    OffsetRect( R, -R.Left, -R.Top );
  end;

  DC0 := GetDC( Sender.fHandle );
  DC1 := CreateCompatibleDC( DC0 );
  if Sender.fDblBufBmp = 0 then
    Sender.Add2AutoFreeEx( TObjectMethod( MakeMethod( Sender, @ DoReleaseDblBufBmp ) ) );
  if (Sender.fDblBufW < R.Right) or (Sender.fDblBufH < R.Bottom) or
     (Sender.fDblBufW > R.Right + 32) or (Sender.fDblBufH > R.Bottom + 32) then
    if Sender.fDblBufBmp <> 0 then
    begin
      DeleteObject( Sender.fDblBufBmp );
      Sender.fDblBufBmp := 0;
    end;
  if Sender.fDblBufBmp = 0 then
  begin
    Sender.fDblBufBmp := CreateCompatibleBitmap( DC0, R.Right, R.Bottom );
    Sender.fDblBufW := R.Right;
    Sender.fDblBufH := R.Bottom;
  end;
  OldBmp := SelectObject( DC1,  Sender.fDblBufBmp );

  OldPaintDC := Sender.fPaintDC;
  Sender.fPaintDC := DC1;
  if ClientOnly then
  begin
    GetClientRect( Sender.fHandle, R2 );
    P2.x := 0; P2.y := 0;
    ClientToScreen( Sender.fHandle, P2 );
    OffsetRect( R2, P2.x, P2.y );
    SendMessage( Sender.fHandle, WM_ERASEBKGND, DC1, 0 );
    SendMessage( Sender.fHandle, WM_PAINT, DC1, 0 );
    DoDrawChildrenDblBuffered( DC1, Sender.fHandle, R2,
                               GetWindow( Sender.fHandle, GW_CHILD ) );
  end
    else
  begin
    {Sender.Perform( WM_PRINT, DC1,
      PRF_CLIENT or PRF_NONCLIENT or PRF_ERASEBKGND or PRF_CHILDREN );}
    GetWindowRect( Sender.fHandle, R2 );
    DoDrawChildrenDblBuffered( DC1, Sender.fHandle, R2, Sender.fHandle );
  end;
  //Sender.fPaintDC := DC1;

  DC2 := GetWindowDC( Sender.fHandle );

  ExcludeCtlsWhichCannotDblBuf( Sender, Sender, DC2 );

  P1.x := 0; P1.y := 0;
  if ClientOnly then
  begin
    GetWindowRect( Sender.fHandle, R2 );
    ClientToScreen( Sender.fHandle, P1 );
    P1.x := P1.x - R2.Left;
    P1.y := P1.y - R2.Top;
    GetClientRect( Sender.fHandle, R );
  end;
  BitBlt( DC2, P1.x, P1.y, R.Right, R.Bottom, DC1, 0, 0, SRCCOPY );

{$IFDEF DEBUGDBLBUFF}
Tmp := NewDIBBitmap( R.Right, R.Bottom, pf16bit );
BitBlt( Tmp.Canvas.Handle, 0, 0, R.Right, R.Bottom, DC1, 0, 0, SRCCopy );
Tmp.SaveToFile( 'c:\tmp.bmp' );
Tmp.Free;
{$ENDIF}

  ReleaseDC( Sender.fHandle, DC2 );

  SelectObject( DC1, OldBmp );
  DeleteDC( DC1 );
  ReleaseDC( Sender.fHandle, DC0 );

  Sender.fPaintDC := OldPaintDC;
  ValidateRect( Sender.fHandle, nil );

  Sender.fDblBufPainting := FALSE;
end;

//[function WndProcBufferedDraw]
function WndProcBufferedDraw( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var Self_DblBufTopParent: PControl;
begin
  Result := False;
  //if AppletTerminated then Exit;
  case Msg.message of
  WM_ERASEBKGND:
    begin
      if Self_.fCannotDoubleBuf then Exit;
      if Self_.DblBufTopParent <> nil then
        // if the Control is not DoubleBuffered, and none of its Parent controls are
        // DoubleBuffered, than ignore this call in Global_OnBufferedDraw, and work
        // as usual.
      begin // Call made in WndProcBufferedDraw of the top DoubleBuffered
            // Parent control, while processing WM_PAINT
        if Self_.fTransparent
             // Handle opaque control as usual.
             // For transparent (child) controls, do nothing at all
             // in responce to WM_ERASEBKGND (just tell to the system, that
             // the operation completed).
        OR
             // If DoubleBuffered control or control's DoubleBuffered parent
             // is not painting now through buffer, just ignore the message
           not Self_.DblBufTopParent.fDblBufPainting
           then
        begin
          if Self_.fParent <> nil then
          begin
            Rslt := 1;
            Result := TRUE;
            Exit;
          end;
        end;
      end;
    end;
  WM_PAINT:
    begin
      if Self_.fCannotDoubleBuf then Exit;
      Self_DblBufTopParent := Self_.DblBufTopParent;
      if Self_DblBufTopParent = nil then
        // if the Control is not DoubleBuffered, and none of its Parent controls are
        // DoubleBuffered, than ignore this call in Global_OnBufferedDraw, and work
        // as usual.
        Exit;
      if Self_DblBufTopParent <> Self_ then
        // if one of the Parent controls is DoubleBuffered, than ignore this call
        // in Global_OnBufferedDraw, and work as usual (actually this allows to
        // paint children of the DoubleBuffered Parent control to be painted on
        // its buffer).
      begin
        if (not Self_DblBufTopParent.fDblBufPainting) or
           (Self_DblBufTopParent.fPaintDC = 0) then
        begin // Usual call. Ignore it.
          ValidateRect( Self_.fHandle, nil );
          //RedrawWindow( Self_.fHandle, nil, 0, RDW_VALIDATE ); experiment
          if not Self_DblBufTopParent.fDblBufPainting then
          begin
            Self_.DblBufTopParent.Invalidate;
            //RedrawWindow( Self_DblBufTopParent.fHandle, nil, 0, RDW_INVALIDATE ); exp.
            //RedrawWindow( Self_DblBufTopParent.fHandle, nil, 0, RDW_UPDATENOW );  exp.
          end;
          Rslt := 0;
          Result := True;
        end;
        Exit; // Call from DoDrawDblBuffered of the top doublebuffered Parent
      end;
      if Msg.wParam <> 0 then Exit;
      DoDrawDblBuffered( Self_ );
      Rslt := 0;
      Result := True;
    end;
  WM_NCPAINT:
    begin
      if Self_.fIsForm {and (WinVer < wvNT)} then Exit;
      if Self_.CannotDoubleBuf then Exit;
      Self_DblBufTopParent := Self_.DblBufTopParent;
      if Self_DblBufTopParent = nil then
        // if the Control is not DoubleBuffered, and none of its Parent controls are
        // DoubleBuffered, than ignore this call in Global_OnBufferedDraw, and work
        // as usual.
        Exit;
      //if Self_.DblBufTopParent <> Self_ then
        // if one of the Parent controls is DoubleBuffered, than ignore this call
        // in Global_OnBufferedDraw, and work as usual (actually this allows to
        // paint children of the DoubleBuffered Parent control to be painted on
        // its buffer).
      begin
        if not Self_DblBufTopParent.fDblBufPainting
        then
        begin // Usual call. Ignore it.
          //ValidateRect( Self_.fHandle, nil );
          Rslt := 0;
          Result := True;
        end;
      end;
    end;
  WM_SETTEXT:
    begin
      if Self_.DblBufTopParent = nil then Exit;
      if not Self_.fIsStaticControl then Exit;
      ShowWindow( Self_.fHandle, SW_HIDE );
      Rslt := DefWindowProc( Self_.fHandle, WM_SETTEXT, Msg.wParam, Msg.lParam );
      ShowWindow( Self_.fHandle, SW_SHOWNA );
      UpdateWindow( Self_.fHandle ); // necessary!!!
      Result := True;
    end;
  WM_HSCROLL, WM_VSCROLL, WM_WINDOWPOSCHANGED:
    begin
      if Self_.DblBufTopParent = nil then Exit;
      Self_.Invalidate;
    end;
  WM_COMMAND:
    case HiWord( Msg.wParam ) of
    LBN_SELCHANGE {, CBN_SELCHANGE }:
      begin
        if Self_.DblBufTopParent = nil then Exit;
        Self_.Invalidate;
      end;
    end;
  end;
end;

const
  MM_MCINOTIFY        = $3B9;

{$IFDEF ASM_VERSION}
{$DEFINE ASM_LOCAL}
{$IFDEF NEW_MODAL}
  {$UNDEF ASM_LOCAL}
{$ENDIF}
{$ENDIF}

{$IFDEF ASM_LOCAL}
//[function TControl.WndProc]
function TControl.WndProc( var Msg: TMsg ): Integer;
asm     //cmd    //opd
        PUSH     EBX
        PUSH     ESI
        PUSH     EDI
        XCHG     ESI, EAX
        MOV      EDI, EDX
        XOR      EAX, EAX
        CMP      EAX, [EDX].TMsg.hWnd
        JNE      @@1
        CMP      EAX, [ESI].TControl.fHandle
        JNE      @@1
        MOV      EAX, [EDX].TMsg.hWnd
        MOV      [ESI].TControl.fHandle, EAX
@@1:
        PUSH     0
        MOV      ECX, ESP
        MOV      EAX, ESI
        CALL     dword ptr [Global_OnBufferedDraw]
        TEST     AL, AL
        POP      EAX
        JNZ      @@pass2defproc

        CMP      [AppletRunning], 0
        JZ       @@dyn2
        MOV      ECX, [Applet]
        JECXZ    @@dyn2
        CMP      ECX, ESI
        JE       @@dyn2

        CALL     @@onmess

@@dyn2: MOV      ECX, ESI
        CALL     @@onmess

        MOV      EBX, [ESI].TControl.fOnDynHandlers
        MOV      EAX, ESI
        CALL     @@callonmes

@@flicksproc:
        MOV      EAX, ESI
        MOV      EDX, EDI
        PUSH     0
        MOV      ECX, ESP
        CALL     dword ptr [ESI].TControl.fWndProcResizeFlicks
        TEST     AL, AL
        POP      EAX
        JNZ      @@pass2defproc

        CMP      word ptr [EDI].TMsg.message, WM_CLOSE
//********************************************************** Changed By M.Gerasimov
//      JNE      @@chk_WM_NCDESTROY
        JNE      @@chk_WM_DESTROY
//********************************************************** Changed By M.Gerasimov


        MOV      ECX, [ESI].TControl.fOnClose.TMethod.Code
        JECXZ    @@wm_close1
        MOV      EBX, ECX
        PUSH     1
        MOV      ECX, ESP
        MOV      EDX, ESI
        MOV      EAX, [ESI].TControl.fOnClose.TMethod.Data
        CALL     EBX
        POP      ECX
        INC      ECX
        LOOP     @@wm_close0
        CMP      [AppletRunning], CL
        JZ       @@wm_close0
        //XOR      EAX, EAX
        //MOV      [ESI].TControl.fModalResult, 0
        JMP      @@0pass2defproc

/////////////////
@@onmess:
        MOV      EAX, [ECX].TControl.fOnMessage.TMethod.Data
        MOV      EBX, [ECX].TControl.fOnMessage.TMethod.Code
@@callonmes:
        TEST     EBX, EBX
        JNZ      @@onmess1 // @@dynmes1
@@2onmessret:
        RET
@@onmess1:
        PUSH     0

        MOV      EDX, EDI
        MOV      ECX, ESP
        CALL     EBX
        TEST     AL, AL

        POP      EAX
        JZ       @@2onmessret
        POP      EDX // pop retaddr
        JMP      @@pass2defproc
/////////////////

@@wm_close0:
        XOR      EAX, EAX
        MOV      [ESI].TControl.fOnClose.TMethod.Code, EAX
@@wm_close1:
        MOV      EAX, ESI
        CALL     TControl.IsMainWindow
        TEST     AL, AL
        MOV      ECX, [Applet]
        JNZ      @@wm_close2
        CMP      ESI, ECX
        JNE      @@calldef

@@wm_close2:
        JECXZ    @@postquit
        CMP      ECX, ESI
        JE       @@postquit
        PUSH     0
        PUSH     0
        PUSH     WM_CLOSE
        PUSH     ECX
        CALL     TControl.Perform
@@postquit:
        PUSH     0
        CALL     PostQuitMessage
        //XOR      EAX, EAX
        JMP      @@0pass2defproc

//********************************************************** Added By M.Gerasimov
//*
@@chk_WM_DESTROY:
        {CMP      word ptr [EDI].TMsg.message, WM_DESTROY
        JNE      @@chk_WM_NCDESTROY
        PUSH     GW_CHILD
        PUSH     [ESI].fHandle
        CALL     GetWindow
        TEST     EAX,EAX
        JZ       @@chk_WM_NCDESTROY
@@RmvNext:
        PUSH     EAX
        PUSH     offset[ID_PREVPROC]
        PUSH     EAX
        CALL     GetProp
        TEST     EAX,EAX
        JZ       @@GetNextChild
        POP      EAX
        PUSH     EAX
        PUSH     offset[ID_PREVPROC]
        PUSH     EAX
        CALL     RemoveProp
@@GetNextChild:
        POP      EAX
        PUSH     GW_HWNDNEXT
        PUSH     EAX
        CALL     GetWindow
        TEST     EAX,EAX
        JNZ       @@RmvNext}
//*
//********************************************************** Added By M.Gerasimov
@@chk_WM_NCDESTROY:
        CMP      word ptr [EDI].TMsg.message, WM_NCDESTROY
        JNE      @@chk_CM_RELEASE
//********************************************************** Added By M.Gerasimov
//*
        PUSH     offset[ID_SELF]
        PUSH     [ESI].fHandle
        CALL     RemoveProp
//*
//********************************************************** Added By M.Gerasimov

        MOV      ECX, [Applet]
        JECXZ    @@nc_destroy1
        MOV      EAX, [ESI].TControl.fHandle
        CMP      EAX, [ECX].TControl.fHandle
        JE       @@calldef
@@nc_destroy1:
        MOV      EAX, ESI
        CALL     TControl.IsMainWindow
        TEST     AL, AL
        JZ       @@nc_destroy2
        PUSH     0
        PUSH     0
        PUSH     CM_RELEASE
        PUSH     [ESI].TControl.fHandle
        CALL     PostMessage
        JMP      @@calldef

@@nc_destroy2:
        MOV      EAX, [ESI].TControl.fParent
        CMP      EAX, [Applet]
        JNE      @@calldef

        MOV      [ESI].TControl.fNCDestroyed, 1
@@do_free:
        XCHG     EAX, ESI
        CALL     TObj.Free

        XOR      EAX, EAX
        JMP      @@exit // WM_NCDESTROY and CM_RELEASE
                        // is not a subject to pass it
                        // to fPass2DefProc

@@chk_CM_RELEASE:
        CMP      word ptr [EDI].TMsg.message, CM_RELEASE
        JNE      @@chk_WM_SIZE

        MOV      [ESI].TControl.fDestroying, 1
        JMP      @@do_free

@@chk_WM_SIZE:
        CMP      word ptr [EDI].TMsg.message, WM_SIZE
        JNE      @@chk_WM_SHOWWINDOW

        MOV      EDX, EDI
        MOV      EAX, ESI
        CALL     TControl.CallDefWndProc
        PUSH     EAX

        MOV      ECX, [EDI].TMsg.wParam
        MOV      [ESI].TControl.fWindowState, CL

        CMP      [ESI].TControl.fIsForm, 0
        JNZ      @@doGlobalAlignSelf
        MOV      EAX, [ESI].TControl.fParent
        TEST     EAX, EAX
        JZ       @@doGlobalAlignSelf
        CALL     dword ptr [Global_Align]
@@doGlobalAlignSelf:
        XCHG     EAX, ESI
        CALL     dword ptr [Global_Align]

        //POP      EAX
        JMP      @@popeax_exit
                        // fPass2DefProc not needed,
                        // CallDefWndProc already called

@@chk_WM_SHOWWINDOW:
        CMP      word ptr [EDI].TMsg.message, WM_SHOWWINDOW
        JNE      @@chk_WM_SYSCOMMAND

        MOV      ECX, [EDI].TMsg.lParam
        LOOP     @@chk_SW_PARENTOPENING

        PUSH     [ESI].TControl.fHandle
        CALL     IsIconic
        XOR      EBX, EBX
        MOV      BL, SW_SHOWMINNOACTIVE
        TEST     EAX, EAX
        JNZ      @@store_action

        PUSH     [ESI].TControl.fHandle
        CALL     IsZoomed
        MOV      BL, SW_SHOWMAXIMIZED
        TEST     EAX, EAX
        JNZ      @@store_action

        MOV      BL, SW_SHOWNOACTIVATE
@@store_action:
        MOV      [ESI].TControl.fShowAction, EBX
@@2calldef:
        JMP      @@calldef

@@chk_SW_PARENTOPENING:
        DEC      ECX
        LOOP     @@2calldef

        MOV      ECX, [ESI].TControl.fShowAction
        JECXZ    @@ret_0

        PUSH     ECX
        PUSH     [ESI].TControl.fHandle
        CALL     ShowWindow

        XOR      EAX, EAX
        MOV      [ESI].TControl.fShowAction, EAX
@@ret_0:
        //XOR      EAX, EAX
        JMP      @@0pass2defproc

@@chk_WM_SYSCOMMAND:
        CMP      word ptr [EDI].TMsg.message, WM_SYSCOMMAND
        JNE      @@chk_WM_SETFOCUS

        MOV      EAX, [EDI].TMsg.wParam
        {$IFDEF PARANOIA}
        DB $24, $F0
        {$ELSE}
        AND      AL, $F0
        {$ENDIF}
        CMP      AX, SC_MINIMIZE
        JNE      @@calldef

        MOV      EAX, ESI
        CALL     TControl.IsMainWindow
        TEST     AL, AL
        JZ       @@calldef

        CMP      ESI, [Applet]
        JE       @@calldef

        PUSH     0
        PUSH     SC_MINIMIZE
        PUSH     WM_SYSCOMMAND
        MOV      EAX, [Applet]
        PUSH     [EAX].TControl.fHandle
        CALL     PostMessage
        JMP      @@ret_0

@@chk_WM_SETFOCUS:
        CMP      word ptr [EDI].TMsg.message, WM_SETFOCUS
        JNE      @@chk_WM_SETCURSOR

        MOV      EAX, ESI
        CALL     TControl.DoSetFocus
        TEST     AL, AL
        JZ       @@0pass2defproc

//@@calldef_clickdisabled:
        INC      [ESI].TControl.fClickDisabled

        MOV      EAX, ESI
        MOV      EDX, EDI
        CALL     TControl.CallDefWndProc

        DEC      [ESI].TControl.fClickDisabled
        JMP      @@exit

@@chk_WM_SETCURSOR:
        CMP      word ptr [EDI].TMsg.message, WM_SETCURSOR
        JNE      @@chk_WM_CTLCOLOR

        CMP      [Global_DisableParentCursor], 0
        JNE      @@calldef

        CALL     GetCapture
        TEST     EAX, EAX
        JNZ      @@calldef

        CMP      word ptr [EDI].TMsg.lParam, HTCLIENT
        JNE      @@calldef

        MOV      ECX, [ScreenCursor]
        INC      ECX
        LOOP     @@setupCursor

        MOV      ECX, [ESI].TControl.fCursor
        TEST     ECX, ECX                    //YS
        JE       @@calldef                   //YS
@@setupCursor:
        PUSH     ECX
        CALL     Windows.SetCursor

        MOV      AL, 1
        JMP      @@exit

@@chk_WM_CTLCOLOR:
        MOV      EAX, [EDI].TMsg.message
        SUB      AX, WM_CTLCOLORMSGBOX
        CMP      AX, WM_CTLCOLORSTATIC-WM_CTLCOLORMSGBOX
        JA       @@chk_WM_COMMAND

        PUSH     [EDI].TMsg.lParam
        PUSH     [EDI].TMsg.wParam
        ADD      AX, CN_BASE+WM_CTLCOLORMSGBOX
        PUSH     EAX
        PUSH     [EDI].TMsg.lParam
        CALL     SendMessage
        JMP      @@pass2defproc

@@chk_WM_COMMAND:
        CMP      word ptr [EDI].TMsg.message, WM_COMMAND
        JNE      @@chk_WM_KEY

        PUSH     offset[ID_SELF]
        PUSH     [EDI].TMsg.lParam
        CALL     GetProp
        TEST     EAX, EAX
        JZ       @@calldef

        PUSH     [EDI].TMsg.lParam
        PUSH     [EDI].TMsg.wParam
        PUSH     CM_COMMAND
        PUSH     [EDI].TMsg.lParam
        CALL     SendMessage
        JMP      @@pass2defproc

@@chk_WM_KEY:
        MOV      EAX, [EDI].TMsg.message
        SUB      AX, WM_KEYFIRST
        CMP      AX, WM_KEYLAST-WM_KEYFIRST
        JA       @@chk_CM_EXECPROC

        CALL     GetFocus
        CMP      EAX, [ESI].TControl.fFocusHandle
        JE       @@in_focus
        CMP      EAX, [ESI].TControl.fHandle
        JNE      @@0pass2defproc

@@in_focus:
        PUSH     EAX

        MOV      ECX, ESP
        MOV      EDX, EDI
        MOV      EAX, ESI
        CALL     dword ptr [fGlobalProcKeybd]
        TEST     AL, AL
        JNZ      @@to_exit

        MOV      ECX, ESP
        MOV      EDX, EDI
        MOV      EAX, ESI
        CALL     [ESI].fWndProcKeybd
        TEST     AL, AL
@@to_exit:
        POP      EAX
        JNZ      @@pass2defproc

        PUSH     VK_CONTROL
        CALL     GetKeyState
        XCHG     EBX, EAX
        PUSH     VK_MENU
        CALL     GetKeyState
        OR       EAX, EBX
        ADD      EAX, EAX
        JC       @@calldef

        CMP      word ptr [EDI].TMsg.message, WM_CHAR
        JNE      @@to_fGotoControl

        CMP      byte ptr [EDI].TMsg.wParam, 9
        JE       @@clear_wParam
        JMP      @@calldef

@@to_fGotoControl:
        MOV      EAX, ESI
        CALL     TControl.ParentForm
        TEST     EAX, EAX
        JZ       @@calldef

        MOV      ECX, [EAX].fGotoControl
        JECXZ    @@calldef

        MOV      EBX, ECX
        CMP      [EDI].TMsg.message, WM_KEYDOWN
        SETNE    CL
        MOV      EDX, [EDI].TMsg.wParam
        MOV      EAX, ESI
        CALL     EBX
        TEST     AL, AL
        JZ       @@calldef

@@clear_wParam:
        XOR      EAX, EAX
        MOV      [EDI].TMsg.wParam, EAX
        JMP      @@pass2defproc

@@chk_CM_EXECPROC:
        CMP      word ptr [EDI].TMsg.message, CM_EXECPROC
        JNE      @@chk_MM_MCINOTIFY

        MOV      EAX, [EDI].TMsg.lParam
        MOV      EDX, [EDI].TMsg.wParam
        CALL     [Global_Synchronized]
        JMP      @@0pass2defproc

@@chk_MM_MCINOTIFY:
        CMP      word ptr [EDI].TMsg.message, MM_MCINOTIFY
        JNE      @@calldef

        MOV      ECX, [FMMNotify]
        JECXZ    @@ret_0_MM

        XCHG     EAX, EDI
        CALL     ECX
@@ret_0_MM:
        XOR      EAX, EAX
        JMP      @@exit

@@calldef:
        XCHG     EAX, ESI
        MOV      EDX, EDI
        CALL     TControl.CallDefWndProc
        JMP      @@exit

@@0pass2defproc:
        XOR      EAX, EAX
@@pass2defproc:
        PUSH     EAX
@@1pass2defproc:
        CMP      [AppletTerminated], 0 //
        JNZ      @@popeax_exit         // uncommented 25-Oct-2003
        CMP      [ESI].fNCDestroyed, 0 //
        JNZ      @@popeax_exit         //

        MOV      ECX, ESP
        XCHG     EAX, ESI
        MOV      EDX, EDI
        CALL     dword ptr[EAX].fPass2DefProc
@@popeax_exit:
        POP      EAX

@@exit:
        POP      EDI
        POP      ESI
        POP      EBX
end;
{$ELSE ASM_LOCAL} //Pascal

  {$IFDEF DEBUG_CREATEWINDOW}
  var DbgCWCount: Integer = 0;
  {$ENDIF DEBUG_CREATEWINDOW}
function TControl.WndProc( var Msg: TMsg ): Integer;
var Accept: Boolean;
    C : PControl;
    F {, Chld}: HWnd;
    Cur: HCURSOR; // YS
    PassFun: function( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;

    procedure Default;
    begin
      Result := CallDefWndProc( Msg );
    end;

begin
   {$IFDEF DEBUG_CREATEWINDOW}
   Inc( DbgCWCount );
   if DbgCWCount < 10 then
     LogFileOutput( GetStartDir + 'Session.log', 'TControl.WndProc: ' +
     ' Msg.hwnd=' + Int2Str( Msg.hwnd ) +
     ' Msg.message=' + Int2Hex( Msg.message, 2 ) +
     ' Msg.wParam=' + Int2Str( Msg.wParam ) + '=$' + Int2Hex( Msg.wParam, 4 ) +
     ' Msg.lParam=' + Int2Str( Msg.lParam ) + '=$' + Int2Hex( Msg.lParam, 4 ) );
   {$ENDIF DEBUG_CREATEWINDOW}
   if (Msg.hwnd <> 0) and (fHandle = 0) then
      fHandle := Msg.hwnd;

   PassFun := fPass2DefProc;
   if not Global_OnBufferedDraw( Self, Msg, Result ) then
   if not (AppletRunning and (Applet <> Self) and Assigned( Applet ) and
      Assigned( Applet.OnMessage ) and Applet.OnMessage( Msg, Result )) then
   if not (Assigned( OnMessage ) and OnMessage( Msg, Result )) then
   if not fOnDynHandlers( Self, Msg, Result ) then
   begin
     if not fWndProcResizeFlicks( Self, Msg, Result ) then
     case Msg.message of
     {$IFDEF NEW_MODAL}
     // version of code by Alexander Pravdin
     WM_CLOSE: begin
                 Accept := True;
                 if Assigned( fOnClose ) then
                 begin
                    fOnClose( Self, Accept );
                    if AppletRunning then
                        if Accept then
                            if fModal > 0 then
                            begin
                                if ModalResult = 0 then
                                    ModalResult := Integer($80000000);
                                Msg.message := 0;
                                Exit;
                            end
                            else
                                fOnClose := nil
                        else
                        begin
                            Result := 0;
                            ModalResult := 0;
                        end
                    else
                      fOnClose := nil;
                 end else
                 begin
                     if fModal > 0 then
                     begin
                       ModalResult := Integer($80000000);
                       Exit;
                     end;
                 end;

                 if Accept then begin
                     if IsMainWindow or (Applet = Self) then
                     begin
                        if Assigned( Applet ) and (Applet <> Self) then
                           Applet.Perform( WM_CLOSE, 0, 0 );
                        PostQuitMessage( 0 );
                        Result := 0;
                     end else
                        Default;
                 end;
               end;
     {$ELSE}
     WM_CLOSE: begin
                  Accept := True;
                  if Assigned( fOnClose ) then
                  begin
                     fOnClose( Self, Accept );
                     if (not Accept) and (AppletRunning) then
                     begin
                        Result := 0;
                        //ModalResult := 0;
                        //Exit; //?????????????????
                     end
                       else //+-+
                     fOnClose := nil;
                  end;
                  if Accept then
                  begin
                    if IsMainWindow or (Applet = Self) then
                    begin
                       if Assigned( Applet ) and (Applet <> Self) then
                          Applet.Perform( WM_CLOSE, 0, 0 );
                       PostQuitMessage( 0 );
                       Result := 0;
                       //Exit; //???????????????
                    end
                      else
                    Default;
                  end;
               end;
     {$ENDIF}
{//********************************************************** Added By M.Gerasimov
//*
     WM_DESTROY:
               begin
                Chld := GetWindow( fHandle, GW_CHILD );
                while Chld <> 0 do
                 begin
                  if GetProp( Chld, ID_PREVPROC ) <> 0 then
                   RemoveProp(Chld, ID_PREVPROC);
                   Chld := GetWindow( Chld, GW_HWNDNEXT );
                 end;
               end;
//*
//********************************************************** Added By M.Gerasimov}
     WM_NCDESTROY:
               begin
//********************************************************** Added By M.Gerasimov
//*
                RemoveProp( fHandle, ID_SELF );
//*
//********************************************************** Added By M.Gerasimov
                if (Applet = nil) or (Handle <> Applet.Handle) then
                  begin
                    if IsMainWindow then
                     begin
                      PostMessage( fHandle, CM_RELEASE, 0, 0 );
                      Default;
                     end
                    else
                     if fParent = Applet then
                      begin
                       fNCDestroyed := True;
                       Free;
                       Result := 0;
                       Exit; //!!!!!!!!!!!!!!!!!!!!!!!!!
                      end
                     else
                       Default;
                  end;
               end;

     CM_RELEASE: begin
                  fDestroying := True;
                  Free;
                  Result := 0;
                  //Exit; //??????????????????????????
                 end;

     WM_SIZE:  begin
                  Default;
                  case Msg.wParam of
                    SIZENORMAL: fWindowState := wsNormal;
                    SIZEICONIC: fWindowState := wsMinimized;
                    SIZEFULLSCREEN: fWindowState := wsMaximized;
                  end;
                  if not fIsForm and (fParent <> nil) then
                    Global_Align( fParent );
                  Global_Align( Self );
                  Exit;
               end;
     WM_SHOWWINDOW:
               begin
                  case Msg.lParam of
                    SW_PARENTCLOSING:
                       begin
                          if IsIconic( fHandle ) then
                             fShowAction := SW_SHOWMINNOACTIVE
                          else
                          if IsZoomed( fHandle ) then
                             fShowAction := SW_SHOWMAXIMIZED
                          else
                             fShowAction := SW_SHOWNOACTIVATE;
                          Default;
                       end;
                    SW_PARENTOPENING:
                       begin
                          if fShowAction <> 0 then
                          begin
                             ShowWindow( Handle, fShowAction );
                             fShowAction := 0;
                          end;
                          Result := 0;
                          //Exit; //?????????????????????????
                       end;
                    else Default;
                  end;
               end;
     WM_SysCommand:
               begin
                  if ((Msg.wParam and $FFF0) = SC_MINIMIZE) and
                     IsMainWindow and (Self <> Applet) then
                  begin
                     PostMessage( Applet.Handle, WM_SYSCOMMAND, SC_MINIMIZE, 0 );
                     Result := 0;
                     //Exit; //???????????????????????????
                  end
                  else Default;
               end;
     WM_SETFOCUS:
               begin
                 if not DoSetFocus then
                 begin
                   Result := 0;
                   //Exit; //???????????????????????????
                 end
                   else
                 begin
                   Inc( fClickDisabled );
                   Default;
                   Dec( fClickDisabled );
                   Exit;
                 end;
               end;
     WM_SETCURSOR:
               if not Global_DisableParentCursor then
               begin
                  if (GetCapture = 0) and
                     (LOWORD( Msg.lParam ) = HTCLIENT) then
                  begin
                    if ScreenCursor <> 0 then                  //YS
                      Cur := ScreenCursor                      //YS
                    else                                       //YS
                      Cur := fCursor;                          //YS
                    if Cur <> 0 then                           //YS
                    begin                                      //YS
                      Windows.SetCursor( Cur );                //YS
                      Result := 1;                             //YS
                    end                                        //YS
                    else                                       //YS
                      Default;                                 //YS
                    //Exit; //?????????????????????
                  end
                  else Default;
               end
               else Default;
     WM_CTLCOLORMSGBOX..WM_CTLCOLORSTATIC:
     begin
       Result := SendMessage(Msg.LParam, CN_BASE + Msg.message, Msg.WParam, Msg.LParam);
       //exit; //???????????????????????
     end;
     WM_COMMAND:
               begin
                 C := Pointer( GetProp( Msg.lParam, ID_SELF ) );
                 if C <> nil then
                 begin
                   Result := SendMessage( Msg.lParam, CM_COMMAND, Msg.wParam, Msg.lParam );
                   //Exit; //???????????????????????
                 end
                 else Default;
               end;
     WM_KEYFIRST..WM_KEYLAST:
               begin
                 F := GetFocus;
                 if (F <> fFocusHandle) and (F <> fHandle) then
                 begin
                   Result := 0;
                   // Jump to PassFun here. Prevents beep in case when WM_KEYDOWN
                   // called another form and focus is changed, so WM_KEYUP failed
                   // to handle.
                 end
                   else
                 begin
                   if fGlobalProcKeybd( Self, Msg, Result ) then Exit; //??????????????????
                     //else
                   if fWndProcKeybd( Self, Msg, Result ) then Exit; //???????????????????
                     //else
                   if ((GetKeystate( VK_CONTROL ) or GetKeyState( VK_MENU )) >= 0) then
                   begin
                     //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                     if (Msg.message <> WM_CHAR) // v1.02 Tabulate AND " in EditBox fix
                     //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                     then
                     begin
                       C := ParentForm;
                       if (C <> nil) and Assigned(C.fGotoControl) and
                          C.fGotoControl( Self, Msg.wParam, Msg.message <> WM_KEYDOWN ) then
                       begin
                            Msg.wParam := 0;
                            Result := 0;
                            //+-+exit;
                       end
                       else Default;
                     end
                     //+++++++++++++++++++++++++++++++++++++++++++++//
                       else                                         //
                     if Msg.wParam = 9 then // prevent system beep  //
                     begin                                          //
                        Msg.wParam := 0;                            //
                        Result := 0;                                //
                        //+-+exit;                                  //
                     end                                            //
                     //+++++++++++++++++++++++++++++++++++++++++++++//
                     else Default;
                   end
                   else Default;
                 end;
               end;
     CM_EXECPROC: begin
                    Global_Synchronized( Pointer( Msg.lParam ), Pointer( Msg.wParam ) );
                    Result := 0;
                    //Exit; //???????????????????
                  end;
     MM_MCINOTIFY: begin
                     if Assigned( FMMNotify ) then
                        FMMNotify( Msg );
                     Result := 0;
                     exit;
                   end;
     else  begin
             Default; //+-+
             Exit;    //+-+
           end;
     end;
   end;

   if not AppletTerminated and not fNCDestroyed then
     PassFun( Self, Msg, Result ); //+-+
end;
{$ENDIF ASM_LOCAL}
//[END TContro]

{$UNDEF ASM_LOCAL}

//[procedure SetMouseEvent]
procedure SetMouseEvent( Self_: PControl );
begin
  Self_.AttachProc( WndProcMouse );
end;

//[procedure TControl.SetMouseDown]
procedure TControl.SetMouseDown(const Value: TOnMouse);
begin
  fOnMouseDown := Value;
  SetMouseEvent( Self );
end;

//[procedure TControl.SetMouseMove]
procedure TControl.SetMouseMove(const Value: TOnMouse);
begin
  fOnMouseMove := Value;
  SetMouseEvent( Self );
end;

//[procedure TControl.SetMouseUp]
procedure TControl.SetMouseUp(const Value: TOnMouse);
begin
  fOnMouseUp := Value;
  SetMouseEvent( Self );
end;

//[procedure TControl.SetMouseDblClk]
procedure TControl.SetMouseDblClk(const Value: TOnMouse);
begin
  fOnMouseDblClk := Value;
  SetMouseEvent( Self );
end;

//[procedure TControl.SetMouseWheel]
procedure TControl.SetMouseWheel(const Value: TOnMouse);
begin
  fOnMouseWheel := Value;
  SetMouseEvent( Self );
end;

{$IFDEF ASM_VERSION}
//[procedure TControl.SetClsStyle]
procedure TControl.SetClsStyle( Value: DWord );
asm     //cmd    //opd
        CMP      EDX, [EAX].TControl.fClsStyle
        JE       @@exit
        MOV      [EAX].TControl.fClsStyle, EDX
        MOV      ECX, [EAX].TControl.fHandle
        JECXZ    @@exit
        PUSH     EDX
        PUSH     GCL_STYLE
        PUSH     EAX
        CALL     SetClassLong
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.SetClsStyle( Value: DWord );
begin
   if fClsStyle = Value then Exit;
   fClsStyle := Value;
   if fHandle = 0 then Exit;
   SetClassLong( fHandle, GCL_STYLE, Value );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TControl.SetStyle]
procedure TControl.SetStyle( Value: DWord );
const SWP_FLAGS = SWP_NOACTIVATE or SWP_NOMOVE or SWP_NOSIZE or
                 SWP_NOZORDER or SWP_FRAMECHANGED;
asm
        CMP      EDX, [EAX].fStyle
        JZ       @@exit
        MOV      [EAX].fStyle, EDX
        MOV      ECX, [EAX].fHandle
        JECXZ    @@exit

        PUSH     EAX

        PUSH     SWP_FLAGS
        XOR      EAX, EAX
        PUSH     EAX
        PUSH     EAX
        PUSH     EAX
        PUSH     EAX
        PUSH     EAX
        PUSH     ECX

        PUSH     EDX
        PUSH     GWL_STYLE
        PUSH     ECX
        CALL     SetWindowLong

        CALL     SetWindowPos

        POP      EAX
        CALL     Invalidate
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.SetStyle( Value: DWord );
begin
   if fStyle = Value then Exit;
   fStyle := Value;
   if fHandle = 0 then Exit;
   SetWindowLong( fHandle, GWL_STYLE, Value );

   SetWindowPos( fHandle, 0, 0, 0, 0, 0,
                 SWP_NOACTIVATE or SWP_NOMOVE or SWP_NOSIZE or
                 SWP_NOZORDER or SWP_FRAMECHANGED );
   Invalidate;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TControl.SetExStyle]
procedure TControl.SetExStyle( Value: DWord );
const SWP_FLAGS = SWP_NOACTIVATE or SWP_NOMOVE or SWP_NOSIZE or
                 SWP_NOZORDER or SWP_FRAMECHANGED;
asm
        CMP      EDX, [EAX].fExStyle
        JZ       @@exit
        MOV      [EAX].fExStyle, EDX
        MOV      ECX, [EAX].fHandle
        JECXZ    @@exit

        PUSH     EAX

        PUSH     SWP_FLAGS
        XOR      EAX, EAX
        PUSH     EAX
        PUSH     EAX
        PUSH     EAX
        PUSH     EAX
        PUSH     EAX
        PUSH     ECX

        PUSH     EDX
        PUSH     GWL_EXSTYLE
        PUSH     ECX
        CALL     SetWindowLong

        CALL     SetWindowPos

        POP      EAX
        CALL     Invalidate
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.SetExStyle( Value: DWord );
begin
   if fExStyle = Value then Exit;
   fExStyle := Value;
   if fHandle = 0 then Exit;
   SetWindowLong( fHandle, GWL_EXSTYLE, Value );

   SetWindowPos( fHandle, 0, 0, 0, 0, 0,
                 SWP_NOACTIVATE or SWP_NOMOVE or SWP_NOSIZE or
                 SWP_NOZORDER or SWP_FRAMECHANGED );
   Invalidate;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TControl.SetCursor]
procedure TControl.SetCursor( Value: HCursor );
asm     //cmd    //opd
        CMP      EDX, [EAX].TControl.fCursor
        JE       @@exit
        MOV      [EAX].TControl.fCursor, EDX
        MOV      ECX, [EAX].TControl.fHandle
        JECXZ    @@exit
        TEST     EDX, EDX                      //YS
        JE       @@exit                        //YS
        MOV      ECX, [ScreenCursor]
        INC      ECX
        LOOP     @@exit

        PUSH     EBX
        XCHG     EBX, EAX
        PUSH     EDX
        PUSH     EAX
        PUSH     EAX
        PUSH     ESP
        CALL     GetCursorPos
        MOV      EDX, ESP
        MOV      ECX, EDX
        MOV      EAX, EBX
        CALL     Screen2Client
        ADD      ESP, -16
        MOV      EDX, ESP
        MOV      EAX, EBX
        CALL     TControl.ClientRect
        MOV      EDX, ESP
        LEA      EAX, [ESP+16]
        CALL     PointInRect
        ADD      ESP, 24
        TEST     AL, AL
        JZ       @@fin
        CALL     Windows.SetCursor
        PUSH     EAX
@@fin:  POP      EAX
        POP      EBX
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.SetCursor( Value: HCursor );
var P: TPoint;
begin
   if fCursor = Value then Exit;
   fCursor := Value;
   if (fHandle = 0) or (fCursor = 0) then Exit;        //YS
   if ScreenCursor <> 0 then Exit;
   GetCursorPos( P );
   P := Screen2Client( P );
   if PointInRect( P, ClientRect ) then
   Windows.SetCursor( Value );
end;
{$ENDIF ASM_VERSION}

//[procedure TControl.CursorLoad]
procedure TControl.CursorLoad(Inst: Integer; ResName: PChar);
begin
  Cursor := LoadCursor( Inst, ResName );
  fCursorShared := TRUE;
end;

{$IFDEF ASM_VERSION}
//[procedure TControl.SetIcon]
procedure TControl.SetIcon( Value: HIcon );
asm     //cmd    //opd
        CMP      EDX, [EAX].TControl.fIcon
        JE       @@exit
        MOV      [EAX].TControl.fIcon, EDX
        INC      EDX
        JZ       @@1
        DEC      EDX
@@1:
        PUSH     EDX
        PUSH     1 //ICON_BIG
        PUSH     WM_SETICON
        PUSH     EAX
        CALL     Perform
        TEST     EAX, EAX
        JZ       @@exit
        PUSH     EAX
        CALL     DestroyIcon
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.SetIcon( Value: HIcon );
var OldIco: HIcon;
begin
   if fIcon = Value then Exit;
   fIcon := Value;
   if Value = THandle(-1) then
     Value := 0;
   OldIco := Perform( WM_SETICON, 1 {ICON_BIG}, Value );
   if OldIco <> 0 then
     DestroyIcon( OldIco );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TControl.SetMenu]
procedure TControl.SetMenu( Value: HMenu );
asm
        PUSH     EBX
        XCHG     EBX, EAX
        CMP      [EBX].fMenu, EDX
        JZ       @@exit
        PUSH     EDX
        MOV      ECX, [EBX].fMenuObj
        JECXZ    @@no_free_menuctl
        XCHG     EAX, EDX
        CALL     TObj.Free
@@no_free_menuctl:
        MOV      ECX, [EBX].fMenu
        JECXZ    @@no_destroy
        PUSH     ECX
        CALL     DestroyMenu
@@no_destroy:
        POP      EDX
        MOV      [EBX].fMenu, EDX
        MOV      ECX, [EBX].fHandle
        JECXZ    @@exit
        PUSH     EDX
        PUSH     ECX
        CALL     Windows.SetMenu
@@exit:
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.SetMenu( Value: HMenu );
begin
  if fMenu = Value then Exit;
  if fMenuObj <> nil then
     fMenuObj.Free;
  if fMenu <> 0 then
     DestroyMenu( fMenu );
  fMenu := Value;
  if fHandle = 0 then Exit;
  Windows.SetMenu( fHandle, Value );
end;
{$ENDIF ASM_VERSION}

//[procedure CallWinHelp]
procedure CallWinHelp( Context: Integer; CtxCtl: PControl );
var Cmd: Integer;
    Form: PControl;
    Popup: Boolean;
begin
  Cmd := HELP_CONTEXT;
  if CtxCtl <> nil then
  begin
    Form := CtxCtl.ParentForm;
    if Form <> nil then
    if Assigned( Form.OnHelp ) then
    begin
      Popup := FALSE;
      Form.OnHelp( CtxCtl, Context, Popup );
      if Popup then
        Cmd := HELP_CONTEXTPOPUP;
      if CtxCtl = nil then Exit;
    end;
  end
    else
  if Context = 0 then
    Cmd := HELP_CONTENTS;
  WinHelp( Applet.Handle, PChar( Applet.GetHelpPath ), Cmd, Context );
end;

var HHCtrl: THandle;
    HtmlHelp: procedure( Wnd: HWnd; Path: PChar; Cmd, Data: Integer ); stdcall;

//[procedure HtmlHelpCommand]
procedure HtmlHelpCommand( Wnd: HWnd; const HelpFilePath: String; Cmd, Data: Integer );
begin
  if HHCtrl = 0 then
    HHCtrl := LoadLibrary( 'HHCTRL.OCX' );
  if HHCtrl = 0 then Exit;
  if not Assigned( HtmlHelp ) then
    HtmlHelp := GetProcAddress( HHCtrl, 'HtmlHelpA' );
  if not Assigned( HtmlHelp ) then Exit;
  HtmlHelp( Wnd, PChar( HelpFilePath ), Cmd, Data );
end;

//[procedure CallHtmlHelp]
procedure CallHtmlHelp( Context: Integer; CtxCtl: PControl );
var Cmd: Integer;
    Form: PControl;
    Popup: Boolean;
    Ids: array[ 0..2 ] of DWORD;
begin

  Cmd := $F; // HH_HELP_CONTEXT;
  if CtxCtl <> nil then
  begin
    Form := CtxCtl.ParentForm;
    if Form <> nil then
    if Assigned( Form.OnHelp ) then
    begin
      Popup := FALSE;
      Form.OnHelp( CtxCtl, Context, Popup );
      if Popup then
      begin
        Cmd := $10; //HH_TP_HELPCONTEXTMENU;
        Ids[ 0 ] := CtxCtl.fMenu;
        Ids[ 1 ] := Context;
        Ids[ 2 ] := 0;
        Context := Integer( @ Ids );
      end;
      if CtxCtl = nil then Exit;
    end;
  end
    else
  if Context = 0 then
    Cmd := 1; // HH_DISPLAY_TOC;
  HtmlHelpCommand( Applet.Handle, HelpFilePath, Cmd, Context );
end;

var
  Global_HelpProc: procedure( Context: Integer; CtxCtl: PControl ) = CallWinHelp;

//[function WndProcHelp]
function WndProcHelp( Sender: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var HI: PHelpInfo;
    Ctx: Integer;
    Ctl: PControl;
begin
  Result := FALSE;
  if Msg.message = WM_HELP then
  begin
    Ctx := 0;
    Ctl := nil;
    HI := Pointer( Msg.lParam );
    if HI.iContextType = HELPINFO_WINDOW then
    begin
      Ctl := Pointer( GetProp( HI.hItemHandle, ID_SELF ) );
      while Ctl <> nil do
      begin
        Ctx := Ctl.fHelpContext;
        if Ctx <> 0 then break;
        Ctl := Ctl.Parent;
      end;
    end
      else
    //if HI.iContextType = HELPINFO_MENUITEM then
      Ctx := GetMenuContextHelpID( HI.hItemHandle );
    Applet.CallHelp( Ctx, Ctl );
    Rslt := 1;
    Result := TRUE;
  end
  {$IFDEF AUTO_CONTEXT_HELP}
    else
  if (Msg.message = WM_CONTEXTMENU) then
  begin
    Ctl := Pointer( GetProp( Msg.wParam, ID_SELF ) );
    if (Ctl <> nil) and (Ctl.fHelpContext <> 0) then
    //if (Ctl.fAutoPopupMenu = nil) then // seems not working
    begin
      Applet.CallHelp( Ctl.fHelpContext, Ctl );
      Rslt := 1;
      Result := TRUE;
    end;
  end
  {$ENDIF}
     ;
end;

//[procedure TControl.SetHelpContext]
procedure TControl.SetHelpContext(Value: Integer);
var F: PControl;
begin
  fHelpContext := Value;
  F := ParentForm;
  if F = nil then Exit;
  F.AttachProc( WndProcHelp );
  SetWindowContextHelpId( GetWindowHandle, Value );
end;

//[function TControl.AssignHelpContext]
function TControl.AssignHelpContext(Context: Integer): PControl;
begin
  SetHelpContext( Context );
  Result := Self;
end;

//[procedure AssignHtmlHelp]
procedure AssignHtmlHelp( const HtmlHelpPath: String );
begin
  Assert( (HtmlHelpPath <> '') and (Applet <> nil), 'Error parameters' );
  if HelpFilePath <> '' then
    FreeMem( HelpFilePath );
  GetMem( HelpFilePath, Length( HtmlHelpPath ) + 1 );
  StrCopy( HelpFilePath, @ HtmlHelpPath[ 1 ] );
  Global_HelpProc := CallHtmlHelp;
  Applet.AttachProc( WndProcHelp );
end;

//[procedure TControl.CallHelp]
procedure TControl.CallHelp(Context: Integer; CtxCtl: PControl {; CtlID: Integer} );
begin
  Global_HelpProc( Context, CtxCtl {, CtlID} );
end;

//[function TControl.GetHelpPath]
function TControl.GetHelpPath: String;
begin
  Result := HelpFilePath;
  if Result = '' then
  begin
    Result := ParamStr( 0 );
    Result := ReplaceFileExt( Result, '.hlp' );
  end;
end;

//[procedure TControl.SetHelpPath]
procedure TControl.SetHelpPath(const Value: String);
begin
  Assert( Value <> '', 'Error parameter' );
  if HelpFilePath <> '' then
    FreeMem( HelpFilePath );
  GetMem( HelpFilePath, Length( Value ) + 1 );
  StrCopy( HelpFilePath, @ Value[ 1 ] );
end;

{$IFDEF ASM_VERSION}
//[function TControl.GetCaption]
function TControl.GetCaption: String;
asm
        XCHG      EAX, EDX
        MOVZX     ECX, [EDX].fIgnoreWndCaption
        JECXZ     @@getwndcaption

@@ret_fCaption:
        MOV       EDX, [EDX].fCaption
        JMP       System.@LStrFromPChar

@@getwndcaption:
        MOV       ECX, [EDX].fHandle
        JECXZ     @@ret_fCaption

        PUSH      EBX
        PUSH      ESI
        XCHG      EBX, EAX

        MOV       ESI, ECX
        PUSH      ESI
        CALL      GetWindowTextLength
        MOV       EDX, EAX
        INC       EAX
        PUSH      EAX // MaxLen

        MOV       EAX, EBX
        CALL      System.@LStrSetLength

        POP       EDX
        MOV       ECX, [EBX]
        JECXZ     @@exit
        PUSH      EDX // MaxLen = Length(Result) + 1

        PUSH      ECX //@Result[1]
        PUSH      ESI // fHandle
        CALL      GetWindowText

@@exit:
        POP       ESI
        POP       EBX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.GetCaption: String;
var Buf: PChar;
    Sz: Integer;
begin
   if not fIgnoreWndCaption and (FHandle <> 0) then
   begin
     Sz := GetWindowTextLength( FHandle );
     if Sz = 0 then
        Buf := nil
     else
     begin
       GetMem( Buf, Sz + 1 );
       GetWindowText( FHandle, Buf, Sz + 1 );
     end;
     Result := Buf;
     if Buf <> nil then
        FreeMem( Buf );
     Exit;
   end;
   Result := FCaption;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TControl.SetCaption]
procedure TControl.SetCaption( const Value: String );
asm
        PUSH    EBX
        XCHG    EBX, EAX
        PUSH    EDX
        MOV     EAX, [EBX].fCaption
        TEST    EAX, EAX
        JZ      @@store_Caption
        CALL    System.@FreeMem
@@store_Caption:
        POP     EAX
        CALL    EAX2PChar
        PUSH    EAX
        CALL    StrLen
        INC     EAX
        CALL    System.@GetMem
        MOV     [EBX].fCaption, EAX
        POP     EDX
        CALL    StrCopy
        MOV     ECX, [EBX].fHandle
        JECXZ   @@exit
        PUSH    [EBX].fCaption
        PUSH    ECX
        CALL    SetWindowText
        MOV     EAX, EBX
        CALL    Invalidate
        XCHG    EAX, EBX
        MOV     ECX, [EAX].fAutoSize
        JECXZ   @@exit
        CALL    ECX
@@exit: POP     EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.SetCaption( const Value: String );
var L: DWORD;
begin
  //if fHandle = 0 then
  begin
    if fCaption <> nil then
       FreeMem( fCaption );
    L := Length( Value ) + 1;
    GetMem( fCaption, L );
    StrCopy( fCaption, PChar( Value ) );
    //Exit;
  end;
  if fHandle = 0 then Exit;
  SetWindowText( fHandle, @Value[ 1 ] );
  Invalidate;
  if Assigned( fAutoSize ) then
    fAutoSize( Self );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.GetVisible]
function TControl.GetVisible: Boolean;
asm
        MOV     ECX, [EAX].fHandle
        JECXZ   @@check_fStyle

        {CMP     [EAX].fIsControl, 0
        JNE     @@check_fStyle}

          PUSH  EAX
        PUSH    ECX
        CALL    IsWindowVisible
        TEST    EAX, EAX
          POP   EAX
        JMP     @@checked // Z if not visible

@@check_fStyle:
        TEST    byte ptr [EAX].fStyle+3, 10h // WS_VISIBLE shr 3
@@checked:
        SETNZ   DL
        MOV     [EAX].fVisible, DL
        XCHG    EAX, EDX
end;
{$ELSE ASM_VERSION}
function TControl.GetVisible: Boolean;
begin
   if (fHandle <> 0)
      //and (not fIsControl or (ParentForm <> nil) and ParentForm.Visible)
      //and not fIsControl
   then
      fVisible :=
        //LongBool( GetWindowLong( fHandle, GWL_STYLE ) and WS_VISIBLE )
        IsWindowVisible( fHandle )
   else
      fVisible := (FStyle and WS_VISIBLE) <> 0;
   Result := fVisible;
end;
{$ENDIF ASM_VERSION}


{$IFDEF ASM_VERSION}
//[function TControl.Get_Visible]
function TControl.Get_Visible: Boolean;
asm     //     //
        MOV    ECX, [EAX].fHandle
        JECXZ  @@ret_fVisible
        CMP    [EAX].fIsControl, 0
        JNZ    @@ret_fVisible
        PUSH   EAX
        PUSH   ECX
        CALL   IsWindowVisible
        XCHG   EDX, EAX
        POP    EAX
        MOV    [EAX].fVisible, DL
@@ret_fVisible:
        MOVZX  EAX, [EAX].fVisible
end;
{$ELSE ASM_VERSION} // Pascal
function TControl.Get_Visible: Boolean;
begin
   if (fHandle <> 0)
      //and (not fIsControl or (ParentForm <> nil) and ParentForm.Visible)
      and not fIsControl
   then
      fVisible :=
        //LongBool( GetWindowLong( fHandle, GWL_STYLE ) and WS_VISIBLE )
        IsWindowVisible( fHandle );
   Result := fVisible;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TControl.Set_Visible]
procedure TControl.Set_Visible( Value: Boolean );
const wsVisible = $10;
asm
        PUSH     EBX
        PUSH     ESI
        //MOV      ESI, EAX
        XCHG     ESI, EAX
        MOVZX    EBX, DL
        {CALL     Get_Visible
        CMP      AL, BL
        JE       @@reset_fCreateHidden}

        MOV      AL, byte ptr [ESI].fStyle + 3
        TEST     EBX, EBX
        JZ       @@reset_WS_VISIBLE
        OR       AL, wsVisible
        PUSH     SW_SHOW
        JMP      @@store_Visible
@@reset_WS_VISIBLE:
        AND      AL, not wsVisible
        PUSH     SW_HIDE

@@store_Visible:
        MOV      byte ptr [ESI].fStyle + 3, AL
        MOV      [ESI].fVisible, BL
        MOV      ECX, [ESI].fHandle
        JECXZ    @@after_showwindow

        PUSH     ECX
        CALL     ShowWindow
        PUSH     ECX
@@after_showwindow:
        POP      ECX

        MOV      ECX, [ESI].fParent
        JECXZ    @@chk_align_Self
        XCHG     EAX, ECX
        CALL     dword ptr [Global_Align]

@@chk_align_Self:
        TEST     EBX, EBX
        JZ       @@reset_fCreateHidden
        MOV      EAX, ESI
        CALL     dword ptr [Global_Align]


@@reset_fCreateHidden:
        MOV      ECX, [ESI].fHandle
        JECXZ    @@exit
        TEST     BL, BL
        JNZ      @@exit
        MOV      [ESI].fCreateHidden, 0 { +++ }
@@exit:
        POP      ESI
        POP      EBX
end;
{$ELSE ASM_VERSION} // Pascal
procedure TControl.Set_Visible( Value: Boolean );
var CmdShow: DWORD;
begin
   //if Get_Visible <> Value then // commented to allow to set up controls visibility
   begin                          // on invisible form (Vladimir Piven)
     if Value then
     begin
       fStyle := fStyle or WS_VISIBLE;
       CmdShow := SW_SHOW;
     end
        else
     begin
       fStyle := fStyle and not WS_VISIBLE;
       CmdShow := SW_HIDE;
     end;
     fVisible := Value;
     if fHandle = 0 then Exit;
     ShowWindow( fHandle, CmdShow );
     if fParent <> nil then
       Global_Align( fParent );
     //else
     if Value then
       Global_Align( Self );
   end;
   if not Value and (fHandle <> 0) then
     fCreateHidden := FALSE; // { +++ }
end;
{$ENDIF ASM_VERSION}

//[procedure TControl.SetVisible]
procedure TControl.SetVisible( Value: Boolean );
begin
   fCreateVisible := TRUE;
   Set_Visible( Value );
end;

{$IFDEF ASM_VERSION}
//[function TControl.GetBoundsRect]
function TControl.GetBoundsRect: TRect;
asm
        PUSH      ESI
        PUSH      EDI
        LEA       ESI, [EAX].fBoundsRect
        MOV       EDI, EDX

        PUSH      EDX

        MOVSD
        MOVSD
        MOVSD
        MOVSD

        POP       EDI

        XCHG      ESI, EAX
        MOV       ECX, [ESI].fHandle
        JECXZ     @@exit

        PUSH      EDI
        PUSH      ECX
        CALL      GetWindowRect

        CMP       [ESI].fIsControl, 0
        JZ        @@storeBounds

        MOV       EAX, [ESI].fParent

        TEST      EAX, EAX
        JZ        @@exit

        XOR       EDX, EDX
        PUSH      EDX
        PUSH      EDX
        MOV       ECX, ESP
        PUSH      EDX
        PUSH      EDX
        MOV       EDX, ESP
        CALL      TControl.Client2Screen
        POP       EAX
        POP       EAX

        POP       EAX
        NEG       EAX
        POP       ECX
        NEG       ECX
        PUSH      ECX
        PUSH      EAX
        PUSH      EDI
        CALL      OffsetRect

@@storeBounds:
        XCHG      ESI, EDI
        LEA       EDI, [EDI].fBoundsRect
        MOVSD
        MOVSD
        MOVSD
        MOVSD

@@exit:
        POP       EDI
        POP       ESI
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.GetBoundsRect: TRect;
var W: PControl;
    P: TPoint;
begin
   Result := fBoundsRect;
   if fHandle <> 0 then
   begin
      GetWindowRect( fHandle, Result );
      if fIsControl then
      begin
        W := fParent; // WindowedParent;
        if W <> nil then
        begin
          P.x := 0; P.y := 0;
          P := W.Client2Screen( P );
          OffsetRect( Result, -P.x, -P.y );
        end;
      end;
      fBoundsRect := Result;
   end;
end;
{$ENDIF ASM_VERSION}

//[PROCEDURE HelpGetBoundsRect]
{$IFDEF ASM_VERSION}
procedure HelpGetBoundsRect;
asm
        POP       ECX
        ADD       ESP, - size_TRect
        MOV       EDX, ESP
        PUSH      ECX
        PUSH      EAX
        CALL      TControl.GetBoundsRect
        POP       EAX
end;
{$ENDIF ASM_VERSION}
//[END HelpGetBoundsRect]

{$IFDEF ASM_VERSION}
//[procedure TControl.SetBoundsRect]
procedure TControl.SetBoundsRect( const Value: TRect );
const swp_flags = SWP_NOZORDER or SWP_NOACTIVATE;
asm
        PUSH      EDI
        MOV       EDI, EAX

        PUSH      ESI
        MOV       ESI, EDX

        CALL      HelpGetBoundsRect

        MOV       EAX, ESI
        MOV       EDX, ESP
        CALL      RectsEqual
        TEST      AL, AL
        JNZ       @@exit

        POP       EDX   // left
        POP       ECX   // top
        POP       EAX   // right
        PUSH      EAX
        PUSH      ECX
        PUSH      EDX

        SUB       EAX, EDX  // EAX = width
        CMP       EDX, [ESI].TRect.Left
        MOV       DL, 0
        JE        @@1
        INC       EDX
@@1:    CMP       ECX, [ESI].TRect.Top
        JE        @@2
        OR        DL, 2
@@2:    OR        [EDI].fChangedPosSz, DL

        PUSH      EAX      // W saved

        MOV       EAX, [EDI].fBoundsRect.Bottom
        SUB       EAX, ECX
        PUSH      EAX      // H saved

        PUSH      EDI      // Self saved

        LEA       EDI, [EDI].fBoundsRect
        MOVSD
        MOVSD
        MOVSD
        MOVSD

        MOV       ESI, EDI
        POP       EDI     // Self restored
        MOV       ECX, [EDI].fHandle
        JECXZ     @@fin

        STD

        PUSH      swp_flags

        LODSD
        LODSD
        XCHG      EDX, EAX // EDX = bottom
        LODSD
        XCHG      ECX, EAX // ECX = right
        LODSD
        SUB       EDX, EAX // EAX = bottom - top
        PUSH      EDX       // push HEIGHT
        XCHG      EDX, EAX  // EDX = top
        LODSD     // EAX = left
        CLD

        SUB       ECX, EAX
        PUSH      ECX       // push WIDTH

        PUSH      EDX       // push TOP
        PUSH      EAX       // push LEFT
        PUSH      0

        PUSH      [EDI].fHandle
        CALL      SetWindowPos

        CMP       [EDI].fSizeRedraw, 0
        JE        @@fin
        XCHG      EAX, EDI
        CALL      Invalidate  // *MUST* be called?

@@fin:
        POP       EDX       // H restored
        POP       EAX       // W restored

@@exit:
        ADD       ESP, size_TRect
        POP       ESI
        POP       EDI
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.SetBoundsRect( const Value: TRect );
var Rect: TRect;
begin
   Rect := GetBoundsRect;
   if RectsEqual( Value, Rect ) then Exit;
   if Value.Left <> fBoundsRect.Left then fChangedPosSz := fChangedPosSz or 1;
   if Value.Top  <> fBoundsRect.Top  then fChangedPosSz := fChangedPosSz or 2;
   fBoundsRect := Value;
   Rect := Value;

   if fHandle <> 0 then
   begin
     SetWindowPos( fHandle, 0, Rect.Left, Rect.Top, Rect.Right - Rect.Left,
                   Rect.Bottom - Rect.Top, SWP_NOZORDER or SWP_NOACTIVATE );
     if fSizeRedraw then
       Invalidate;
   end;
end;
{$ENDIF ASM_VERSION}

const
  WindowStateShowCommands: array[TWindowState] of Byte =
    (SW_SHOWNOACTIVATE, SW_SHOWMINNOACTIVE, SW_SHOWMAXIMIZED);
{$IFDEF ASM_VERSION}
//[procedure TControl.SetWindowState]
procedure TControl.SetWindowState( Value: TWindowState );
asm     //cmd    //opd
        CMP      [EAX].TControl.fWindowState, DL
        JE       @@exit
        MOV      [EAX].TControl.fWindowState, DL
        XCHG     EAX, EDX
        CBW
        CWDE
        MOV      AL, byte ptr [WindowStateShowCommands+EAX]
        PUSH     EAX
        XCHG     EAX, EDX
        CALL     TControl.GetWindowHandle
        PUSH     EAX
        CALL     ShowWindow
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.SetWindowState( Value: TWindowState );
begin
   if fWindowState <> Value then
   begin
      fWindowState := Value;
      ShowWindow(GetWindowHandle, WindowStateShowCommands[Value]);
   end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TControl.Show]
procedure TControl.Show;
asm
        PUSH     EBX
        MOV      EBX, EAX
        CALL     CreateWindow
        MOV      DL, 1
        MOV      EAX, EBX
        CALL     SetVisible
        PUSH     [EBX].fHandle
        CALL     SetForegroundWindow
        XCHG     EAX, EBX
        CALL     DoSetFocus
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.Show;
begin
   CreateWindow;
   SetVisible( True );
   SetForegroundWindow( Handle );
   DoSetFocus;
end;
{$ENDIF ASM_VERSION}

//[procedure TControl.Hide]
procedure TControl.Hide;
begin
   SetVisible( False );
end;

{$IFDEF ASM_VERSION}
//[function TControl.Client2Screen]
function TControl.Client2Screen( const P: TPoint ): TPoint;
asm
        PUSH      ESI
        PUSH      EDI

        MOV       ESI, EDX
        MOV       EDI, ECX

        MOVSD
        MOVSD

        PUSH      ECX
        MOV       ECX, [EAX].fHandle
        JECXZ     @@exit

        PUSH      ECX
        CALL      ClientToScreen
        PUSH      ECX

@@exit: POP       ECX
        POP       EDI
        POP       ESI
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.Client2Screen( const P: TPoint ): TPoint;
begin
   Result := P;
   if fHandle <> 0 then
      Windows.ClientToScreen( fHandle, Result );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.Screen2Client]
function TControl.Screen2Client( const P: TPoint ): TPoint;
asm
        PUSH      ESI
        PUSH      EDI

        MOV       ESI, EDX
        MOV       EDI, ECX

        MOVSD
        MOVSD

        PUSH      ECX
        MOV       ECX, [EAX].fHandle
        JECXZ     @@exit

        PUSH      ECX
        CALL      ScreenToClient
        PUSH      ECX

@@exit: POP       ECX
        POP       EDI
        POP       ESI
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.Screen2Client( const P: TPoint ): TPoint;
begin
   Result := P;
   if Handle <> 0 then
      Windows.ScreenToClient( Handle, Result );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.ClientRect]
function TControl.ClientRect: TRect;
asm
        PUSH      [EAX].fClientLeft
        PUSH      [EAX].fClientRight
        PUSH      [EAX].fClientTop
        PUSH      [EAX].fClientBottom
        PUSH      EDX
        PUSH      EDX      // prepare 'dest' for GetClientRect

          PUSH      EAX
            LEA       EAX, [EAX].fBoundsRect

            XOR       ECX, ECX
            MOV       CL, size_TRect

            CALL      System.Move
          POP       EAX  // EAX = Self

          CALL      TControl.GetWindowHandle

          // this version is more correct ?:
          //------------------------------
          {PUSH      EAX
          CALL      CallTControlCreateWindow
          POP       EAX
          MOV       EAX, [EAX].fHandle}
          //-------------------------------

          TEST      EAX, EAX
          JZ        @@exit

          PUSH      EAX    // prepare 'handle' for GetClientRect
          CALL      GetClientRect
          PUSH      EAX

@@exit: POP       EDX
        POP       EDX  // EDX = @Result
        POP       EAX  // EAX = fClientBottom
        SUB       [EDX].TRect.Bottom, EAX
        POP       EAX  // EAX = fClientTop
        ADD       [EDX].TRect.Top, EAX  // Correct Result.Top
        POP       EAX  // EAX = fClientRight
        SUB       [EDX].TRect.Right, EAX
        POP       EAX // EAX = fClientLeft
        ADD       [EDX].TRect.Left, EAX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.ClientRect: TRect;
const BorderParams: array[ 0..5 ] of DWORD =
      ( SM_CXBORDER, SM_CXFRAME, SM_CXSIZEFRAME, SM_CYBORDER, SM_CYFRAME, SM_CYSIZEFRAME );
begin
   Result := fBoundsRect;
   GetWindowHandle;
   //CreateWindow; //virtual!!!
   if (fHandle <> 0) then
      GetClientRect( fHandle, Result );
   Inc( Result.Top, fClientTop );
   Dec( Result.Bottom, fClientBottom );
   Inc( Result.Left, fClientLeft );
   Dec( Result.Right, fClientRight );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TControl.Invalidate]
procedure TControl.Invalidate;
asm
        XOR       EDX, EDX
        CMP       [AppletTerminated], DL
        JNZ       @@exit
        MOV       ECX, [EAX].fHandle
        JECXZ     @@exit
        PUSH      EAX
        PUSH      1
        PUSH      EDX //=0
        PUSH      ECX
        CALL      Windows.InvalidateRect
        POP       EAX
        CALL      dword ptr[Global_Invalidate]
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.Invalidate;
begin
   if AppletTerminated then Exit;
   if fHandle = 0 then Exit;
   InvalidateRect( fHandle, nil, True );

   Global_Invalidate( Self );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.GetIcon]
function TControl.GetIcon: HIcon;
asm
        PUSH      EBX
        XCHG      EBX, EAX
        MOV       EAX, [EBX].fIcon
        INC       EAX
        JZ        @@exit
        DEC       EAX
        JNZ       @@exit

        MOV       ECX, [Applet]
        JECXZ     @@load
        CMP       ECX, EBX
        JZ        @@load

        XCHG      EAX, ECX
        CALL      TControl.GetIcon
        TEST      EAX, EAX
        JZ        @@exit

        XOR       EDX, EDX
        PUSH      EDX
        PUSH      EDX
        PUSH      EDX
        INC       EDX  // IMAGE_ICON = 1
        PUSH      EDX
        PUSH      EAX
        CALL      CopyImage
        JMP       @@store_fIcon

@@main_icon:
        DB  'MAINICON',0

@@load:
        PUSH      offset @@main_icon
        PUSH      [hInstance]
        CALL      LoadIcon
@@store_fIcon:
        MOV       [EBX].fIcon, EAX
@@exit:
        POP       EBX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.GetIcon: HIcon;
begin
   Result := fIcon;
   if Result = THandle( -1 ) then
   begin
     Result := 0;
     Exit;
   end;
   if Result = 0 then
   if (Assigned( Applet )) and
      (Self <> Applet) then
   begin
      Result := Applet.Icon;
      if Result <> 0 then
        Result := CopyImage( Result, IMAGE_ICON, 0, 0, 0 );
   end
     else
   begin
     //if Result = 0 then
        Result := LoadIcon( hInstance, 'MAINICON' );
        //Result := LoadImage( hInstance, 'MAINICON', IMAGE_ICON, 16, 16, LR_SHARED );
   end;
   fIcon := Result;
end;
{$ENDIF ASM_VERSION}

//*
//[procedure TControl.IconLoad]
procedure TControl.IconLoad(Inst: Integer; ResName: PChar);
begin
  Icon := LoadIcon( Inst, ResName );
  fIconShared := TRUE;
end;

//[procedure TControl.IconLoadCursor]
procedure TControl.IconLoadCursor(Inst: Integer; ResName: PChar);
begin
  Icon := LoadCursor( Inst, ResName );
  fIconShared := TRUE;
end;

{$IFDEF ASM_VERSION}
//[function TControl.CallDefWndProc]
function TControl.CallDefWndProc(var Msg: TMsg): Integer;
asm
        PUSH     [EDX].TMsg.lParam
        PUSH     [EDX].TMsg.wParam
        PUSH     [EDX].TMsg.message

        MOV      ECX, [EAX].fDefWndProc
        JECXZ    @@defwindowproc

        PUSH     [EAX].fHandle
        PUSH     ECX
        CALL     CallWindowProc
        RET

@@defwindowproc:
        PUSH     [EDX].TMsg.hwnd
        CALL     DefWindowProc
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.CallDefWndProc(var Msg: TMsg): Integer;
begin
    if FDefWndProc <> nil then
       Result := CallWindowProc( FDefWndProc, FHandle, Msg.message, Msg.wParam, Msg.lParam )
    else
       Result := DefWindowProc( Msg.hwnd, Msg.message, Msg.wParam, Msg.lParam );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.GetWindowState]
function TControl.GetWindowState: TWindowState;
asm     //cmd    //opd
        PUSH     EBX
        PUSH     ESI
        XCHG     ESI, EAX
        MOVZX    EBX, [ESI].TControl.fWindowState
        MOV      ECX, [ESI].TControl.fHandle
        JECXZ    @@ret_EBX
        MOV      BL, 2
        MOV      ESI, ECX
        PUSH     ESI
        CALL     IsZoomed
        TEST     EAX, EAX
        JNZ      @@ret_EBX
        DEC      EBX
        PUSH     ESI
        CALL     IsIconic
        TEST     EAX, EAX
        JNZ      @@ret_EBX
        DEC      EBX
@@ret_EBX:
        XCHG     EAX, EBX
        POP      ESI
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.GetWindowState: TWindowState;
begin
   Result := fWindowState;
   if Handle <> 0 then
   begin
      if IsIconic( Handle ) then
         Result := wsMinimized
      else
      if IsZoomed( Handle ) then
         Result := wsMaximized
      else
         Result := wsNormal;
      fWindowState := Result;
   end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.DoSetFocus]
function TControl.DoSetFocus: Boolean;
asm
        PUSH      ESI
        MOV       ESI, EAX

        {MOV       EDX, [ESI].fStyle
        TEST      EDX, WS_TABSTOP
        JZ        @@exit}

        CALL      GetEnabled
        TEST      AL, AL
        JZ        @@exit

        XOR       EAX, EAX
        CMP       [ESI].fTabstop, AL
        JZ        @@exit

        INC       [ESI].TControl.fClickDisabled

        PUSH      [ESI].fHandle
        CALL      SetFocus

        DEC       [ESI].TControl.fClickDisabled

        MOV       AL, 1

@@exit:
        POP       ESI
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.DoSetFocus: Boolean;
begin
  Result := False;
  if Enabled and fTabstop {and (fStyle and WS_TABSTOP <> 0)} then
  begin
    Inc( fClickDisabled );
    SetFocus( fHandle );
    Dec( fClickDisabled );
    Result := True;
  end;
end;
{$ENDIF ASM_VERSION}

//[function TControl.HandleAllocated]
function TControl.HandleAllocated: Boolean;
begin
  Result := FHandle <> 0;
end;

{$IFDEF ASM_VERSION}
//[function TControl.GetEnabled]
function TControl.GetEnabled: Boolean;
asm
        MOV       ECX, [EAX].fHandle
        JECXZ     @@get_field

        PUSH      ECX
        CALL      IsWindowEnabled
        {                  but 00000001 is returned anywhere...
        NEG       EAX
        SBB       EAX, EAX
        NEG       EAX
        }
        RET

@@get_field:
        TEST      byte ptr [EAX].fStyle + 3, 8 //WS_DISABLED shr 3
        SETZ      AL
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.GetEnabled: Boolean;
begin
  if FHandle = 0 then
     Result := (Style and WS_DISABLED) = 0
  else
     Result := IsWindowEnabled( FHandle );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.IsMainWindow]
function TControl.IsMainWindow: Boolean;
asm
        CMP       [EAX].fIsControl, 0
        JNZ       @@no_notmain

        XCHG      EDX, EAX
        MOV       EAX, [EDX].fParent

        TEST      EAX, EAX
        JZ        @@1

        MOV       ECX, [EAX].fParent
        INC       ECX
        LOOP      @@no_notmain

        MOV       EAX, [EAX].fChildren

        MOV       ECX, [EAX].TList.fCount
        JECXZ     @@no_notmain

        MOV       EAX, [EAX].TList.fItems
        CMP       EDX, [EAX]
        MOV       AL, 1
        JMP       @@2
@@1:
        INC       EAX
        MOVZX     ECX, [AppButtonUsed]
        JECXZ     @@yes_main
        CMP       EDX, [Applet]
@@2:
        JZ        @@yes_main

@@no_notmain:
        XOR       EAX, EAX
@@yes_main:
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.IsMainWindow: Boolean;
var A: PControl;
begin
  Result := False;
  if fIsControl then Exit;
  A := fParent; // WindowedParent;
  if A = nil then
  begin
    Result := (Self = Applet) or not AppButtonUsed;
    Exit;
  end
     else
  if A.fParent <> nil then Exit;
  //--------------------------------------------------------------------------------
  if A.fChildren.fCount = 0 then Exit; // by ECM, fixes AV when user changed (logoff)
  //--------------------------------------------------------------------------------
  Result := A.fChildren.fItems[ 0 ] = Self;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.get_ClassName]
function TControl.get_ClassName: String;
asm
        PUSH      EBX
        XCHG      EBX, EAX
        XCHG      EAX, EDX
        MOV       EDX, [EBX].fControlClassName
        PUSH      EAX
        CALL      System.@LStrFromPChar
        POP       EAX
        CMP       [EBX].fCtlClsNameChg, 0
        JNZ       @@exit
        MOV       ECX, [EAX]
        MOV       EDX, offset[ @@obj ]
        CALL      System.@LStrCat3
        JMP       @@exit

        DD        -1, 4
@@obj:  DB        'obj_', 0

@@exit:
        POP       EBX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.get_ClassName: String;
begin
  if not fCtlClsNameChg then
    Result := 'obj_' + fControlClassName
  else
    Result := fControlClassName;
end;
{$ENDIF ASM_VERSION}

//[procedure TControl.set_ClassName]
procedure TControl.set_ClassName(const Value: String);
begin
  if fCtlClsNameChg then
    FreeMem( fControlClassName );
  GetMem( fControlClassName, Length( Value ) + 1 );
  StrCopy( fControlClassName, @ Value[ 1 ] );
  fCtlClsNameChg := TRUE;
end;

//[function WndProcQueryEndSession]
function WndProcQueryEndSession( Sender: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var Accept: Boolean;
begin
  Result := FALSE;
  if Msg.message = WM_QUERYENDSESSION then
  begin
    if Assigned( Sender.fOnQueryEndSession ) then
    begin
      Accept := TRUE;
      Sender.fCloseQueryReason := qShutdown;
      if LongBool(Msg.lParam and {ENDSESSION_LOGOFF} DWORD($80000000)) then
        Sender.fCloseQueryReason := qLogoff;
      Sender.fOnQueryEndSession( Sender, Accept );
      Sender.fCloseQueryReason := qClose;
      Rslt := Integer( Accept );
    end;
  end;
end;

//[procedure TControl.SetOnQueryEndSession]
procedure TControl.SetOnQueryEndSession(const Value: TOnEventAccept);
begin
  AttachProc( WndProcQueryEndSession );
  fOnQueryEndSession := Value;
end;

//[function WndProcMinMaxRestore]
function WndProcMinMaxRestore( Sender: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
begin
  Result := FALSE;
  if Msg.message = WM_SYSCOMMAND then
  begin
    case Msg.wParam of
    SC_MINIMIZE: if Assigned( Sender.fOnMinimize ) then
                   Sender.fOnMinimize( Sender );
    SC_MAXIMIZE: if Assigned( Sender.fOnMaximize ) then
                   Sender.fOnMaximize( Sender );
    SC_RESTORE:  if Assigned( Sender.fOnRestore ) then
                   Sender.fOnRestore( Sender );
    end;
  end;
end;

//[procedure TControl.SetOnMinMaxRestore]
procedure TControl.SetOnMinMaxRestore(const Index: Integer;
  const Value: TOnEvent);
type POnEvent = ^TOnEvent;
{$IFDEF F_P}
var Ptr1: Pointer;
{$ELSE DELPHI}
var Ev: POnEvent;
{$ENDIF F_P/DELPHI}
begin
  AttachProc( WndProcMinMaxRestore );
  {$IFDEF F_P}
  Ptr1 := Self;
  asm
    MOV  EAX, [Ptr1]
    LEA  EAX, [EAX].TControl.fOnMinimize
    ADD  EAX, [Index]
    MOV  EDX, [Value]
    MOV  [EAX], EDX
    MOV  EDX, [Value+4]
    MOV  [EAX+4], EDX
  end [ 'EAX', 'EDX' ];
  {$ELSE DELPHI}
  Ev := Pointer( Integer( @ TMethod( fOnMinimize ).Code ) + Index );
  //Ev := Pointer( Integer( @ fOnMinimize ) + Index );
  Ev^ := Value;
  {$ENDIF}
end;

{$IFDEF F_P}
//[function TControl.GetOnMinMaxRestore]
function TControl.GetOnMinMaxRestore(const Index: Integer): TOnEvent;
begin
  CASE Index OF
  0: Result := fOnMinimize;
  8: Result := fOnMaximize;
  16: Result := fOnRestore;
  END;
end;
{$ENDIF F_P}

{$IFDEF ASM_VERSION} // add call to fNotifyChild
//[procedure TControl.SetParent]
procedure TControl.SetParent( Value: PControl );
asm
        PUSH     EBX
        PUSH     EDI
        XCHG     EBX, EAX
        MOV      EDI, [EBX].fParent
        PUSH     EDX
        TEST     EDI, EDI
        JZ       @@set_another_parent

        MOV      EAX, [EDI].fChildren
        MOV      EDX, EBX
        CALL     TList.Remove

        MOV      ECX, [EDI].fNotifyChild
        JECXZ    @@set_another_parent

        MOV      EAX, EDI
        XOR      EDX, EDX
        CALL     ECX

@@set_another_parent:
        POP      EDI
        MOV      [EBX].fParent, EDI
        TEST     EDI, EDI
        JZ       @@exit

        MOV      EAX, [EDI].fChildren
        MOV      EDX, EBX
        CALL     TList.Add

        MOV      ECX, [EDI].fNotifyChild
        JECXZ    @@exit

        MOV      EAX, EDI
        MOV      EDX, EBX
        CALL     ECX

@@exit:
        POP      EDI
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.SetParent( Value: PControl );
begin
   if Value = fParent then Exit;
   if fParent <> nil then
   begin
     {I := fParent.fChildren.IndexOf( Self );
     if I >= 0 then
        fParent.fChildren.Delete( I );}
     fParent.fChildren.Remove( Self );
     if Assigned( fParent.fNotifyChild ) then
       fParent.fNotifyChild( fParent, nil );
   end;
   fParent := Value;
   if fParent <> nil then
   begin
     fParent.fChildren.Add( Self );
     if Assigned( fParent.fNotifyChild ) then
       fParent.fNotifyChild( fParent, Self );
   end;
end;
{$ENDIF ASM_VERSION}

//[function TControl.ChildIndex]
function TControl.ChildIndex(Child: PControl): Integer;
begin
  Result := fChildren.IndexOf( Child );
end;

//*
//[procedure TControl.MoveChild]
procedure TControl.MoveChild(Child: PControl; NewIdx: Integer);
var I: Integer;
begin
  I := ChildIndex( Child );
  Assert( I>=0, 'TControl.MoveChild: index out of bounds' );
  fChildren.MoveItem( I, NewIdx );
end;

//[procedure TControl.EnableChildren]
procedure TControl.EnableChildren(Enable, Recursive: Boolean);
var I: Integer;
    C: PControl;
begin
  for I := 0 to ChildCount-1 do
  begin
    C := Children[ I ];
    C.Enabled := Enable;
    if Recursive then
      C.EnableChildren( Enable, TRUE );
  end;
end;

{$IFDEF ASM_VERSION}
//[constructor TControl.CreateParented]
constructor TControl.CreateParented(AParent: PControl);
asm     //cmd    //opd
        //CALL     System.@ObjSetup // generated automatically
        //JZ       @@exit           // generated automatically
        PUSH     EAX
        MOV      EDX, ECX
        MOV      ECX, [EAX]
        CALL     dword ptr [ECX+8]
        POP      EAX
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
constructor TControl.CreateParented(AParent: PControl);
begin
  InitParented( AParent );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.GetLeft]
function TControl.GetLeft: Integer;
asm
        CALL      HelpGetBoundsRect
        POP       EAX

        POP       ECX
        POP       ECX
        POP       ECX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.GetLeft: Integer;
begin
   Result := BoundsRect.Left;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TControl.SetLeft]
procedure TControl.SetLeft( Value: Integer );
asm
        PUSH      EDI

        PUSH      EDX
        CALL      HelpGetBoundsRect
        POP       EDX           // EDX = Left
        POP       ECX           // ECX = Top
        POP       EDI           // EDI = Right

        SUB       EDI, EDX      // EDI = width
        MOV       EDX, [ESP+4]  // EDX = Left'
        ADD       EDI, EDX      // EDI = Right'

        PUSH      EDI
        PUSH      ECX
        PUSH      EDX
        MOV       EDX, ESP

        CALL      SetBoundsRect
        ADD       ESP, size_TRect + 4

        POP       EDI

end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.SetLeft( Value: Integer );
var R: TRect;
begin
   R := BoundsRect;
   R.Left := Value;
   R.Right := Value + Width;
   SetBoundsRect( R );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.GetTop]
function TControl.GetTop: Integer;
asm
        CALL      HelpGetBoundsRect
        POP       EDX
          POP       EAX
        POP       EDX
        POP       EDX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.GetTop: Integer;
begin
   Result := BoundsRect.Top;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TControl.SetTop]
procedure TControl.SetTop( Value: Integer );
asm
        PUSH      ESI
        PUSH      EDI

          PUSH      EDX
        CALL      HelpGetBoundsRect
        POP       EDX           // EDX = Left
        POP       ECX           // ECX = Top
        POP       EDI           // EDI = Right
        POP       ESI           // ESI = Bottom

        SUB       ESI, ECX      // ESI = Height'
          POP       ECX         // ECX = Top'
        ADD       ESI, ECX      // ESI = Bottom'

        PUSH      ESI
        PUSH      EDI
        PUSH      ECX
        PUSH      EDX
        MOV       EDX, ESP

        CALL      SetBoundsRect
        ADD       ESP, size_TRect

        POP       EDI
        POP       ESI
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.SetTop( Value: Integer );
var R: TRect;
begin
   R := BoundsRect;
   R.Top := Value;
   R.Bottom := Value + Height;
   SetBoundsRect( R );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.GetWidth]
function TControl.GetWidth: Integer;
asm
        CALL      HelpGetBoundsRect
        POP       EDX
          POP       ECX
        POP       EAX
        SUB       EAX, EDX
          POP       ECX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.GetWidth: Integer;
begin
  with BoundsRect do
    Result := Right - Left;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TControl.SetWidth]
procedure TControl.SetWidth( Value: Integer );
asm
        PUSH      EDX

        CALL      HelpGetBoundsRect
        POP       EDX
        PUSH      EDX
        ADD       EDX, [ESP].size_TRect
        MOV       [ESP].TRect.Right, EDX

        MOV       EDX, ESP
        CALL      SetBoundsRect

        ADD       ESP, size_TRect + 4
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.SetWidth( Value: Integer );
var R: TRect;
begin
  R := BoundsRect;
  with R do
    Right := Left + Value;
  SetBoundsRect( R );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.GetHeight]
function TControl.GetHeight: Integer;
asm
        CALL      HelpGetBoundsRect
        POP       ECX
        POP       EDX          // EDX = top
        POP       ECX
        POP       EAX          // EAX = bottom
        SUB       EAX, EDX     // result = height
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.GetHeight: Integer;
begin
  with BoundsRect do
   Result := Bottom - Top;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TControl.SetHeight]
procedure TControl.SetHeight( Value: Integer );
asm
        PUSH      EDX

        CALL      HelpGetBoundsRect
        MOV       EDX, [ESP].TRect.Top
        ADD       EDX, [ESP].size_TRect
        MOV       [ESP].TRect.Bottom, EDX

        MOV       EDX, ESP
        CALL      SetBoundsRect

        ADD       ESP, size_TRect + 4
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.SetHeight( Value: Integer );
var R: TRect;
begin
   R := BoundsRect;
   with R do
     Bottom := Top + Value;
   SetBoundsRect( R );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.GetPosition]
function TControl.GetPosition: TPoint;
asm
        PUSH      EDX
        CALL      HelpGetBoundsRect
        POP       EAX         // EAX = left
        POP       ECX         // ECX = top
        POP       EDX
        POP       EDX
        POP       EDX         // EDX = @Result
        MOV       [EDX], EAX
        MOV       [EDX+4], ECX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.GetPosition: TPoint;
begin
  Result.x := BoundsRect.Left;
  Result.y := BoundsRect.Top;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TControl.Set_Position]
procedure TControl.Set_Position( Value: TPoint );
asm
        PUSH      ESI
        PUSH      EDI

        PUSH      EAX
        PUSH      EDX
        CALL      HelpGetBoundsRect
        POP       EDX           // left
        POP       EAX           // top
        POP       ECX           // right
        SUB       ECX, EDX      // ECX = width
        POP       EDX           // bottom
        SUB       EDX, EAX      // EDX = height
        POP       EAX           // EAX = @Value
        POP       ESI           // ESI = Self

        MOV       EDI, [EAX+4]  // top'
        ADD       EDX, EDI
        PUSH      EDX           // bottom'

        MOV       EAX, [EAX]    // left'
        ADD       ECX, EAX
        PUSH      ECX           // right'

        PUSH      EDI           // top'
        PUSH      EAX           // left'

        MOV       EAX, ESI
        MOV       EDX, ESP
        CALL      SetBoundsRect

        ADD       ESP, size_TRect

        POP       EDI
        POP       ESI
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.Set_Position( Value: TPoint );
var R: TRect;
begin
   R.Top := Value.y;
   R.Left := Value.x;
   R.Right := R.Left + Width;
   R.Bottom := R.Top + Height;
   BoundsRect := R;
end;
{$ENDIF ASM_VERSION}

//[function WndProcConstraints]
function WndProcConstraints( Sender: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var MMI: PMinMaxInfo;
begin
  Result := FALSE;
  if Msg.message = WM_GETMINMAXINFO then
  begin
    Rslt := Sender.CallDefWndProc( Msg );
    MMI := Pointer( Msg.lParam );
    if Sender.FMaxWidth > 0 then
    begin
      MMI.ptMaxSize.x := Sender.FMaxWidth;
      MMI.ptMaxTrackSize.x := Sender.FMaxWidth;
    end;
    if Sender.FMaxHeight > 0 then
    begin
      MMI.ptMaxSize.y := Sender.FMaxHeight;
      MMI.ptMaxTrackSize.y := Sender.FMaxHeight;
    end;
    MMI.ptMinTrackSize := MakePoint( Sender.FMinWidth, Sender.FMinHeight );
    Rslt := 0;
    Result := TRUE;
  end;
end;

{$IFDEF USE_MHTOOLTIP}
{$DEFINE implementation}
{$I KOLMHToolTip}
{$UNDEF implementation}
{$ENDIF}

//[procedure TControl.SetConstraint]
procedure TControl.SetConstraint(const Index, Value: Integer);
begin
  AttachProc( WndProcConstraints );
  case Index of
  0: FMinWidth := Value;
  1: FMinHeight := Value;
  2: FMaxWidth := Value;
  3: FMaxHeight := Value;
  end;
end;

{$IFDEF F_P}
//[function TControl.GetConstraint]
function TControl.GetConstraint(const Index: Integer): Integer;
begin
  CASE Index OF
  0: Result := FMinWidth;
  1: Result := FMinHeight;
  2: Result := FMaxWidth;
  3: Result := FMaxHeight;
  END;
end;
{$ENDIF F_P}

//*
//[function TControl.ControlRect]
function TControl.ControlRect: TRect;
var C: PControl;
    R: TRect;
begin
   Result := BoundsRect;
   C := Parent;
   if C <> nil then
   begin
      //DoScrollOffset( @Result );

      if not C.fIsControl then Exit;

      R := C.ControlRect;
      OffsetRect( Result, R.Left, R.Top );

      if C.fChildren <> nil then
      if C.FChildren.IndexOf( Self ) >= C.MembersCount then
      begin
         R := C.ClientRect;
         Dec( R.Top, C.fClientTop );
         Dec( R.Left, C.fClientLeft );
         OffsetRect( Result, R.Left, R.Top );
      end;
   end;
end;

//*
//[function TControl.ControlAtPos]
function TControl.ControlAtPos( X, Y: Integer;
                                   IgnoreDisabled: Boolean ): PControl;
var I: Integer;
    C: PControl;
    CR, VR: TRect;
begin
   Result := nil;
   CR := ControlRect;
   if Windowed then
      CR := MakeRect( 0, 0, 0, 0 );
   X := X + CR.Left; // - R.Left;
   Y := Y + CR.Top; // - R.Top;
   for I := ChildCount { + MembersCount } - 1 downto 0 do
   begin
      C := Children[ I ]; //Members[ I ];
      if C.Visible then
      if (not IgnoreDisabled) or IgnoreDisabled and C.Enabled then
      begin
         VR := C.ControlRect;
         if (X >= VR.Left) and (X < VR.Right) and
            (Y >= VR.Top) and (Y < VR.Bottom) then
         begin
            Result := C;
            Exit;
         end;
      end;
   end;
end;

//[PROCEDURE DefaultPaintBackground]
{$IFDEF ASM_VERSION}
procedure DefaultPaintBackground( Sender: PControl; DC: HDC; Rect: PRect );
asm
        PUSH      EDI

        PUSH      EDI
        MOV       EDI, ESP

        PUSH      ECX
        PUSH      EDX

        MOV       EAX, [EAX].TControl.fColor
        CALL      Color2RGB
        PUSH      EAX
        CALL      CreateSolidBrush
        STOSD
        MOV       EDI, EAX
        CALL      windows.FillRect
        PUSH      EDI
        CALL      DeleteObject
        POP       EDI
end;
{$ELSE ASM_VERSION} //Pascal
procedure DefaultPaintBackground( Sender: PControl; DC: HDC; Rect: PRect );
var B: HBrush;
begin
  B := CreateSolidBrush( Color2Rgb( Sender.Color ) );
  Windows.FillRect( DC, Rect^, B );
  DeleteObject( B );
end;
{$ENDIF ASM_VERSION}
//[END DefaultPaintBackground]

//[procedure TControl.PaintBackground]
procedure TControl.PaintBackground( DC: HDC; Rect: PRect );
begin
  Global_OnPaintBkgnd( Self, DC, Rect );
end;

{$IFDEF ASM_VERSION}
//[procedure TControl.SetCtlColor]
procedure TControl.SetCtlColor( Value: TColor );
asm
        PUSH     EBX
        XCHG     EBX, EAX

        MOV      ECX, [EBX].fHandle
        JECXZ    @@1

        MOVZX    ECX, [EBX].fCommandActions.aSetBkColor
        JECXZ    @@1

        PUSH     EDX

        XCHG     EAX, EDX
        PUSH     ECX
        CALL     Color2RGB
        POP      ECX

        PUSH     EAX        // Color2RGB( Value )
        PUSH     0          // 0
        PUSH     ECX        // fCommandActions.aSetBkColor
        PUSH     EBX        // Self
        CALL     TControl.Perform

        POP      EDX

@@1:
        CMP      EDX, [EBX].fColor
        JZ       @@exit

        MOV      [EBX].fColor, EDX

        XOR      ECX, ECX
        XCHG     ECX, [EBX].fTmpBrush
        JECXZ    @@setbrushcolor

        PUSH     EDX
        PUSH     ECX
        CALL     DeleteObject
        POP      EDX

@@setbrushcolor:
        MOV      ECX, [EBX].fBrush
        JECXZ    @@invldte

        XCHG     EAX, ECX
        MOV      ECX, EDX
        //MOV      EDX, go_Color
        XOR      EDX, EDX
        CALL     TGraphicTool.SetInt

@@invldte:
        XCHG     EAX, EBX
        CALL     TControl.Invalidate
@@exit:
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.SetCtlColor( Value: TColor );
begin
  if fHandle <> 0 then
  if fCommandActions.aSetBkColor <> 0 then
    Perform( fCommandActions.aSetBkColor, 0, Color2RGB( Value ) );
  if fColor = Value then Exit;
  fColor := Value;
  if fTmpBrush <> 0 then
  begin
    DeleteObject( fTmpBrush );
    fTmpBrush := 0;
  end;
  if fBrush <> nil then
    fBrush.Color := Value;
  Invalidate;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.GetParentWnd]
function TControl.GetParentWnd( NeedHandle: Boolean ): HWnd;
asm
        MOV       ECX, [EAX].fParent
        JECXZ     @@exit

        PUSH      ECX
        TEST      DL, DL
        JZ        @@load_handle

        XCHG      EAX, ECX
        CALL      GetWindowHandle

@@load_handle:
        POP       ECX
        MOV       ECX, [ECX].fHandle

@@exit: XCHG      EAX, ECX

end;
{$ELSE ASM_VERSION} //Pascal
function TControl.GetParentWnd( NeedHandle: Boolean ): HWnd;
var C: PControl;
begin
   Result := 0;
   C := fParent; // WindowedParent;
   if C <> nil then
   begin
     if NeedHandle then
        C.GetWindowHandle;
     Result := C.fHandle;
   end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TControl.CreateChildWindows]
procedure TControl.CreateChildWindows;
asm
        PUSH      ESI
        MOV       ESI, [EAX].TControl.fChildren
        MOV       ECX, [ESI].TList.fCount
        MOV       ESI, [ESI].TList.fItems
        JECXZ     @@exit

@@loop: PUSH      ECX
        LODSD
        CALL      CallTControlCreateWindow
        //CALL      TControl.GetWindowHandle
        POP       ECX
        LOOP      @@loop

@@exit: POP       ESI
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.CreateChildWindows;
var I: Integer;
    C: PControl;
begin
  for I := 0 to fChildren.Count - 1 do
  begin
     C := fChildren.fItems[ I ];
     //C.GetWindowHandle;
     C.CreateWindow; //virtual!!!
  end;
end;
{$ENDIF ASM_VERSION}

//[function TControl.GetMembers]
function TControl.GetMembers(Idx: Integer): PControl;
begin
   Result := fChildren.fItems[ Idx ];
end;

{$IFDEF ASM_VERSION}
//[procedure TControl.DestroyChildren]
procedure TControl.DestroyChildren;
asm
        PUSH      ESI

        MOV       EAX, [EAX].fChildren
        PUSH      EAX
        MOV       ECX, [EAX].TList.fCount
        JECXZ     @@clear
        MOV       ESI, [EAX].TList.fItems
        LEA       ESI, [ESI + ECX*4 - 4]  // is order really important ?

@@loop: STD                               //
        LODSD
        CLD                               //

        PUSH      ECX
        CALL      TObj.Free
        POP       ECX

        LOOP      @@loop

@@clear:
        POP       EAX
        CALL      TList.Clear

        POP       ESI
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.DestroyChildren;
var I: Integer;
    W: PControl;
begin
   for I := fChildren.fCount - 1 downto 0 do
   begin
      W := fChildren.fItems[ I ];
      W.Free;
   end;
   fChildren.Clear;
end;
{$ENDIF ASM_VERSION}

{//-
//[function TControl.WindowedParent]
function TControl.WindowedParent: PControl;
begin
  Result := fParent;
end;}

{$IFDEF ASM_VERSION}
//[function TControl.ProcessMessage]
function TControl.ProcessMessage: Boolean;
const size_TMsg = sizeof( TMsg );
asm
        PUSH      EBX
        XCHG      EBX, EAX

        ADD       ESP, -size_TMsg-4

        MOV       EDX, ESP
        PUSH      1
        XOR       ECX, ECX
        PUSH      ECX
        PUSH      ECX
        PUSH      ECX
        PUSH      EDX
        CALL      PeekMessage

        TEST      EAX, EAX
        JZ        @@exit

        MOV       EDX, [ESP].TMsg.message
        CMP       DX, WM_QUIT
        JNZ       @@tran_disp
        MOV       [AppletTerminated], 1
        JMP       @@fin

@@tran_disp:
        MOV       ECX, [EBX].fExMsgProc
        JECXZ     @@do_tran_disp
        MOV       EAX, EBX
        MOV       EDX, ESP
        CALL      ECX
        TEST      AL, AL
        JNZ       @@fin

@@do_tran_disp:
        MOV       EAX, ESP
        PUSH      EAX
        PUSH      EAX
        CALL      TranslateMessage
        CALL      DispatchMessage

@@fin:
        MOV       AX, word ptr [ESP].TMsg.message
        TEST      AX, AX
        SETNZ     AL

@@exit: ADD       ESP, size_TMsg+4
        POP       EBX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.ProcessMessage: Boolean;
var Msg: TMsg;
begin
   Result := False;
   if PeekMessage( Msg, 0, 0, 0, PM_REMOVE ) then
   begin
      Result := Msg.message <> 0;
      if (Msg.message = WM_QUIT) then
        AppletTerminated := True
      else
      begin
        if not(Assigned( fExMsgProc ) and fExMsgProc( Self, Msg )) then
        begin
          TranslateMessage( Msg );
          DispatchMessage( Msg );
        end;
      end;
   end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TControl.ProcessMessages]
procedure TControl.ProcessMessages;
asm
@@loo:  PUSH     EAX
        CALL     ProcessMessage
        DEC      AL
        POP      EAX
        JZ       @@loo
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.ProcessMessages;
begin
  while ProcessMessage do ;
end;
{$ENDIF ASM_VERSION}

//[procedure TControl.ProcessMessagesEx]
procedure TControl.ProcessMessagesEx;
begin
  PostMessage( GetWindowHandle, CM_PROCESS, 0, 0 );
  ProcessMessages;
end;

//[FUNCTION WndProcForm]
{$IFDEF ASM_VERSION}
function WndProcForm(Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
const szPaintStruct = sizeof(TPaintStruct);
asm     //cmd    //opd
        CMP      word ptr [EDX].TMsg.message, WM_ENDSESSION
        JNE      @@chk_WM_SETFOCUS

        CMP      [EDX].TMsg.wParam, 0
        JZ       @@ret_false

        CALL     TObj.RefDec
        XOR      EAX, EAX
        MOV      [AppletRunning], AL
        XCHG     EAX, [Applet]
        INC      [AppletTerminated]

        CALL     TObj.Free
        CALL     System.@Halt0
        //-------

@@chk_WM_SETFOCUS:
        CMP      word ptr [EDX].TMsg.message, WM_SETFOCUS
        JNE      @@ret_false

        PUSH     EBX
        PUSH     ESI
        XOR      EBX, EBX
        XCHG     ESI, EAX
      {$IFDEF FIX_MODAL_SETFOCUS}
        MOV      ECX, [ESI].TControl.fModalForm
        JECXZ    @@no_fix_modal_setfocus
        PUSH     [ECX].TControl.fHandle
        CALL     SetFocus
@@no_fix_modal_setfocus:
      {$ENDIF}

        MOV      ECX, [ESI].TControl.FCurrentControl
        JECXZ    @@1
        INC      EBX
        XCHG     EAX, ECX

        // or CreateForm?
        PUSH     EAX
        CALL     CallTControlCreateWindow
        POP      EAX
        PUSH     [EAX].TControl.fHandle

        CALL     SetFocus
@@1:    MOV      ECX, [Applet]
        JECXZ    @@ret_EBX
        CMP      ECX, ESI
        JE       @@ret_EBX
        MOV      [ECX].TControl.FCurrentControl, ESI
@@ret_EBX:
        XCHG     EAX, EBX
        POP      ESI
        POP      EBX
        RET

@@ret_false:
        XOR      EAX, EAX
end;
{$ELSE ASM_VERSION} //Pascal
function WndProcForm(Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var App: PControl;
begin
  Result := True;
  with Self_ do
  case Msg.message of
  WM_ENDSESSION:
    begin
      if Msg.wParam <> 0 then
      begin
        Self_.RefDec;
        { Normally, WM_ENDSESSION is sent to a main form, not to Applet.
          Since we do not plan further working after handling this message,
          we decrease RefCount for the form (in was increased in EnumDynHandlers
          to prevent object destroying while its message processing is not
          finished). }
        App := Applet;
        //Rslt := 0; { We will not return any result at all. }
        {$IFDEF DEBUG_ENDSESSION}
        EndSession_Initiated := TRUE;
        LogFileOutput( GetStartDir + 'es_debug.txt',
                       'Self_=' + Int2Hex( DWORD( Self_ ), 8 ) +
                       ' Self_.Handle=' + Int2Str( Self_.FHandle ) );
        {$ENDIF}
        AppletTerminated := TRUE;
        AppletRunning := FALSE;
        Applet := nil;
        App.Free; { We provide OnDestroy handlers to be called for any objects here }
        Halt; { Stop further executing. }
      end else Result := FALSE;
    end;
  WM_SETFOCUS:
    begin
      {$IFDEF FIX_MODAL_SETFOCUS}
      if fModalForm <> nil then
        SetFocus( fModalForm.fHandle )
      else
      {$ENDIF}
      if FCurrentControl <> nil then
      begin
        FCurrentControl.CreateWindow; //virtual!!!
        SetFocus( FCurrentControl.fHandle );
      end
      else
        Result := False;
      if assigned( Applet ) and (Applet <> Self_) then
         Applet.FCurrentControl := Self_;
    end;
  else Result := False;
  end;
end;
{$ENDIF ASM_VERSION}
//[END WndProcForm]

//[FUNCTION GetPrevCtrlBoundsRect]
{$IFDEF ASM_VERSION}
function GetPrevCtrlBoundsRect( P: PControl; var R: TRect ): Boolean;
asm
        MOV       EDX, EBX
        MOV       EAX, [EBX].TControl.fParent
        TEST      EAX, EAX
        JZ        @@exit
          PUSH      EAX
        CALL      TControl.ChildIndex
        TEST      EAX, EAX
        XCHG      EDX, EAX
          POP       EAX
        JZ        @@exit
        DEC       EDX
        CALL      TControl.GetMembers

        POP       ECX  // retaddr
        ADD       ESP, -size_TRect
        MOV       EDX, ESP
        PUSH      ECX
        CALL      TControl.GetBoundsRect
        STC       // return CARRY
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
function GetPrevCtrlBoundsRect( P: PControl; var R: TRect ): Boolean;
var Idx: Integer;
begin
  Result := False;
  if P.FParent = nil then Exit;
  Idx := P.FParent.ChildIndex( P ) - 1;
  if Idx < 0 then Exit;
  Result := True;
  R := P.FParent.Children[ Idx ].BoundsRect;
end;
{$ENDIF ASM_VERSION}
//[END GetPrevCtrlBoundsRect]

{$IFDEF ASM_VERSION}
//[function TControl.PlaceUnder]
function TControl.PlaceUnder: PControl;
asm
        PUSH      EBX
        XCHG      EBX, EAX
        CALL      GetPrevCtrlBoundsRect
        JNC       @@exit
        POP       EDX  // EDX = Left
        MOV       EAX, EBX
        CALL      TControl.SetLeft

        POP       EDX
        POP       EDX
        POP       EDX  // EDX = Bottom

        MOV       EAX, [EBX].fParent
        ADD       EDX, [EAX].fMargin

        MOV       EAX, EBX
        CALL      TControl.SetTop
@@exit:
        XCHG      EAX, EBX
        POP       EBX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.PlaceUnder: PControl;
var R: TRect;
begin
  Result := Self;
  if not GetPrevCtrlBoundsRect( Self, R ) then Exit;
  Top := R.Bottom + fParent.fMargin;
  Left := R.Left;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.PlaceDown]
function TControl.PlaceDown: PControl;
asm
        PUSH      EBX
        XCHG      EBX, EAX
        CALL      GetPrevCtrlBoundsRect
        JNC       @@exit
        POP       EDX
        POP       EDX
        POP       EDX
        POP       EDX  // EDX = Bottom

        MOV       EAX, [EBX].fParent
        ADD       EDX, [EAX].fMargin

        MOV       EAX, EBX
        CALL      TControl.SetTop
@@exit:
        XCHG       EAX, EBX
        POP       EBX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.PlaceDown: PControl;
var R: TRect;
begin
  Result := Self;
  if not GetPrevCtrlBoundsRect( Self, R ) then Exit;
  Top := R.Bottom + fParent.fMargin;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.PlaceRight]
function TControl.PlaceRight: PControl;
asm
        PUSH      EBX
        XCHG      EBX, EAX
        CALL      GetPrevCtrlBoundsRect
        JNC       @@exit
        POP       EDX
        POP       EDX  // EDX = Top
        MOV       EAX, EBX
        CALL      TControl.SetTop
        POP       EDX  // EDX = Right

        MOV       EAX, [EBX].fParent
        ADD       EDX, [EAX].fMargin

        POP       ECX
        MOV       EAX, EBX
        CALL      TControl.SetLeft
@@exit:
        XCHG      EAX, EBX
        POP       EBX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.PlaceRight: PControl;
var R: TRect;
begin
  Result := Self;
  if not GetPrevCtrlBoundsRect( Self, R ) then Exit;
  Top := R.Top;
  Left := R.Right + fParent.fMargin;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.SetSize]
function TControl.SetSize(W, H: Integer): PControl;
asm
        PUSH      EAX
        CMP       EDX, 0
          PUSH    ECX
        JLE       @@check_set_height

        CALL      TControl.SetWidth
@@check_set_height:
          POP     EDX
        POP       EAX
        PUSH      EAX
        CMP       EDX, 0
        JLE       @@exit

        CALL      TControl.SetHeight
@@exit: POP       EAX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.SetSize(W, H: Integer): PControl;
begin
  if W > 0 then Width := W;
  if H > 0 then Height := H;
  Result := Self;
end;
{$ENDIF ASM_VERSION}

//[function TControl.SetClientSize]
function TControl.SetClientSize(W, H: Integer): PControl;
begin
  if W > 0 then ClientWidth := W;
  if H > 0 then ClientHeight := H;
  Result := Self;
end;

{$IFDEF ASM_VERSION}
//[function TControl.AlignLeft]
function TControl.AlignLeft(P: PControl): PControl;
asm
        PUSH     EAX
        MOV      EAX, EDX
        CALL     TControl.GetLeft
        MOV      EDX, EAX
        POP      EAX
        PUSH     EAX
        CALL     TControl.SetLeft
        POP      EAX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.AlignLeft(P: PControl): PControl;
begin
  Result := Self;
  Left := P.Left;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.AlignTop]
function TControl.AlignTop(P: PControl): PControl;
asm
        PUSH     EAX
        MOV      EAX, EDX
        CALL     TControl.GetTop
        MOV      EDX, EAX
        POP      EAX
        PUSH     EAX
        CALL     TControl.SetTop
        POP      EAX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.AlignTop(P: PControl): PControl;
begin
  Result := Self;
  Top := P.Top;
end;
{$ENDIF ASM_VERSION}

//[FUNCTION WndProcCtrl]
{$IFDEF ASM_VERSION} // see addition for combobox in pas version
function WndProcCtrl( Self_: PControl; var Msg: TMsg; var Rslt: Integer): Boolean;
asm     //cmd    //opd
        PUSH     EBX
        XCHG     EBX, EAX
        PUSH     ESI
        PUSH     EDI
        MOV      EDI, EDX
        MOV      EDX, [EDI].TMsg.message

        SUB      DX, CN_CTLCOLORMSGBOX
        CMP      DX, CN_CTLCOLORSTATIC-CN_CTLCOLORMSGBOX
        JA       @@chk_CM_COMMAND
@@2:
        PUSH     ECX
        MOV      EAX, [EBX].TControl.fTextColor
        CALL     Color2RGB
        XCHG     ESI, EAX
        PUSH     ESI
        PUSH     [EDI].TMsg.wParam
        CALL     SetTextColor
        CMP      [EBX].TControl.fTransparent, 0
        JZ       @@opaque

        PUSH     Windows.TRANSPARENT
        PUSH     [EDI].TMsg.wParam
        CALL     SetBkMode
        PUSH     NULL_BRUSH
        CALL     GetStockObject
        JMP      @@ret_rslt

@@opaque:
        MOV      EAX, [EBX].TControl.fColor
        CALL     Color2RGB
        XCHG     ESI, EAX
        PUSH     OPAQUE
        PUSH     [EDI].TMsg.wParam
        CALL     SetBkMode
        PUSH     ESI
        PUSH     [EDI].TMsg.wParam
        CALL     SetBkColor

        MOV      EAX, EBX
        CALL     Global_GetCtlBrushHandle
@@ret_rslt:
        XCHG     ECX, EAX
@@tmpbrushready:
        POP      EAX
        MOV      [EAX], ECX
@@ret_true:
        MOV      AL, 1

        JMP      @@ret_EAX

@@chk_CM_COMMAND:
        CMP      word ptr [EDI].TMsg.message, CM_COMMAND
        JNE      @@chk_WM_SETFOCUS

        PUSH     ECX

        MOVZX    ECX, word ptr [EDI].TMsg.wParam+2
        CMP      CX, [EBX].TControl.fCommandActions.aClick
        JNE      @@chk_aEnter

        CMP      [EBX].TControl.fClickDisabled, 0
        JG       @@calldef
        MOV      EAX, EBX
        CALL     TControl.DoClick
        JMP      @@calldef

@@chk_aEnter:
        LEA      EAX, [EBX].TControl.fOnEnter
        CMP      CX, [EBX].TControl.fCommandActions.aEnter
        JE       @@goEvent
        LEA      EAX, [EBX].TControl.fOnLeave
        CMP      CX, [EBX].TControl.fCommandActions.aLeave
        JE       @@goEvent
        LEA      EAX, [EBX].TControl.fOnChange
        CMP      CX, [EBX].TControl.fCommandActions.aChange
        JNE      @@chk_aSelChange
@@goEvent:
        MOV      ECX, [EAX].TMethod.Code
        JECXZ    @@2calldef
        MOV      EAX, [EAX].TMethod.Data
        MOV      EDX, EBX
        CALL     ECX
@@2calldef:
        JMP      @@calldef

@@chk_aSelChange:
        CMP      CX, [EBX].TControl.fCommandActions.aSelChange
        JNE      @@chk_WM_SETFOCUS_1
        MOV      EAX, EBX
        CALL     TControl.DoSelChange

@@calldef:
        XCHG     EAX, EBX
        MOV      EDX, EDI
        CALL     TControl.CallDefWndProc
        JMP      @@ret_rslt

@@chk_WM_SETFOCUS_1:
        POP      ECX
@@chk_WM_SETFOCUS:
        XOR      EAX, EAX
        CMP      word ptr [EDI].TMsg.message, WM_SETFOCUS
        JNE      @@ret_EAX

        MOV      [ECX], EAX
        MOV      EAX, EBX
        CALL     TControl.ParentForm
        TEST     EAX, EAX
        JZ       @@ret_true

        MOV      [EAX].TControl.FCurrentControl, EBX
        XOR      EAX, EAX

        PUSH     EDX
@@2ret_EAX:
        POP      EDX

@@ret_EAX:
        POP      EDI
        POP      ESI
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function WndProcCtrl(Self_: PControl; var Msg: TMsg; var Rslt: Integer): Boolean;
var F: PControl;
    Cmd : DWORD;
begin
  //Result := FALSE;
  with Self_ do
  case Msg.message of
  CN_CTLCOLORMSGBOX..CN_CTLCOLORSTATIC:
       begin
         SetTextColor(Msg.WParam, Color2RGB(fTextColor));
         if fTransparent {AND (fPaintDC = Msg.wParam)} then
         begin
            SetBkMode( Msg.wParam, Windows.TRANSPARENT );
            Rslt := GetStockObject( NULL_BRUSH );
         end
            else
         begin
            SetBkMode( Msg.wParam, Windows.OPAQUE );
            SetBkColor(Msg.WParam, Color2RGB( fColor ) );
            Rslt := Global_GetCtlBrushHandle( Self_ );
         end;
         Result := TRUE;
       end;
  CM_COMMAND:
       begin
         Result := True;
         Cmd := HiWord( Msg.wParam );
         if Cmd = fCommandActions.aClick then
         begin
            if Integer( fClickDisabled ) <= 0 then
              DoClick;
         end else
         if Cmd = fCommandActions.aEnter then
         begin
            if Assigned( fOnEnter ) then fOnEnter( Self_ );
         end else
         if Cmd = fCommandActions.aLeave then
         begin
            if Assigned( fOnLeave ) then fOnLeave( Self_ );
         end else
         if Integer(Cmd) = fCommandActions.aChange then
         begin
            if Assigned( fOnChange ) then fOnChange( Self_ );
            //if fTransparent then Invalidate;
         end else
         if Integer(Cmd) = fCommandActions.aSelChange then
         begin
           DoSelChange;
           // if fTransparent then Invalidate;
         end
         else Result := False;

         if Result then
           Rslt := CallDefWndProc( Msg );

       end;

  WM_SETFOCUS:
       begin
         Rslt := 0;
         Result := TRUE;
         F := ParentForm;
         if F <> nil then
         begin
           F.fCurrentControl := Self_;
           Result := False; // go further handling
         end;
       end;
  {$IFDEF ESC_CLOSE_DIALOGS}
  //---------------------------------Babenko Alexey--------------------------
  WM_KEYDOWN:
         begin
           if (Self_.ParentForm.ExStyle and WS_EX_DLGMODALFRAME) <> 0 then
            if Msg.wParam = 27 then SendMessage(Self_.ParentForm.Handle, WM_CLOSE, 0, 0);
            result:=false;
         end;
  //---------------------------------Babenko Alexey--------------------------
  {$ENDIF ESC_CLOSE_DIALOGS}
  else Result := False;
  end;
end;
{$ENDIF ASM_VERSION}
//[END WndProcCtrl]

//[FUNCTION WndProcPaint]
{$IFDEF ASM_noVERSION}
function WndProcPaint( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
const szPaintStruct = sizeof(TPaintStruct);
asm     //cmd    //opd
        CMP      word ptr [EDX].TMsg.message, WM_PRINT
        JE       @@print
        CMP      word ptr [EDX].TMsg.message, WM_PAINT
        JNE      @@ret_false
@@print:
        CMP      word ptr [EAX].TControl.fOnPaint.TMethod.Code+2, 0
        JE       @@ret_false
        PUSH     EBX
        PUSH     ESI

        XCHG     EBX, EAX
        MOV      ESI, EDX
        XOR      EAX, EAX
        PUSH     ECX
        PUSH     EAX
        PUSH     EAX
        PUSH     EAX
        PUSH     EAX
        CALL     CreateRectRgn
        MOV      [EBX].TControl.fUpdRgn, EAX

        MOVSX    EDX, [EBX].TControl.fEraseUpdRgn
        PUSH     EDX
        PUSH     EAX
        PUSH     [EBX].TControl.fHandle
        CALL     GetUpdateRgn

        CMP      EAX, 1
        JA       @@collectUpdRgn

        XOR      EAX, EAX
        XCHG     EAX, [EBX].TControl.fUpdRgn
        PUSH     EAX
        CALL     DeleteObject

@@collectUpdRgn:
        MOV      ECX, [EBX].TControl.fCollectUpdRgn
        JECXZ    @@asg_fPaintDC
        XCHG     EAX, ECX
        MOV      ECX, [EBX].TControl.fUpdRgn
        JECXZ    @@asg_fPaintDC

        PUSH     RGN_OR
        PUSH     ECX
        PUSH     EAX
        PUSH     EAX
        CALL     CombineRgn

        DEC      EAX
        JNZ      @@invalidateRgn

        ADD      ESP, -16
        PUSH     ESP
        PUSH     [EBX].TControl.fHandle
        CALL     Windows.GetClientRect

        PUSH     [EBX].TControl.fCollectUpdRgn
        CALL     DeleteObject
        CALL     CreateRectRgn
        MOV      [EBX].TControl.fCollectUpdRgn, EAX

@@invalidateRgn:
        MOVSX    EDX, [EBX].TControl.fEraseUpdRgn
        PUSH     EDX
        PUSH     [EBX].TControl.fCollectUpdRgn
        PUSH     [EBX].TControl.fHandle
        CALL     InvalidateRgn


@@asg_fPaintDC:
        MOV      ECX, [ESI].TMsg.wParam
        INC      ECX
        LOOP     @@storePaintDC

        ADD      ESP, -szPaintStruct
        PUSH     ESP
        PUSH     [EBX].TControl.fHandle
        CALL     BeginPaint
        XCHG     ECX, EAX
@@storePaintDC:
        MOV      [EBX].TControl.fPaintDC, ECX
        XCHG     EAX, ECX

        MOV      ECX, [EBX].TControl.fCollectUpdRgn
        JECXZ    @@doOnPaint

        PUSH     ECX
        PUSH     EAX
        CALL     SelectClipRgn

@@doOnPaint:
        MOV      ECX, [EBX].TControl.fPaintDC
        MOV      EDX, EBX
        MOV      EAX, [EBX].TControl.fOnPaint.TMethod.Data
        CALL     dword ptr [EBX].TControl.fOnPaint.TMethod.Code

        MOV      ECX, [EBX].TControl.fCanvas
        JECXZ    @@e_paint

        XCHG     EAX, ECX
        XOR      EDX, EDX
        CALL     TCanvas.SetHandle

@@e_paint:
        MOV      ECX, [ESI].TMsg.wParam
        INC      ECX
        LOOP     @@zero_fPaintDC

        PUSH     ESP
        PUSH     [EBX].TControl.fHandle
        CALL     EndPaint
        ADD      ESP, szPaintStruct

@@zero_fPaintDC:
        XOR      ECX, ECX
        MOV      [EBX].TControl.fPaintDC, ECX

        POP      EAX
        MOV      [EAX], ECX

        XCHG     ECX, [EBX].TControl.fUpdRgn
        JECXZ    @@exit_True

        PUSH     ECX
        CALL     DeleteObject

@@exit_True:
        POP      ESI
        POP      EBX
        MOV      AL, 1
        RET

@@ret_false:
        XOR      EAX, EAX
end;
{$ELSE ASM_VERSION} //Pascal
function WndProcPaint( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var PaintStruct: TPaintStruct;
    CR: TRect;
    Cplxity: Integer;
    OldPaintDC: HDC;
begin
  with Self_ do
  case Msg.message of
  WM_PRINT,
  WM_PAINT: if assigned( fOnPaint ) then
            begin
               fUpdRgn := CreateRectRgn( 0, 0, 0, 0 );
               Cplxity := Integer( GetUpdateRgn( fHandle, fUpdRgn, fEraseUpdRgn ) );
               if (Cplxity = NULLREGION) or (Cplxity = ERROR) then
               begin
                 DeleteObject( fUpdRgn );
                 fUpdRgn := 0;
               end;

               if (fCollectUpdRgn <> 0) and (fUpdRgn <> 0) then
               begin
                 if CombineRgn( fCollectUpdRgn, fCollectUpdRgn, fUpdRgn, RGN_OR )
                    = COMPLEXREGION then
                 begin
                   windows.GetClientRect( Self_.fHandle, CR );
                   DeleteObject( fCollectUpdRgn );
                   fCollectUpdRgn := CreateRectRgnIndirect( CR );
                 end;
                 InvalidateRgn( fHandle, fCollectUpdRgn, fEraseUpdRgn );
               end;

               OldPaintDC := fPaintDC;
               fPaintDC := Msg.wParam;
               if fPaintDC = 0 then
                 fPaintDC := BeginPaint( fHandle, PaintStruct );

               if fCollectUpdRgn <> 0 then
                 SelectClipRgn( fPaintDC, fCollectUpdRgn );

               fOnPaint( Self_, fPaintDC );

               if assigned( Self_.fCanvas ) then
                 Self_.fCanvas.SetHandle( 0 );

               if Msg.wParam = 0 then
                 EndPaint( fHandle, PaintStruct );
               fPaintDC := OldPaintDC;

               Rslt := 0;

               Result := True;
               if fUpdRgn <> 0 then
                 DeleteObject( fUpdRgn );
               fUpdRgn := 0;
               Exit;
            end;
  end;
  Result := FALSE;
end;
{$ENDIF ASM_VERSION}
//[END WndProcPaint]

//[procedure TControl.SetOnPaint]
procedure TControl.SetOnPaint( const Value: TOnPaint );
begin
  fOnPaint := Value;
  AttachProc( WndProcPaint );
end;

//*
//[function WndProcEraseBkgnd]
function WndProcEraseBkgnd( Sender: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var PaintStruct: TPaintStruct;
    OldPaintDC: HDC;
begin
  Result := FALSE;
  if Msg.message = WM_ERASEBKGND then
  begin
    if Assigned( Sender.OnEraseBkgnd ) then
    begin
      OldPaintDC := Sender.fPaintDC;
      Sender.fPaintDC := Msg.wParam;
      if Sender.fPaintDC = 0 then
        Sender.fPaintDC := BeginPaint( Sender.fHandle, PaintStruct );
      Sender.OnEraseBkgnd( Sender, Msg.wParam );
      if Msg.wParam = 0 then
        EndPaint( Sender.fHandle, PaintStruct );
      if Assigned( Sender.fCanvas ) then
        Sender.fCanvas.SetHandle( 0 );
      Sender.fPaintDC := OldPaintDC;
      Rslt := 0;
      Result := TRUE;
    end
      else
      Rslt := 0;
  end;
end;

//[procedure TControl.SetOnEraseBkgnd]
procedure TControl.SetOnEraseBkgnd(const Value: TOnPaint);
begin
  fOnEraseBkgnd := Value;
  AttachProc( WndProcEraseBkgnd );
end;

//[FUNCTION WndProcGradient]
{$IFDEF ASM_noVERSION}
function WndProcGradient( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
const szPaintStruct = sizeof( TPaintStruct );
asm     //cmd    //opd
        CMP      word ptr [EDX].TMsg.message, WM_PRINTCLIENT
        JE       @@print
        CMP      word ptr [EDX].TMsg.message, WM_PAINT
        JNE      @@ret_false
@@print:
        PUSHAD
        XCHG     EDI, EAX
        MOV      ESI, EDX
        XOR      EAX, EAX
        MOV      [ECX], EAX
        OR       EAX, [ESI].TMsg.wParam
        JNZ      @@1
        ADD      ESP, -szPaintStruct
        PUSH     ESP
        PUSH     [EDI].TControl.fHandle
        CALL     BeginPaint
@@1:    MOV      [EDI].TControl.fPaintDC, EAX
        ADD      ESP, -16
        MOV      EDX, ESP
        MOV      EAX, EDI
        CALL     TControl.ClientRect
        MOV      EAX, [EDI].TControl.fColor1
        CALL     Color2RGB
        XCHG     EBX, EAX
        MOV      EAX, [EDI].TControl.fColor2
        CALL     Color2RGB
        MOV      EBP, [ESP].TRect.Bottom
@@loo:
        MOV      EDX, [ESP].TRect.Top
        CMP      EBP, EDX
        JLE      @@e_loo
        INC      EDX
        MOV      [ESP].TRect.Bottom, EDX

        INC      EBP
        PUSH     EAX

        PUSH     EAX
        {SUB      AL, BL
        MOV      AH, 0

        CWDE}
        AND      EAX, $FF
        MOV      EDX, EBX
        AND      EDX, $FF
        SUB      EAX, EDX


        MOV      ECX, [ESP+8].TRect.Top
        IMUL     ECX
        IDIV     EBP
        XOR      EDX, EDX
        ADD      AL, BL
        MOV      AH, 0
        CWDE
        XCHG     [ESP], EAX

        PUSH     EAX
        {SUB      AH, BH
        MOV      AL, AH
        MOV      AH, 0

        CWDE}
        SHR      EAX, 8
        AND      EAX, $FF
        MOV      EDX, EBX
        SHR      EDX, 8
        AND      EDX, $FF
        SUB      EAX, EDX

        IMUL     ECX
        IDIV     EBP
        ADD      AL, BH
        AND      EAX, $FF
        SHL      EAX, 8
        XCHG     [ESP], EAX

        SHR      EAX, 16
        MOV      EDX, EBX
        SHR      EDX, 16
        PUSH     EDX
        SUB      EAX, EDX
        IMUL     ECX
        IDIV     EBP
        POP      EDX
        //AND      EAX, $FF00
        ADD      EAX, EDX
        SHL      EAX, 16

        POP      EDX
        MOV      AH, DH
        POP      EDX
        MOV      AL, DL

        PUSH     EAX
        CALL     CreateSolidBrush

        PUSH     EAX

        PUSH     EAX
        LEA      EDX, [ESP+12]
        PUSH     EDX
        PUSH     [EDI].TControl.fPaintDC
        CALL     Windows.FillRect

        CALL     DeleteObject

        POP      EAX
        DEC      EBP
        INC      [ESP].TRect.Top
        JMP      @@loo
@@e_loo:
        ADD      ESP, 16
        MOV      ECX, [ESI].TMsg.wParam
        INC      ECX
        LOOP     @@2
        PUSH     ESP
        PUSH     [EDI].TControl.fHandle
        CALL     EndPaint
        ADD      ESP, szPaintStruct
@@2:    XOR      EAX, EAX
        MOV      [EDI].TControl.fPaintDC, EAX
        POPAD
        MOV      Al, 1
        RET
@@ret_false:
        XOR      EAX, EAX
end;
{$ELSE ASM_VERSION} //Pascal
function WndProcGradient( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var PaintStruct: TPaintStruct;
    Bmp: PBitmap;
    CR: TRect;
    I: Integer;
    R, G, B: Integer;
    R1, G1, B1: Integer;
    C: TColor;
    W, H, WH: Integer;
    W9x: Boolean;
    Br: HBrush;
    //Save: Integer;
    OldPaintDC: HDC;
begin
  case Msg.message of
  WM_PAINT, WM_PRINTCLIENT:
            begin
               OldPaintDC := Self_.fPaintDC;
               Self_.fPaintDC := Msg.wParam;
               if Self_.fPaintDC = 0 then
                  Self_.fPaintDC := BeginPaint( Self_.fHandle, PaintStruct );
               CR := Self_.ClientRect;
               W9x := WinVer < wvNT;
               W := 1;
               H := CR.Bottom;
               WH := H;
               Bmp := nil;
               if Self_.fGradientStyle = gsHorizontal then
               begin
                 W := CR.Right;
                 H := 1;
                 WH := W;
               end;
               if not W9x then
                 Bmp := NewDIBBitmap( W, H, pf32bit );
               C := Color2RGB( Self_.fColor1 );
               R := C shr 16;
               G := (C shr 8) and $FF;
               B := C and $FF;
               C := Color2RGB( Self_.fColor2 );
               R1 := C shr 16;
               G1 := (C shr 8) and $FF;
               B1 := C and $FF;
               for I := 0 to WH-1 do
               begin
                 C := ((( R + (R1 - R) * I div WH ) and $FF) shl 16) or
                      ((( G + (G1 - G) * I div WH ) and $FF) shl 8) or
                      ( B + (B1 - B) * I div WH ) and $FF;
                 if W9x then
                 begin
                   if Self_.fGradientStyle = gsVertical then
                     CR.Bottom := CR.Top + 1
                   else
                     CR.Right := CR.Left + 1;
                   Br := CreateSolidBrush( C );
                   Windows.FillRect( Self_.fPaintDC, CR, Br );
                   DeleteObject( Br );
                   if Self_.fGradientStyle = gsVertical then
                     Inc( CR.Top )
                   else
                     Inc( CR.Left );
                 end
                   else
                 begin
                   if Self_.fGradientStyle = gsVertical then
                     Bmp.DIBPixels[ 0, I ] := C
                   else
                     Bmp.DIBPixels[ I, 0 ] := C;
                 end;
               end;
               if not W9x then
               begin
                 SetStretchBltMode( Self_.fPaintDC, HALFTONE );
                 SetBrushOrgEx( Self_.fPaintDC, 0, 0, nil );
                 StretchBlt( Self_.fPaintDC, 0, 0, CR.Right, CR.Bottom, Bmp.Canvas.Handle,
                             0, 0, W, H, SRCCOPY );
                 Bmp.Free;
               end;
               if Msg.wParam = 0 then
                 EndPaint( Self_.fHandle, PaintStruct );
               Self_.fPaintDC := OldPaintDC;
               Rslt := 0;
               Result := True;
               Exit;
            end;
  end;
  Result := False;
end;
{$ENDIF ASM_VERSION}
//[END WndProcGradient]

//[function WndProcGradientEx]
function WndProcGradientEx( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
  function Ceil( X: Double ): Integer;
  begin
    Result := Round( X ) + 1;
  end;
const
  SQRT2 = 1.4142135623730950488016887242097;
var
  RC, R0: TRect;
  C, C2: TColor;
  R1, G1, B1: Integer;
  R2, G2, B2: Integer;
  DX1, DX2, DY1, DY2, DR, DG, DB, K: Double;
  PaintStruct: TPaintStruct;
  I: Integer;
  Br: HBrush;
  Rgn: HRgn;
  Poly: array[ 0..3 ] of TPoint;
  OldPaintDC: HDC;
  fX1, fX2, fY1, fY2: Double;

  procedure OffsetF( DX, DY: Double );
  begin
    fX1 := fX1 + DX;
    fX2 := fX2 + DX;
    fY1 := fY1 + DY;
    fY2 := fY2 + DY;
  end;
begin
  Result := FALSE;
  if (Msg.message <> WM_PAINT) and (Msg.message <> WM_PRINTCLIENT) then Exit;
  if Self_.fGradientStyle in [ gsHorizontal, gsVertical ] then
  begin
    Result := WndProcGradient( Self_, Msg, Rslt );
    Exit;
  end;
  C := Color2RGB( Self_.fColor2 );
  R2 := C and $FF;
  G2 := (C shr 8) and $FF;
  B2 := (C shr 16) and $FF;
  C := Color2RGB( Self_.fColor1 );
  R1 := C and $FF;
  G1 := (C shr 8) and $FF;
  B1 := (C shr 16) and $FF;
  DR := (R2 - R1) / 256;
  DG := (G2 - G1) / 256;
  DB := (B2 - B1) / 256;
  OldPaintDC := Self_.fPaintDC;
  Self_.fPaintDC := Msg.wParam;
  if Self_.fPaintDC = 0 then
    Self_.fPaintDC := BeginPaint( Self_.fHandle, PaintStruct );
  RC := Self_.ClientRect;
  fX1 := 0;
  fY1 := 0;
  case Self_.fGradientStyle of
  gsRombic:
    //RF := MakeRect( 0, 0, RC.Right div 128, RC.Bottom div 128 );
    begin
      fX2 := RC.Right / 128;
      fY2 := RC.Bottom / 128;
    end;
  gsElliptic:
    //RF := MakeRect( 0, 0, Ceil( RC.Right / 256 * SQRT2 ), Ceil( RC.Bottom / 256 * SQRT2 ) );
    begin
      fX2 := RC.Right / 256 * SQRT2;
      fY2 := RC.Bottom / 256 * SQRT2;
    end;
  else
    //RF := MakeRect( 0, 0, RC.Right div 256, RC.Bottom div 256 );
    begin
      fX2 := RC.Right / 256;
      fY2 := RC.Bottom / 256;
    end;
  end;
  case Self_.fGradientStyle of
  gsRectangle, gsRombic, gsElliptic:
    begin
      case Self_.FGradientLayout of
      glCenter, glTop, glBottom:
        //OffsetRect( RF, (RC.Right - RF.Right) div 2, 0 );
        OffsetF( (RC.Right - fX2) / 2, 0 );
      glTopRight, glBottomRight, glRight:
        //OffsetRect( RF, RC.Right - RF.Right div 2, 0 );
        OffsetF( RC.Right - fX2 / 2, 0 );
      glTopLeft, glBottomLeft, glLeft:
        //OffsetRect( RF, -RF.Right div 2, 0 );
        OffsetF( -fX2 / 2, 0 );
      end;
      case Self_.FGradientLayout of
      glCenter, glLeft, glRight:
        //OffsetRect( RF, 0, (RC.Bottom - RF.Bottom) div 2 );
        OffsetF( 0, (RC.Bottom - fY2) / 2 );
      glBottom, glBottomLeft, glBottomRight:
        //OffsetRect( RF, 0, RC.Bottom - RF.Bottom div 2 );
        OffsetF( 0, RC.Bottom - fY2 / 2 );
      glTop, glTopLeft, glTopRight:
        //OffsetRect( RF, 0, -RF.Bottom div 2 );
        OffsetF( 0, -fY2 / 2 )
      end;
    end;
  end;
  DX1 := -fX1 / 255; //(-RF.Left) / 255;
  DY1 := -fY1 / 255; // (-RF.Top) / 255;
  DX2 := (RC.Right - fX2) / 255; //(RC.Right - RF.Right) / 255;
  DY2 := (RC.Bottom - fY2) / 255;
  case Self_.fGradientStyle of
  gsRombic, gsElliptic:
    begin
      if DX2 < -DX1 then DX2 := -DX1;
      if DY2 < -DY1 then DY2 := -DY1;
      K := 2;
      if Self_.fGradientStyle = gsElliptic then K := SQRT2;
      DX2 := DX2 * K;
      DY2 := DY2 * K;
      DX1 := -DX2;
      DY1 := -DY2;
    end;
  end;
  C2 := C;
  for I := 0 to 255 do
  begin
    if (I < 255) then
    begin
      C2 := TColor( (( Ceil( B1 + DB * (I+1) ) and $FF) shl 16) or
          (( Ceil( G1 + DG * (I+1) ) and $FF) shl 8) or
           Ceil( R1 + DR * (I+1) ) and $FF );
      if (Self_.fGradientStyle in [gsRombic,gsElliptic,gsRectangle]) and
         (C2 = C) then continue;
    end;
    Br := CreateSolidBrush( C );
    R0 := MakeRect( Ceil( fX1 + DX1 * I ),
                    Ceil( fY1 + DY1 * I ),
                    Ceil( fX2 + DX2 * I ) + 1,
                    Ceil( fY2 + DY2 * I ) + 1 );
    Rgn := 0;
    case Self_.fGradientStyle of
    gsRectangle:
      Rgn := CreateRectRgnIndirect( R0 );
    gsRombic:
      begin
        Poly[ 0 ].x := R0.Left;
        Poly[ 0 ].y := R0.Top + (R0.Bottom - R0.Top) div 2;
        Poly[ 1 ].x := R0.Left + (R0.Right - R0.Left) div 2;
        Poly[ 1 ].y := R0.Top;
        Poly[ 2 ].x := R0.Right;
        Poly[ 2 ].y := Poly[ 0 ].y;
        Poly[ 3 ].x := Poly[ 1 ].x;
        Poly[ 3 ].y := R0.Bottom;
        Rgn := CreatePolygonRgn( Poly[ 0 ].x, 4, ALTERNATE );
      end;
    gsElliptic:
      Rgn := CreateEllipticRgnIndirect( R0 );
    end;
    if Rgn <> 0 then
    begin
      if Rgn <> NULLREGION then
      begin
        Windows.FillRgn( Self_.fPaintDC, Rgn, Br );
        ExtSelectClipRgn( Self_.fPaintDC, Rgn, RGN_DIFF );
      end;
      DeleteObject( Rgn );
    end;
    DeleteObject( Br );
    C := C2;
  end;
  if Self_.fPaintDC <> HDC( Msg.wParam ) then
    EndPaint( Self_.fHandle, PaintStruct );
  Self_.fPaintDC := OldPaintDC;
  Rslt := 0;
  Result := True;
end;

//*
//[function WndProcLabelEffect]
function WndProcLabelEffect( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var
    Sz: TSize;
    P0: TPoint;
    CR: TRect;
    B : Boolean;
    CShadow: TColor;
    Target: PCanvas;
    Txt: String;
    LCaption: PChar;
    OldPaintDC: HDC;

    procedure doTextOut( shfx, shfy: Integer; col: TColor );
    begin
        SetTextColor( Target.fHandle, col );
        Windows.ExtTextOut( Target.fHandle, P0.x + shfx, P0.y + shfy,
                            ETO_CLIPPED, @CR,
                            PChar(Txt), Length(Txt), nil );
        //GDIFlush; // for test only
    end;

var I, J, Istp : Integer;
    PS: TPaintStruct;
    //DoEndPaint: Boolean;
begin
  Result := False;

  case Msg.message of

  WM_SETTEXT:
    begin
      LCaption := PChar( Msg.lParam );
      if LCaption <> Self_.fCaption then
      begin
        if Self_.fCaption <> nil then
           FreeMem( Self_.fCaption );
        GetMem( Self_.fCaption, StrLen( LCaption ) + 1 );
        StrCopy( Self_.fCaption, LCaption );
      end;
      Result := True;
      Rslt := 1;
      Exit;
    end;

  WM_PRINTCLIENT, WM_PAINT:
  begin
    OldPaintDC := Self_.fPaintDC;
    Self_.fPaintDC := Msg.wParam;
    if Self_.fPaintDC = 0 then
      Self_.fPaintDC := BeginPaint( Self_.fHandle, PS );
    begin
       Target := Self_.Canvas;
       Txt := Self_.fCaption;
       Target.TextArea( Txt, Sz, P0 );
       if Self_.fShadowDeep <> 0 then
       begin
         for B := False to Self_.fCtl3D do
         begin
           Inc( Sz.cx, Abs( Self_.fShadowDeep ) );
           Inc( Sz.cy, Abs( Self_.fShadowDeep ) );
         end;
       end;
       CR := Self_.ClientRect;
       case Self_.fTextAlign of
       taCenter: P0.x := P0.x + (CR.Right - Sz.cx) div 2;
       taRight:  P0.x := P0.x + (CR.Right - Sz.cx);
       end;
       case Self_.fVerticalAlign of
       vaCenter: P0.y := P0.y + (CR.Bottom - Sz.cy) div 2;
       vaBottom: P0.y := P0.y + (CR.Bottom - Sz.cy);
       end;
       if Self_.fShadowDeep <> 0 then
       begin
         if Self_.fColor2 = clNone then
           CShadow := ColorsMix(Color2RGB(Self_.fTextColor),Color2RGB(Self_.fColor2))
         else
           CShadow := Color2RGB( Self_.fColor2 );
         if not Self_.fTransparent then
           Target.FillRect( CR ); // GDIFlush; for test only
         //Target.DeselectHandles;
         Target.RequiredState( HandleValid or FontValid or BrushValid or ChangingCanvas );
         SetBkMode( Target.fHandle, Windows.TRANSPARENT );
         if Self_.fCtl3D then
         begin
           I := - Self_.fShadowDeep;
           Istp := 1;
           if Self_.ShadowDeep > 0 then Istp := -1;
           repeat
             J := - Self_.fShadowDeep;
             repeat
               if not ( (I=0) and (J=0) ) then
               begin
                 if (I * Istp < 0) and (J * Istp < 0) then
                 begin
                    doTextOut( I, J, CShadow );
                 end;
               end;
               J := J - Istp;
             until J = Self_.fShadowDeep - IStp;
             I := I - Istp;
           until I = Self_.fShadowDeep - IStp;
         end
            else
         doTextout( Self_.fShadowDeep, Self_.fShadowdeep, CShadow );
         doTextout( 0, 0, Color2RGB(Self_.fTextColor) );
       end
          else
       begin
         //Target.DeselectHandles;
         Target.RequiredState( HandleValid or FontValid or BrushValid or ChangingCanvas );
         SetBkMode( Target.fHandle, Windows.TRANSPARENT );
         //Target.TextRect( CR, P0.x, P0.y, Txt );
         doTextout( 0, 0, Color2RGB(Self_.fTextColor) );
       end;
    end;
    if assigned( Self_.fCanvas ) then
      Self_.fCanvas.SetHandle( 0 );
    if MSg.wParam = 0 then
      EndPaint( Self_.fHandle, PS );
    Self_.fPaintDC := OldPaintDC;
    Rslt := 0;
    Result := True;
    Exit;
    end;
  end;
end;

{$IFDEF ASM_VERSION}
//[procedure TControl.DoClick]
procedure TControl.DoClick;
asm
        PUSH     EAX
        CALL     [EAX].fControlClick
        POP      EDX

        MOV      ECX, [EDX].fOnClick.TMethod.Code
        JECXZ    @@exit
        MOV      EAX, [EDX].fOnClick.TMethod.Data
        CALL     ECX
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.DoClick;
begin
  fControlClick( Self );
  if Assigned( fOnClick ) then
     fOnClick( Self );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.ParentForm]
function TControl.ParentForm: PControl;
asm
@@1:    CMP      [EAX].fIsControl, 0
        JZ       @@exit
        MOV      EAX, [EAX].fParent
        TEST     EAX, EAX
        JNZ      @@1
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.ParentForm: PControl;
begin
  Result := Self;
  if Result.fIsControl then
  repeat
    Result := Result.fParent;
  until (Result = nil) or not Result.fIsControl;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TControl.SetProgressColor]
procedure TControl.SetProgressColor(const Value: TColor);
asm
        PUSH     EDX
        PUSH     EAX
        MOV      EAX, EDX
        CALL     Color2RGB
        POP      EDX
        PUSH     EDX
        PUSH     EAX
        PUSH     0
        PUSH     PBM_SETBARCOLOR
        PUSH     EDX
        CALL     Perform
        TEST     EAX, EAX
        POP      EAX
        POP      EDX
        JZ       @@exit
        MOV      [EAX].fTextColor, EDX
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.SetProgressColor(const Value: TColor);
begin
  if Perform( PBM_SETBARCOLOR, 0, Color2RGB(Value) ) <> 0 then
    fTextColor := Value;
end;
{$ENDIF ASM_VERSION}

//[procedure TControl.SetShadowDeep]
procedure TControl.SetShadowDeep(const Value: Integer);
begin
  fShadowDeep := Value;
  Invalidate;
end;

{$IFDEF ASM_VERSION}
//[function TControl.GetFont]
function TControl.GetFont: PGraphicTool;
asm
        MOV      ECX, [EAX].FFont
        INC      ECX
        LOOP     @@exit
        PUSH     EAX
        CALL     NewFont
        POP      EDX
        MOV      [EDX].FFont, EAX
        MOV      ECX, [EDX].fTextColor
        MOV      [EAX].TGraphicTool.fData.Color, ECX
        MOV      [EAX].TGraphicTool.fOnChange.TMethod.Code, offset[FontChanged]
        MOV      [EAX].TGraphicTool.fOnChange.TMethod.Data, EDX
        RET
@@exit: XCHG     EAX, ECX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.GetFont: PGraphicTool;
begin
  if FFont = nil then
  begin
     FFont := NewFont;
     FFont.fData.Color := fTextColor;
     FFont.OnChange := FontChanged;
  end;
  Result := FFont;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.GetBrush]
function TControl.GetBrush: PGraphicTool;
asm
        MOV      ECX, [EAX].FBrush
        INC      ECX
        LOOP     @@exit
        PUSH     EAX
        CALL     NewBrush
        POP      EDX
        MOV      [EDX].FBrush, EAX
        MOV      ECX, [EDX].fColor
        MOV      [EAX].TGraphicTool.fData.Color, ECX
        MOV      [EAX].TGraphicTool.fOnChange.TMethod.Code, offset[BrushChanged]
        MOV      [EAX].TGraphicTool.fOnChange.TMethod.Data, EDX
        RET
@@exit: XCHG     EAX, ECX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.GetBrush: PGraphicTool;
begin
  if FBrush = nil then
  begin
    FBrush := NewBrush;
    FBrush.fData.Color := fColor;
    FBrush.OnChange := BrushChanged;
  end;
  Result := FBrush;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TControl.FontChanged]
procedure TControl.FontChanged(Sender: PGraphicTool);
asm
        MOV      ECX, [EDX].TGraphicTool.fData.Color
        MOV      [EAX].fTextColor, ECX
        PUSH     EAX
        CALL     ApplyFont2Wnd
        POP      EAX
        CALL     Invalidate
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.FontChanged(Sender: PGraphicTool);
begin
  fTextColor := Sender.fData.Color;
  ApplyFont2Wnd;
  Invalidate;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TControl.BrushChanged]
procedure TControl.BrushChanged(Sender: PGraphicTool);
asm
        MOV      ECX, [EDX].TGraphicTool.fData.Color
        MOV      [EAX].fColor, ECX
        XOR      ECX, ECX
        XCHG     ECX, [EAX].fTmpBrush
        JECXZ    @@inv
        PUSH     EAX
        PUSH     ECX
        CALL     DeleteObject
        POP      EAX
@@inv:  CALL     Invalidate
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.BrushChanged(Sender: PGraphicTool);
begin
  fColor := Sender.fData.Color;
  if fTmpBrush <> 0 then
  begin
    DeleteObject( fTmpBrush );
    fTmpBrush := 0;
  end;
  if fPaintDC = 0 then
  // only if not in painting already :
    Invalidate;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TControl.ApplyFont2Wnd]
procedure TControl.ApplyFont2Wnd;
asm
        PUSH       EBX
        XCHG       EBX, EAX

        MOV        ECX, [EBX].fFont
        JECXZ      @@exit
        XCHG       EAX, ECX

        MOV        ECX, [EBX].fHandle
        JECXZ      @@0

        MOV        EDX, [EAX].TGraphicTool.fData.Color
        MOV        [EBX].fTextColor, EDX

        PUSH       $FFFF
        CALL       TGraphicTool.GetHandle
        PUSH       EAX
        PUSH       WM_SETFONT
        PUSH       EBX
        CALL       Perform

@@0:
        XOR        ECX, ECX
        XCHG       ECX, [EBX].fCanvas
        JECXZ      @@1

        XCHG       EAX, ECX
        CALL       TObj.Free
@@1:
        MOV        ECX, [EBX].fAutoSize
        JECXZ      @@exit
        XCHG       EAX, EBX
        CALL       ECX
@@exit:
        POP        EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.ApplyFont2Wnd;
begin
  if fFont <> nil then
  begin
    if fHandle <> 0 then
    begin
      fTextColor := fFont.fData.Color;
      Perform( WM_SETFONT, FFont.Handle, 1 );
    end;

    if fCanvas <> nil then
    begin
      fCanvas.Free;
      fCanvas := nil;
    end;

    if Assigned( fAutoSize ) then
      fAutoSize( Self );
    //if assigned( fCanvas ) then
    //   {fCanvas.fFont :=} fCanvas.fFont.Assign( fFont );
  end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.ResizeParent]
function TControl.ResizeParent: PControl;
asm
        LEA       EDX, [TControl.ResizeParentRight]
        PUSH      EDX
        CALL      EDX
        CALL      TControl.ResizeParentBottom
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.ResizeParent: PControl;
begin
            ResizeParentBottom;
            ResizeParentRight;
            // Once again, to fix Windows (or my???) bug with
            // incorrect calculating of GetClientRect after
            // SetWindowLong( GWL_[EX}STYLE,... )
  Result := ResizeParentBottom;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.ResizeParentBottom]
function TControl.ResizeParentBottom: PControl;
asm
        PUSH      EAX
        PUSH      EBX
        MOV       EBX, [EAX].fParent
        TEST      EBX, EBX
        JZ        @@exit

        MOV       EDX, [EAX].fBoundsRect.Bottom
        ADD       EDX, [EBX].fMargin

        TEST      [EBX].fChangedPosSz, 20h
        JZ        @@1

        PUSH      EDX
        MOV       EAX, EBX
        CALL      GetClientHeight
        POP       EDX

        CMP       EDX, EAX
        JLE       @@exit
@@1:
        MOV       EAX, EBX
        CALL      TControl.SetClientHeight
        OR        [EBX].fChangedPosSz, 20h
@@exit:
        POP       EBX
        POP       EAX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.ResizeParentBottom: PControl;
var NewCH: Integer;
begin
  Result := Self;
  if fParent <> nil then
  begin
    NewCH := BoundsRect.Bottom + fParent.fMargin;
    if (fParent.fChangedPosSz and $20) <> 0 then
       if NewCH < fParent.ClientHeight then Exit;
    fParent.ClientHeight := NewCH;
    fParent.fChangedPosSz := fParent.fChangedPosSz or $20;
  end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.ResizeParentRight]
function TControl.ResizeParentRight: PControl;
asm
        PUSH      EAX
        PUSH      EBX
        MOV       EBX, [EAX].fParent
        TEST      EBX, EBX
        JZ        @@exit

        MOV       EDX, [EAX].fBoundsRect.Right
        ADD       EDX, [EBX].fMargin

        TEST      [EBX].fChangedPosSz, 10h
        JZ        @@1

        PUSH      EDX
        MOV       EAX, EBX
        CALL      GetClientWidth
        POP       EDX

        CMP       EDX, EAX
        JLE       @@exit
@@1:
        MOV       EAX, EBX
        CALL      TControl.SetClientWidth
        OR        [EBX].fChangedPosSz, 10h
@@exit:
        POP       EBX
        POP       EAX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.ResizeParentRight: PControl;
var NewCW: Integer;
begin
  Result := Self;
  if fParent <> nil then
  begin
    NewCW := fBoundsRect.Right + fParent.fMargin;
    if (fParent.fChangedPosSz and $10) <> 0 then
       if NewCW < fParent.ClientWidth then Exit;
    fParent.ClientWidth := NewCW;
    fParent.fChangedPosSz := fParent.fChangedPosSz or $10;
  end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.GetClientHeight]
function TControl.GetClientHeight: Integer;
asm
        ADD       ESP, -size_TRect
        MOV       EDX, ESP
        CALL      TControl.ClientRect
        POP       EDX
        POP       ECX            // Top
        POP       EDX
        POP       EAX            // Bottom
        SUB       EAX, ECX       // Result = Bottom - Top
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.GetClientHeight: Integer;
begin
  with ClientRect do
    Result := Bottom - Top;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.GetClientWidth]
function TControl.GetClientWidth: Integer;
asm
        ADD       ESP, -size_TRect
        MOV       EDX, ESP
        CALL      TControl.ClientRect
        POP       ECX            // Left
        POP       EDX
        POP       EAX            // Right
        SUB       EAX, ECX       // Result = Right - Left
        POP       EDX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.GetClientWidth: Integer;
begin
  with ClientRect do
    Result := Right - Left;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TControl.SetClientHeight]
procedure TControl.SetClientHeight(const Value: Integer);
asm
        PUSH      EBX
         PUSH      EDX

        MOV       EBX, EAX
        CALL      TControl.GetClientHeight
          PUSH      EAX
        MOV       EAX, EBX
        CALL      TControl.GetHeight // EAX = Height

          POP       EDX              // EDX = ClientHeight
        SUB       EAX, EDX           // EAX = Delta
         POP       EDX               // EDX = Value
        ADD       EDX, EAX           // EDX = Value + Delta
        XCHG      EAX, EBX           // EAX = Self
        CALL      TControl.SetHeight
        POP       EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.SetClientHeight(const Value: Integer);
var Delta: Integer;
begin
  Delta := ClientHeight;
  Delta := Height - Delta;
  Height := Value + Delta;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TControl.SetClientWidth]
procedure TControl.SetClientWidth(const Value: Integer);
asm
        PUSH      EBX
         PUSH      EDX

        MOV       EBX, EAX
        CALL      TControl.GetClientWidth
          PUSH      EAX
        MOV       EAX, EBX
        CALL      TControl.GetWidth  // EAX = Width

          POP       EDX              // EDX = ClientWidth
        SUB       EAX, EDX           // EAX = Width - ClientWidth
         POP       EDX               // EDX = Value
        ADD       EDX, EAX           // EDX = Value + Delta
        XCHG      EAX, EBX           // EAX = Self
        CALL      TControl.SetWidth
        POP       EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.SetClientWidth(const Value: Integer);
var Delta: Integer;
begin
  Delta := ClientWidth;
  Delta := Width - Delta;
  Width := Value + Delta;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.CenterOnParent]
function TControl.CenterOnParent: PControl;
asm
        PUSHAD

        XCHG     ESI, EAX
        MOV      ECX, [ESI].fParent
        JECXZ    @@1
        CMP      [ESI].fIsControl, 0
        JNZ      @@2

@@1:
        PUSH     SM_CYSCREEN
        CALL     GetSystemMetrics
        PUSH     EAX

        PUSH     SM_CXSCREEN
        CALL     GetSystemMetrics
        PUSH     EAX

        PUSH     0
        PUSH     0               // ESP -> Rect( 0, 0, CX, CY )

        JMP      @@3

@@2:    ADD      ESP, -size_TRect
        MOV      EDX, ESP
        XCHG     EAX, ECX
        CALL     TControl.ClientRect
                                 // ESP -> ClientRect
@@3:    MOV      EAX, ESI
        CALL     GetWindowHandle

        MOV      EAX, ESI
        CALL     GetWidth

        POP      EDX       // left
        ADD      EAX, EDX          // + width

        POP      EDI       // top
        POP      EDX       // right

        SUB      EDX, EAX
        SAR      EDX, 1

        MOV      EAX, ESI
        CALL     SetLeft

        MOV      EAX, ESI
        CALL     GetHeight

        ADD      EAX, EDI  // height + top

        POP      EDX       // bottom
        SUB      EDX, EAX
        SAR      EDX, 1

        XCHG     EAX, ESI
        CALL     SetTop

        POPAD
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.CenterOnParent: PControl;
var PCR: TRect;
begin
  Result := Self;
  if (fParent = nil) or not fIsControl then
    PCR := MakeRect( 0, 0, GetSystemMetrics( SM_CXSCREEN ), GetSystemMetrics( SM_CYSCREEN ) )
  else
    PCR := fParent.ClientRect;
  GetWindowHandle;
  Left := (PCR.Right - PCR.Left - Width) div 2;
  Top := (PCR.Bottom - PCR.Top - Height) div 2;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_noVERSION}
//[function TControl.GetHasBorder]
function TControl.GetHasBorder: Boolean;
const style_mask = WS_BORDER or WS_THICKFRAME or WS_DLGFRAME;
asm
        CALL     UpdateWndStyles
        MOV      EAX, [EAX].fStyle
        AND      EAX, style_mask
        SETNZ    AL
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.GetHasBorder: Boolean;
begin
  UpdateWndStyles;
  Result := LongBool( fStyle and (WS_BORDER or WS_THICKFRAME or WS_DLGFRAME))
         or LongBool( fExStyle and WS_EX_CLIENTEDGE );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_noVERSION} // YS
//[procedure TControl.SetHasBorder]
procedure TControl.SetHasBorder(const Value: Boolean);
const style_mask = WS_BORDER or WS_THICKFRAME or WS_DLGFRAME or WS_CAPTION
                             or WS_MINIMIZEBOX or WS_MAXIMIZEBOX or WS_SYSMENU;
      exstyle_mask = not (WS_EX_CONTROLPARENT or WS_EX_DLGMODALFRAME
                                or WS_EX_WINDOWEDGE or WS_EX_CLIENTEDGE);
asm

        PUSH     EAX
          PUSH     EDX

            CALL     GetHasBorder
          POP      ECX
          CMP      AL, CL

        POP      EAX
        JZ       @@exit

        MOV      EDX, [EAX].fStyle
        DEC      CL
        MOVZX    ECX, [EAX].fIsControl
        JNZ      @@1

        OR       EDX, WS_THICKFRAME
        INC      ECX
        LOOP     @@set_style
        OR       EDX, style_mask
        JMP      @@set_style

@@1:    AND      EDX, not style_mask
        INC      ECX
        LOOP     @@2
        OR       EDX, WS_POPUP

@@2:    PUSH     EDX

        MOV      EDX, [EAX].fExStyle
        AND      EDX, exstyle_mask

        PUSH     EAX
        CALL     SetExStyle
        POP      EAX

        POP      EDX
@@set_style:
        CALL     SetStyle
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.SetHasBorder(const Value: Boolean);
var NewStyle: DWORD;
begin
  if Value = GetHasBorder then Exit;
  {if Value then
  begin
    NewStyle := fStyle or WS_THICKFRAME;
    if not fIsControl then
      NewStyle := NewStyle or WS_BORDER or
               WS_DLGFRAME or WS_CAPTION or WS_MINIMIZEBOX or WS_MAXIMIZEBOX or
               WS_SYSMENU;
    Style := NewStyle;
  end}
  if Value then
  begin
    if not fIsControl then
      Style := fStyle or WS_THICKFRAME or WS_BORDER or
               WS_DLGFRAME or WS_CAPTION or WS_MINIMIZEBOX or WS_MAXIMIZEBOX or
               WS_SYSMENU
    else
      if fCtl3D then
        ExStyle := fExStyle or WS_EX_CLIENTEDGE
      else
        Style := fStyle or WS_BORDER;
  end
    else
  begin
    NewStyle := fStyle and not (WS_BORDER or WS_THICKFRAME or WS_DLGFRAME or WS_CAPTION
                             or WS_MINIMIZEBOX or WS_MAXIMIZEBOX or WS_SYSMENU);
    if not fIsControl then NewStyle := NewStyle or WS_POPUP;
    Style := NewStyle;
    ExStyle := fExStyle and not (WS_EX_CONTROLPARENT or WS_EX_DLGMODALFRAME
                                or WS_EX_WINDOWEDGE or WS_EX_CLIENTEDGE);
  end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.GetHasCaption]
function TControl.GetHasCaption: Boolean;
const style_mask1 = (WS_POPUP or WS_DLGFRAME) shr 16;
      style_mask2 = WS_CAPTION shr 16;
asm
        CALL     UpdateWndStyles
        MOV      ECX, [EAX].fStyle + 2
        MOV      EDX, ECX
        MOV      AL, 1
        AND      DX, style_mask1
        JZ       @@1
        AND      CX, style_mask2
        JNZ      @@1
        XOR      EAX, EAX
@@1:
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.GetHasCaption: Boolean;
begin
  UpdateWndStyles;
  Result := not LongBool( fStyle and (WS_POPUP or WS_DLGFRAME))
            or LongBool( fStyle and WS_CAPTION);
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TControl.SetHasCaption]
procedure TControl.SetHasCaption(const Value: Boolean);
const style_mask = not (WS_BORDER or WS_THICKFRAME or WS_DLGFRAME or WS_CAPTION
                             or WS_MINIMIZEBOX or WS_MAXIMIZEBOX or WS_SYSMENU);
      exstyle_mask = not (WS_EX_CONTROLPARENT or WS_EX_DLGMODALFRAME
                                or WS_EX_WINDOWEDGE or WS_EX_CLIENTEDGE);
asm
        PUSH     EAX
          PUSH     EDX

            CALL     GetHasCaption
          POP      ECX
          CMP      AL, CL

        POP      EAX
        JZ       @@exit   // Value = HasCaption

        MOV      EDX, [EAX].fStyle
        DEC      CL
        JNZ      @@1      // if not Value -> @@1

        AND      EDX, not WS_POPUP
        OR       EDX, WS_CAPTION
        JMP      @@set_style

@@1:
        CMP      [EAX].fIsControl, 0
        JNZ      @@2               // if fIsControl -> @@2

        AND      EDX, not (WS_CAPTION or WS_SYSMENU)
        OR       EDX, WS_POPUP
        JMP      @@3

@@2:
        AND      EDX, not WS_CAPTION
        OR       EDX, WS_DLGFRAME

@@3:
        PUSH     EDX

        MOV      EDX, [EAX].fExStyle
        OR       EDX, WS_EX_DLGMODALFRAME

        PUSH     EAX
        CALL     SetExStyle
        POP      EAX

        POP      EDX
@@set_style:
        CALL     SetStyle
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.SetHasCaption(const Value: Boolean);
begin
  if Value = GetHasCaption then Exit;
  if Value then
  begin
     Style := fStyle and not (WS_POPUP or WS_DLGFRAME) or WS_CAPTION;
  end
    else
  begin
    if fIsControl then
       Style := fStyle and not WS_CAPTION or WS_DLGFRAME
    else
       Style := fStyle and not (WS_CAPTION or WS_SYSMENU) or WS_POPUP;
    ExStyle := fExStyle or WS_EX_DLGMODALFRAME;
  end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.GetCanResize]
function TControl.GetCanResize: Boolean;
asm
        MOV      AL, [EAX].fPreventResize
        {$IFDEF PARANOIA}
        DB $34,$01
        {$ELSE}
        XOR      AL, 1
        {$ENDIF}
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.GetCanResize: Boolean;
begin
  //UpdateWndStyles;
  //Result := LongBool( fStyle and WS_THICKFRAME);
  Result := not fPreventResize;
end;
{$ENDIF ASM_VERSION}

//[function WndProcCanResize]
function WndProcCanResize( Sender: PControl; var M: TMsg; var Rslt: Integer ): Boolean;
var W, H: Integer;
    P: PMinMaxInfo;
begin
  if not Sender.CanResize then
  if M.message = WM_GETMINMAXINFO then
  begin
    Rslt := Sender.CallDefWndProc( M );
    W := Sender.FFixWidth;
    H := Sender.FFixHeight;
    P := Pointer( M.lParam );
    P.ptMinTrackSize.x := W;
    P.ptMinTrackSize.y := H;
    P.ptMaxTrackSize := P.ptMinTrackSize;
    Result := True; // stop further processing (prevent resizing)
    Exit;
  end
    else
  if M.message = WM_NCHITTEST then
  begin
    Rslt := Sender.CallDefWndProc( M );
    if (Rslt >= 10) and (Rslt <= 17) then
    begin
      Rslt := 18{HTBORDER};
      Result := True;
      exit;
    end;
  end;
  Result := False; // continue message processing
end;

{$IFDEF ASM_VERSION}
//[procedure TControl.SetCanResize]
procedure TControl.SetCanResize( const Value: Boolean );
asm
        PUSH     EBX
        MOV      EBX, EAX

            CALL     GetCanResize
        CMP      AL, DL

        JZ       @@exit   // Value = CanResize
        MOV      [EBX].fPreventResize, AL
        TEST     DL, DL

        MOV      EDX, [EBX].fStyle
        JZ       @@set_thick

        AND      EDX, not WS_THICKFRAME
        JMP      @@set_style

@@set_thick:
        OR       EDX, WS_THICKFRAME

@@set_style:
        MOV      EAX, EBX
        CALL     SetStyle

        MOV      EAX, EBX
        CALL     GetWindowHandle

        MOV      EAX, EBX
        CALL     GetWidth
        MOV      [EBX].FFixWidth, EAX

        MOV      EAX, EBX
        CALL     GetHeight
        MOV      [EBX].FFixHeight, EAX

        XCHG     EAX, EBX
        MOV      EDX, offset[WndProcCanResize]
        CALL     TControl.AttachProc
@@exit:
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.SetCanResize( const Value: Boolean );
begin
  if Value = CanResize then Exit;
  fPreventResize := not Value;
  if Value then
    Style := Style and not WS_THICKFRAME
  else
    Style := Style or WS_THICKFRAME;
  GetWindowHandle;
  FFixWidth := Width;
  FFixHeight := Height;
  AttachProc( WndProcCanResize );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.GetStayOnTop]
function TControl.GetStayOnTop: Boolean;
asm
        CALL     UpdateWndStyles
        TEST     byte ptr [EAX].fExStyle, WS_EX_TOPMOST
        SETNZ    AL
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.GetStayOnTop: Boolean;
begin
  UpdateWndStyles;
  Result := LongBool( fExStyle and WS_EX_TOPMOST);
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TControl.SetStayOnTop]
procedure TControl.SetStayOnTop(const Value: Boolean);
asm
        PUSH     EAX
          PUSH     EDX

            CALL     GetStayOnTop
          POP      ECX
          MOVZX    ECX, CL
          CMP      AL, CL

        POP      EAX
        JZ       @@exit   // Value = StayOnTop

        MOV      EDX, [EAX].fHandle
        TEST     EDX, EDX
        JZ       @@1

        PUSH     SWP_NOMOVE or SWP_NOSIZE or SWP_NOACTIVATE
        XOR      EAX, EAX
        PUSH     EAX
        PUSH     EAX
        PUSH     EAX
        PUSH     EAX
        DEC      ECX
        DEC      ECX
        PUSH     ECX

        PUSH     EDX
        CALL     SetWindowPos
        RET

@@1:
        JECXZ    @@1and

        OR       byte ptr [EAX].fExStyle, WS_EX_TOPMOST
        RET

@@1and: AND      byte ptr [EAX].fExStyle, not WS_EX_TOPMOST

@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.SetStayOnTop(const Value: Boolean);
begin
  if Value = GetStayOnTop then Exit;
  if fHandle <> 0 then
  if Value then
     SetWindowPos( fHandle, HWND_TOPMOST, 0,0,0,0,
                   SWP_NOMOVE or SWP_NOSIZE or SWP_NOACTIVATE )
  else
     SetWindowPos( fHandle, HWND_NOTOPMOST, 0,0,0,0,
                   SWP_NOMOVE or SWP_NOSIZE or SWP_NOACTIVATE )
           else
  if Value then fExStyle := fExStyle or WS_EX_TOPMOST
           else fExStyle := fExStyle and not WS_EX_TOPMOST;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.UpdateWndStyles]
function TControl.UpdateWndStyles: PControl;
asm
        MOV      ECX, [EAX].fHandle
        JECXZ    @@exit

        PUSH     EBX

        XCHG     EBX, EAX
          PUSH     GCL_STYLE
          PUSH     ECX

          PUSH     GWL_EXSTYLE
          PUSH     ECX

          PUSH     GWL_STYLE
          PUSH     ECX

          CALL     GetWindowLong
          MOV      [EBX].fStyle, EAX

          CALL     GetWindowLong
          MOV      [EBX].fExStyle, EAX

          CALL     GetClassLong
          MOV      [EBX].fClsStyle, EAX
        XCHG     EAX, EBX
        POP      EBX
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.UpdateWndStyles: PControl;
begin
  Result := Self;
  if fHandle = 0 then Exit;
  fStyle := GetWindowLong( fHandle, GWL_STYLE );
  fExStyle := GetWindowLong( fHandle, GWL_EXSTYLE );
  fClsStyle := GetClassLong( fHandle, GCL_STYLE );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.GetChecked]
function TControl.GetChecked: Boolean;
asm
        TEST     [EAX].fBitBtnOptions, 8 //1 shl Ord(bboFixed)
        JZ       @@1
        MOV      AL, [EAX].fChecked
        RET
@@1:
        PUSH     0
        PUSH     0
        PUSH     BM_GETCHECK
        PUSH     EAX
        CALL     Perform
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.GetChecked: Boolean;
begin
  if bboFixed in fBitBtnOptions then
    Result := fChecked
  else
    Result := LongBool( Perform( BM_GETCHECK, 0, 0 ) ) ; //= BST_CHECKED;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TControl.Set_Checked]
procedure TControl.Set_Checked(const Value: Boolean);
asm
        TEST     [EAX].fBitBtnOptions, 8 //1 shl Ord(bboFixed)
        JZ       @@1
        MOV      [EAX].fChecked, DL
        JMP      Invalidate
@@1:
        PUSH     0
        MOVZX    EDX, DL
        PUSH     EDX
        PUSH     BM_SETCHECK
        PUSH     EAX
        Call     Perform
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.Set_Checked(const Value: Boolean);
begin
  if bboFixed in fBitBtnOptions then
  begin
    fChecked := //not fChecked;
                Value;
    Invalidate;
  end
  else
    Perform( BM_SETCHECK, Integer( Value ), 0 );
end;
{$ENDIF ASM_VERSION}

//[function TControl.SetChecked]
function TControl.SetChecked(const Value: Boolean): PControl;
begin
  Perform( BM_SETCHECK, Integer( Value ), 0 );
  Result := Self;
end;

{$IFDEF ASM_VERSION}
//[function TControl.SetRadioCheckedOld]
function TControl.SetRadioCheckedOld: PControl;
asm
        PUSH     EAX
        MOV      ECX, [EAX].fParent
        JECXZ    @@exit

        PUSH     [EAX].fMenu
        PUSH     [ECX].fRadioLast
        PUSH     [ECX].fRadio1st
        MOV      EAX, ECX
        CALL     GetWindowHandle
        PUSH     EAX
        CALL     CheckRadioButton
@@exit:
        POP      EAX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.SetRadioCheckedOld: PControl;
begin
  Result := Self;
  if fParent = nil then Exit;
  CheckRadioButton( fParent.GetWindowHandle,
                    fParent.fRadio1st,
                    fParent.fRadioLast,
                    fMenu );
end;
{$ENDIF ASM_VERSION}

//*
//[function TControl.SetRadioChecked]
function TControl.SetRadioChecked: PControl;
begin
  Click;
  Result := Self;
end;

//*
//[procedure TControl.Click]
procedure TControl.Click;
begin
  if (fCommandActions.aClick <> 0) or
     (fCommandActions.aEnter = BN_SETFOCUS) then
    Perform( WM_COMMAND, (fCommandActions.aClick shl 16) or fMenu,
             GetWindowHandle )
  else
  begin
    Perform( WM_LBUTTONDOWN, MK_LBUTTON, 0 );
    Perform( WM_LBUTTONUP, MK_LBUTTON, 0 );
  end;
end;

{$IFDEF ASM_VERSION}
//[function TControl.GetSelStart]
function TControl.GetSelStart: Integer;
asm
         MOVZX    ECX, [EAX].fCommandActions.aGetSelRange
         JECXZ    @@1

         XOR      EDX, EDX
         PUSH     EDX
         PUSH     EDX
         PUSH     ECX
         PUSH     EAX
         CALL     Perform
         CWDE
         RET

@@1:
         MOVZX    ECX, [EAX].fCommandActions.aExGetSelRange
         JECXZ    @@exit
         XCHG     EAX, ECX
         CDQ
         PUSH     EDX
         PUSH     EDX
         PUSH     ESP
         PUSH     EDX
         PUSH     EAX
         PUSH     ECX
         CALL     Perform
         POP      ECX
         POP      EDX

@@exit:
         XCHG     EAX, ECX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.GetSelStart: Integer;
var SR: TCharRange;
begin
  Result := 0;
  if fCommandActions.aGetSelRange <> 0 then
    Result := LoWord( Perform( fCommandActions.aGetSelRange, 0, 0 ) )
  else
  if fCommandActions.aExGetSelRange <> 0 then
  begin
    Perform( fCommandActions.aExGetSelRange, 0, Integer( @SR ) );
    Result := SR.cpMin;
  end;
end;
{$ENDIF ASM_VERSION}

//[procedure TControl.SetSelStart]
procedure TControl.SetSelStart(const Value: Integer);
begin
  ItemSelected[ Value ] := True;
end;

{$IFDEF ASM_VERSION}
//[function TControl.GetSelLength]
function TControl.GetSelLength: Integer;
asm
        XOR       EDX, EDX
        MOVZX     ECX, word ptr[EAX].fCommandActions.aGetSelCount
        JECXZ     @@check_ex

        PUSH      ECX
        AND       CH, $7F
        PUSH      EDX
        PUSH      EDX
        PUSH      ECX
        PUSH      EAX
        CALL      Perform
        POP       ECX
        SHL       CH, 1
        JC        @@fin_EAX

        CMP       EAX, 32768
        JL        @@2

        PUSH      EAX
        POP       DX
        POP       AX
        SUB       AX, DX
        MOVZX     EAX, AX
@@fin_EAX:
        RET

@@check_ex:
        MOVZX     ECX, [EAX].fCommandActions.aExGetSelRange
        JECXZ     @@ret_0
        PUSH      EDX
        PUSH      EDX
        PUSH      ESP
        PUSH      EDX
        PUSH      ECX
        PUSH      EAX
        CALL      Perform
        POP       EDX
        POP       EAX
        SUB       EAX, EDX
        RET

@@ret_0:
        XOR       EAX, EAX
        //RET

@@2:    TEST      EAX, EAX
        JL        @@ret_0
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.GetSelLength: Integer;
var SR: TCharRange;
begin
  Result := 0;
  if fCommandActions.aGetSelCount <> 0 then
  begin
    Result := Perform( fCommandActions.aGetSelCount and $7FFF, 0, 0 );
    if (fCommandActions.aGetSelCount and $8000) = 0 then
      if Result >= 32768 then
        Result := HiWord( Result ) - LoWord( Result )
      else
      if Result < 0 then
        Result := 0;
  end
     else
  if fCommandActions.aExGetSelRange <> 0 then
  begin
    Perform( fCommandActions.aExGetSelRange, 0, Integer( @SR ) );
    Result := SR.cpMax - SR.cpMin;
  end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TControl.SetSelLength]
procedure TControl.SetSelLength(const Value: Integer);
asm
        PUSH     EBP
        MOV      EBP, ESP
        PUSH     EAX
        PUSH     EDX
        CALL     GetSelStart
        POP      ECX
        POP      EDX
        ADD      ECX, EAX
        PUSH     ECX
        MOVZX    ECX, [EDX].fCommandActions.aSetSelRange
        JECXZ    @@check_ex
        PUSH     EAX
        JMP      @@perform

@@check_ex:
        MOVZX    ECX, [EDX].fCommandActions.aExSetSelRange
        JECXZ    @@exit
        PUSH     EAX
        PUSH     ESP
        PUSH     0
@@perform:
        PUSH     ECX
        PUSH     EDX
        CALL     Perform
@@exit: MOV      ESP, EBP
        POP      EBP
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.SetSelLength(const Value: Integer);
var
    SR: TCharRange;
begin
  SR.cpMin := GetSelStart;
  SR.cpMax := SR.cpMin + Value;
  if Value < 0 then
    SR.cpMax := -1;
  if fCommandActions.aSetSelRange <> 0 then
     Perform( fCommandActions.aSetSelRange, SR.cpMin, SR.cpMax )
  else
  if fCommandActions.aExSetSelRange <> 0 then
     Perform( fCommandActions.aExSetSelRange, 0, Integer( @SR ) );
  // Preform( EM_SCROLLCARET, 0, 0 );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.GetItems]
function TControl.GetItems(Idx: Integer): String;
asm
        PUSH     ESI
        PUSH     EDI
        PUSH     EBX
        PUSH     EBP
        MOV      EBP, ESP

        MOV      EBX, EAX       // Self
        MOV      ESI, EDX       // Idx
        MOV      EDI, ECX       // @Result

        CALL     Item2Pos
        PUSH     0              // push  0
        PUSH     EAX            // store Pos

        XCHG     EDX, EAX
        MOV      EAX, EBX
        CALL     Pos2Item       // EAX = Idx'
        XCHG     ESI, EAX       // ESI = Idx'

        XOR      EAX, EAX
        MOVZX    ECX, [EBX].fCommandActions.aGetItemLength
        JECXZ    @@ret_empty

        PUSH     ECX            // push aGetItemLength

        PUSH     EBX
        CALL     Perform

        TEST     EAX, EAX
        JZ       @@ret_empty

        PUSH     EAX              // save L
        ADD      EAX, 4

        CALL     System.@GetMem   // GetMem( L+4 )
        POP      EDX              // restore L
        MOV      byte ptr [EAX], 0
        MOVZX    ECX, [EBX].fCommandActions.aGetItemText
        JECXZ    @@ret_buf

        PUSH     EDX              // save L
        MOV      word ptr [EAX], DX

        PUSH     EAX
          PUSH     EAX            // push Buf
          PUSH     ESI            // push Idx

          PUSH     ECX            // push aGetItemText
          PUSH     EBX
          CALL     Perform
        POP      EAX

        POP      EDX
@@ret_buf:
        MOV      byte ptr [EAX + EDX], 0   // Buf[ L ] := #0

@@ret_empty:     // EAX = 0
        XCHG     EDX, EAX
        MOV      EAX, EDI
        PUSH     EDX
        CALL     System.@LStrFromPChar
        POP      ECX
        JECXZ    @@exit
        XCHG     EAX, ECX
        CALL     System.@FreeMem

@@exit:
        MOV      ESP, EBP
        POP      EBP
        POP      EBX
        POP      EDI
        POP      ESI
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.GetItems(Idx: Integer): String;
var L, Pos: Integer;
    Buf: PChar;
begin
  Result := '';
  Pos := Item2Pos( Idx );
  Idx := Pos2Item( Pos );
  if fCommandActions.aGetItemLength <> 0 then
    L := Perform( fCommandActions.aGetItemLength, Pos, 0 )
  else
    Exit;
  if L = 0 then Exit;
  GetMem( Buf, L + 4 );
  PWORD( Buf )^ := L + 1;
  if fCommandActions.aGetItemText <> 0 then
    Perform( fCommandActions.aGetItemText, Idx, Integer( Buf ) );
  Buf[ L ] := #0;
  Result := Buf;
  FreeMem( Buf );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TControl.SetItems]
procedure TControl.SetItems(Idx: Integer; const Value: String);
asm
        PUSH     EDI
        PUSH     EBX
        XCHG     EBX, EAX
        XCHG     EDI, EDX       // EDI = Idx
        CALL     ECX2PChar
        PUSH     ECX       // @Value[1]

        MOVZX    ECX, [EBX].fCommandActions.aSetItemText
        JECXZ    @@1

        PUSH     0
        PUSH     ECX

        MOV      EDX, EDI
        MOV      EAX, EBX
        CALL     Item2Pos
        PUSH     EAX            // store Strt

        MOV      EDX, EDI
        INC      EDX
        MOV      EAX, EBX
        CALL     Item2Pos
        POP      EDX            // EDX = Strt

        SUB      EAX, EDX
        PUSH     EAX            // store L

        MOV      EAX, EBX
        CALL     SetSelStart

        POP      EDX            // EDX = L
        PUSH     EBX            // prepare Self for Perform
        XCHG     EAX, EBX
        CALL     SetSelLength

        // @Value[1] already in stack,
        // 0 already in stack
        // aSetItemText already in stack
        // Self already in stack

        CALL     Perform
        JMP      @@exit

@@1:    // @Value[1] in stack already
        POP      EDX
        MOVZX    ECX, [EBX].fCommandActions.aDeleteItem
        JECXZ    @@exit

        {$IFNDEF  NOT_FIX_CURINDEX}
        PUSH     ESI
        PUSH     EBP

        PUSH     EDX

        MOV      EAX, EBX               // +AK
        CALL     GetCurIndex            // +AK
        XCHG     ESI, EAX    // ESI = TmpCurIdx

        MOV      EAX, EBX
        MOV      EDX, EDI
        CALL     GetItemData
        XCHG     EBP, EAX   // EBP = TmpData

        MOV      EDX, EDI
        MOV      EAX, EBX
        CALL     Delete

        MOV      EAX, EBX               // *AK
        MOV      EDX, EDI
        POP      ECX
        CALL     Insert

        MOV      ECX, EBP // ECX = TmpData
        MOV      EDX, EDI
        MOV      EAX, EBX
        CALL     SetItemData

        XCHG     EAX, EBX               // +AK
        MOV      EDX, ESI               // +AK
        CALL     SetCurIndex            // +AK

        POP      EBP
        POP      ESI
        {$ELSE NOT_FIX_CURINDEX}
        PUSH     EDX

        MOV      EDX, EDI
        MOV      EAX, EBX
        CALL     Delete

        XCHG     EAX, EBX
        XCHG     EDX, EDI

        POP      ECX
        CALL     Insert
        {$ENDIF NOT_FIX_CURINDEX}

@@exit:
        POP      EBX
        POP      EDI
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.SetItems(Idx: Integer; const Value: String);
var Strt, L : Integer;
    {$IFNDEF NOT_FIX_CURINDEX}
    TmpCurIdx: Integer; // AK - Andrzey Kubasek
    TmpData: DWORD;
    {$ENDIF NOT_FIX_CURINDEX}
begin
  if fCommandActions.aSetItemText <> 0 then
  begin
    Strt := Item2Pos( Idx );
    L := Item2Pos( Idx + 1 ) - Strt;
    SelStart := Strt;
    SelLength := L;
    Perform( fCommandActions.aSetItemText, 0, Integer( PChar( Value ) ) );
  end
     else
  if fCommandActions.aDeleteItem <> 0 then
  begin
    {$IFNDEF NOT_FIX_CURINDEX}
    TmpCurIdx := CurIndex; // +AK
    TmpData := ItemData[ Idx ];
    {$ENDIF}
    Delete( Idx );
    Insert( Idx, Value );
    {$IFNDEF NOT_FIX_CURINDEX}
    CurIndex := TmpCurIdx; //+AK
    ItemData[ Idx ] := TmpData;
    {$ENDIF}
  end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.GetItemsCount]
function TControl.GetItemsCount: Integer;
asm
        PUSH     0
        MOVZX    ECX, [EAX].fCommandActions.aGetCount
        JECXZ    @@ret_0
        PUSH     0
        PUSH     ECX
        PUSH     EAX
        CALL     Perform
        PUSH     EAX

@@ret_0:
        POP      EAX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.GetItemsCount: Integer;
begin
  Result := 0;
  {$IFDEF DEBUG}
  try
  {$ENDIF}
  if fCommandActions.aGetCount = 0 then Exit;
  Result := Perform( fCommandActions.aGetCount, 0, 0 );
  {$IFDEF DEBUG}
  except
    asm
      int 3
    end;
  end;
  {$ENDIF}
end;
{$ENDIF ASM_VERSION}

//*
//[procedure TControl.SetItemsCount]
procedure TControl.SetItemsCount(const Value: Integer);
begin
  if fCommandActions.aSetCount = 0 then Exit;
  Perform( fCommandActions.aSetCount, Value, 0 );
end;

//[PROCEDURE HelpConvertItem2Pos]
{$IFDEF ASM_VERSION}
procedure HelpConvertItem2Pos;
asm
        JECXZ     @@exit
        PUSH      0
        PUSH      EDX
        PUSH      ECX
        PUSH      EAX
        CALL      TControl.Perform
        TEST      EAX, EAX
        XOR       EDX, EDX
        JL        @@exit
        RET

@@exit:
        MOV       EAX, EDX

end;
{$ENDIF ASM_VERSION}
//[END HelpConvertItem2Pos]

{$IFDEF ASM_VERSION}
//[function TControl.Item2Pos]
function TControl.Item2Pos(ItemIdx: Integer): Integer;
asm
        MOVZX     ECX, [EAX].fCommandActions.aItem2Pos
        JMP       HelpConvertItem2Pos
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.Item2Pos(ItemIdx: Integer): Integer;
begin
  Result := ItemIdx;
  if fCommandActions.aItem2Pos <> 0 then
  begin
    Result := Perform( fCommandActions.aItem2Pos, ItemIdx, 0 );
    if Result < 0 then Result := 0;
  end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.Pos2Item]
function TControl.Pos2Item(Pos: Integer): Integer;
asm
        MOVZX     ECX, [EAX].fCommandActions.aPos2Item
        JMP       HelpConvertItem2Pos
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.Pos2Item(Pos: Integer): Integer;
begin
  Result := Pos;
  if fCommandActions.aPos2Item <> 0 then
  Result := Perform( fCommandActions.aPos2Item, Pos, 0 );
end;
{$ENDIF ASM_VERSION}

//[function WndProcTabChar]
function WndProcTabChar( Sender: PControl; var M: TMsg; var Rslt: Integer ): Boolean;
begin
  if M.message = WM_CHAR then
  begin
    if M.wParam = 9 then
    begin
      //M.wParam := 0;
      Sender.ReplaceSelection( #9, TRUE );
    end;
  end;
  Result := FALSE;
end;

//[function TControl.EditTabChar]
function TControl.EditTabChar: PControl;
begin
  AttachProc( WndProcTabChar );
  Result := Self;
end;

{$IFDEF ASM_VERSION}
//[function TControl.Add]
function TControl.Add(const S: String): Integer;
asm
        PUSH     EBX
        MOV      EBX, EAX               // EBX = Self

        MOVZX    ECX, [EBX].fCommandActions.aAddItem   // ECX = aAddItem
        JECXZ    @@chk_addtext

        CALL     EDX2PChar
        PUSH     EDX
        PUSH     0
        PUSH     ECX
        PUSH     EBX
        CALL     Perform
        PUSH     EAX

        MOV      EAX, EBX
        CALL     TControl.GetItemsCount
        XCHG     EAX, ECX
        LOOP     @@ret_EAX

        XCHG     EAX, EBX
        INC      ECX
        XOR      EDX, EDX
        CALL     TControl.SetItemSelected
@@ret_EAX:
        POP      EAX
        JMP      @@exit

@@chk_addtext:
        MOV      ECX, [EBX].fCommandActions.aAddText
        JECXZ    @@add_text_simple

        CALL     ECX
        JMP      @@exit_0

@@add_text_simple:
        PUSH     EDX
        PUSH     0
        MOV      EDX, ESP
        CALL     GetCaption
        POP      EAX
        POP      EDX
        PUSH     EAX
        MOV      EAX, ESP
        CALL     System.@LStrCat
        MOV      EAX, EBX
        POP      EDX
        PUSH     EDX
        CALL     SetCaption
        CALL     RemoveStr
@@exit_0:
        XOR      EAX, EAX
@@exit:
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.Add(const S: String): Integer;
begin
  if fCommandActions.aAddItem <> 0 then
  begin
    Result := Perform( fCommandActions.aAddItem, 0, Integer( PChar( S ) ) );
    if Count = 1 then
      ItemSelected[ 0 ] := True;
  end
    else
  begin
    if assigned( fCommandActions.aAddText ) then
      fCommandActions.aAddText( Self, S )
    else
      Text := Text + S;
    Result := 0;
  end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TControl.Delete]
procedure TControl.Delete(Idx: Integer);
asm
        MOVZX    ECX, [EAX].fCommandActions.aDeleteItem
        JECXZ    @@exit

        PUSH     0
        PUSH     EDX
        PUSH     ECX
        PUSH     EAX
        CALL     Perform
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.Delete(Idx: Integer);
begin
  if fCommandActions.aDeleteItem <> 0 then
    Perform( fCommandActions.aDeleteItem, Idx, 0 );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.Insert]
function TControl.Insert(Idx: Integer; const S: String): Integer;
asm
         CALL    ECX2PChar
         PUSH    ECX
         MOVZX   ECX, [EAX].fCommandActions.aInsertItem
         JECXZ   @@exit_1

         PUSH    EDX
         PUSH    ECX
         PUSH    EAX
         CALL    Perform
         RET

@@exit_1:OR      EAX, -1
         POP     ECX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.Insert(Idx: Integer; const S: String): Integer;
begin
  if fCommandActions.aInsertItem <> 0 then
    Result := Perform( fCommandActions.aInsertItem, Idx, Integer( PChar( S ) ) )
  else
    Result := -1;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.GetItemSelected]
function TControl.GetItemSelected(ItemIdx: Integer): Boolean;
asm
        MOVZX    ECX, [EAX].fCommandActions.aGetSelected
        JECXZ    @@check_range

        PUSH     0
        PUSH     EDX
        PUSH     ECX
        PUSH     EAX
        CALL     Perform
        TEST     EAX, EAX
        SETG     AL
        RET

@@check_range:
        MOVZX    ECX, [EAX].fCommandActions.aGetSelRange
        JECXZ    @@check_ex

          PUSH     EDX
        PUSH     0
        PUSH     0
        PUSH     ECX
        PUSH     EAX
        CALL     Perform
          POP      EDX
        TEST     EAX, EAX
        JL       @@ret_false

        CMP      DX, AX
        JL       @@ret_false

        SHR      EAX, 16
        SUB      EDX, EAX
        SETL     AL
        RET

@@check_ex:
        MOVZX    ECX, [EAX].fCommandActions.aExGetSelRange
        JECXZ    @@ret_false
          PUSH     EDX
        PUSH     EDX
        PUSH     EDX
        PUSH     ESP
        PUSH     0
        PUSH     ECX
        PUSH     EAX
        CALL     Perform
        POP      ECX
        POP      EDX
          POP      EAX

        SUB      EAX, EDX
        CMP      EAX, ECX
        SETB     AL
        RET

@@ret_false:
        XOR      EAX, EAX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.GetItemSelected(ItemIdx: Integer): Boolean;
var SR: TCharRange;
begin
  Result := False;
  if fCommandActions.aGetSelected <> 0 then
    Result := 0 < Perform( fCommandActions.aGetSelected, ItemIdx, 0 )
  else if fCommandActions.aGetSelRange <> 0 then
  begin
    Perform( fCommandActions.aGetSelRange, Integer( @SR.cpMin ), Integer( @SR.cpMax ) );
    Result := (SR.cpMin <= ItemIdx) and (ItemIdx < SR.cpMax);
  end
  else if fCommandActions.aExGetSelRange <> 0 then
  begin
    Perform( fCommandActions.aExGetSelRange, 0, Integer( @SR ) );
    Result := (SR.cpMin <= ItemIdx) and (ItemIdx < SR.cpMax);
  end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TControl.SetItemSelected]
procedure TControl.SetItemSelected(ItemIdx: Integer; const Value: Boolean);
asm
        PUSH     EDX
        PUSH     ECX
        MOVZX    ECX, [EAX].fCommandActions.aSetSelected
        JECXZ    @@chk_aSetCurrent

@@0:
        PUSH     ECX
        PUSH     EAX
        CALL     Perform
        RET

@@chk_aSetCurrent:
        POP      ECX
        MOVZX    ECX, [EAX].fCommandActions.aSetCurrent
        JECXZ    @@chk_aSetSelRange

        POP      EDX
        PUSH     0
        JMP      @@3

@@chk_aSetSelRange:
        MOVZX    ECX, [EAX].fCommandActions.aSetSelRange
        JECXZ    @@chk_aExSetSelRange
@@3:
        PUSH     EDX
        JMP      @@0

@@else: MOV      [EAX].FCurIndex, EDX
        CALL     Invalidate
        JMP      @@exit

@@chk_aExSetSelRange:
        MOVZX    ECX, [EAX].fCommandActions.aExSetSelRange
        JECXZ    @@else

        PUSH     EDX
        PUSH     ESP
        PUSH     0
        PUSH     ECX
        PUSH     EAX
        CALL     Perform
        POP      ECX

@@exit:
        POP      ECX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.SetItemSelected(ItemIdx: Integer; const Value: Boolean);
var SR: TCharRange;
begin
  if fCommandActions.aSetSelected <> 0 then
    Perform( fCommandActions.aSetSelected, Integer( Value ), ItemIdx )
  else
  if fCommandActions.aSetCurrent <> 0 then
    Perform( fCommandActions.aSetCurrent, ItemIdx, 0 )
  else
  if fCommandActions.aSetSelRange <> 0 then
    Perform( fCommandActions.aSetSelRange, ItemIdx, ItemIdx )
  else
  if fCommandActions.aExSetSelRange <> 0 then
  begin
    SR.cpMin := ItemIdx;
    SR.cpMax := ItemIdx;
    Perform( fCommandActions.aExSetSelRange, 0, Integer( @SR ) );
  end
    else
  begin // for ImageShow: set the index and invalidate the control
    FCurIndex := ItemIdx;
    Invalidate;
  end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TControl.SetCtl3D]
procedure TControl.SetCtl3D(const Value: Boolean);
asm
        MOV      [EAX].fCtl3Dchild, DL
        CMP      [EAX].fCtl3D, DL
        JE       @@exit
        MOV      [EAX].fCtl3D, DL
        PUSHAD
        CALL     UpdateWndStyles
        POPAD
        MOV      ECX, [EAX].fExStyle
        DEC      DL
        MOV      EDX, [EAX].fStyle
        JNZ      @@1
        AND      EDX, not WS_BORDER
        OR       CH, WS_EX_CLIENTEDGE shr 8
        JMP      @@2
@@1:
        OR       EDX, WS_BORDER
        AND      CH, not(WS_EX_CLIENTEDGE shr 8)
@@2:
        PUSH     ECX
        PUSH     EAX
        CALL     SetStyle
        POP      EAX
        POP      EDX
        JMP      SetExStyle
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.SetCtl3D(const Value: Boolean);
begin
  fCtl3Dchild := Value;
  if fCtl3D = Value then Exit;
  fCtl3D := Value;
  UpdateWndStyles;
  if Value then
  begin
    ExStyle := fExStyle or WS_EX_CLIENTEDGE;
    Style := fStyle and not WS_BORDER;
  end
     else
  begin
    ExStyle := fExStyle and not WS_EX_CLIENTEDGE;
    Style := fStyle or WS_BORDER;
  end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.Shift]
function TControl.Shift(dX, dY: Integer): PControl;
asm
        PUSHAD
        ADD      EDX, [EAX].fBoundsRect.TRect.Left
        CALL     SetLeft
        POPAD
        PUSH     EAX
        MOV      EDX, [EAX].fBoundsRect.TRect.Top
        ADD      EDX, ECX
        CALL     SetTop
        POP      EAX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.Shift(dX, dY: Integer): PControl;
begin
  Left := fBoundsRect.Left + dX;
  Top := fBoundsRect.Top + dY;
  Result := Self;
end;
{$ENDIF ASM_VERSION}

//[procedure SetKeyEvent]
procedure SetKeyEvent( Self_: PControl );
begin
  Self_.fWndProcKeybd := WndProcKeybd;
  //Self_.AttachProc( WndProcKeyBd );
end;

//[procedure TControl.SetOnChar]
procedure TControl.SetOnChar(const Value: TOnChar);
begin
  fOnChar := Value;
  SetKeyEvent( Self );
end;

//[procedure TControl.SetOnKeyDown]
procedure TControl.SetOnKeyDown(const Value: TOnKey);
begin
  fOnKeyDown := Value;
  SetKeyEvent( Self );
end;

//[procedure TControl.SetOnKeyUp]
procedure TControl.SetOnKeyUp(const Value: TOnKey);
begin
  fOnKeyUp := Value;
  SetKeyEvent( Self );
end;

//[FUNCTION CollectTabControls]
{$IFDEF ASM_VERSION}
function CollectTabControls( Form: PControl ): PList;
asm
        PUSH     EDI
        PUSH     EAX
        CALL     NewList
        XCHG     EDI, EAX
        POP      EAX
        CALL     @@collecttab
        XCHG     EAX, EDI
        POP      EDI
        RET
@@collecttab:
        { <- EDI = Result:PList
             EAX = Form (or Control)
        }
        PUSH     ESI
        PUSH     EBX
        MOV      EDX, [EAX].TControl.fChildren
        MOV      ECX, [EDX].TList.fCount
        MOV      ESI, [EDX].TList.fItems
        JECXZ    @@e_loop
@@loo:  PUSH     ECX
        LODSD

          PUSH     EAX

        TEST     byte ptr [EAX].TControl.fStyle+2, WS_TABSTOP shr 16
        JZ       @@call_recur

        MOV      DL, [EAX].TControl.fTabStop
        AND      DL, [EAX].TControl.fEnabled
        JZ       @@call_recur

        CALL     TControl.GetToBeVisible
        TEST     AL, AL
        POP      EAX
        JZ       @@next
        PUSH     EAX

          XCHG     EDX, EAX
          PUSH     ESI
          MOV      ECX, [EDI].TList.fCount
          MOV      ESI, [EDI].TList.fItems
          XOR      EBX, EBX
          JECXZ    @@e_loo2
@@loo2:   LODSD
          MOV      EAX, [EAX].TControl.fTabOrder
          CMP      EAX, [EDX].TControl.fTabOrder
          JLE      @@next2
          POP      ESI
          MOV      ECX, EDX
          MOV      EDX, EBX
          MOV      EAX, EDI
          CALL     TList.Insert
          JMP      @@call_recur

@@next2:  INC      EBX
          LOOP     @@loo2
@@e_loo2:
          POP      ESI
          MOV      EAX, EDI
          CALL     TList.Add

@@call_recur:
          POP      EAX
          MOVZX    ECX, [EAX].TControl.fEnabled
          JECXZ    @@next
          CALL     @@collecttab

@@next: POP      ECX
        LOOP     @@loo

@@e_loop:
        POP      EBX
        POP      ESI
end;
{$ELSE ASM_VERSION} //Pascal
function CollectTabControls( Form: PControl ): PList;
var R: PList;
  procedure CollectTab( P: PControl );
  var I, J: Integer;
      C, D: PControl;
  begin
    for I := 0 to P.fChildren.fCount - 1 do
    begin
      C := P.fChildren.fItems[ I ];
      if C.fTabstop and C.fEnabled and C.ToBeVisible and
         (C.fStyle and WS_TABSTOP <> 0) then
      begin
        D := nil;
        for J := 0 to R.fCount - 1 do
        begin
          D := R.fItems[ J ];
          if D.fTabOrder > C.fTabOrder then
          begin
            R.Insert( J, C );
            break;
          end
             else
            D := nil;
        end;
        if D = nil then
           R.Add( C );
      end;
      if C.fEnabled then
        CollectTab( C );
    end;
  end;
begin
  R := NewList;
  CollectTab( Form );
  Result := R;
end;
{$ENDIF ASM_VERSION}
//[END CollectTabControls]

//[PROCEDURE Tabulate2Next]
{$IFDEF ASM_VERSION}
procedure Tabulate2Next( Form: PControl; Dir: Integer );
asm
        PUSHAD
        PUSH     EAX      // save Form
        MOV      EBX, EAX
        MOV      EBP, EDX // EBP = Dir (direction <0 or >0)
        CALL     CollectTabControls
        XCHG     EDI, EAX // EDI = CL (list of controls)

        MOV      ECX, [EBX].TControl.fCurrentControl // C := Form.fCurrentControl
        XOR      EBX, EBX // I = 0
        JECXZ    @@1
        MOV      EBX, [ECX].TControl.fTabOrder // I = C.fTabOrder
@@1:
        MOV      ECX, [EDI].TList.fCount
        MOV      ESI, [EDI].TList.fItems
        XOR      EDX, EDX
        PUSH     EDX      // Ctrl1 = nil
        PUSH     EDX      // Ctrl2 = nil
        //JECXZ    @@e_loop
        TEST     ECX, ECX
        JZ       @@e_loop

@@loop: PUSH     ECX
        LODSD
        CMP      [EAX].TControl.fTabOrder, EBX
        JZ       @@next

        MOV      ECX, [ESP+8] // ECX = Ctrl1
        JECXZ    @@c1nil
        MOV      ECX, [ECX].TControl.fTabOrder // ECX = Ctrl1.fTabOrder
        TEST     EBP, EBP
        JGE      @@c1ge

        CMP      [EAX].TControl.fTabOrder, EBX
        JGE      @@2
        CMP      [EAX].TControl.fTabOrder, ECX
        JLE      @@2

@@c1new:
        MOV      [ESP+8], EAX // Ctrl1 := C
        JMP      @@2

@@c1ge: CMP      [EAX].TControl.fTabOrder, EBX
        JLE      @@2
        CMP      [EAX].TControl.fTabOrder, ECX
        JL       @@c1new
        JMP      @@2

@@c1nil:
        TEST     EBP, EBP
        JL       @@c1nil_dirL
        CMP      [EAX].TControl.fTabOrder, EBX
        JG       @@c1new
        JMP      @@2

@@c1nil_dirL:
        CMP      [EAX].TControl.fTabOrder, EBX
        JL       @@c1new

@@2:
        MOV      ECX, [ESP+4] // ECX = Ctrl2
        JECXZ    @@c2new
        MOV      ECX, [ECX].TControl.fTabOrder

        TEST     EBP, EBP
        JL       @@c2dirL
        CMP      [EAX].TControl.fTabOrder, ECX
        JGE      @@next
        JMP      @@c2new

@@c2dirL:
        CMP      [EAX].TControl.fTabOrder, ECX
        JLE      @@next
@@c2new:
        MOV      [ESP+4], EAX

@@next: POP      ECX
        DEC      ECX
        JNZ      @@loop
        //LOOP     @@loop
@@e_loop:

        POP      EDX // Ctrl2
        POP      ECX // Ctrl1
        INC      ECX
        LOOP     @@3
        MOV      ECX, EDX
@@3:
        POP      EBX // EBX = Form
        JECXZ    @@exit

        XCHG     EAX, ECX
        MOV      ECX, [EAX].TControl.fHandle
        JECXZ    @@no_handle

        INC      [EAX].TControl.fClickDisabled
        PUSH     EAX
        PUSH     ECX
        CALL     Windows.SetFocus
        POP      EAX
        DEC      [EAX].TControl.fClickDisabled

@@no_handle:
        MOV      [EBX].TControl.fCurrentControl, EAX

@@exit:
        XCHG     EAX, EDI
        CALL     TObj.Free
        POPAD
end;
{$ELSE ASM_VERSION} //Pascal
procedure Tabulate2Next( Form: PControl; Dir: Integer );
var CL : PList;
    I, J : Integer;
    Ctrl1, Ctrl2, C : PControl;
begin
  CL := CollectTabControls( Form );

  I := 0;
  C := Form.fCurrentControl;
  if C <> nil then
    I := C.fTabOrder;
  Ctrl2 := nil;
  Ctrl1 := nil;
  for J := 0 to CL.fCount - 1 do
  begin
    C := CL.fItems[ J ];
    if C.fTabOrder = I then continue;
    if (Ctrl1 = nil)
       and (    (Dir >= 0) and (C.fTabOrder > I)
             or (Dir < 0) and (C.fTabOrder < I)  )
    or (Dir >= 0)
       and (C.fTabOrder > I) and (C.fTabOrder < Ctrl1.fTabOrder)
    or (Dir < 0)
       and (C.fTabOrder < I) and (C.fTabOrder > Ctrl1.fTabOrder)
    then Ctrl1 := C;
    if (Ctrl2 = nil)
    or (Dir >= 0) and (C.fTabOrder < Ctrl2.fTabOrder)
    or (Dir < 0) and (C.fTabOrder > Ctrl2.fTabOrder)
    then Ctrl2 := C;
  end;
  if Ctrl1 = nil then
    Ctrl1 := Ctrl2;
  if Ctrl1 <> nil then
  begin
    if Ctrl1.fHandle <> 0 then
    begin
      Inc( Ctrl1.fClickDisabled );
      SetFocus( Ctrl1.fHandle );
      Dec( Ctrl1.fClickDisabled );
    end;
    Form.fCurrentControl := Ctrl1;
  end;
  CL.Free;
end;
{$ENDIF ASM_VERSION}
//[END Tabulate2Next]

//[FUNCTION Tabulate2Control]
{$IFDEF ASM_VERSION}
function Tabulate2Control( Self_: PControl; Key: DWORD; checkOnly: Boolean ): Boolean;
const tk_Tab = 1;
      tk_LR  = 2;
      tk_UD  = 4;
      tk_PuPd= 8;
asm
        PUSH     ESI
        MOV      ESI, offset[@@data]
        PUSH     EAX
        MOV      AH, 9
@@loop:
        LODSB
        CMP      DL, AL
        JE       @@1
        LODSB
        CMP      DL, AL
        JE       @@2
        ADD      AH, AH
        JNB      @@loop
        POP      EAX
@@exit0:
        XOR      EAX, EAX
        JMP      @@exit

@@data:
        DB       -1, VK_TAB, VK_LEFT, VK_RIGHT, VK_UP, VK_DOWN, VK_PRIOR, VK_NEXT

@@1:
        OR       EDX, -1
        JMP      @@3
@@2:
        XOR      EDX, EDX
        TEST     AH, 1
        JZ       @@3

          PUSH     ECX
        PUSH     EAX
        PUSH     VK_SHIFT
        CALL     GetAsyncKeyState
        CDQ
        POP      EAX
          POP      ECX
@@3:
        POP      ESI
        //////////////////////////////////////////////////
        MOV      AL, AH
        {$IFDEF PARANOIA}
        DB $24, 1
        {$ELSE}
        AND      AL, 1
        {$ENDIF}
        TEST     byte ptr [ESI].TControl.fLookTabKeys, AL
        //////////////////////////////////////////////////
        JZ       @@exit0

        TEST     CL, CL
        JNZ      @@exit

        PUSH     EDX
        MOV      EAX, ESI
        CALL     TControl.ParentForm
        POP      EDX
        CALL     Tabulate2Next
@@exit:
        POP      ESI
end;
{$ELSE ASM_VERSION} //Pascal
function Tabulate2Control( Self_: PControl; Key: DWORD; checkOnly: Boolean ): Boolean;
var Form: PControl;
begin
  Result := False;
  case Key of
  VK_TAB: if not (tkTab in Self_.fLookTabKeys) then exit;
  VK_LEFT, VK_RIGHT: if not (tkLeftRight in Self_.fLookTabKeys) then exit;
  VK_UP, VK_DOWN: if not (tkUpDown in Self_.fLookTabKeys) then exit;
  VK_NEXT, VK_PRIOR: if not (tkPageUpPageDn in Self_.fLookTabKeys) then exit;
  else Exit;
  end;

  Result := True;
  if checkOnly then Exit;

  Form := Self_.ParentForm;
  case Key of
  VK_TAB:
    if GetKeyState( VK_SHIFT ) < 0 then
      Tabulate2Next( Form, -1 )
    else
      Tabulate2Next( Form, 1 );
  VK_RIGHT, VK_DOWN, VK_NEXT: Tabulate2Next( Form, 1 );
  VK_LEFT, VK_UP, VK_PRIOR:   Tabulate2Next( Form, -1 );
  end;
end;
{$ENDIF ASM_VERSION}
//[END Tabulate2Control]

//[FUNCTION Tabulate2ControlEx]
{$IFDEF ASM_VERSION}
function Tabulate2ControlEx( Self_: PControl; Key: DWORD; checkOnly: Boolean ): Boolean;
asm
        PUSH     EDI
        MOVZX    EDI, CL
        TEST     byte ptr [EAX].TControl.fLookTabKeys, 1
        JZ       @@1
@@0:
        MOV      ECX, EDX
        AND      CL, 7Fh
        CMP      CL, VK_TAB
        JNE      @@1

        PUSH     EDX
        CALL     TControl.ParentForm
        POP      EDX
        MOVSX    EDX, DL
        TEST     EDX, EDX
        JS       @@tab

        PUSH     EAX

        PUSH     VK_SHIFT
        CALL     GetAsyncKeyState
        SAR      EAX, 31
        {$IFDEF PARANOIA}
        DB $0C, $01
        {$ELSE}
        OR       AL, 1
        {$ENDIF}
        MOV      EDX, EAX

        POP      EAX
@@tab:
        TEST     EDI, EDI
        POP      EDI
        JNZ      @@no_tab
        CALL     Tabulate2Next
@@no_tab:
        MOV      AL, 1
        RET

@@data: DB VK_LEFT, VK_LEFT
        DD offset[@@left]
        DB VK_UP, 2
        DB VK_RIGHT, VK_RIGHT
        DD offset[@@right]
        DB VK_DOWN, 2
        DB VK_UP, VK_PRIOR
        DD offset[@@up]
        DB VK_TAB or 80h, $C
        DB VK_DOWN, VK_NEXT
        DD offset[@@down]
        DB VK_TAB, $C

@@1:
        {
          EAX <- Self_:PControl
           DL <- Key
        }
        PUSH     ESI
        MOV      ESI, offset[@@data]-6
        MOV      DH, 9
        PUSH     EAX
@@loop:
        ADD      DH, DH
        JNB      @@l1
        JMP      @@abort
@@fault1:
        POP      EDI
        POPAD
        PUSH     EAX
@@abort:
        POP      EAX
@@abort1:
        POP      ESI
        POP      EDI
        XOR      EAX, EAX
        RET

@@right:
        MOV      EAX, [ESP].TRect.Left
        SUB      EAX, [ESP+16].TRect.Left
@@left_right:
        JL       @@next1
        MOV      EDX, [ESP].TRect.Bottom
        SUB      EDX, [ESP+16].TRect.Top
        JL       @@next1
        MOV      EDX, [ESP].TRect.Top
        SUB      EDX, [ESP+16].TRect.Bottom
        JGE      @@next1
@@chk_dist:
        CMP      EAX, EDI
        JA       @@next1
        MOV      EDI, EAX
        MOV      EAX, [EBX+ECX*4-4]
        MOV      [ESP+36], EAX     // Found = Ctrl
        JMP      @@next1

@@l1:
        LODSD
        LODSW
        LODSW
        CMP      AL, DL
        JE       @@2
        CMP      AH, DL
        JNE      @@loop

@@2:
        PUSH     ESI
        LODSD
        LODSW
        POP      ESI
        XCHG     EDX, EAX
        POP      EAX
        TEST     [EAX].TControl.fLookTabKeys, DH
        JZ       @@abort1

        PUSHAD
        PUSH     EDI
        CALL     TControl.ParentForm
        MOV      ECX, [EAX].TControl.fCurrentControl
        JECXZ    @@fault1
        MOV      EBP, ECX           // EBP = CurCtrl

        PUSH     EAX                // save Form
        MOV      EBX, EAX
        CALL     CollectTabControls
        PUSH     0                  // save Found = nil
        PUSH     EAX                // save CollectedList
        MOV      EDI, EAX

        MOV      EBX, [EDI].TList.fItems
        ADD      ESP, -16
        PUSH     ESP
        PUSH     [EBP].TControl.fHandle
        CALL     GetWindowRect

        MOV      ECX, [EDI].TList.fCount
        OR       EDI, -1            // EDI = minDist
@@loop1:
        MOV      EAX, [EBX+ECX*4-4]
        CMP      EAX, EBP
        JE       @@next
        {}
        MOV      DL, [EAX].TControl.fEnabled
        AND      DL, [EAX].TControl.fTabstop
        JZ       @@next
        {}
        ADD      ESP, -16
        MOV      EDX, ESP
        PUSH     ECX

        //CALL     TControl.ControlRect
        PUSH     EDX
        PUSH     [EAX].TControl.fHandle
        CALL     GetWindowRect

        POP      ECX
        JMP      dword ptr [ESI]

@@left:
        MOV      EAX, [ESP+16].TRect.Left
        SUB      EAX, [ESP].TRect.Left
        JMP      @@left_right

@@not_found:
        POP      EDI
        POPAD
        MOV      DL, [ESI+4]
        POP      ESI
        JMP      @@0

@@up:
        MOV      EAX, [ESP+16].TRect.Top
        SUB      EAX, [ESP].TRect.Top
        JMP      @@up_down
@@down:
        MOV      EAX, [ESP].TRect.Top
        SUB      EAX, [ESP+16].TRect.Top
@@up_down:
        JL       @@next1
        MOV      EDX, [ESP].TRect.Right
        SUB      EDX, [ESP+16].TRect.Left
        JL       @@next1
        MOV      EDX, [ESP].TRect.Left
        SUB      EDX, [ESP+16].TRect.Right
        JL       @@chk_dist

@@next1:
        ADD      ESP, 16
@@next:
        LOOP     @@loop1
        ADD      ESP, 16
        POP      EAX       // pop CollectedList
        CALL     TObj.Free
        POP      ECX       // pop Found
        POP      EAX       // pop Form
        JECXZ    @@not_found

        POP      EDI
        TEST     EDI, EDI
        JNZ      @@no_go

        MOV      [EAX].TControl.fCurrentControl, ECX
        INC      [ECX].TControl.fClickDisabled
        PUSH     ECX
        MOV      ECX, [ECX].TControl.fHandle
        JECXZ    @@4
        PUSH     ECX
        CALL     Windows.SetFocus
@@4:    POP      ECX
        DEC      [ECX].TControl.fClickDisabled
@@no_go:
        POPAD
        POP      ESI
        POP      EDI
        MOV      AL, 1      // Result = True
end;
{$ELSE ASM_VERSION} //Pascal
function Tabulate2ControlEx( Self_: PControl; Key: DWORD; checkOnly: Boolean ): Boolean;
label search_tabcontrol;
var Form: PControl;
    CL : PList;
    I : Integer;
    CurCtrl, Ctrl, Found : PControl;
    MinDist, Dist: Integer;
    R, R1 : TRect;
begin
  Result := False;
  case Key of
  VK_TAB: if not (tkTab in Self_.fLookTabKeys) then exit;
  VK_LEFT, VK_RIGHT: if not (tkLeftRight in Self_.fLookTabKeys) then exit;
  VK_UP, VK_DOWN: if not (tkUpDown in Self_.fLookTabKeys) then exit;
  VK_NEXT, VK_PRIOR: if not (tkPageUpPageDn in Self_.fLookTabKeys) then exit;
  else exit;
  end;

  Result := True;
  if checkOnly then Exit;

  Form := Self_.ParentForm;
  if Key = VK_TAB then
    if GetKeyState( VK_SHIFT ) < 0 then
      Tabulate2Next( Form, -1 )
    else
      Tabulate2Next( Form, 1 )
  else
  begin
    CL := CollectTabControls( Form );
    I := CL.IndexOf( Form.fCurrentControl );
    Found := nil;
    if I >= 0 then
    begin
      CurCtrl := CL.fItems[ I ];
      //R := CurCtrl.ControlRect;
      GetWindowRect( CurCtrl.Handle, R );
    search_tabcontrol:
      MinDist := MaxInt;
      for I := CL.fCount - 1 downto 0 do
      begin
        Ctrl := CL.fItems[ I ];
        if Ctrl = CurCtrl then continue;
        if not (Ctrl.fEnabled and Ctrl.fTabstop) then continue;
        //R1 := Ctrl.ControlRect;
        GetWindowRect( Ctrl.Handle, R1 );
        Dist := MaxInt;
        case Key of
          VK_LEFT:
            begin
              if (R1.Bottom < R.Top)
              or (R1.Top >= R.Bottom)
              or (R1.Left > R.Left) then continue;
              Dist := R.Left - R1.Left;
            end;
          VK_RIGHT:
            begin
              if (R1.Bottom < R.Top)
              or (R1.Top >= R.Bottom)
              or (R1.Left < R.Left) then continue;
              Dist := R1.Left - R.Left;
            end;
          VK_UP, VK_PRIOR:
            begin
              if (R1.Right < R.Left)
              or (R1.Left >= R.Right)
              or (R1.Top > R.Top) then continue;
              Dist := R.Top - R1.Top;
            end;
          VK_DOWN, VK_NEXT:
            begin
              if (R1.Right < R.Left)
              or (R1.Left >= R.Right)
              or (R1.Top < R.Bottom) then continue;
              Dist := R1.Top - R.Top;
            end;
        end;
        if Dist < MinDist then
        begin
          Found := Ctrl;
          MinDist := Dist;
        end;
      end;
      if Found = nil then
      begin
        case Key of
          VK_LEFT:
            begin
              Key := VK_UP; goto search_tabcontrol;
            end;
          VK_RIGHT:
            begin
              Key := VK_DOWN; goto search_tabcontrol;
            end;
          VK_UP, VK_PRIOR:
            Tabulate2Next( Form, -1 );
          VK_DOWN, VK_NEXT:
            Tabulate2Next( Form, 1 );
        end;
      end
         else
      begin
        if Found.fHandle <> 0 then
        begin
          Inc( Found.fClickDisabled );
          SetFocus( Found.fHandle );
          Dec( Found.fClickDisabled );
        end;
        Form.fCurrentControl := Found;
      end;
    end;
    CL.Free;
  end;
end;
{$ENDIF ASM_VERSION}
//[END Tabulate2ControlEx]

{$IFDEF ASM_VERSION}
//[function TControl.Tabulate]
function TControl.Tabulate: PControl;
asm
        PUSH     EAX
        CALL     ParentForm
        TEST     EAX, EAX
        JZ       @@exit
        MOV      [EAX].fGotoControl, offset[Tabulate2Control]
@@exit: POP      EAX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.Tabulate: PControl;
var F : PControl;
begin
  Result := Self;
  F := ParentForm;
  if F = nil then Exit;
  F.fGotoControl := Tabulate2Control;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.TabulateEx]
function TControl.TabulateEx: PControl;
asm
        PUSH     EAX
        CALL     ParentForm
        TEST     EAX, EAX
        JZ       @@exit
        MOV      [EAX].fGotoControl, offset[Tabulate2ControlEx]
@@exit: POP      EAX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.TabulateEx: PControl;
var F : PControl;
begin
  Result := Self;
  F := ParentForm;
  if F = nil then Exit;
  F.fGotoControl := Tabulate2ControlEx;
end;
{$ENDIF ASM_VERSION}

//*
//[procedure TControl.GotoControl]
procedure TControl.GotoControl(Key: DWORD);
var Form: PControl;
begin
  Form := ParentForm;
  if Form <> nil then
  if assigned( Form.fGotoControl ) then
     Form.fGotoControl( Form.fCurrentControl, Key, false );
end;

{$IFDEF ASM_VERSION}
//[function TControl.GetCurIndex]
function TControl.GetCurIndex: Integer;
asm
        PUSH     EBX
        XCHG     EBX, EAX
        MOV      EAX, [EBX].fCurIndex
        MOVZX    ECX, [EBX].fCommandActions.aGetCurrent
        JECXZ    @@exit
        XOR      EAX, EAX
        CDQ
        CMP      CX, LVM_GETNEXTITEM
        JNE      @@0
        INC      EAX
        INC      EAX
        JMP      @@1
@@0:
        CMP      CL, EM_LINEINDEX and $FF
        JNZ      @@2
@@1:
        DEC      EDX
@@2:
        PUSH     EAX
        PUSH     EDX
        PUSH     ECX
        PUSH     EBX
        CALL     Perform

@@exit: POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.GetCurIndex: Integer;
var I, J: Integer;
begin
  Result := fCurIndex;
  if fCommandActions.aGetCurrent = 0 then
    Exit;
  I := 0;
  if fCommandActions.aGetCurrent = EM_LINEINDEX then
     Dec( I );
  J := 0;
  if fCommandActions.aGetCurrent = LVM_GETNEXTITEM then
  begin
     J := 2 {LVNI_SELECTED};
     Dec( I );
  end;
  Result := Perform( fCommandActions.aGetCurrent, I, J );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TControl.SetCurIndex]
procedure TControl.SetCurIndex(const Value: Integer);
asm
        MOVZX    ECX, [EAX].fCommandActions.aSetCurrent
        JECXZ    @@set_item_sel
        PUSHAD
        PUSH     0
        PUSH     EDX
        PUSH     ECX
        PUSH     EAX
        CALL     Perform
        POPAD
        CMP      CX, TCM_SETCURSEL
        JNE      @@exit
        PUSH     TCN_SELCHANGE
        PUSH     EAX // idfrom doesn't matter
        PUSH     [EAX].fHandle
        PUSH     ESP
        PUSH     0
        PUSH     WM_NOTIFY
        PUSH     EAX
        CALL     Perform
        POP      ECX
        POP      ECX
        POP      ECX
@@exit:
        RET
@@set_item_sel:
        INC      ECX
        CALL     SetItemSelected
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.SetCurIndex(const Value: Integer);
var NMHdr: TNMHdr;
begin
  if fCommandActions.aSetCurrent <> 0 then
  begin
     Perform( fCommandActions.aSetCurrent, Value, 0 );
     if fCommandActions.aSetCurrent = TCM_SETCURSEL then
     begin
       NMHdr.code := TCN_SELCHANGE;
       NMHdr.hwndFrom := fHandle;
       Perform( WM_NOTIFY, 0, Integer( @NMHdr ) );
     end;
  end
  else
     ItemSelected[ Value ] := True;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.GetTextAlign]
function TControl.GetTextAlign: TTextAlign;
asm
        PUSH     EAX
        CALL     UpdateWndStyles
        MOV      ECX, [EAX].fStyle
        MOV      EDX, dword ptr [EAX].fCommandActions.aTextAlignRight
        XOR      EAX, EAX
        AND      DX, CX
        JNZ      @@ret_1
        SHR      EDX, 16
        AND      ECX, EDX
        JNZ      @@ret_2
        POP      EAX
        MOVZX    EAX, [EAX].fTextAlign
        RET

@@ret_2:INC      EAX
@@ret_1:INC      EAX
@@ret_0:POP      ECX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.GetTextAlign: TTextAlign;
begin
  UpdateWndStyles;
  if (fStyle and fCommandActions.aTextAlignRight) = fCommandActions.aTextAlignRight then
     Result := taRight
  else
  if (fStyle and fCommandActions.aTextAlignCenter) = fCommandActions.aTextAlignCenter then
     Result := taCenter
  else
     Result := fTextAlign;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.GetVerticalAlign]
function TControl.GetVerticalAlign: TVerticalAlign;
asm
        PUSH     EAX
        CALL     UpdateWndStyles
        MOV      EDX, dword ptr [EAX].fCommandActions.aVertAlignCenter
        MOV      ECX, [EAX].fStyle
        XOR      EAX, EAX
        MOV      DH, DL
        AND      DL, CH
        JZ       @@1
        CMP      DL, DH
        JE       @@ret_0
@@1:    SHR      EDX, 16
        MOV      DH, DL
        AND      DL, CH
        JZ       @@2
        CMP      DL, DH
        JE       @@ret_2
@@2:    POP      EAX
        MOVZX    EAX, [EAX].fVerticalAlign
        RET
@@ret_2:INC      EAX
@@ret_1:INC      EAX
@@ret_0:POP      ECX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.GetVerticalAlign: TVerticalAlign;
begin
  UpdateWndStyles;
  if (fStyle and (fCommandActions.aVertAlignCenter shl 8)) = (fCommandActions.aVertAlignCenter shl 8) then
     Result := vaCenter
  else
  if (fStyle and (fCommandActions.aVertAlignBottom shl 8)) = (fCommandActions.aVertAlignBottom shl 8) then
     Result := vaBottom
  else
     Result := fVerticalAlign;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TControl.SetTextAlign]
procedure TControl.SetTextAlign(const Value: TTextAlign);
asm
        MOV      [EAX].fTextAlign, DL
        XOR      ECX, ECX
        MOV      CX, [EAX].fCommandActions.aTextAlignLeft
        OR       CX, [EAX].fCommandActions.aTextAlignCenter
        OR       CX, [EAX].fCommandActions.aTextAlignRight
        NOT      ECX
        AND      ECX, [EAX].fStyle

        AND      EDX, 3
        OR       CX, [EAX + EDX * 2].fCommandActions.aTextAlignLeft

        MOV      DL, [EAX].fCommandActions.aTextAlignMask
        NOT      EDX
        AND      EDX, ECX
        CALL     SetStyle
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.SetTextAlign(const Value: TTextAlign);
var NewStyle: DWORD;
begin
  fTextAlign := Value;
  NewStyle := 0;
  with fCommandActions do
  case Value of
  taLeft: NewStyle := fStyle and not DWORD(aTextAlignCenter or aTextAlignRight)
                          or aTextAlignLeft;
  taRight: NewStyle := fStyle and not DWORD(aTextAlignLeft or aTextAlignCenter)
                          or aTextAlignRight;
  taCenter: NewStyle := fStyle and not DWORD(aTextAlignLeft or aTextAlignRight)
                          or aTextAlignCenter;
  end;
  NewStyle := NewStyle and not DWORD(fCommandActions.aTextAlignMask);
  Style := NewStyle;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_noVERSION}
//[procedure TControl.SetVerticalAlign]
procedure TControl.SetVerticalAlign(const Value: TVerticalAlign);
asm
        MOV      [EAX].fVerticalAlign, DL
        XOR      ECX, ECX
        MOV      CX, word ptr [EAX].fCommandActions.aVertAlignTop
        OR       CH, CL
        MOV      CL, 0
        NOT      ECX
        AND      ECX, [EAX].fStyle
        AND      EDX, 3
        MOV      DH, [EAX + EDX].fCommandActions.aVertAlignCenter
        MOV      DL, 0
        OR       EDX, ECX
        CALL     SetStyle
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.SetVerticalAlign(const Value: TVerticalAlign);
var NewStyle: DWORD;
begin
  fVerticalAlign := Value;
  with fCommandActions do
  begin
    NewStyle := fStyle and not DWORD((aVertAlignTop or aVertAlignCenter or aVertAlignBottom) shl 8);
    case Value of
    vaCenter: NewStyle := NewStyle or (aVertAlignCenter shl 8);
    vaTop:    NewStyle := NewStyle or (aVertAlignTop shl 8);
    vaBottom: NewStyle := NewStyle or (aVertAlignBottom shl 8);
    end;
  end;
  Style := NewStyle;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_noVERSION}
//[function TControl.Dc2Canvas]
function TControl.Dc2Canvas( Sender: PCanvas ): HDC;
asm
        MOV      ECX, [EAX].fPaintDC
        JECXZ    @@chk_fHandle
        PUSH     ECX
        XCHG     EAX, EDX // EAX <= Sender
        MOV      EDX, ECX // EDX <= fPaintDC
        PUSH     EAX
        CALL     TCanvas.SetHandle
        POP      EAX
        MOV      [EAX].TCanvas.fIsPaintDC, 1
        POP      ECX
@@ret_ECX:
        XCHG     EAX, ECX
        RET
@@chk_fHandle:
        MOV      ECX, [EDX].TCanvas.fHandle
        INC      ECX
        LOOP     @@ret_ECX
        CALL     GetWindowHandle
        PUSH     EAX
        CALL     GetDC
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.Dc2Canvas( Sender: PCanvas ): HDC;
begin
  if fPaintDC <> 0 then
  begin
     Result := fPaintDC;
     Sender.SetHandle( Result );
     Sender.fIsPaintDC := True;
  end
    else
  begin
    if Sender.fHandle <> 0 then
       Result := Sender.fHandle
    else
       Result := GetDC( GetWindowHandle );
  end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.GetCanvas]
function TControl.GetCanvas: PCanvas;
asm
        PUSH     EBX
        PUSH     ESI
        XCHG     EBX, EAX

        MOV      ESI, [EBX].fCanvas
        TEST     ESI, ESI
        JNZ      @@exit

        XOR      EAX, EAX
        CALL     NewCanvas
        MOV      [EBX].fCanvas, EAX
        MOV      [EAX].TCanvas.fOwnerControl, EBX
        MOV      [EAX].TCanvas.fOnGetHandle.TMethod.Code, offset[ DC2Canvas ]
        MOV      [EAX].TCanvas.fOnGetHandle.TMethod.Data, EBX
        XCHG     ESI, EAX

        MOV      ECX, [EBX].fFont
        JECXZ    @@exit

        MOV      EAX, [ESI].TCanvas.fFont
        MOV      EDX, ECX
        CALL     TGraphicTool.Assign
        MOV      [ESI].TCanvas.fFont, EAX

        MOV      ECX, [EBX].fBrush
        JECXZ    @@exit

        MOV      EAX, [ESI].TCanvas.fBrush
        MOV      EDX, ECX
        CALL     TGraphicTool.Assign
        MOV      [ESI].TCanvas.fBrush, EAX

@@exit: XCHG     EAX, ESI
        POP      ESI
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.GetCanvas: PCanvas;
begin
  if not assigned( fCanvas ) then
  begin
    fCanvas := NewCanvas( 0 );
    fCanvas.OnGetHandle := Dc2Canvas;
    fCanvas.fOwnerControl := Self;
    if assigned( fFont ) then
      fCanvas.fFont := fCanvas.fFont.Assign( fFont );
    if assigned( fBrush ) then
      fCanvas.fBrush := fCanvas.fBrush.Assign( fBrush );
  end;
  Result := fCanvas;
end;
{$ENDIF ASM_VERSION}

//[function TControl.DblBufTopParent]
function TControl.DblBufTopParent: PControl;
var Ctl: PControl;
begin
  Result := nil;
  Ctl := Self;
  while Ctl <> nil do
  begin
    if Ctl.fDoubleBuffered then
      Result := Ctl;
    Ctl := Ctl.fParent;
  end;
end;

//[procedure InvalidateDblBufParent]
procedure InvalidateDblBufParent( Sender: PControl );
var C: PControl;
begin
  C := Sender.DblBufTopParent;
  if C <> nil then
    InvalidateRect( C.fHandle, nil, TRUE );
end;

//[function WndFuncPreventDraw]
function WndFuncPreventDraw( W: HWnd; Msg: Cardinal; wParam, lParam: Integer ): Integer; stdcall;
var C: PControl;
    PrntW: HWnd;
//********************************************************** Added By M.Gerasimov
//*
    PrevProc:Pointer;
//*
//********************************************************** Added By M.Gerasimov
begin
  //if not AppletTerminated then
  case Msg of
  WM_NCPAINT,
  //WM_PAINT,
  WM_ERASEBKGND:
    begin
      C := Pointer( GetProp( W, ID_SELF ) );
      if C = nil then
      begin
        PrntW := GetParent( W );
        if PrntW <> 0 then
        begin
          C := Pointer( GetProp( PrntW, ID_SELF ) );
          if (C <> nil) and not C.fCannotDoubleBuf and
             (C.DblBufTopParent <> nil) and
             (not C.DblBufTopParent.fDblBufPainting) then
          begin
            case Msg of
            WM_NCPAINT: Result := 0;
            WM_PAINT:   Result := 0;
            else Result := 1;
            end;
            Exit;
          end;
        end;
      end;
    end;
  end;
//********************************************************** By M.Gerasimov
//*
      PrevProc:=Pointer(GetProp( W, ID_PREVPROC ));
      if PrevProc <> Nil then
       Result := CallWindowProc( PrevProc , W, Msg, wParam, lParam )
      else
       Result:=0;
//*
//********************************************************** Remarked By M.Gerasimov
//Result := CallWindowProc( Pointer( GetProp( W, 'PREV_PROC' ) ),
//       W, Msg, wParam, lParam );
//******************************************************************************
end;

//[procedure DblBufCreateWndProc]
procedure DblBufCreateWndProc( Sender: PControl );
var Chld: HWnd;
    PrevProc: DWORD;
begin
  Chld := GetWindow( Sender.fHandle, GW_CHILD );
  while Chld <> 0 do
  begin
//********************************************************** Changed By M.Gerasimov
//  if GetProp( Chld, 'PREV_PROC' ) = 0 then
//**********************************************************
    if GetProp( Chld, ID_PREVPROC ) = 0 then              //
//**********************************************************
    begin
      PrevProc :=
        SetWindowLong( Chld, GWL_WNDPROC, Longint( @WndFuncPreventDraw ) );
//********************************************************** Changed By M.Gerasimov
//    SetProp( Chld, 'PREV_PROC', PrevProc );
//**********************************************************
      SetProp( Chld, ID_PREVPROC, PrevProc );             //
//**********************************************************
     end;
    Chld := GetWindow( Chld, GW_HWNDNEXT );
  end;
end;

//[procedure TControl.SetDoubleBuffered]
procedure TControl.SetDoubleBuffered(const Value: Boolean);
begin
  if CannotDoubleBuf then Exit;
  fDoubleBuffered := Value;
  Global_OnBufferedDraw := WndProcBufferedDraw;
  Global_Invalidate := @ InvalidateDblBufParent;
  Global_DblBufCreateWnd := @ DblBufCreateWndProc;
end;

{$IFDEF ASM_VERSION}
//[procedure TControl.SetTransparent]
procedure TControl.SetTransparent(const Value: Boolean);
asm
        CMP      [EAX].fTransparent, DL
        JZ       @@exit
        MOV      [EAX].fTransparent, DL
        TEST     DL, DL
        JZ       @@exit
        MOV      ECX, [EAX].fParent
        JECXZ    @@exit
        XCHG     EAX, ECX
        CALL     SetDoubleBuffered
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.SetTransparent(const Value: Boolean);
begin
  if fTransparent = Value then Exit;
  fTransparent := Value;
  //ExStyle := ExStyle or WS_EX_TRANSPARENT;
  if fParent = nil then Exit;
  if Value then
    fParent.DoubleBuffered := True;
end;
{$ENDIF ASM_VERSION}

//[function TControl.SetBorder]
function TControl.SetBorder( Value: Integer ): PControl;
begin
  fMargin := Value;
  Result := Self;
end;

{ TTrayIcon }

var FTrayItems: PList;

//[FUNCTION WndProcTray]
{$IFDEF ASM_noVERSION}
function WndProcTray( Control: PControl; var Msg: TMsg; var Rslt: Integer ) : Boolean;
asm
        PUSH     ECX
        MOV      ECX, [EDX].TMsg.message
        CMP      CX, CM_TRAYICON
        JNE      @@1

          MOV      ECX, [EDX].TMsg.lParam
          MOV      EDX, [EDX].TMsg.wParam
          MOV      EAX, [EDX].TTrayIcon.fOnMouse.TMethod.Data
          CMP      word ptr [EDX].TTrayIcon.fOnMouse.TMethod.Code+2, 0
          JE       @@no_on

          CALL     [EDX].TTrayIcon.fOnMouse.TMethod.Code
@@no_on:
          POP      ECX
          XOR      EAX, EAX
          MOV      [ECX], EAX
          INC      EAX
          RET

@@1:
        SUB      ECX, WM_CLOSE
        JNE      @@exit_0
@@2:

          POP      ECX
          PUSH     EBX
          XCHG     EBX, EAX

          MOV      EAX, [EBX].TControl.fHandle
          CMP      EAX, [EDX].TMsg.hwnd
          JNE      @@otherwin

          MOV      EDX, [FTrayItems]
          MOV      ECX, [EDX].TList.fCount
          MOV      EDX, [EDX].TList.fItems
@@loop:
          MOV      EAX, [EDX + ECX*4 - 4]
          CMP      [EAX].TTray.FNoAutoDeactivate, 0
          JNZ      @@3
          CMP      [EAX].TTrayIcon.fControl, EBX
          JNE      @@3
          PUSHAD
          XOR      EDX, EDX
          CALL     TTrayIcon.SetActive
          POPAD
@@3:      LOOP     @@loop

@@otherwin:
          POP      EBX
          PUSH     ECX

@@exit_0:
        XOR      EAX, EAX
        POP      ECX
end;
{$ELSE ASM_VERSION} //Pascal
function WndProcTray( Control: PControl; var Msg: TMsg; var Rslt: Integer ) : Boolean;
var Self_: PTrayIcon;
    I : Integer;
begin
  Result := False;
  case Msg.message of
  CM_TRAYICON:
    begin
      Self_ := Pointer( Msg.wParam );
      if Assigned( Self_.FOnMouse ) then
         Self_.FOnMouse( Self_, Msg.lParam );
      Rslt := 0;
      Result := True;
    end;
  WM_CLOSE:
    if Msg.hwnd = Control.fHandle then
    begin
      if FTrayItems <> nil then // ?????????????????
      for I := FTrayItems.Count - 1 downto 0 do
      begin
        Self_ := FTrayItems.Items[ I ];
        if not Self_.FNoAutoDeactivate then
        if Self_.FControl = Control then
           Self_.Active := False;
      end;
    end;
  end;
end;
{$ENDIF ASM_VERSION}
//[END WndProcTray]

//[FUNCTION _NewTrayIcon]
{$IFDEF ASM_VERSION}
function _NewTrayIcon: PTrayIcon;
begin
  New(Result,Create);
end;
{$ENDIF ASM_VERSION}
//[END _NewTrayIcon]

function WndProcTrayIconWnd( Wnd: HWnd; Msg: DWORD; wParam, lParam: Integer ): Integer;
         stdcall;
var PrevProc: function ( Wnd: HWnd; Msg: DWORD;
                         wParam, lParam: Integer ): Integer; stdcall;
var Tr: PTrayIcon;
begin
  PrevProc := Pointer( GetProp( Wnd, 'TRAYSAVEPROC' ) );
  if Msg = CM_TRAYICON then
  begin
    Tr := Pointer( wParam );
    if Assigned( Tr.FOnMouse ) then
       Tr.FOnMouse( Tr, lParam );
    Result := 0;
    Exit;
  end
    else
  if Msg = WM_CLOSE then
  begin
    if Assigned( PrevProc ) then
    begin
      SetWindowLong( Wnd, GWL_WNDPROC, Integer( @ PrevProc ) );
      RemoveProp( Wnd, 'TRAYSAVEPROC' );
      PostMessage( Wnd, WM_CLOSE, wParam, lParam );
      Result := 0;
      Exit;
      //Wnd := 0;
    end;
  end;
  if (Wnd <> 0) and IsWindow( Wnd ) and Assigned( PrevProc ) then
    Result := PrevProc( Wnd, Msg, wParam, lParam )
  else
    Result := DefWindowProc( Wnd, Msg, wParam, lParam );
end;

//[PROCEDURE TTrayIcon.AttachProc2Wnd]
procedure TTrayIcon.AttachProc2Wnd;
begin
  if FWnd = 0 then Exit;
  if GetProp( FWnd, 'TRAYSAVEPROC' ) <> 0 then Exit; // already attached
  SetProp( FWnd, 'TRAYSAVEPROC', GetWindowLong( FWnd, GWL_WNDPROC ) );
  SetWindowLong( FWnd, GWL_WNDPROC, Integer( @ WndProcTrayIconWnd ) );
end;
// [END TTrayIcon.AttachProc2Wnd]

// [PROCEDURE TTrayIcon.DetachProc2Wnd]
procedure TTrayIcon.DetachProc2Wnd;
var OldProc: function ( Wnd: HWnd; Msg: DWORD;
             wParam, lParam: Integer ): Integer; stdcall;
begin
  if FWnd = 0 then Exit;
  OldProc := Pointer( GetProp( FWnd, 'TRAYSAVEPROC' ) );
  if not Assigned( OldProc ) then Exit; // not attached
  SetWindowLong( FWnd, GWL_WNDPROC, Integer( @ OldProc ) );
  RemoveProp( FWnd, 'TRAYSAVEPROC' );
end;
// [END TTrayIcon.DetachProc2Wnd]

//[FUNCTION NewTrayIcon]
{$IFDEF ASM_VERSION}
function NewTrayIcon( Wnd: PControl; Icon: HIcon ): PTrayIcon;
asm
        PUSH     EBX
        PUSH     EDX // push Icon
        PUSH     EAX // push Wnd
        CALL     _NewTrayIcon
        XCHG     EBX, EAX

        MOV      EAX, [FTrayItems]
        TEST     EAX, EAX
        JNZ      @@1
        CALL     NewList
        MOV      [FTrayItems], EAX
@@1:
        MOV      EDX, EBX
        CALL     TList.Add

        POP      EAX //Wnd
        MOV      [EBX].TTrayIcon.fControl, EAX
        POP      [EBX].TTrayIcon.fIcon //Icon

        MOV      EDX, offset[WndProcTray]
        TEST     EAX, EAX
        JZ       @@2
        CALL     TControl.AttachProc
@@2:
        MOV      DL, 1
        MOV      EAX, EBX
        CALL     TTrayIcon.SetActive
        XCHG     EAX, EBX
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function NewTrayIcon( Wnd: PControl; Icon: HIcon ): PTrayIcon;
begin
  if FTrayItems = nil then
     FTrayItems := NewList;
  Result := PTrayIcon.Create;
  FTrayItems.Add( Result );
  if Wnd <> nil then
    Wnd.AttachProc( WndProcTray );
  Result.FControl := Wnd;
  Result.FIcon := Icon;
  Result.Active := True;
end;
{$ENDIF ASM_VERSION}
//[END NewTrayIcon]

var fRecreateMsg: DWORD;

//[FUNCTION WndProcRecreateTrayIcons]
{$IFDEF ASM_VERSION}
function WndProcRecreateTrayIcons( Sender: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
asm     //cmd    //opd
        MOV      ECX, [fRecreateMsg]
        CMP      word ptr [EDX].TMsg.message, CX
        JNE      @@ret_false
        PUSH     ESI
        MOV      ESI, [FTrayItems]
        MOV      ECX, [ESI].TList.fCount
        MOV      ESI, [ESI].TList.fItems
        //JECXZ    @@e_loo
@@loo:  PUSH     ECX
        LODSD
        MOV      DL, [EAX].TTrayIcon.fAutoRecreate
        AND      DL, [EAX].TTrayIcon.fActive
        JZ       @@nx
        DEC      [EAX].TTrayIcon.fActive
        CALL     TTrayIcon.SetActive
@@nx:   POP      ECX
        LOOP     @@loo
@@e_loo:POP      ESI
@@ret_false:
        XOR      EAX, EAX
end;
{$ELSE ASM_VERSION} //Pascal
function WndProcRecreateTrayIcons( Sender: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var I: Integer;
    TI: PTrayIcon;
begin
  if Msg.message = fRecreateMsg then
  begin
    for I := 0 to FTrayItems.fCount - 1 do
    begin
      TI := FTrayItems.Items[ I ];
      if TI.fAutoRecreate then
      if TI.fActive then
      begin
        TI.fActive := False;
        TI.Active := True;
      end;
    end;
  end;
  Result := False;
end;
{$ENDIF ASM_VERSION}
//[END WndProcRecreateTrayIcons]

const
  TaskbarCreatedMsg: array[ 0..14 ] of Char = ('T','a','s','k','b','a','r',
                     'C','r','e','a','t','e','d',#0);
{$IFDEF ASM_VERSION}
//[procedure TTrayIcon.SetAutoRecreate]
procedure TTrayIcon.SetAutoRecreate(const Value: Boolean);
asm     //cmd    //opd
        MOV      [EAX].fAutoRecreate, DL
        MOV      EAX, [EAX].FControl
        CALL     TControl.ParentForm
        MOV      EDX, offset[WndProcRecreateTrayIcons]
        CALL     TControl.AttachProc
        PUSH     offset[TaskbarCreatedMsg]
        CALL     RegisterWindowMessage
        MOV      [fRecreateMsg], EAX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TTrayIcon.SetAutoRecreate(const Value: Boolean);
begin
  fAutoRecreate := Value;
  FControl.ParentForm.AttachProc( WndProcRecreateTrayIcons );
  fRecreateMsg := RegisterWindowMessage( TaskbarCreatedMsg );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[destructor TTrayIcon.Destroy]
destructor TTrayIcon.Destroy;
asm
        PUSH     EBX
        PUSH     ESI
        MOV      EBX, EAX
        XOR      EDX, EDX
        CALL     SetActive

        MOV      ECX, [EBX].fIcon
        JECXZ    @@icon_destroyed
        PUSH     ECX
        CALL     DestroyIcon
@@icon_destroyed:

        MOV      EDX, EBX
        MOV      ESI, [FTrayItems]
        MOV      EAX, ESI
        CALL     TList.IndexOf
        TEST     EAX, EAX
        JL       @@fin
          XCHG     EDX, EAX
          MOV      EAX, ESI
          CALL     TList.Delete
          MOV      EAX, [ESI].TList.fCount
          TEST     EAX, EAX
          JNZ      @@fin
          XCHG     EAX, [FTrayItems]
          CALL     TObj.Free
@@fin:  LEA      EAX, [EBX].FTooltip
        CALL     System.@LStrClr
        XCHG     EAX, EBX
        CALL     TObj.Destroy
        POP      ESI
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
destructor TTrayIcon.Destroy;
begin
  Active := False;

  if fIcon <> 0 then
    DestroyIcon( fIcon );

  FTrayItems.Remove( Self );
  if FTrayItems.Count = 0 then
    Free_And_Nil( FTrayItems );
  FTooltip := '';
  inherited;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TTrayIcon.SetActive]
procedure TTrayIcon.SetActive(const Value: Boolean);
asm
        CMP      [EAX].fActive, DL
        JE       @@exit
        MOV      ECX, [EAX].fIcon
        JECXZ    @@exit
        PUSH     EDX
        PUSH     EAX
          MOV      ECX, [EAX].FWnd
          INC      ECX
          LOOP     @@1
          MOV      ECX, [EAX].fControl
          XOR      EAX, EAX
          JECXZ    @@1
          XCHG     EAX, ECX
          CALL     TControl.GetWindowHandle
@@1:
        POP      ECX
        POP      EDX
        XCHG     EAX, ECX
        JECXZ    @@exit
        MOV      [EAX].fActive, DL
        MOVZX    EDX, DL
        XOR      DL, 1
        ADD      EDX, EDX
        CALL     SetTrayIcon
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TTrayIcon.SetActive(const Value: Boolean);
begin
  if FActive = Value then Exit;
  if FIcon = 0 then Exit;
  if (Wnd = 0) and ((FControl = nil) or (FControl.GetWindowHandle = 0)) then Exit;
  FActive := Value;
  if Value then
     SetTrayIcon( NIM_ADD )
  else
     SetTrayIcon( NIM_DELETE );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TTrayIcon.SetIcon]
procedure TTrayIcon.SetIcon(const Value: HIcon);
asm
        MOV      ECX, [EAX].fIcon
        CMP      ECX, EDX
        JE       @@exit
        MOV      [EAX].fIcon, EDX
        XOR      EDX, EDX
        JECXZ    @@nim_add
        INC      EDX      // NIM_MODIFY = 1
@@nim_add:
        MOVZX    ECX, [EAX].fActive
        JECXZ    @@exit
        CALL     SetTrayIcon
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TTrayIcon.SetIcon(const Value: HIcon);
var Cmd : DWORD;
begin
  if FIcon = Value then Exit;
  // Previous icon is not destroying. This is normal for
  // icons, loaded from resources using LoadIcon. For icons,
  // created using CreateIconIndirect, You have to call
  // DestroyIcon manually.
  Cmd := NIM_MODIFY;
  if FIcon = 0 then
     Cmd := NIM_ADD;
  FIcon := Value;
  if FActive then
     SetTrayIcon( Cmd );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TTrayIcon.SetTooltip]
procedure TTrayIcon.SetTooltip(const Value: String);
asm
        PUSH     EBX
        XCHG     EBX, EAX
        MOV      EAX, [EBX].fTooltip
        PUSH     EDX
        CALL     System.@LStrCmp
        POP      EDX
        JE       @@exit
        LEA      EAX, [EBX].fTooltip
        CALL     System.@LStrAsg
        CMP      [EBX].fActive, 0
        JE       @@exit
        XOR      EDX, EDX
        INC      EDX     // EDX = NIM_MODIFY
        XCHG     EAX, EBX
        CALL     SetTrayIcon
@@exit:
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TTrayIcon.SetTooltip(const Value: String);
begin
  if FTooltip = Value then Exit;
  FTooltip := Value;
  if Active then
     SetTrayIcon( NIM_MODIFY );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TTrayIcon.SetTrayIcon]
procedure TTrayIcon.SetTrayIcon(const Value: DWORD);
const sz_tid = sizeof( TNotifyIconData );
asm
        //MOV      ECX, [EAX].fIcon
        //JECXZ    @@exit

        CMP      [AppletTerminated], 0
        JE       @@1
        MOV      DL, NIM_DELETE
@@1:
        PUSH     EBX
        PUSH     ESI
        MOV      ESI, EAX
        MOV      EBX, EDX

        XOR      ECX, ECX
        PUSH     ECX
        ADD      ESP, -60
        MOV      EDX, [ESI].fToolTip
        CALL     EDX2PChar
        MOV      EAX, ESP
        MOV      CL, 63
        CALL     StrLCopy

        PUSH     [ESI].fIcon
        PUSH     CM_TRAYICON
        XOR      EDX, EDX
        CMP      BL, NIM_DELETE
        JE       @@2
        MOV      DL, NIF_ICON or NIF_MESSAGE or NIF_TIP
@@2:    PUSH     EDX
        PUSH     ESI
        MOV      EAX, [ESI].FWnd
        TEST     EAX, EAX
        JNZ      @@3
        MOV      EAX, [ESI].fControl
        MOV      EAX, [EAX].TControl.fHandle
@@3:
        PUSH     EAX
        PUSH     sz_tid

        PUSH     ESP
        PUSH     EBX
        CALL     Shell_NotifyIcon

        ADD      ESP, sz_tid
        POP      ESI
        POP      EBX
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TTrayIcon.SetTrayIcon(const Value: DWORD);
var NID : TNotifyIconData;
    L : Integer;
    V : DWORD;
begin
  //if FIcon = 0 then Exit; - already tested
  V := Value;
  if AppletTerminated then
    V := NIM_DELETE;
  if Wnd <> 0 then
    NID.Wnd := Wnd
  else
    NID.Wnd := FControl.fHandle;

  NID.cbSize := Sizeof( NID );
  NID.uID := DWORD( Self );
  NID.uFlags := NIF_ICON or NIF_MESSAGE or NIF_TIP;
  if V = NIM_DELETE then
     NID.uFlags := 0;
  NID.uCallbackMessage := CM_TRAYICON;
  NID.hIcon := FIcon;
  L := Length( FToolTip );
  if L > 63 then L := 63;
  Move( FTooltip[1], NID.szTip[0], Min( 63, L ) );
  NID.szTip[ L ] := #0;

  Shell_NotifyIcon( V, @NID );
end;
{$ENDIF ASM_VERSION}

{ -- JustOne -- }

var JustOneMutex: THandle;

//[FUNCTION WndProcJustOne]
{$IFDEF ASM_VERSION}
function WndProcJustOne( Control: PControl; var Msg: TMsg; var Rslt: Integer ) : Boolean;
asm
        MOV      ECX, [EDX].TMsg.message
        SUB      ECX, WM_CLOSE
        JE       @@1
        SUB      ECX, WM_NCDESTROY - WM_CLOSE
        JNE      @@exit
@@1:
        XCHG     ECX, [JustOneMutex]
        JECXZ    @@exit
        PUSH     ECX
        PUSH     ECX
        CALL     ReleaseMutex
        CALL     CloseHandle

@@exit:
        XOR      EAX, EAX
end;
{$ELSE ASM_VERSION} //Pascal
function WndProcJustOne( Control: PControl; var Msg: TMsg; var Rslt: Integer ) : Boolean;
begin
  Result := False;
  case Msg.message of
  WM_CLOSE, WM_NCDESTROY:
      if LongBool( JustOneMutex ) then
      begin
        ReleaseMutex( JustOneMutex );
        CloseHandle( JustOneMutex );
        JustOneMutex := 0;
      end;
  end;
end;
{$ENDIF ASM_VERSION}
//[END WndProcJustOne]

//[FUNCTION JustOne]
{$IFDEF ASM_VERSION}
function JustOne( Wnd: PControl; const Identifier : String ) : Boolean;
const JOcs: PChar = 'KOL.Just1.CrtSec';
asm
        PUSH     EBX
        PUSH     ESI
        XOR      ESI, ESI
        PUSH     EDI
        XCHG     EBX, EAX

        CALL     EDX2PChar
        PUSH     EDX

        PUSH     [JOcs]
        PUSH     1
        PUSH     ESI
        MOV      EDI, offset[CreateMutex]
        CALL     EDI

        POP      EDX
        TEST     EAX, EAX
        JZ       @@exit     //
        PUSH     EAX
        PUSH     EAX

        PUSH     EDX
        PUSH     ESI
        PUSH     ESI
        CALL     EDI
        MOV      [JustOneMutex], EAX
        TEST     EAX, EAX
        JE       @@1        //

        PUSH     ESI
        PUSH     EAX
        CALL     WaitForSingleObject
        SUB      EAX, WAIT_TIMEOUT
        JE       @@1

        INC      ESI
@@1:
        //MOV      [EBX].TControl.fWndProcJustOne, offset[WndProcJustOne]
        XCHG     EAX, EBX
        MOV      EDX, offset[WndProcJustOne]
        CALL     TControl.AttachProc

        CALL     ReleaseMutex
        CALL     CloseHandle

@@exit:
        XCHG     EAX, ESI
        POP      EDI
        POP      ESI
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function JustOne( Wnd: PControl; const Identifier : String ) : Boolean;
var CritSecMutex : THandle;
    DW : Longint;
begin
   Result := False;
   CritSecMutex := CreateMutex( nil, True, PChar( 'KOL.Just1.CrtSec' ) );
   if CritSecMutex = 0 then Exit;

   JustOneMutex := CreateMutex( nil, False, PChar( Identifier ) );
   if JustOneMutex <> 0 then
   begin
     DW := WaitForSingleObject( JustOneMutex, 0 );
     Result := (DW <> WAIT_TIMEOUT);
   end;

   //Wnd.fWndProcJustOne := WndProcJustOne;
   Wnd.AttachProc( WndProcJustOne );

   ReleaseMutex( CritSecMutex );
   CloseHandle( CritSecMutex );
end;
{$ENDIF ASM_VERSION}
//[END JustOne]

{ JustOneNotify }

var
  OnAnotherInstance: TOnAnotherInstance;
  JustOneMsg: DWORD;

//[FUNCTION WndProcJustOneNotify]
{$IFDEF ASM_VERSION}
function WndProcJustOneNotify( Control: PControl; var Msg: TMsg; var Rslt: Integer ) : Boolean;
asm
        PUSH     EBP
        MOV      EBP, ESP
        PUSHAD
        CALL     WndProcJustOne
        POPAD
        XOR      EAX, EAX
        PUSH     ECX
          MOV      ECX, [EDX].TMsg.message
          SUB      ECX, [JustOneMsg]
        POP      ECX
        JNE      @@exit
        MOV      [ECX], EAX
        CMP      [OnAnotherInstance].TMethod.Code, EAX
        JE       @@exit_1

        //MOV      EAX, (MAX_PATH + 3) and 0FFFFCh
        MOV      AH, 2
        SUB      ESP, EAX

        MOV      ECX, ESP
        PUSH     EAX
        PUSH     ECX
        PUSH     [EDX].TMsg.lParam
        CALL     GetWindowText

        MOV      EDX, ESP
        PUSH     0
        MOV      EAX, ESP
        CALL     System.@LStrFromPChar

        MOV      EDX, [ESP]
        MOV      EAX, [OnAnotherInstance].TMethod.Data
        CALL     [OnAnotherInstance].TMethod.Code

        MOV      EAX, ESP
        CALL     System.@LStrClr
@@exit_1:
        MOV      AL, 1
@@exit:
        MOV      ESP, EBP
        POP      EBP
end;
{$ELSE ASM_VERSION} //Pascal
function WndProcJustOneNotify( Control: PControl; var Msg: TMsg; var Rslt: Integer ) : Boolean;
var Buf : array[0..MAX_PATH] of Char;
begin
  WndProcJustOne( Control, Msg, Rslt );
  Result := False;
  if Msg.message = JustOneMsg then
  begin
    Result := True;
    if assigned( OnAnotherInstance ) then
    begin
      GetWindowText( Msg.lParam, Buf, MAX_PATH );
      OnAnotherInstance( Buf );
    end;
    Rslt := 0;
  end;
end;
{$ENDIF ASM_VERSION}
//[END WndProcJustOneNotify]

// Redefine here incorrectly declared BroadcastSystemMessage API function.
// It should not refer to BroadcastSystemMessageA, which is not present in
// earlier versions of Windows95, but to BroadcastSystemMessage, which is
// present in all Windows95/98/Me and NT/2K/XP.
//[API BroadcastSystemMessage]
function BroadcastSystemMessage(Flags: DWORD; Recipients: PDWORD;
  uiMessage: UINT; wParam: WPARAM; lParam: LPARAM): Longint; stdcall;
external user32 name 'BroadcastSystemMessage';

//[FUNCTION JustOneNotify]
{$IFDEF ASM_VERSION}
function JustOneNotify( Wnd: PControl; const Identifier : String;
                        const aOnAnotherInstance: TOnAnotherInstance ) : Boolean;
asm
        PUSHAD
        MOV      EBP, ESP

        XCHG     EAX, EDX
        PUSH     EAX
        CALL     System.@LStrLen
        POP      EDX
        ADD      EAX, EAX
        SUB      ESP, EAX
        MOV      EAX, ESP
        CALL     StrPCopy
        PUSH     '.ega'
        PUSH     'sseM'
        PUSH     ESP
        CALL     RegisterWindowMessage
        MOV      [JustOneMsg], EAX
        TEST     EAX, EAX

        MOV      ESP, EBP
        POPAD
        JE       @@exit_f

        PUSHAD
        CALL     JustOne
        DEC      AL
        POPAD
        JZ       @@exit_t

        PUSH     EBX
        XCHG     EBX, EAX
        XOR      EDX, EDX
        XCHG     [EBX].TControl.fCaption, EDX
        PUSH     EDX

        CALL     GetCommandLine
        XCHG     EDX, EAX
        MOV      EAX, EBX
        CALL     TControl.SetCaption
        MOV      EAX, EBX
        CALL     TControl.GetWindowHandle
        TEST     EAX, EAX
        JZ       @@rest_cap

        PUSH     BSM_APPLICATIONS
        MOV      EDX, ESP

        PUSH     EAX
        PUSH     0
        PUSH     [JustOneMsg]
        PUSH     EDX
        PUSH     BSF_QUERY or BSF_IGNORECURRENTTASK
        CALL     BroadcastSystemMessage

        POP      EDX
@@rest_cap:
        XOR      EDX, EDX
        MOV      EAX, EBX
        CALL     TControl.SetCaption
        POP      EDX
        MOV      [EBX].TControl.fCaption, EDX
        PUSH     EDX
        PUSH     [EBX].TControl.fHandle
        CALL     SetWindowText
        POP      EBX
@@exit_f:
        XOR      EAX, EAX
          POP      EBP  // because compiler inserts PUSH EBP;MOV EBP,ESP at the BEGIN
        RET

@@exit_t:
        PUSHAD
        LEA      ESI, [aOnAnotherInstance]
        LEA      EDI, [OnAnotherInstance]
        MOVSD
        MOVSD
        //MOV      [EAX].TControl.fWndProcJustOne, offset[WndProcJustOneNotify]
        MOV      EDX, offset[WndProcJustOneNotify]
        CALL     TControl.AttachProc

        POPAD
        MOV      AL, 1
end;
{$ELSE ASM_VERSION} //Pascal
function JustOneNotify( Wnd: PControl; const Identifier : String;
                        const aOnAnotherInstance: TOnAnotherInstance ) : Boolean;
var Recipients : DWord;
    OldCap: String;
begin
   Result := False;
   JustOneMsg := RegisterWindowMessage( PChar( 'Message.' + Identifier ) );
   if JustOneMsg = 0 then Exit;

   Result := JustOne( Wnd, Identifier );
   if not Result then
   begin
      // Send a message to the first instance of applet

      //Wnd.CreateVisible := False;
      OldCap := Wnd.Caption;
      Wnd.Caption := GetCommandLine;
      if Wnd.GetWindowHandle <> 0 then
      begin
         Recipients := BSM_APPLICATIONS;
         BroadcastSystemMessage( BSF_QUERY or BSF_IGNORECURRENTTASK, @Recipients,
                                 JustOneMsg, 0, Wnd.fHandle );
      end;
      Wnd.Caption := OldCap;
   end
      else
   begin
      // Store event handler to notify this instance about another
      // instance staring:
      OnAnotherInstance := aOnAnotherInstance;
      //Wnd.fWndProcJustOne := WndProcJustOneNotify;
      Wnd.AttachProc( WndProcJustOneNotify );

      {
      if JustOneNotifier = nil then
         JustOneNotifier := ZJustOneNotifier.Create;
      }
   end;
end;
{$ENDIF ASM_VERSION}
//[END JustOneNotify]


///////////////////////////////////////// STRING LIST OBJECT /////////////////

{ TStrList }

//[function NewStrList]
function NewStrList: PStrList;
begin


  Result := PStrList.Create;

end;
//[END NewStrList]

{$IFDEF ASM_VERSION}
//[destructor TStrList.Destroy]
destructor TStrList.Destroy;
asm
        PUSH     EAX
        CALL     Clear
        POP      EAX
        CALL     TObj.Destroy
end;
{$ELSE ASM_VERSION} //Pascal
destructor TStrList.Destroy;
begin
  Clear;
  inherited;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TStrList.Add]
function TStrList.Add(const S: string): integer;
asm
        MOV      ECX, EDX
        MOV      EDX, [EAX].fCount
        PUSH     EDX
        CALL     Insert
        POP      EAX
end;
{$ELSE ASM_VERSION} //Pascal
function TStrList.Add(const S: string): integer;
begin
  Result := fCount;
  Insert( Result, S );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TStrList.AddStrings]
procedure TStrList.AddStrings(Strings: PStrList);
asm
        PUSH     EAX
        XCHG     EAX, EDX
        PUSH     0
        MOV      EDX, ESP
        CALL     GetTextStr
        POP      EDX
        POP      EAX
        MOV      CL, 1
        PUSH     EDX
        CALL     SetText
        CALL     RemoveStr
end;
{$ELSE ASM_VERSION} //Pascal
procedure TStrList.AddStrings(Strings: PStrList);
begin
  SetText( Strings.Text, True );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TStrList.AppendToFile]
function TStrList.AppendToFile(const FileName: string): Boolean;
asm
        PUSH     EBX
        MOV      EBX, EDX
        PUSH     0
        MOV      EDX, ESP
        CALL     GetTextStr
        XCHG     EAX, EBX
        MOV      EDX, ofOpenWrite or ofOpenAlways
        CALL     FileCreate
        MOV      EBX, EAX
        INC      EAX
        JZ       @@exit
        DEC      EAX
        XOR      EDX, EDX
        XOR      ECX, ECX
        MOV      CL, spEnd
        CALL     FileSeek
        POP      EAX
        PUSH     EAX
        CALL     System.@LStrLen
        XCHG     ECX, EAX
        MOV      EAX, EBX
        POP      EDX
        PUSH     EDX
        CALL     FileWrite
        XCHG     EAX, EBX
        CALL     FileClose
@@exit:
        CALL     RemoveStr
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function TStrList.AppendToFile(const FileName: string): Boolean;
var F: HFile;
    Buf: String;
    L: Integer;
begin
  F := FileCreate( FileName, ofOpenWrite or ofOpenAlways );
  Result := F <> INVALID_HANDLE_VALUE;
  if Result then
  begin
    FileSeek( F, 0, spEnd );
    Buf := Text;
    L := Length( Buf );
    FileWrite( F, Buf[ 1 ], L );
    FileClose( F );
  end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TStrList.Assign]
procedure TStrList.Assign(Strings: PStrList);
asm
        PUSHAD
        CALL     Clear
        POPAD
        JMP      AddStrings
end;
{$ELSE ASM_VERSION} //Pascal
procedure TStrList.Assign(Strings: PStrList);
begin
  Clear;
  AddStrings( Strings );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TStrList.Clear]
procedure TStrList.Clear;
asm
        PUSH     EBX
        XCHG     EBX, EAX
        MOV      EDX, [EBX].fCount
@@loo:  DEC      EDX
        JL       @@eloo
        PUSH     EDX
        MOV      EAX, EBX
        CALL     Delete
        POP      EDX
        JMP      @@loo
@@eloo:
        XOR      EAX, EAX
        MOV      [EBX].fTextSiz, EAX
        XCHG     EAX, [EBX].fTextBuf
        TEST     EAX, EAX
        JZ       @@1
        CALL     System.@FreeMem
        //XOR      EAX, EAX // not needed: if OK, EAX = 0
@@1:    XCHG     EAX, [EBX].fList
        CALL     TObj.Free
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TStrList.Clear;
var I: Integer;
begin
  if fCount > 0 then
  for I := fList.Count - 1 downto 0 do
    Delete( I );
  fList.Free;
  fList := nil;
  fCount := 0;
  if fTextBuf <> nil then
  begin
    FreeMem( fTextBuf );
    fTextBuf := nil;
    fTextSiz := 0;
  end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TStrList.Delete]
procedure TStrList.Delete(Idx: integer);
asm
        DEC      [EAX].fCount
        PUSH     EAX
        MOV      EAX, [EAX].fList
        MOV      ECX, [EAX].TList.fItems
        PUSH     dword ptr [ECX+EDX*4]
        CALL     TList.Delete
        POP      EAX
        POP      EDX
        MOV      ECX, [EDX].fTextSiz
        JECXZ    @@fremem
        CMP      EAX, [EDX].fTextBuf
        JB       @@fremem
        ADD      ECX, [EDX].fTextBuf
        CMP      EAX, ECX
        JB       @@exit
@@fremem:
        CALL     System.@FreeMem
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TStrList.Delete(Idx: integer);
var P: DWORD;
    El:Pointer;
begin
  P := DWORD( fList.fItems[ Idx ] );
  if (fTextBuf <> nil) and ( P >= DWORD( fTextBuf )) and
     ( P < DWORD( fTextBuf ) + fTextSiz ) then
  else
  begin
    El := FList.Items[ Idx ];
    FreeMem( El );
  end;
  fList.Delete( Idx );
  Dec( fCount );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TStrList.Get]
function TStrList.Get(Idx: integer): string;
asm
        PUSH     ECX
        MOV      EAX, [EAX].fList
        TEST     EAX, EAX
        JZ       @@1
        CALL     TList.Get
@@1:    XCHG     EDX, EAX
        POP      EAX
        JMP      System.@LStrFromPChar
end;
{$ELSE ASM_VERSION} //Pascal
function TStrList.Get(Idx: integer): string;
begin
  if fList <> nil then
    Result := PChar( fList.Items[ Idx ] )
  else Result := '';
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TStrList.GetPChars]
function TStrList.GetPChars(Idx: Integer): PChar;
asm
        MOV      EAX, [EAX].fList
        MOV      EAX, [EAX].TList.fItems
        MOV      EAX, [EAX+EDX*4]
end;
{$ELSE ASM_VERSION} //Pascal
function TStrList.GetPChars(Idx: Integer): PChar;
begin
  Result := PChar( fList.fItems[ Idx ] );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TStrList.GetTextStr]
function TStrList.GetTextStr: string;
asm
        PUSH     ESI
        PUSH     EDI
        MOV      ECX, [EAX].fCount
        MOV      EAX, [EAX].fList
        PUSH     ECX
        JECXZ    @@1
        MOV      ESI, [EAX].TList.fItems
@@1:    PUSH     ESI
        XCHG     EAX, EDX
        XOR      EDX, EDX
        JECXZ    @@10
        PUSH     EAX
@@loo1:
        PUSH     ECX
        PUSH     EDX
        LODSD
        CALL     StrLen
        POP      EDX
        LEA      EDX, [EDX+EAX+2]
        POP      ECX
        LOOP     @@loo1

        POP      EAX
        POP      ESI
        XCHG     ECX, EDX
        PUSH     EAX
@@10:
        {$IFDEF _D2}
        CALL     _LStrFromPCharLen
        {$ELSE}
        CALL     System.@LStrFromPCharLen
        {$ENDIF}

        POP      EDI
        POP      ECX
        JECXZ    @@exit
        MOV      EDI, [EDI]

@@loo2: PUSH     ECX
        LODSD
        PUSH     EAX
        CALL     StrLen
        XCHG     ECX, EAX
        POP      EAX
        XCHG     EAX, ESI
        REP      MOVSB
        XCHG     ESI, EAX
        MOV      AX, $0A0D
        STOSW
        POP      ECX
        LOOP     @@loo2

        XCHG     EAX, ECX
        STOSB
@@exit:
        POP      EDI
        POP      ESI
end;
{$ELSE ASM_VERSION} //Pascal
function TStrList.GetTextStr: string;
var
   I, Len, Size: integer;
   P: PChar;
begin
     Size := 0;

     for I := 0 to fCount - 1 do
       Inc(Size, StrLen( PChar(fList.fItems[I]) ) + 2);

     SetString(Result, nil, Size);

     P := Pointer(Result);
     for I := 0 to Count - 1 do
     begin
       Len := StrLen(PChar(fList.fItems[I]));
       if (Len > 0) then
       begin
         System.Move(PChar(fList.fItems[I])^, P^, Len);
         Inc(P, Len);
       end;
       P^ := #13;
       Inc(P);
       P^ := #10;
       Inc(P);
     end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TStrList.IndexOf]
function TStrList.IndexOf(const S: string): integer;
asm
        PUSH     EBX
        PUSH     ESI
        OR       EBX, -1
        MOV      ECX, [EAX].fCount
        JECXZ    @@exit
        MOV      ESI, [EAX].fList
        MOV      ESI, [ESI].TList.fItems
@@loo:  LODSD
        INC      EBX
        CMP      EAX, EDX
        JE       @@exit
        OR       EDX, EDX
        JZ       @@1
        PUSH     EDX
        PUSH     ECX
        CALL     StrComp
        POP      ECX
        POP      EDX
        JE       @@exit
@@1:    LOOP     @@loo
        OR       EBX, -1
@@exit: XCHG     EAX, EBX
        POP      ESI
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function TStrList.IndexOf(const S: string): integer;
begin
  for Result := 0 to fCount - 1 do
    if (S = PChar( fList.Items[Result] )) then Exit;
  Result := -1;
end;
{$ENDIF ASM_VERSION}

//[function TStrList.Find]
function TStrList.Find(const S: String; var Index: Integer): Boolean;
var
  L, H, I, C: Integer;
begin
  Result := FALSE;
  L := 0;
  H := FCount - 1;
  while L <= H do
  begin
    I := (L + H) shr 1;
    C := AnsiCompareStr( PChar( fList.Items[ I ] ), S );
    if C < 0 then L := I + 1 else
    begin
      H := I - 1;
      if C = 0 then
      begin
        Result := TRUE;
        L := I;
        //break;
        //if Duplicates <> dupAccept then L := I;
      end;
    end;
  end;
  Index := L;
end;

{$IFDEF ASM_VERSION}
//[procedure TStrList.Insert]
procedure TStrList.Insert(Idx: integer; const S: string);
asm
        PUSH     EBX
        PUSH     EDX
        PUSH     ECX
        XCHG     EBX, EAX
        MOV      EAX, [EBX].fList
        TEST     EAX, EAX
        JNZ      @@1
        CALL     NewList
        MOV      [EBX].fList, EAX
@@1:
        POP      EAX
        PUSH     EAX          // push S
        CALL     System.@LStrLen
        INC      EAX
        PUSH     EAX          // push L
        CALL     System.@GetMem
        MOV      byte ptr[EAX], 0
        XCHG     EDX, EAX
        POP      ECX
        POP      EAX
        PUSH     EDX          // push Mem
        TEST     EAX, EAX
        JE       @@2
        CALL     System.Move
@@2:    POP      ECX
        POP      EDX
        MOV      EAX, [EBX].fList
        CALL     TList.Insert
        INC      [EBX].fCount
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TStrList.Insert(Idx: integer; const S: string);
var Mem: PChar;
    L: Integer;
begin
  if fList = nil then
     fList := NewList;
  L := Length( S ) + 1;
  GetMem( Mem, L );
  Mem[0] := #0;
  if L > 1 then
     System.Move( S[1], Mem[0], L );
  fList.Insert( Idx, Mem );
  Inc( fCount );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TStrList.LoadFromFile]
function TStrList.LoadFromFile(const FileName: string): Boolean;
asm
      PUSH     EAX
        XCHG     EAX, EDX
        MOV      EDX, ofOpenRead or ofShareDenyWrite or ofOpenExisting
        CALL     FileCreate
        INC      EAX
        JZ       @@exit
        DEC      EAX
        PUSH     EBX
        XCHG     EBX, EAX
        PUSH     0
        PUSH     EBX
        CALL     GetFileSize
        XOR      EDX, EDX
        PUSH     EDX
        XCHG     ECX, EAX
        MOV      EAX, ESP
        PUSH     ECX
        {$IFDEF _D2}
        CALL     _LStrFromPCharLen
        {$ELSE}
        CALL     System.@LStrFromPCharLen
        {$ENDIF}
        POP      ECX
        MOV      EAX, EBX
        POP      EDX
        PUSH     EDX
        CALL     FileRead
        XCHG     EAX, EBX
        CALL     FileClose
        POP      EDX
        POP      EBX
      POP      EAX
        PUSH     EDX
        XOR      ECX, ECX
        CALL     SetText
        CALL     RemoveStr
        PUSH     EDX
        MOV      AL, 1
@@exit: POP      EDX
end;
{$ELSE ASM_VERSION} //Pascal
function TStrList.LoadFromFile(const FileName: string): Boolean;
var Buf: String;
    F: HFile;
    Sz: Integer;
begin
  F := FileCreate( FileName, ofOpenRead or ofShareDenyWrite or ofOpenExisting );
  Result := F <> INVALID_HANDLE_VALUE;
  if Result then
  begin
    Sz := GetFileSize( F, nil );
    SetString( Buf, nil, Sz );
    FileRead( F, Buf[1], Sz );
    FileClose( F );

    SetText( Buf, False );
  end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TStrList.LoadFromStream]
procedure TStrList.LoadFromStream(Stream: PStream; Append2List: boolean);
asm
        PUSH     EAX
        PUSH     ECX
        PUSH     EBX
        XCHG     EAX, EDX
        MOV      EBX, EAX
        CALL     TStream.GetSize
        PUSH     EAX
        MOV      EAX, EBX
        CALL     TStream.GetPosition
        POP      ECX
        SUB      ECX, EAX
        XOR      EDX, EDX
        PUSH     EDX
        MOV      EAX, ESP
        PUSH     ECX
        {$IFDEF _D2}
        CALL     _LStrFromPCharLen
        {$ELSE}
        CALL     System.@LStrFromPCharLen
        {$ENDIF}
        POP      ECX
        POP      EDX
        XCHG     EAX, EBX
        PUSH     EDX
        CALL     TStream.Read
        POP      EDX
        POP      EBX
        POP      ECX
        POP      EAX
        PUSH     EDX
        CALL     SetText
        CALL     RemoveStr
end;
{$ELSE ASM_VERSION} //Pascal
procedure TStrList.LoadFromStream(Stream: PStream; Append2List: boolean);
var Buf: String;
    Sz: Integer;
begin
  Sz := Stream.Size - Stream.Position;
  SetString( Buf, nil, Sz );
  Stream.Read( Buf[1], Sz );
  SetText( Buf, Append2List );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TStrList.MergeFromFile]
procedure TStrList.MergeFromFile(const FileName: string);
asm
        PUSH     EAX
        XCHG     EAX, EDX
        CALL     NewReadFileStream
        XCHG     EDX, EAX
        POP      EAX
        MOV      CL, 1
        PUSH     EDX
        CALL     LoadFromStream
        POP      EAX
        JMP      TObj.Free
end;
{$ELSE ASM_VERSION} //Pascal
procedure TStrList.MergeFromFile(const FileName: string);
var TmpStream: PStream;
begin
  TmpStream := NewReadFileStream( FileName );
  LoadFromStream( TmpStream, True );
  TmpStream.Free;
end;
{$ENDIF ASM_VERSION}

//[procedure TStrList.Move]
procedure TStrList.Move(CurIndex, NewIndex: integer);
begin
  fList.MoveItem( CurIndex, NewIndex );
end;

{$IFDEF ASM_VERSION}
//[procedure TStrList.Put]
procedure TStrList.Put(Idx: integer; const Value: string);
asm
        PUSH     EAX
        PUSH     EDX
        CALL     Insert
        POP      EDX
        POP      EAX
        INC      EDX
        JMP      Delete
end;
{$ELSE ASM_VERSION} //Pascal
procedure TStrList.Put(Idx: integer; const Value: string);
begin
  Delete( Idx );
  Insert( Idx, Value );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TStrList.SaveToFile]
function TStrList.SaveToFile(const FileName: string): Boolean;
asm
        PUSH     EBX
        PUSH     EAX
        XCHG     EAX, EDX
        MOV      EDX, ofOpenWrite or ofOpenAlways
        CALL     FileCreate
        INC      EAX
        JZ       @@exit
        DEC      EAX
        XCHG     EBX, EAX
        POP      EAX
        PUSH     0
        MOV      EDX, ESP
        CALL     GetTextStr
        POP      EAX
        PUSH     EAX
        CALL     System.@LStrLen
        XCHG     ECX, EAX
        POP      EDX
        PUSH     EDX
        MOV      EAX, EBX
        CALL     FileWrite
        PUSH     EBX
        CALL     SetEndOfFile
        XCHG     EAX, EBX
        CALL     FileClose
        CALL     RemoveStr
        PUSH     EDX
        INC      EAX
@@exit:
        POP      EDX
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function TStrList.SaveToFile(const FileName: string): Boolean;
var F: HFile;
    Buf: String;
begin
  F := FileCreate( FileName, ofOpenWrite or ofOpenAlways );
  Result := F <> INVALID_HANDLE_VALUE;
  if Result then
  begin
    Buf := Text;
    FileWrite( F, Buf[ 1 ], Length( Buf ) );
    SetEndOfFile( F ); // necessary! - V.K.
    FileClose( F );
  end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TStrList.SaveToStream]
procedure TStrList.SaveToStream(Stream: PStream);
asm
        PUSH     EDX
        PUSH     0
        MOV      EDX, ESP
        CALL     GetTextStr
        POP      EAX
        PUSH     EAX
        CALL     System.@LStrLen
        XCHG     ECX, EAX
        POP      EDX
        POP      EAX
        PUSH     EDX
        JECXZ    @@1
        CALL     TStream.Write
@@1:
        CALL     RemoveStr
end;
{$ELSE ASM_VERSION} //Pascal
procedure TStrList.SaveToStream(Stream: PStream);
var S: string;
    L: Integer;
begin
   S := GetTextStr;
   L := Length( S );
   if L <> 0 then
   Stream.Write( S[1], L );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TStrList.SetText]
procedure TStrList.SetText(const S: string; Append2List: boolean);
asm
        DEC      CL
        JZ       @@1
        PUSHAD
        CALL     Clear
        POPAD
@@1:    CALL     EDX2PChar
        JZ       @@exit

        PUSH     EBX
        PUSH     EDI
        MOV      EBX, EAX
        MOV      EDI, [EBX].fTextSiz

        MOV      EAX, [EDX-4] // EAX = Length(S)
        INC      EAX
        PUSH     EAX

        // add S to text buffer
        //CMP      byte ptr [EDX], 0
        //JZ       @@eatb

        PUSH     EDX
        PUSH     [EBX].fTextBuf
        ADD      EAX, [EBX].fTextSiz
        CALL     System.@GetMem
        MOV      [EBX].fTextBuf, EAX

        MOV      ECX, EDI
        XCHG     EDX, EAX
        POP      EAX
        JECXZ    @@atb_fin
        PUSH     EAX
        CALL     System.Move

        POP      EDX
        PUSH     EDX

        PUSH     ESI
        MOV      ESI, [EBX].fList
        MOV      ESI, [ESI].TList.fItems
        MOV      ECX, [EBX].fCount

@@atb_loo:
        LODSD
        SUB      EAX, EDX
        CMP      EAX, [EBX].fTextSiz
        JAE      @@atb_nxt

        ADD      EAX, [EBX].fTextBuf
        MOV      [ESI-4], EAX

@@atb_nxt: LOOP  @@atb_loo

        POP      ESI
        POP      EAX
        CALL     System.@FreeMem
@@atb_fin:
        POP      EAX

        MOV      EDX, EDI
        ADD      EDX, [EBX].fTextBuf
        POP      ECX
        PUSH     ECX
        ADD      [EBX].fTextSiz, ECX

        CALL     System.Move

@@eatb:
        ADD      EDI, [EBX].fTextBuf // EDI ~ P

        MOV      ECX, [EBX].fList
        INC      ECX
        LOOP     @@2
        CALL     NewList
        MOV      [EBX].fList, EAX
@@2:
        POP      ECX
        MOV      EDX, [EBX].fCount

        PUSH     EDI
        PUSH     ECX
        MOV      AL, $0D

@@loo1: CMP      byte ptr [EDI], 0
        JZ       @@eloo1

        INC      EDX
        REPNZ    SCASB
        JNZ      @@eloo1

        CMP      byte ptr [EDI], $0A
        JNZ      @@loo1
        INC      EDI
        LOOP     @@loo1

@@eloo1:
        MOV      [EBX].fCount, EDX
        MOV      EAX, [EBX].fList
        PUSH     EDX
        PUSH     EAX
        CMP      EDX, [EAX].TList.fCapacity
        JLE      @@3
        CALL     TList.SetCapacity
@@3:    POP      EAX
        POP      ECX

        XCHG     ECX, [EAX].TList.fCount
        MOV      EDX, [EAX].TList.fItems
        LEA      EDX, [EDX+ECX*4]

        POP      ECX
        POP      EDI

        MOV      EAX, $0D
@@loo2: CMP      byte ptr [EDI], AH
        JZ       @@eloo2

        MOV      [EDX], EDI
        ADD      EDX, 4

        REPNZ    SCASB
        JNZ      @@eloo2

        MOV      [EDI-1], AH

        CMP      byte ptr [EDI], $0A
        JNZ      @@loo2
        INC      EDI
        LOOP     @@loo2
@@eloo2:

        POP      EDI
        POP      EBX
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
//[procedure TStrList.SetText]
procedure TStrList.SetText(const S: string; Append2List: boolean);
var
  P, TheLast : PChar;
  L, I : Integer;

  procedure AddTextBuf(Src: PChar; Len: DWORD);
  var OldTextBuf, P: PChar;
      I : Integer;
  begin
    if Src <> nil then
    begin
      OldTextBuf := fTextBuf;
      GetMem( fTextBuf, fTextSiz + Len );
      if fTextSiz <> 0 then
      begin
        System.Move( OldTextBuf^, fTextBuf^, fTextSiz );
        for I := 0 to fCount - 1 do
        begin
          P := fList.fItems[ I ];
          if (DWORD( P ) >= DWORD( OldTextBuf )) and
             (DWORD( P ) < DWORD( OldTextBuf ) + fTextSiz) then
            fList.fItems[ I ] := Pointer( DWORD( P ) - DWORD( OldTextBuf ) + DWORD( fTextBuf ) );
        end;
        FreeMem( OldTextBuf );
      end;
      System.Move( Src^, fTextBuf[ fTextSiz ], Len );
      Inc( fTextSiz, Len );
    end;
  end;

begin
     if not Append2List then Clear;
     if S = '' then Exit;

     L := fTextSiz;
     AddTextBuf( PChar( S ), Length( S ) + 1 );

     P := PChar( DWORD( fTextBuf ) + DWORD( L ) );
     if fList = nil then
       fList := NewList;

     I := 0;
     TheLast := P + Length( S );
     while P^ <> #0 do
     begin
       Inc( I );
       P := StrScanLen( P, #13, TheLast - P );
       if P^ = #10 then
         Inc( P );
     end;

     Inc( fCount, I );
     if fList.fCapacity < fCount  then
        fList.Capacity := fCount;

     P := PChar( DWORD( fTextBuf ) + DWORD( L ) );
     while P^ <> #0 do
     begin
       fList.Add( P );
       P := StrScanLen( P, #13, TheLast - P );
       if PChar( P - 1 )^ = #13 then
         PChar( P - 1 )^ := #0;
       if P^ = #10 then Inc(P);
     end;
end;
{$ENDIF ASM_VERSION}

//[procedure TStrList.SetUnixText]
procedure TStrList.SetUnixText(const S: String; Append2List: Boolean);
var S1: String;
begin
  S1 := S;
  NormalizeUnixText( S1 );
  SetText( S1, Append2List );
end;

//[procedure TStrList.SetTextStr]
procedure TStrList.SetTextStr(const Value: string);
begin
  SetText( Value, False );
end;

//[PROCEDURE LowerCaseStrFromPCharEDX]
{$IFDEF ASM_VERSION}
procedure LowerCaseStrFromPCharEDX;
asm
          { <- EDX = PChar string
            -> [ESP] = LowerCase( PChar( EDX ) ),
               EAX, EDX, ECX - ?
          }
        POP      EAX
        PUSH     0
        PUSH     EAX
        LEA      EAX, [ESP+4]
        PUSH     EAX
        CALL     System.@LStrFromPChar
        POP      EDX
        MOV      EAX, [EDX]
        JMP      LowerCase
end;
{$ENDIF ASM_VERSION}
//[END LowerCaseStrFromPCharEDX]

//[FUNCTION CompareStrListItems]
{$IFDEF ASM_VERSION}
function CompareStrListItems( const Sender : Pointer; const e1, e2 : DWORD ) : Integer;
asm
        CMP      [EAX].TStrList.fCaseSensitiveSort, 0
        MOV      EAX, [EAX].TStrList.fList
        MOV      EAX, [EAX].TList.fItems
        MOV      EDX, [EAX+EDX*4]
        MOV      EAX, [EAX+ECX*4]
        XCHG     EAX, EDX
        JNZ      StrComp
        PUSH     EBX

        XCHG     EBX, EAX
        CALL     LowerCaseStrFromPCharEDX

        MOV      EDX, EBX
        CALL     LowerCaseStrFromPCharEDX

        POP      EAX
        POP      EDX
        PUSH     EDX
        PUSH     EAX
        CALL     EAX2PChar
        CALL     EDX2PChar
        CALL     StrComp
        XCHG     EBX, EAX

        CALL     RemoveStr
        CALL     RemoveStr

        XCHG     EAX, EBX
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function CompareStrListItems( const Sender : Pointer; const e1, e2 : DWORD ) : Integer;
var S1, S2 : PChar;
begin
  S1 := PStrList( Sender ).fList.Items[ e1 ];
  S2 := PStrList( Sender ).fList.Items[ e2 ];
  if PStrList( Sender ).fCaseSensitiveSort then
    Result := StrComp( S1, S2 )
  else
    Result := StrComp( PChar( LowerCase( S1 ) ), PChar( LowerCase( S2 ) ) );
end;
{$ENDIF ASM_VERSION}
//[END CompareStrListItems]

//[FUNCTION CompareAnsiStrListItems]
{$IFDEF ASM_VERSION}
function CompareAnsiStrListItems( const Sender : Pointer; const e1, e2 : DWORD ) : Integer;
asm
        CMP      byte ptr [EAX].TStrList.fCaseSensitiveSort, 0
        MOV      EAX, [EAX].TStrList.fList
        MOV      EAX, [EAX].TList.fItems
        MOV      EDX, [EAX+EDX*4]
        MOV      EAX, [EAX+ECX*4]
        XCHG     EAX, EDX
        JZ       _AnsiCompareStrNoCase
        JMP      _AnsiCompareStr
end;
{$ELSE ASM_VERSION} //Pascal
function CompareAnsiStrListItems( const Sender : Pointer; const e1, e2 : DWORD ) : Integer;
var S1, S2 : PChar;
begin
  S1 := PStrList( Sender ).fList.Items[ e1 ];
  S2 := PStrList( Sender ).fList.Items[ e2 ];
  if PStrList( Sender ).fCaseSensitiveSort then
    Result := _AnsiCompareStr( S1, S2 )
  else
    Result := _AnsiCompareStrNoCase( S1, S2 );
end;
{$ENDIF ASM_VERSION}
//[END CompareAnsiStrListItems]

{$IFNDEF ASM_VERSION}
//[procedure SwapStrListItems]
procedure SwapStrListItems( const Sender: Pointer; const e1, e2: DWORD );
begin
  PStrList( Sender ).Swap( e1, e2 );
end;
{$ENDIF}

{$IFDEF ASM_VERSION}
//[procedure TStrList.Sort]
procedure TStrList.Sort(CaseSensitive: Boolean);
asm
        MOV      [EAX].fCaseSensitiveSort, DL
        PUSH     Offset[TStrList.Swap]
        MOV      ECX, Offset[CompareStrListItems]
        MOV      EDX, [EAX].fCount
        CALL     SortData
end;
{$ELSE ASM_VERSION} //Pascal
procedure TStrList.Sort(CaseSensitive: Boolean);
begin
  fCaseSensitiveSort := CaseSensitive;
  SortData( Self, fCount, @CompareStrListItems, @SwapStrListItems );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TStrList.AnsiSort]
procedure TStrList.AnsiSort(CaseSensitive: Boolean);
asm
        MOV      [EAX].fCaseSensitiveSort, DL
        PUSH     Offset[TStrList.Swap]
        MOV      ECX, Offset[CompareAnsiStrListItems]
        MOV      EDX, [EAX].fCount
        CALL     SortData
end;
{$ELSE ASM_VERSION} //Pascal
procedure TStrList.AnsiSort(CaseSensitive: Boolean);
begin
  fCaseSensitiveSort := CaseSensitive;
  SortData( Self, fCount, @CompareAnsiStrListItems, @SwapStrListItems );
end;
{$ENDIF ASM_VERSION}

//[procedure TStrList.Swap]
procedure TStrList.Swap(Idx1, Idx2: Integer);
begin
  fList.Swap( Idx1, Idx2 );
end;

//[function TStrList.Last]
function TStrList.Last: String;
begin
  if Count = 0 then
    Result := ''
  else
    Result := Items[ Count - 1 ];
end;

//-- code by Dod:
//[function TStrList.IndexOfName]
function TStrList.IndexOfName(Name: string): Integer;
var
  i: Integer;
  L: Integer;
begin
  Result:=-1;
  // Do not start search if empty string
  L := Length( Name );
  if L > 0 then
  begin
    Name := LowerCase( Name ) + '=';
    Inc( L );
    for i := 0 to fCount - 1 do
    begin
      // For optimization, check only list entry that begin with same letter as searched name
      if StrLComp( PChar( LowerCase( ItemPtrs[ i ] ) ), PChar( Name ), L ) = 0 then
      begin
        Result:=i;
        exit;
      end;
    end;
  end;
end;

//-- code by Dod:
//[function TStrList.GetValue]
function TStrList.GetValue(const Name: string): string;
var
  i: Integer;
begin
  I := IndexOfName(Name);
  if I >= 0
  then Result := Copy(Items[i], Length(Name) + 2, Length(Items[i])-Length(Name)-1)
  else Result := '';
end;

//-- code by Dod:
//[procedure TStrList.SetValue]
procedure TStrList.SetValue(const Name, Value: string);
var
  I: Integer;
begin
  I := IndexOfName(Name);
  if i=-1
  then Add( Name + '=' + Value )
  else Items[i] := Name + '=' + Value;
end;

//[function TStrList.GetLineName]
function TStrList.GetLineName(Idx: Integer): string;
begin
  Result := Items[ Idx ];
  Result := Parse( Result, '=' );
end;

//[procedure TStrList.SetLineName]
procedure TStrList.SetLineName(Idx: Integer; const NV: string);
begin
  Items[ Idx ] := NV + '=' + LineValue[ Idx ];
end;

//[function TStrList.GetLineValue]
function TStrList.GetLineValue(Idx: Integer): string;
begin
  Result := Items[ Idx ];
  Parse( Result, '=' );
end;

//[procedure TStrList.SetLineValue]
procedure TStrList.SetLineValue(Idx: Integer; const Value: string);
begin
  Items[ Idx ] := LineName[ Idx ] + '=' + Value;
end;

////////////////////////////////// EXTENDED STRING LIST OBJECT ////////////////

{ TStrListEx }

//[function NewStrListEx]
function NewStrListEx: PStrListEx;
begin


  Result := PStrListEx.Create;

end;
//[END NewStrListEx]

//[destructor TStrListEx.Destroy]
destructor TStrListEx.Destroy;
var Obj: PList;
begin
  Obj := FObjects;
  inherited;
  Obj.Free;
end;

//[function TStrListEx.GetObjects]
function TStrListEx.GetObjects(Idx: Integer): DWORD;
begin
  Result := DWORD( FObjects.Items[ Idx ] );
end;

//[procedure TStrListEx.SetObjects]
procedure TStrListEx.SetObjects(Idx: Integer; const Value: DWORD);
begin
  ProvideObjCapacity( Idx + 1 );
  FObjects.Items[ Idx ] := Pointer( Value );
end;

//[procedure TStrListEx.Init]
procedure TStrListEx.Init;
begin
  FObjects := NewList;
end;

//[procedure SwapStrListExItems]
procedure SwapStrListExItems( const Sender: Pointer; const e1, e2: DWORD );
begin
  PStrListEx( Sender ).Swap( e1, e2 );
end;

//[procedure TStrListEx.AnsiSort]
procedure TStrListEx.AnsiSort(CaseSensitive: Boolean);
begin
  fCaseSensitiveSort := CaseSensitive;
  SortData( Self, fCount, @CompareAnsiStrListItems, @SwapStrListExItems );
end;

//[procedure TStrListEx.Sort]
procedure TStrListEx.Sort(CaseSensitive: Boolean);
begin
  fCaseSensitiveSort := CaseSensitive;
  SortData( Self, fCount, @CompareStrListItems, @SwapStrListExItems );
end;

//[procedure TStrListEx.Move]
procedure TStrListEx.Move(CurIndex, NewIndex: integer);
begin
  // move string
  fList.MoveItem( CurIndex, NewIndex );
  // move object
  if FObjects.fCount >= Min( CurIndex, NewIndex ) then
  begin
    ProvideObjCapacity( max( CurIndex, NewIndex ) + 1 );
    FObjects.MoveItem( CurIndex, NewIndex );
  end;
end;

//[procedure TStrListEx.Swap]
procedure TStrListEx.Swap(Idx1, Idx2: Integer);
begin
  // swap strings
  fList.Swap( Idx1, Idx2 );
  // swap objects
  if FObjects.fCount >= Min( Idx1, Idx2 ) then
  begin
    ProvideObjCapacity( max( Idx1, Idx2 ) + 1 );
    FObjects.Swap( Idx1, Idx2 );
  end;
end;

//[procedure TStrListEx.ProvideObjCapacity]
procedure TStrListEx.ProvideObjCapacity(NewCap: Integer);
begin
  if FObjects.FCount < NewCap then
  begin
    FObjects.Capacity := NewCap;
    FillChar( FObjects.FItems[ FObjects.FCount ],
              (FObjects.Capacity - FObjects.Count) * sizeof( Pointer ), 0 );
    FObjects.FCount := NewCap;
  end;
end;

//[procedure TStrListEx.AddStrings]
procedure TStrListEx.AddStrings(Strings: PStrListEx);
var I: Integer;
begin
  I := Count;
  if Strings.FObjects.fCount > 0 then
    ProvideObjCapacity( Count );
  inherited AddStrings( Strings );
  if Strings.FObjects.fCount > 0 then
  begin
    ProvideObjCapacity( I + Strings.FObjects.fCount );
    System.Move( Strings.FObjects.FItems[ 0 ],
                 FObjects.FItems[ I ],
                 Sizeof( Pointer ) * Strings.FObjects.fCount );
  end;
end;

//[procedure TStrListEx.Assign]
procedure TStrListEx.Assign(Strings: PStrListEx);
begin
  inherited Assign( Strings );
  FObjects.Assign( Strings.FObjects );
end;

//[procedure TStrListEx.Clear]
procedure TStrListEx.Clear;
begin
  inherited;
  FObjects.Clear;
end;

//[procedure TStrListEx.Delete]
procedure TStrListEx.Delete(Idx: integer);
begin
  inherited;
  if FObjects.fCount > Idx then // mdw: '>=' -> '>'
    FObjects.Delete( Idx );
end;

//[function TStrListEx.LastObj]
function TStrListEx.LastObj: DWORD;
begin
  if Count = 0 then
    Result := 0
  else
    Result := Objects[ Count - 1 ];
end;

//[function TStrListEx.AddObject]
function TStrListEx.AddObject(const S: String; Obj: DWORD): Integer;
begin
  Result := Count;
  InsertObject( Count, S, Obj );
end;

//[procedure TStrListEx.InsertObject]
procedure TStrListEx.InsertObject(Before: Integer; const S: String; Obj: DWORD);
begin
  Insert( Before, S );
  FObjects.Insert( Before, Pointer( Obj ) );
end;

//[function TStrListEx.IndexOfObj]
function TStrListEx.IndexOfObj( Obj: Pointer ): Integer;
begin
  Result := FObjects.IndexOf( Obj );
end;




//////////////////////////////////////////////////////////////////////////
//
//
//                            S  O  R  T  I  N  G
//
//
//////////////////////////////////////////////////////////////////////////

{ -- qsort -- }

//[PROCEDURE SortData]
{$IFDEF ASM_VERSION} // translated to BASM by Kladov Vladimir
procedure SortData( const Data: Pointer; const uNElem: Dword;
                    const CompareFun: TCompareEvent;
                    const SwapProc: TSwapEvent );
asm
        CMP      EDX, 2
        JL       @@exit

        PUSH     EAX      // [EBP-4] = Data
        PUSH     ECX      // [EBP-8] = CompareFun
        PUSH     EBX      // EBX = pivotP
        XOR      EBX, EBX
        INC      EBX      // EBX = 1 to pass to qSortHelp as PivotP
        MOV      EAX, EDX // EAX = nElem
        CALL     @@qSortHelp
        POP      EBX
        POP      ECX
        POP      ECX
@@exit:
        POP      EBP
        RET      4

@@qSortHelp:
        PUSH     EBX      // EBX (in) = PivotP
        PUSH     ESI      // ESI      = leftP
        PUSH     EDI      // EDI      = rightP

@@TailRecursion:
        CMP      EAX, 2
        JG       @@2
        JNE      @@exit_qSortHelp
        LEA      ECX, [EBX+1]
        MOV      EDX, EBX
        CALL     @@Compare
        JLE      @@exit_qSortHelp
@@swp_exit:
        CALL     @@Swap
@@exit_qSortHelp:
        POP      EDI
        POP      ESI
        POP      EBX
        RET

        // ESI = leftP
        // EDI = rightP
@@2:    LEA      EDI, [EAX+EBX-1]
        MOV      ESI, EAX
        SHR      ESI, 1
        ADD      ESI, EBX
        MOV      ECX, ESI
        MOV      EDX, EDI
        CALL     @@CompareLeSwap
        MOV      EDX, EBX
        CALL     @@Compare

        JG       @@4
        CALL     @@Swap
        JMP      @@5
@@4:    MOV      ECX, EBX
        MOV      EDX, EDI
        CALL     @@CompareLeSwap
@@5:
        CMP      EAX, 3
        JNE      @@6
        MOV      EDX, EBX
        MOV      ECX, ESI
        JMP      @@swp_exit
@@6:    // classic Horae algorithm

        PUSH     EAX     // EAX = pivotEnd
        LEA      EAX, [EBX+1]
        MOV      ESI, EAX
@@repeat:
        MOV      EDX, ESI
        MOV      ECX, EBX
        CALL     @@Compare
        JG       @@while2
@@while1:
        JNE      @@7
        MOV      EDX, ESI
        MOV      ECX, EAX
        CALL     @@Swap
        INC      EAX
@@7:
        CMP      ESI, EDI
        JGE      @@qBreak
        INC      ESI
        JMP      @@repeat
@@while2:
        CMP      ESI, EDI
        JGE      @@until
        MOV      EDX, EBX
        MOV      ECX, EDI
        CALL     @@Compare
        JGE      @@8
        DEC      EDI
        JMP      @@while2
@@8:
        MOV      EDX, ESI
        MOV      ECX, EDI
        PUSHFD
        CALL     @@Swap
        POPFD
        JE       @@until
        INC      ESI
        DEC      EDI
@@until:
        CMP      ESI, EDI
        JL       @@repeat
@@qBreak:
        MOV      EDX, ESI
        MOV      ECX, EBX
        CALL     @@Compare
        JG       @@9
        INC      ESI
@@9:
        PUSH     EBX      // EBX = PivotTemp
        PUSH     ESI      // ESI = leftTemp
        DEC      ESI
@@while3:
        CMP      EBX, EAX
        JGE      @@while3_break
        CMP      ESI, EAX
        JL       @@while3_break
        MOV      EDX, EBX
        MOV      ECX, ESI
        CALL     @@Swap
        INC      EBX
        DEC      ESI
        JMP      @@while3
@@while3_break:
        POP      ESI
        POP      EBX

        MOV      EDX, EAX
        POP      EAX     // EAX = nElem
        PUSH     EDI     // EDI = lNum
        MOV      EDI, ESI
        SUB      EDI, EDX
        ADD      EAX, EBX
        SUB      EAX, ESI

        PUSH     EBX
        PUSH     EAX
        CMP      EAX, EDI
        JGE      @@10

        MOV      EBX, ESI
        CALL     @@qSortHelp
        POP      EAX
        MOV      EAX, EDI
        POP      EBX
        JMP      @@11

@@10:   MOV      EAX, EDI
        CALL     @@qSortHelp
        POP      EAX
        POP      EBX
        MOV      EBX, ESI
@@11:
        POP      EDI
        JMP      @@TailRecursion

@@Compare:
        PUSH     EAX
        PUSH     EDX
        PUSH     ECX
        MOV      EAX, [EBP-4]
        DEC      EDX
        DEC      ECX
        CALL     dword ptr [EBP-8]
        POP      ECX
        POP      EDX
        TEST     EAX, EAX
        POP      EAX
        RET

@@CompareLeSwap:
        CALL     @@Compare
        JG       @@ret

@@Swap: PUSH     EAX
        PUSH     EDX
        PUSH     ECX
        MOV      EAX, [EBP-4]
        DEC      EDX
        DEC      ECX
        CALL     dword ptr [SwapProc]
        POP      ECX
        POP      EDX
        TEST     EAX, EAX
        POP      EAX
@@ret:
        RET

end;
{$ELSE ASM_VERSION} //Pascal
procedure SortData( const Data: Pointer; const uNElem: Dword;
                    const CompareFun: TCompareEvent;
                    const SwapProc: TSwapEvent );
{ uNElem - number of elements to sort }

  function Compare( const e1, e2 : DWord ) : Integer;
  begin
    Result := CompareFun( Data, e1 - 1, e2 - 1 );
  end;

  procedure Swap( const e1, e2 : DWord );
  begin
    SwapProc( Data, e1 - 1, e2 - 1 );
  end;

  procedure qSortHelp(pivotP: Dword; nElem: Dword);
  label
    TailRecursion,
    qBreak;
  var
    leftP, rightP, pivotEnd, pivotTemp, leftTemp: Dword;
    lNum: Dword;
    retval: integer;
  begin
    TailRecursion:
      if (nElem <= 2) then
      begin
        if (nElem = 2) then
          begin
            rightP := pivotP +1;
            retval := Compare(pivotP,rightP);
            if (retval > 0) then Swap(pivotP,rightP);
          end;
        exit;
      end;
      rightP := (nElem -1) + pivotP;
      leftP :=  (nElem shr 1) + pivotP;
      { sort pivot, left, and right elements for "median of 3" }
      retval := Compare(leftP,rightP);
      if (retval > 0) then Swap(leftP, rightP);
      retval := Compare(leftP,pivotP);

      if (retval > 0) then
        Swap(leftP, pivotP)
      else
      begin
        retval := Compare(pivotP,rightP);
        if retval > 0 then Swap(pivotP, rightP);
      end;
      if (nElem = 3) then
      begin
        Swap(pivotP, leftP);
        exit;
      end;
      { now for the classic Horae algorithm }
      pivotEnd := pivotP + 1;
      leftP := pivotEnd;
      repeat

        retval := Compare(leftP, pivotP);
        while (retval <= 0) do
          begin

            if (retval = 0) then
              begin
                Swap(leftP, pivotEnd);
                Inc(pivotEnd);
              end;
            if (leftP < rightP) then
              Inc(leftP)
            else
              goto qBreak;
            retval := Compare(leftP, pivotP);
          end; {while}
        while (leftP < rightP) do
          begin
            retval := Compare(pivotP, rightP);
            if (retval < 0) then
              Dec(rightP)

            else
              begin
                Swap(leftP, rightP);
                if (retval <> 0) then
                  begin
                    Inc(leftP);
                    Dec(rightP);
                  end;
                break;
              end;
          end; {while}

      until (leftP >= rightP);
    qBreak:
      retval := Compare(leftP,pivotP);
      if (retval <= 0) then Inc(leftP);

      leftTemp := leftP -1;
      pivotTemp := pivotP;
      while ((pivotTemp < pivotEnd) and (leftTemp >= pivotEnd)) do
      begin
        Swap(pivotTemp, leftTemp);
        Inc(pivotTemp);
        Dec(leftTemp);
      end; {while}
      lNum := (leftP - pivotEnd);
      nElem := ((nElem + pivotP) -leftP);

      if (nElem < lNum) then
      begin
        qSortHelp(leftP, nElem);
        nElem := lNum;
      end
        else
      begin
        qSortHelp(pivotP, lNum);
        pivotP := leftP;
      end;
      goto TailRecursion;
    end; {qSortHelp }

begin
  if (uNElem < 2) then  exit; { nothing to sort }
  qSortHelp(1, uNElem);
end;
{$ENDIF ASM_VERSION}
//[END SortData]

//[FUNCTION CompareIntegers]
{$IFDEF ASM_VERSION}
function CompareIntegers( const Sender : Pointer; const e1, e2 : DWORD ) : Integer;
asm
        MOV      EDX, [EAX+EDX*4]
        SUB      EDX, [EAX+ECX*4]
        XCHG     EAX, EDX
end;
{$ELSE ASM_VERSION} //Pascal
function CompareIntegers( const Sender : Pointer; const e1, e2 : DWORD ) : Integer;
var I1, I2 : Integer;
begin
  I1 := PInteger( DWORD( Sender ) + e1 * Sizeof( Integer ) )^;
  I2 := PInteger( DWORD( Sender ) + e2 * Sizeof( Integer ) )^;
  Result := 0;
  if I1 < I2 then Result := -1
  else
  if I1 > I2 then Result := 1;
end;
{$ENDIF ASM_VERSION}
//[END CompareIntegers]

//[FUNCTION CompareDwords]
{$IFDEF ASM_VERSION}
function CompareDwords( const Sender : Pointer; const e1, e2 : DWORD ) : Integer;
asm
        MOV      EDX, [EAX+EDX*4]
        SUB      EDX, [EAX+ECX*4]
        XCHG     EAX, EDX
        JNB      @@1
        SBB      EAX, EAX
@@1:
end;
{$ELSE ASM_VERSION} //Pascal
function CompareDwords( const Sender : Pointer; const e1, e2 : DWORD ) : Integer;
var I1, I2 : DWord;
begin
  I1 := PDWORD( DWORD( Sender ) + e1 * Sizeof( Integer ) )^;
  I2 := PDWORD( DWORD( Sender ) + e2 * Sizeof( Integer ) )^;
  Result := 0;
  if I1 < I2 then Result := -1
  else
  if I1 > I2 then Result := 1;
end;
{$ENDIF ASM_VERSION}
//[END CompareDwords]

//[PROCEDURE SwapIntegers]
{$IFDEF ASM_VERSION}
procedure SwapIntegers( const Sender : Pointer; const e1, e2 : DWORD );
asm
        LEA      EDX, [EAX+EDX*4]
        LEA      ECX, [EAX+ECX*4]
        MOV      EAX, [EDX]
        XCHG     EAX, [ECX]
        MOV      [EDX], EAX
end;
{$ELSE ASM_VERSION} //Pascal
procedure SwapIntegers( const Sender : Pointer; const e1, e2 : DWORD );
var Tmp : Integer;
begin
  Tmp := PInteger( DWORD( Sender ) + e1 * SizeOf( Integer ) )^;
  PInteger( DWORD( Sender ) + e1 * Sizeof( Integer ) )^ :=
  PInteger( DWORD( Sender ) + e2 * Sizeof( Integer ) )^;
  PInteger( DWORD( Sender ) + e2 * Sizeof( Integer ) )^ := Tmp;
end;
{$ENDIF ASM_VERSION}
//[END SwapIntegers]

//[procedure SortIntegerArray]
procedure SortIntegerArray( var A : array of Integer );
begin
  SortData( @A[ 0 ], High( A ) - Low( A ) + 1, @CompareIntegers, @SwapIntegers );
end;

//[procedure SortDwordArray]
procedure SortDwordArray( var A : array of DWORD );
begin
  SortData( @A[ 0 ], High( A ) - Low( A ) + 1, @CompareDwords, @SwapIntegers );
end;


{ -- status bar implementation -- }

//[FUNCTION _NewStatusbar]
{$IFDEF ASM_VERSION}
function _NewStatusbar( AParent: PControl ): PControl;
const STAT_CLS_NAM: PChar = STATUSCLASSNAME;
asm
        PUSH     0
        PUSH     0
        //PUSH     EAX
        //CALL     TControl.GetCanResize
        CMP      [EAX].TControl.fSizeGrip, 0
        MOV      ECX, WS_CHILD or WS_CLIPSIBLINGS or WS_CLIPCHILDREN or 3 or WS_VISIBLE
        //MOV      CH, AL  // SBARS_SIZEGRIP =     $0100
        JZ       @@1
        //SETNZ    CH
        INC      CH
        AND      CL, not 3
@@1:
        //POP      EAX
        MOV      EDX, [STAT_CLS_NAM]
        CALL     _NewCommonControl
        PUSH     EBX
        XCHG     EBX, EAX
        PUSH     EDI
        LEA      EDI, [EBX].TControl.fBoundsRect
        XOR      EAX, EAX
        STOSD
        STOSD
        STOSD
        STOSD
        MOV      [EBX].TControl.fAlign, caBottom
        INC      [EBX].TControl.fNotUseAlign
        POP      EDI
        MOV      EAX, EBX
        CALL     InitCommonControlSizeNotify
        XCHG     EAX, EBX
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function _NewStatusbar( AParent: PControl ): PControl;
var Style: DWORD;
    //R: TRect;
begin
  Style := WS_CHILD or WS_CLIPSIBLINGS or WS_CLIPCHILDREN or 3 or WS_VISIBLE;
  {if AParent.CanResize then
     Style := Style or SBARS_SIZEGRIP;}
  if AParent.fSizeGrip then
     Style := (Style or SBARS_SIZEGRIP) and not 3;
  Result := _NewCommonControl( AParent, STATUSCLASSNAME,
            Style, FALSE, nil  );

  with Result.fBoundsRect do
  begin
    Left := 0;
    Right := 0;
    Top := 0;
    Bottom := 0;
  end;
  Result.fAlign := caBottom;
  Result.fNotUseAlign := True;
  {$IFDEF TEST_VERSION}
  Result.fTag := DWORD( PChar( 'Status bar' ) );
  {$ENDIF}
  InitCommonControlSizeNotify( Result );
  //R := AParent.ClientRect;
  //AParent.Perform( WM_SIZING, WMSZ_TOPLEFT, Integer( @ R ) );
  //Result.AttachProc( WndProcEraseBkgnd );
end;
{$ENDIF ASM_VERSION}
//[END _NewStatusbar]

{$IFDEF ASM_VERSION}
//[procedure TControl.SetStatusText]
procedure TControl.SetStatusText(Index: Integer; Value: PChar);
asm
        PUSHAD
        MOV      EBX, EDX // EBX = Index
        MOV      ESI, EAX // ESI = Self

        PUSH     Value // prepare value for call at the end of procedure
        PUSH     EBX   // prepare Index for call at the end of procedure

        MOV      ECX, [ESI].fStatusCtl
        INC      ECX
        LOOP     @@status_created

        CALL     GetClientHeight
        PUSH     EAX // ch = old client height

        MOV      EAX, ESI
        CALL     _NewStatusBar
        MOV      [ESI].fStatusCtl, EAX
        PUSH     EAX //-----------v

        CALL     TControl.GetWindowHandle
        MOV      [ESI].fStatusWnd, EAX
        XCHG     EDI, EAX
        POP      EAX //-----------^

        XOR      EDX, EDX
        PUSH     EDX
        INC      DH
        DEC      EDX
        CMP      EBX, EDX
        SETZ     DL
        NEG      EDX

@@1:    PUSH     EDX
        PUSH     SB_SIMPLE

        PUSH     EAX
        CALL     TControl.Perform

        ADD      ESP, -16
        PUSH     ESP
        PUSH     [ESI].fStatusWnd
        CALL     GetWindowRect
        POP      EAX
        POP      EDX
        POP      EAX
        POP      EAX
        SUB      EAX, EDX
        MOV      [ESI].fClientBottom, EAX

        POP      EDX // ch

        PUSH     0
        PUSH     0
        PUSH     WM_SIZE
        PUSH     EDI

        MOV      EAX, ESI
        CALL     TControl.SetClientHeight

        CALL     SendMessage

@@status_created:
        CMP      EBX, 255
        JGE      @@not_simple

        PUSH     0
        PUSH     0
        PUSH     SB_GETPARTS
        PUSH     [ESI].fStatusWnd
        CALL     SendMessage

        CMP      EAX, EBX
        JG       @@reset_simple

        MOV      EAX, ESI
        CALL     GetWidth
        CDQ
        MOV      ECX, EBX
        INC      ECX
        IDIV     ECX
        MOV      EDX, EAX

        ADD      ESP, -1024
        MOV      ECX, EBX
        MOV      EDI, ESP
        JECXZ    @@2

@@store_loo:
        STOSD
        ADD      EAX, EDX
        LOOP     @@store_loo
@@2:
        OR       dword ptr [ESP+EBX*4], -1
        PUSH     ESP
        INC      EBX
        PUSH     EBX
        PUSH     SB_SETPARTS
        PUSH     [ESI].fStatusWnd
        CALL     SendMessage
        ADD      ESP, 1024

@@reset_simple:
        PUSH     0
        PUSH     0
        PUSH     SB_SIMPLE
        PUSH     [ESI].fStatusWnd
        CALL     SendMessage

@@not_simple:
        PUSH     SB_SETTEXT
        PUSH     [ESI].fStatusWnd
        CALL     SendMessage
        POPAD
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.SetStatusText(Index: Integer; Value: PChar);
var ch: Integer;
    R : TRect;
    N, I, L, W : Integer;
    WidthsBuf: array[ 0..254 ] of Integer;
begin
  if fStatusCtl = nil then
  begin
    ch := GetClientHeight;
    fStatusCtl := _NewStatusBar( Self );
    fStatusWnd := fStatusCtl.GetWindowHandle;
    fStatusCtl.Perform( SB_SIMPLE, Integer( LongBool( Index = 255 ) ), 0 );
    GetWindowRect( fStatusWnd, R );
    fClientBottom := R.Bottom - R.Top;
    SetClientHeight( ch );
    SendMessage( fStatusWnd, WM_SIZE, 0, 0 );
  end;
  if Index < 255 then
  begin
    N := SendMessage( fStatusWnd, SB_GETPARTS, 0, 0 );
    if N <= Index then
    begin
      W := Width;
      L := W div (Index + 1);
      W := L;
      for I := 0 to Index - 1 do
      begin
        WidthsBuf[ I ] := W;
        Inc( W, L );
      end;
      WidthsBuf[ Index ] := -1;
      SendMessage( fStatusWnd, SB_SETPARTS, Index + 1, Integer( @WidthsBuf[ 0 ] ) );
    end;
    SendMessage( fStatusWnd, SB_SIMPLE, 0, 0 );
  end;
  SendMessage( fStatusWnd, SB_SETTEXT, Index, Integer( Value ) );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.GetStatusText]
function TControl.GetStatusText( Index: Integer ): PChar;
asm
        MOV      ECX, [EAX].fStatusWnd
        JECXZ    @@exit

        PUSH     EBX
        PUSH     ESI
        XCHG     ESI, EAX // ESI = Self
        MOV      EBX, EDX // EBX = Index

        XOR      EAX, EAX
        XCHG     EAX, [ESI].fStatusTxt
        TEST     EAX, EAX
        JZ       @@1
        CALL     System.@FreeMem
@@1:
        XOR      EAX, EAX
        CDQ
        MOV      DL, WM_GETTEXTLENGTH
          PUSH     WM_GETTEXT
        CMP      EBX, 255
        JZ       @@2
          POP      EAX
        MOV      EAX, EBX
        MOV      DX, SB_GETTEXTLENGTH
          PUSH     SB_GETTEXT
@@2:
        MOV      EBX, EAX

        PUSH     0
        PUSH     EAX
        PUSH     EDX
        PUSH     [ESI].fStatusWnd
        CALL     SendMessage
        TEST     AX, AX
        JZ       @@get_rslt

        PUSH     EAX
        INC      EAX
        CALL     System.@GetMem
        POP      EDX
        MOV      [ESI].fStatusTxt, EAX
        MOV      byte ptr [EAX+EDX], 0

        POP      EDX // Msg
        PUSH     EAX
        PUSH     EBX
        PUSH     EDX
        PUSH     [ESI].fStatusWnd
        CALL     SendMessage
          PUSH     EDX
@@get_rslt:
          POP      EDX
        MOV      ECX, [ESI].fStatusTxt
        POP      ESI
        POP      EBX

@@exit: XCHG     EAX, ECX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.GetStatusText( Index: Integer ): PChar;
var L, I: Integer;
    Msg: DWORD;
begin
  Result := nil;
  if fStatusWnd = 0 then Exit;
  if fStatusTxt <> nil then
     FreeMem( fStatusTxt );
  fStatusTxt := nil;
  Msg := SB_GETTEXTLENGTH;
  I := Index;
  if Index = 255 then
  begin
     Msg := WM_GETTEXTLENGTH;
     I := 0;
  end;
  L := SendMessage( fStatusWnd, Msg, I, 0 ) and $FFFF;
  if L > 0 then
  begin
    GetMem( fStatusTxt, L + 1 );
    fStatusTxt[ L ] := #0;
    Msg := SB_GETTEXT;
    if Index = 255 then
      Msg := WM_GETTEXT;
    SendMessage( fStatusWnd, Msg, I, Integer( fStatusTxt ) );
  end;
  Result := fStatusTxt;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TControl.RemoveStatus]
procedure TControl.RemoveStatus;
asm
        MOV      ECX, [EAX].fStatusCtl
        JECXZ    @@exit
        PUSH     EBX
        MOV      EBX, EAX
        CALL     GetClientHeight
        PUSH     EAX
        CDQ
        MOV      [EBX].fStatusWnd, EDX
        XCHG     EAX, EDX
        XCHG     [EBX].fStatusCtl, EAX
        CALL     TControl.Free
        POP      EAX
        CDQ
        MOV      [EBX].fClientBottom, EDX
        XCHG     EDX, EAX
        XCHG     EAX, EBX
        POP      EBX
        CALL     SetClientHeight
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.RemoveStatus;
var ch: Integer;
begin
  if fStatusCtl = nil then Exit;
  ch := ClientHeight;
  fStatusWnd := 0;
  fStatusCtl.Free;
  fStatusCtl := nil;
  fClientBottom := 0;
  ClientHeight := ch;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.StatusPanelCount]
function TControl.StatusPanelCount: Integer;
asm
        MOV      EAX, [EAX].fStatusWnd
        TEST     EAX, EAX
        JZ       @@exit
        PUSH     0
        PUSH     0
        PUSH     SB_GETPARTS
        PUSH     EAX
        CALL     SendMessage
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.StatusPanelCount: Integer;
begin
  Result := 0;
  if fStatusWnd = 0 then Exit;
  Result := SendMessage( fStatusWnd, SB_GETPARTS, 0, 0 );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.GetStatusPanelX]
function TControl.GetStatusPanelX(Idx: Integer): Integer;
asm
        MOV      ECX, [EAX].fStatusWnd
        JECXZ    @@exit
        PUSH     EBX
        MOV      EBX, EDX
        ADD      ESP, -1024
        PUSH     ESP
        XOR      EDX, EDX
        DEC      DL
        PUSH     EDX
        MOV      DX, SB_GETPARTS
        PUSH     EDX
        PUSH     ECX
        CALL     SendMessage
        CMP      EAX, EBX
        MOV      ECX, [ESP+EBX*4]
        JG       @@1
        XOR      ECX, ECX
@@1:    ADD      ESP, 1024
        POP      EBX
@@exit:
        XCHG     EAX, ECX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.GetStatusPanelX(Idx: Integer): Integer;
var Buf: array[0..254] of Integer;
    N : Integer;
begin
  Result := 0;
  if fStatusWnd = 0 then Exit;
  N := SendMessage( fStatusWnd, SB_GETPARTS, 255, Integer( @Buf[ 0 ] ) );
  if N <= Idx then Exit;
  Result := Buf[ Idx ];
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TControl.SetStatusPanelX]
procedure TControl.SetStatusPanelX(Idx: Integer; const Value: Integer);
asm
        ADD      ESP, -1024
        MOV      EAX, [EAX].fStatusWnd
        TEST     EAX, EAX
        JZ       @@exit

        PUSH     ESP
        PUSH     EDX
        PUSH     SB_SETPARTS
        PUSH     EAX

        PUSH     EDX
        PUSH     ECX

        LEA      EDX, [ESP+24]
        PUSH     EDX
        PUSH     255
        PUSH     SB_GETPARTS
        PUSH     EAX
        CALL     SendMessage

        POP      ECX
        POP      EDX
        CMP      EAX, EDX
        JG       @@1
        ADD      ESP, 16
        JMP      @@exit

@@1:    MOV      [ESP+8], EAX
        MOV      [ESP+16+EDX*4], ECX
        CALL     SendMessage

@@exit: ADD      ESP, 1024
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.SetStatusPanelX(Idx: Integer; const Value: Integer);
var Buf: array[0..254] of Integer;
    N : Integer;
begin
  if fStatusWnd = 0 then Exit;
  N := SendMessage( fStatusWnd, SB_GETPARTS, 255, Integer( @Buf[ 0 ] ) );
  if N <= Idx then Exit;
  Buf[ Idx ] := Value;
  SendMessage( fStatusWnd, SB_SETPARTS, N, Integer( @Buf[ 0 ] ) );
end;
{$ENDIF ASM_VERSION}

//[procedure TControl.SetColor1]
procedure TControl.SetColor1(const Value: TColor);
begin
  fColor1 := Value;
  Invalidate;
end;

//[procedure TControl.SetColor2]
procedure TControl.SetColor2(const Value: TColor);
begin
  fColor2 := Value;
  Invalidate;
end;

//[procedure TControl.SetGradientLayout]
procedure TControl.SetGradientLayout(const Value: TGradientLayout);
begin
  FGradientLayout := Value;
  Invalidate;
end;

//[procedure TControl.SetGradientStyle]
procedure TControl.SetGradientStyle(const Value: TGradientStyle);
begin
  FGradientStyle := Value;
  Invalidate;
end;












{ -- Image List -- }

//*
{$IFDEF USE_CONSTRUCTORS}
//[function NewImageList]
function NewImageList( AOwner: PControl ): PImageList;
begin
  new( Result, CreateImageList( AOwner ) );
end;
//[END NewImageList]
{$ELSE not_USE_CONSTRUCTORS}
//[function NewImageList]
function NewImageList( AOwner: PControl ): PImageList;
begin
  {*************} DoInitCommonControls( ICC_WIN95_CLASSES );

  Result := TImageList.Create;
  Result.FAllocBy := 1;
  Result.FMasked := True;
  if AOwner = nil then exit;

  Result.FControl := AOwner;
  Result.fNext := PImageList( AOwner.fImageList );
  if AOwner.fImageList <> nil then
     PImageList( AOwner.fImageList ).fPrev := Result;
  Result.fBkColor := clNone;
  //ImageList_SetBkColor( Result.FHandle, CLR_NONE );
  AOwner.fImageList := Result;
  Result.FImgWidth := 32;
  Result.FImgHeight := 32;
  Result.FColors := ilcDefault;
end;
{$ENDIF}

//[API ImageList_XXX]
function ImageList_Create; stdcall; external cctrl name 'ImageList_Create';
function ImageList_Destroy; external cctrl name 'ImageList_Destroy';
function ImageList_GetImageCount; external cctrl name 'ImageList_GetImageCount';
function ImageList_SetImageCount; external cctrl name 'ImageList_SetImageCount';
function ImageList_Add; external cctrl name 'ImageList_Add';
function ImageList_ReplaceIcon; external cctrl name 'ImageList_ReplaceIcon';
function ImageList_SetBkColor; external cctrl name 'ImageList_SetBkColor';
function ImageList_GetBkColor; external cctrl name 'ImageList_GetBkColor';
function ImageList_SetOverlayImage; external cctrl name 'ImageList_SetOverlayImage';
function ImageList_Draw; external cctrl name 'ImageList_Draw';
function ImageList_Replace; external cctrl name 'ImageList_Replace';
function ImageList_AddMasked; external cctrl name 'ImageList_AddMasked';
function ImageList_DrawEx; external cctrl name 'ImageList_DrawEx';
function ImageList_Remove; external cctrl name 'ImageList_Remove';
function ImageList_GetIcon; external cctrl name 'ImageList_GetIcon';
function ImageList_LoadImageA; external cctrl name 'ImageList_LoadImageA';
function ImageList_LoadImageW; external cctrl name 'ImageList_LoadImageW';
function ImageList_LoadImage; external cctrl name 'ImageList_LoadImageA';
function ImageList_BeginDrag; external cctrl name 'ImageList_BeginDrag';
function ImageList_EndDrag; external cctrl name 'ImageList_EndDrag';
function ImageList_DragEnter; external cctrl name 'ImageList_DragEnter';
function ImageList_DragLeave; external cctrl name 'ImageList_DragLeave';
function ImageList_DragMove; external cctrl name 'ImageList_DragMove';
function ImageList_SetDragCursorImage; external cctrl name 'ImageList_SetDragCursorImage';
function ImageList_DragShowNolock; external cctrl name 'ImageList_DragShowNolock';
function ImageList_GetDragImage; external cctrl name 'ImageList_GetDragImage';
//function ImageList_Read; external cctrl name 'ImageList_Read';
//function ImageList_Write; external cctrl name 'ImageList_Write';
function ImageList_GetIconSize; external cctrl name 'ImageList_GetIconSize';
function ImageList_SetIconSize; external cctrl name 'ImageList_SetIconSize';
function ImageList_GetImageInfo; external cctrl name 'ImageList_GetImageInfo';
function ImageList_Merge; external cctrl name 'ImageList_Merge';

//[function ImageList_AddIcon]
function ImageList_AddIcon(ImageList: HImageList; Icon: HIcon): Integer;
begin
  Result := ImageList_ReplaceIcon(ImageList, -1, Icon);
end;

//[function Index2OverlayMask]
function Index2OverlayMask(Index: Integer): Integer;
begin
  Result := Index shl 8;
end;

{ macros }
//[procedure ImageList_RemoveAll]
procedure ImageList_RemoveAll(ImageList: HImageList); stdcall;
begin
  ImageList_Remove(ImageList, -1);
end;

//[function ImageList_ExtractIcon]
function ImageList_ExtractIcon(Instance: THandle; ImageList: HImageList;
  Image: Integer): HIcon; stdcall;
begin
  Result := ImageList_GetIcon(ImageList, Image, 0);
end;

//[function ImageList_LoadBitmap]
function ImageList_LoadBitmap(Instance: THandle; Bmp: PChar;
  CX, Grow: Integer; Mask: TColorRef): HImageList; stdcall;
begin
  Result := ImageList_LoadImage(Instance, Bmp, CX, Grow, Mask,
    IMAGE_BITMAP, 0);
end;

//[procedure FreeBmp]
procedure FreeBmp( Bmp: HBitmap );
begin
  DeleteObject( Bmp );
end;

//[function LoadBmp]
function LoadBmp( Instance: Integer; Rsrc: PChar; MasterObj: PObj ): HBitmap;
begin
  Result := LoadBitmap( Instance, Rsrc );
  MasterObj.Add2AutoFreeEx( TObjectMethod( MakeMethod( Pointer( Result ), @ FreeBmp ) ) );
end;

{ TImageList }

//*
//[function TImageList.Add]
function TImageList.Add(Bmp, Msk: HBitmap): Integer;
begin
  Result := -1;
  if not HandleNeeded then Exit;
  Result := ImageList_Add( FHandle, Bmp, Msk );
end;

//*
//[function TImageList.AddIcon]
function TImageList.AddIcon(Ico: HIcon): Integer;
{var Bmp : HBitmap;
    DC : HDC;}
begin
  Result := -1;
  if ImgWidth = 0 then
    ImgWidth := 32;
  if ImgHeight = 0 then
    ImgHeight := 32;
  if not HandleNeeded then Exit;

  {DC := GetDC( 0 );
  Bmp := CreateCompatibleBitmap( DC, ImgWidth, ImgHeight );
  Result := AddMasked( Bmp, 0 );
  DeleteObject( Bmp );
  ReleaseDC( 0, DC );
  if Result >= 0 then
     ReplaceIcon( Result, Ico );}
  Result := ImageList_AddIcon( fHandle, Ico );
end;

//*
//[function TImageList.AddMasked]
function TImageList.AddMasked(Bmp: HBitmap; Color: TColor): Integer;
begin
  Result := -1;
  if not HandleNeeded then Exit;
  Result := ImageList_AddMasked( FHandle, Bmp, Color2RGB( Color ) );
end;

//+
//[procedure TImageList.Clear]
procedure TImageList.Clear;
begin
  Handle := 0;
end;

//*
//[procedure TImageList.Delete]
procedure TImageList.Delete(Idx: Integer);
begin
   if FHandle = 0 then Exit;
   ImageList_Remove( FHandle, Idx );
end;

{$IFDEF ASM_VERSION}
//[destructor TImageList.Destroy]
destructor TImageList.Destroy;
asm
        PUSH     EAX
        XOR      EDX, EDX
        CALL     SetHandle
        POP      EAX
        MOV      EDX, [EAX].fNext
        MOV      ECX, [EAX].fPrev
        TEST     EDX, EDX
        JZ       @@nonext
        MOV      [EDX].fPrev, ECX
@@nonext:
        JECXZ    @@noprev
        MOV      [ECX].fNext, EDX
@@noprev:
        MOV      ECX, [EAX].fControl
        JECXZ    @@fin
        CMP      [ECX].TControl.fImageList, EAX
        JNZ      @@fin
        MOV      [ECX].TControl.fImageList, EDX
@@fin:  CALL     TObj.Destroy
end;
{$ELSE ASM_VERSION} //Pascal
destructor TImageList.Destroy;
begin
  Clear;
  if fNext <> nil then
    fNext.fPrev := fPrev;
  if fPrev <> nil then
    fPrev.fNext := fNext;
  if fControl <> nil then
  if PControl( fControl ).fImageList = Self then
    PControl( fControl ).fImageList := fNext;
  inherited;
end;
{$ENDIF ASM_VERSION}

//*
//[procedure TImageList.Draw]
procedure TImageList.Draw(Idx: Integer; DC: HDC; X, Y: Integer);
begin
  if FHandle = 0 then Exit;
  ImageList_Draw( FHandle, Idx, DC, X, Y, GetDrawStyle );
end;

//[function TImageList.ExtractIcon]
function TImageList.ExtractIcon(Idx: Integer): HIcon;
begin
  Result := ImageList_ExtractIcon( 0, FHandle, Idx );
end;

//[function TImageList.ExtractIconEx]
function TImageList.ExtractIconEx(Idx: Integer): HIcon;
begin
  Result := ImageList_GetIcon( FHandle, Idx, GetDrawStyle );
end;

//*
//[function TImageList.GetBitmap]
function TImageList.GetBitmap: HBitmap;
var II : TImageInfo;
begin
  Result := 0;
  if FHandle = 0 then Exit;
  if ImageList_GetImageInfo( FHandle, 0, II ) then
     Result := II.hbmImage;
end;

//*
//[function TImageList.GetBkColor]
function TImageList.GetBkColor: TColor;
begin
  Result := fBkColor;
  if FHandle = 0 then Exit;
  Result := ImageList_GetBkColor( FHandle );
end;

//*
//[function TImageList.GetCount]
function TImageList.GetCount: Integer;
begin
  Result := 0;
  if FHandle <> 0 then
     Result := ImageList_GetImageCount( FHandle );
end;

//*
//[function TImageList.GetDrawStyle]
function TImageList.GetDrawStyle: DWord;
begin
  Result := 0;
  if dsBlend25 in DrawingStyle then
     Result := Result or ILD_BLEND25;
  if dsBlend50 in DrawingStyle then
     Result := Result or ILD_BLEND50;
  if dsTransparent in DrawingStyle then
     Result := Result or ILD_TRANSPARENT
  else
  if dsMask in DrawingStyle then
     Result := Result or ILD_MASK
  {else
     Result := Result or ILD_NORMAL}; // ILD_NORMAL = 0
end;

{$IFDEF ASM_VERSION}
//[function TImageList.GetHandle]
function TImageList.GetHandle: THandle;
asm
        PUSH     EAX
        CALL     HandleNeeded
        POP      EAX
        MOV      EAX, [EAX].FHandle
end;
{$ELSE ASM_VERSION} //Pascal
function TImageList.GetHandle: THandle;
begin
  HandleNeeded;
  Result := FHandle;
end;
{$ENDIF ASM_VERSION}

//*
//[function TImageList.GetMask]
function TImageList.GetMask: HBitmap;
var II : TImageInfo;
begin
  Result := 0;
  if FHandle = 0 then Exit;
  if ImageList_GetImageInfo( FHandle, 0, II ) then
     Result := II.hbmMask;
end;

{$IFDEF ASM_noVERSION}
//[function TImageList.HandleNeeded]
function TImageList.HandleNeeded: Boolean;
const ColorFlags : array[ TImageListColors ] of Byte = ( ILC_COLOR,
                 ILC_COLOR4, ILC_COLOR8, ILC_COLOR16, ILC_COLOR24,
                 ILC_COLOR32, ILC_COLORDDB );
asm
        MOV      ECX, [EAX].FHandle
        JECXZ    @@make_handle
        MOV      AL, 1
        RET
@@make_handle:
        MOV      ECX, [EAX].fImgWidth
        JECXZ    @@ret_ECX
        MOV      EDX, ECX
        MOV      ECX, [EAX].fImgHeight
        JECXZ    @@ret_ECX
        PUSH     EBX
        XCHG     EBX, EAX

        PUSH     [EBX].FAllocBy
        PUSH     0
        MOVZX    EAX, [EBX].FColors
        MOVZX    EAX, byte ptr [ColorFlags+EAX]
        CMP      [EBX].FMasked, 0
        JZ       @@flags_ready
        {$IFDEF PARANOIA}
        DB $0C, $01
        {$ELSE}
        OR AL, 1
        {$ENDIF}
@@flags_ready:
        PUSH     EAX
        PUSH     ECX
        PUSH     EDX
        CALL     ImageList_Create
        MOV      [EBX].FHandle, EAX
        XCHG     ECX, EAX
        POP      EBX
@@ret_ECX:
        TEST     ECX, ECX
        SETNZ    AL
end;
{$ELSE ASM_VERSION} //Pascal
function TImageList.HandleNeeded: Boolean;
const ColorFlags : array[ TImageListColors ] of Byte = ( ILC_COLOR,
                 ILC_COLOR4, ILC_COLOR8, ILC_COLOR16, ILC_COLOR24,
                 ILC_COLOR32, ILC_COLORDDB, 0 );
var Flags : DWord;
begin
  Result := True;
  if FHandle <> 0 then Exit;
  Result := False;
  if ImgWidth = 0 then Exit;
  if ImgHeight = 0 then Exit;
  Flags := ColorFlags[ FColors ];
  if Masked then
     Flags := Flags or ILC_MASK;
  FHandle := ImageList_Create( ImgWidth, ImgHeight, Flags, 0, FAllocBy );
  if fBkColor <> clNone then
    SetBkColor( fBkColor );
  Result := FHandle <> 0;
end;
{$ENDIF ASM_VERSION}

//*
//[function TImageList.ImgRect]
function TImageList.ImgRect(Idx: Integer): TRect;
var II : TImageInfo;
begin
  Result := MakeRect( 0, 0, 0, 0 );
  if FHandle = 0 then Exit;
  if ImageList_GetImageInfo( FHandle, Idx, II ) then
     Result := II.rcImage;
end;

{$IFDEF ASM_noVERSION}
//[function TImageList.LoadBitmap]
function TImageList.LoadBitmap(ResourceName: PChar;
  TranspColor: TColor): Boolean;
asm
        PUSH     EBX
        XCHG     EBX, EAX
        XCHG     EAX, ECX //TranspColor
        PUSH     EDX
        CMP      EAX, clNone
        JNE      @@2rgb
        OR       EAX, -1
        JMP      @@tranColorReady
@@2rgb:
        CALL     Color2RGB
@@tranColorReady:
        POP      EDX
        PUSH     EAX
        PUSH     [EBX].fAllocBy
        PUSH     [EBX].fImgWidth
        PUSH     EDX
        PUSH     [hInstance]
        CALL     ImageList_LoadBitmap
        TEST     EAX, EAX
        JZ       @@exit
        XCHG     EDX, EAX
        XCHG     EAX, EBX
        CALL     SetHandle
        MOV      AL, 1
@@exit: POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function TImageList.LoadBitmap(ResourceName: PChar;
  TranspColor: TColor): Boolean;
var NewHandle : THandle;
    TranColr: TColor;
begin
  TranColr := TranspColor;
  if TranColr = clNone then TranColr := TColor( CLR_NONE )
  else TranColr := Color2RGB( TranColr );
  NewHandle := ImageList_LoadBitmap( hInstance, ResourceName,
            ImgWidth, AllocBy, TranColr );
  //ImageList_GetIconSize( NewHandle, fImgWidth, fImgHeight );
  Result := NewHandle <> 0;
  if Result then
     Handle := NewHandle;
  ImageList_GetIconSize( fHandle, FImgWidth, FImgHeight );
end;
{$ENDIF ASM_VERSION}

//*
//[function TImageList.LoadFromFile]
function TImageList.LoadFromFile(FileName: PChar; TranspColor: TColor;
  ImgType: TImageType): Boolean;
const ImgTypes:array[ TImageType ] of DWord = ( IMAGE_BITMAP, IMAGE_ICON, IMAGE_CURSOR );
var NewHandle : THandle;
    TranspFlag : DWord;
begin
  TranspFlag := 0;
  if TranspColor <> clNone then
     TranspFlag := LR_LOADTRANSPARENT;
  NewHandle := ImageList_LoadImage( hInstance, FileName, ImgWidth, AllocBy, Color2RGB( TranspColor ),
                                    ImgTypes[ ImgType ], LR_LOADFROMFILE or TranspFlag );
  Result := NewHandle <> 0;
  if Result then
     Handle := NewHandle;
end;

//*
//[function TImageList.LoadSystemIcons]
function TImageList.LoadSystemIcons(SmallIcons: Boolean): Boolean;
var NewHandle : THandle;
    FileInfo : TSHFileInfo;
    Flags : DWord;
begin
  OleInit;
  Flags := SHGFI_SYSICONINDEX;
  if SmallIcons then
     Flags := Flags or SHGFI_SMALLICON;
  NewHandle := SHGetFileInfo( '', 0, FileInfo, Sizeof( FileInfo ), Flags );
  Result := NewHandle <> 0;
  if Result then
  begin
     Handle := NewHandle;
     FShareImages := True;
  end;
end;

//*
//[function TImageList.Merge]
function TImageList.Merge(Idx: Integer; ImgList2: PImageList; Idx2, X,
  Y: Integer): PImageList;
var L : THandle;
begin
  Result := nil;
  //if FHandle = 0 then Exit;
  L := ImageList_Merge( FHandle, Idx, ImgList2.Handle, Idx2, X, Y );
  if L <> 0 then
  begin
     Result := NewImageList( fControl );
     Result.Handle := L;
  end;
end;

//*
//[function TImageList.Replace]
function TImageList.Replace(Idx: Integer; Bmp, Msk: HBitmap): Boolean;
begin
  Result := False;
  if FHandle = 0 then Exit;
  Result := ImageList_Replace( FHandle, Idx, Bmp, Msk );
end;

//*
//[function TImageList.ReplaceIcon]
function TImageList.ReplaceIcon(Idx: Integer; Ico: HIcon): Boolean;
begin
  Result := False;
  if FHandle = 0 then Exit;
  Result := ImageList_ReplaceIcon( FHandle, Idx, Ico ) >= 0;
end;

//*
//[procedure TImageList.SetAllocBy]
procedure TImageList.SetAllocBy(const Value: Integer);
begin
  if FHandle <> 0 then Exit;
     // AllocBy can be changed only before adding images
     // and creating image list handle
  FAllocBy := Value;
end;

//*
//[procedure TImageList.SetBkColor]
procedure TImageList.SetBkColor(const Value: TColor);
begin
  fBkColor := Value;
  if fHandle <> 0 then
    ImageList_SetBkColor( FHandle, Color2RGB( Value ) );
end;

//*
//[procedure TImageList.SetColors]
procedure TImageList.SetColors(const Value: TImageListColors);
begin
  if FHandle <> 0 then Exit;
  FColors := Value;
end;

{$IFDEF ASM_VERSION}
//[procedure TImageList.SetHandle]
procedure TImageList.SetHandle(const Value: THandle);
asm
        PUSH     EBX
        XCHG     EBX, EAX
        MOV      ECX, [EBX].FHandle
        CMP      ECX, EDX
        JZ       @@exit
        JECXZ    @@set_handle
        CMP      [EBX].fShareImages, 0
        JNZ      @@set_handle
        PUSH     EDX
        PUSH     ECX
        CALL     ImageList_Destroy
        POP      EDX

@@set_handle:
        MOV      [EBX].FHandle, EDX
        TEST     EDX, EDX
        JZ       @@set_sz0
        LEA      EAX, [EBX].FImgHeight
        PUSH     EAX
        LEA      EAX, [EBX].FImgWidth
        PUSH     EAX
        PUSH     EDX
        CALL     ImageList_GetIconSize
        JMP      @@exit

@@set_sz0:
        MOV      [EBX].fImgWidth, EDX
        MOV      [EBX].fImgHeight, EDX

@@exit:
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TImageList.SetHandle(const Value: THandle);
begin
  if FHandle = Value then Exit;
  if (FHandle <> 0) and not FShareImages then
     ImageList_Destroy( FHandle );
  FHandle := Value;
  if FHandle <> 0 then
     ImageList_GetIconSize( FHandle, FImgWidth, FImgHeight )
  else
  begin
    FImgWidth := 0;
    FImgHeight := 0;
  end;
  //FBkColor := ImageList_GetBkColor( FHandle );
end;
{$ENDIF ASM_VERSION}

//[procedure TImageList.SetImgHeight]
procedure TImageList.SetImgHeight(const Value: Integer);
begin
  if FHandle <> 0 then Exit;
  FImgHeight := Value;
end;

//[procedure TImageList.SetImgWidth]
procedure TImageList.SetImgWidth(const Value: Integer);
begin
  if FHandle <> 0 then Exit;
  FImgWidth := Value;
end;

//[procedure TImageList.SetMasked]
procedure TImageList.SetMasked(const Value: Boolean);
begin
  if FHandle <> 0 then Exit;
  FMasked := Value;
end;

//*
//[function TImageList.GetOverlay]
function TImageList.GetOverlay(Idx: TImgLOVrlayIdx): Integer;
begin
  Result := fOverlay[ Idx ];
end;

//[procedure TImageList.SetOverlay]
procedure TImageList.SetOverlay(Idx: TImgLOVrlayIdx; const Value: Integer);
begin
  if ImageList_SetOverlayImage( fHandle, Value, Idx shl 8 ) then
    fOverlay[ Idx ] := Value;
end;

//[procedure TImageList.StretchDraw]
procedure TImageList.StretchDraw(Idx: Integer; DC: HDC; const Rect: TRect);
begin
  if FHandle = 0 then Exit;
  ImageList_DrawEx( FHandle, Idx, DC, Rect.Left, Rect.Top,
                    Rect.Right- Rect.Left, Rect.Bottom-Rect.Top,
                    BkColor, BlendColor, GetDrawStyle );
end;

//*
//[function GetImgListSize]
function GetImgListSize( Sender: PControl; Size: Integer ): PImageList;
begin
  if Size > 16 then
    Result := Sender.fCtlImageListNormal
  else
    Result := Sender.fCtlImageListSml;
  if Result <> nil then
  begin
    if Result.fImgWidth = 0 then
      Result.ImgWidth := Size;
    if Result.fImgHeight = 0 then
      Result.ImgHeight := Size;
    //if (Result.FImgWidth <> Size) or (Result.FImgHeight <> Size) then
    //  Result := nil;
  end;
  if Result = nil then
  begin
    Result := Sender.fImageList;
    while Result <> nil do
    begin
      if (Result.FImgWidth = Size) and (Result.FImgHeight = Size) then
        break;
      Result := Result.fNext;
    end;
  end;
end;

//*
//[function TControl.GetImgListIdx]
function TControl.GetImgListIdx(const Index: Integer): PImageList;
begin
  if Index <> 0 then
    Result := GetImgListSize( Self, Index )
  else
  begin
    Result := fCtlImgListState;
    if Result = nil then
    begin
      Result := fImageList;
      while Result <> nil do
      begin
        if (Result <> GetImgListIdx( 16 )) and (Result <> GetImgListIdx( 32 )) then
           break;
        Result := Result.fNext;
      end;
    end;
  end;
end;

//*
//[procedure TControl.SetImgListIdx]
procedure TControl.SetImgListIdx(const Index: Integer;
  const Value: PImageList);
begin

  if Value <> nil then
  begin
    if Index <> 0 then
    if (Value.ImgWidth = 0) or (Value.ImgHeight = 0) then
    begin
      Value.ImgWidth := Index;
      Value.ImgHeight := Index;
    end;
  end;

  case Index of
  32: fCtlImageListNormal := Value;
  16: fCtlImageListSml := Value;
  else fCtlImgListState := Value;
  end;
  ApplyImageLists2Control( Self );
end;

{ -- list view -- }

//[function WndProcEndLabelEdit]
function WndProcEndLabelEdit( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var NMhdr: PNMHdr;
    LVDisp: PLVDispInfo;
    {$IFNDEF _FPC}
    {$IFNDEF _D2}
    {$IFDEF UNICODE_CTRLS}
    LVDispW: PLVDispInfoW;
    {$ENDIF UNICODE_CTRLS}
    {$ENDIF _D2}
    {$ENDIF _FPC}
    Flag: Boolean;
begin
  Result := False;
  if Msg.message = WM_NOTIFY then
  begin
    NMHdr := Pointer( Msg.lParam );
    case NMHdr.code of
      LVN_ENDLABELEDIT {$IFDEF UNICODE_CTRLS}, LVN_ENDLABELEDITW {$ENDIF UNICODE_CTRLS}:
        begin
          LVDisp := Pointer( Msg.lParam );
          Result := True;
          if LVDisp.item.pszText = nil then Exit;
          Rslt := 1;
          if assigned( Self_.fOnEditLVItem ) then
          begin
          {$IFNDEF _FPC}
          {$IFNDEF _D2}
          {$IFDEF UNICODE_CTRLS}
            if NMHdr.code = LVN_ENDLABELEDITW then
            begin
              LVDispW := Pointer( LVDisp );
              Flag := Self_.fOnEditLVItem( Self_, LVDispW.item.iItem,
                   LVDispW.item.iSubItem, PChar( LVDispW.item.pszText ) );
            end else
          {$ENDIF UNICODE_CTRLS}
          {$ENDIF _D2}
          {$ENDIF _FPC}
            Flag := Self_.fOnEditLVItem( Self_, LVDisp.item.iItem,
                             LVDisp.item.iSubItem, LVDisp.item.pszText );
            if Flag then Rslt := 1
                    else Rslt := 0;
          end;
        end;
    end;
  end;
end;

//[procedure TControl.SetOnEditLVItem]
procedure TControl.SetOnEditLVItem(const Value: TOnEditLVItem);
begin
  fOnEditLVITem := Value;
  AttachProc( WndProcEndLabelEdit );
end;

//*
//[procedure TControl.LVColAdd]
procedure TControl.LVColAdd(const aText: String; aalign: TTextAlign;
  aWidth: Integer);
begin
////////////////////////////////////////////////////
//LVColInsert( fLVColCount + 1, aText, aalign, aWidth );
//////////////////////////////////////////////////////
  LVColInsert( fLVColCount, aText, aalign, aWidth );// 21.10.2001
  ////////////////////////////////////////////////////
end;

{$IFNDEF _FPC}
{$IFNDEF _D2}
//[procedure TControl.LVColAddW]
procedure TControl.LVColAddW(const aText: WideString; aalign: TTextAlign;
  aWidth: Integer);
begin
  LVColInsertW( fLVColCount, aText, aalign, aWidth );
end;
{$ENDIF _D2}
{$ENDIF _FPC}

//****************** changed by Mike Gerasimov
//[procedure TControl.LVColInsert]
procedure TControl.LVColInsert(ColIdx: Integer; const aText: String;
  aAlign: TTextAlign; aWidth: Integer);
var LVColData: TLVColumn;
begin
  LVColData.mask := LVCF_FMT or LVCF_TEXT;
  if ImageListSmall <> nil then
    LVColData.mask := LVColData.mask; // or LVCF_IMAGE ;
  LVColData.iImage := -1;
  LVColData.fmt := Ord( aAlign );
  if aWidth < 0 then
  begin
    aWidth := -aWidth;
    LVColData.fmt := LVColData.fmt or LVCFMT_BITMAP_ON_RIGHT;
  end;
  LVColData.cx := aWidth;
  if aWidth > 0 then
    LVColData.mask := LVColData.mask or LVCF_WIDTH;
  LVColData.pszText := PChar( aText );
  if Perform( LVM_INSERTCOLUMN, ColIdx, Integer( @LVColData ) ) >= 0 then
    Inc( fLVColCount );
end;

{$IFNDEF _FPC}
{$IFNDEF _D2}
//[procedure TControl.LVColInsertW]
procedure TControl.LVColInsertW(ColIdx: Integer; const aText: WideString;
  aAlign: TTextAlign; aWidth: Integer);
var LVColData: TLVColumnW;
begin
  LVColData.mask := LVCF_FMT or LVCF_TEXT;
  if ImageListSmall <> nil then
    LVColData.mask := LVColData.mask; // or LVCF_IMAGE ;
  LVColData.iImage := -1;
  LVColData.fmt := Ord( aAlign );
  if aWidth < 0 then
  begin
    aWidth := -aWidth;
    LVColData.fmt := LVColData.fmt or LVCFMT_BITMAP_ON_RIGHT;
  end;
  LVColData.cx := aWidth;
  if aWidth > 0 then
    LVColData.mask := LVColData.mask or LVCF_WIDTH;
  LVColData.pszText := PWideChar( aText );
  if Perform( LVM_INSERTCOLUMNW, ColIdx, Integer( @LVColData ) ) >= 0 then
    Inc( fLVColCount );
end;
{$ENDIF _D2}
{$ENDIF _FPC}

//[function TControl.GetLVColText]
function TControl.GetLVColText(Idx: Integer): String;
var Buf: array[ 0..4095 ] of Char;
    LC: TLVColumn;
begin
  LC.mask := LVCF_TEXT;
  LC.pszText := @ Buf[ 0 ];
  LC.cchTextMax := Sizeof( Buf );
  Buf[ 0 ] := #0;
  Perform( LVM_GETCOLUMN, Idx, Integer( @ LC ) );
  Result := Buf;
end;

//[procedure TControl.SetLVColText]
procedure TControl.SetLVColText(Idx: Integer; const Value: String);
var LC: TLVColumn;
begin
  FillChar( LC, Sizeof( LC ), 0 ); {Alexey (Lecha2002)}
  LC.mask := LVCF_TEXT;
  LC.pszText := '';
  if Value <> '' then
    LC.pszText := @ Value[ 1 ];
  Perform( LVM_SETCOLUMN, Idx, Integer( @ LC ) );
end;

{$IFNDEF _FPC}
{$IFNDEF _D2}
//[function TControl.GetLVColTextW]
function TControl.GetLVColTextW(Idx: Integer): WideString;
var Buf: array[ 0..4095 ] of WideChar;
    LC: TLVColumnW;
begin
  LC.mask := LVCF_TEXT;
  LC.pszText := @ Buf[ 0 ];
  LC.cchTextMax := High( Buf ) + 1;
  Buf[ 0 ] := #0;
  Perform( LVM_GETCOLUMNW, Idx, Integer( @ LC ) );
  Result := Buf;
end;

//[procedure TControl.SetLVColTextW]
procedure TControl.SetLVColTextW(Idx: Integer; const Value: WideString);
var LC: TLVColumnW;
begin
  FillChar( LC, Sizeof( LC ), 0 );
  LC.mask := LVCF_TEXT;
  LC.pszText := '';
  if Value <> '' then
    LC.pszText := @ Value[ 1 ];
  Perform( LVM_SETCOLUMNW, Idx, Integer( @ LC ) );
end;
{$ENDIF _D2}
{$ENDIF _FPC}

//[function TControl.GetLVColalign]
function TControl.GetLVColalign(Idx: Integer): TTextAlign;
const Formats: array[ 0..2 ] of TTextAlign = ( taLeft, taRight, taCenter );
var LC: TLVColumn;
begin
  FillChar( LC, Sizeof( LC ), 0 ); {Alexey (Lecha2002)}
  LC.mask := LVCF_FMT;
  Perform( LVM_GETCOLUMN, Idx, Integer( @ LC ) );
  Result := Formats[ LC.fmt and LVCFMT_JUSTIFYMASK ];
end;

//[procedure TControl.SetLVColalign]
procedure TControl.SetLVColalign(Idx: Integer; const Value: TTextAlign);
const FormatFlags: array[ TTextAlign ] of BYTE = ( LVCFMT_LEFT, LVCFMT_RIGHT,
      LVCFMT_CENTER );
var LC: TLVColumn;
begin
  FillChar( LC, Sizeof( LC ), 0 ); {Alexey (Lecha2002)}
  LC.mask := LVCF_FMT;
  Perform( LVM_GETCOLUMN, Idx, Integer( @ LC ) );
  LC.fmt := LC.fmt and not LVCFMT_JUSTIFYMASK or FormatFlags[ Value ];
  Perform( LVM_SETCOLUMN, Idx, Integer( @ LC ) );
end;

//[function TControl.GetLVColEx]
function TControl.GetLVColEx(Idx: Integer; const Index: Integer): Integer;
var LC: TLVColumn;
begin
  FillChar( LC, Sizeof( LC ), 0 ); {Alexey (Lecha2002)}
  LC.mask := LoWord( Index );
  Perform( LVM_GETCOLUMN, Idx, Integer( @ LC ) );
  Result := PDWORD( Integer( @ LC ) + HiWord( Index ) )^;
end;

//********************** changed by Mike Gerasimov
//[procedure TControl.SetLVColEx]
procedure TControl.SetLVColEx(Idx: Integer; const Index: Integer;
  const Value: Integer);
var LC: TLVColumn;
begin
  FillChar(LC,SizeOf(LC),0);                                    // Added Line
  LC.mask := LoWord( Index );
  if HiWord( Index ) = 24 then                                  // Added Line
   begin                                                        // Added Line
    LC.mask := LC.mask or LVCF_FMT;                             // Added Line
    if Value <>-1 Then                                          // Added Line
    LC.fmt := LC.fmt or LVCFMT_IMAGE or LVCFMT_COL_HAS_IMAGES;  // Added Line
   end;
  PDWORD( Integer( @ LC ) + HiWord( Index ) )^ := Value;
  Perform( LVM_SETCOLUMN, Idx, Integer( @ LC ) );
end;

//*
//[function TControl.LVAdd]
function TControl.LVAdd(const aText: String; ImgIdx: Integer;
  State: TListViewItemState; StateImgIdx, OverlayImgIdx: Integer;
  Data: DWORD): Integer;
begin
  Result := LVInsert( MaxInt {Count}, aText, ImgIdx, State, StateImgIdx, OverlayImgIdx, Data );
end;

//*
//[function TControl.LVInsert]
function TControl.LVInsert(Idx: Integer; const aText: String;
  ImgIdx: Integer; State: TListViewItemState;  StateImgIdx, OverlayImgIdx: Integer;
  Data: DWORD): Integer;
const
  LVM_REDRAWITEMS         = LVM_FIRST + 21;
var LVI: TLVItem;
begin
  LVI.mask := LVIF_TEXT or LVIF_IMAGE or LVIF_PARAM or LVIF_STATE
              or LVIF_DI_SETITEM;
  LVI.iItem := Idx;
  LVI.iSubItem := 0;
  LVI.state := 0;
  if lvisBlend in State then
     LVI.state := LVIS_CUT;
  if lvisHighlight in State then
     LVI.state := LVI.state or LVIS_DROPHILITED;
  if lvisFocus in State then
     LVI.state := LVI.state or LVIS_FOCUSED;
  if lvisSelect in State then
     LVI.state := LVI.state or LVIS_SELECTED;
  LVI.stateMask := $FFFF;
  if StateImgIdx <> 0 then
     LVI.state := LVI.state or ((StateImgIdx and $F) shl 12);
  if OverlayImgIdx <> 0 then
     LVI.state := LVI.state or ((OverlayImgIdx and $F) shl 8);
  LVI.pszText := PChar( aText );
  LVI.iImage := ImgIdx;
  LVI.lParam := Data;
  Result := Perform( LVM_INSERTITEM, 0, Integer( @LVI ) );
  //Perform( LVM_REDRAWITEMS, Idx, Idx );
end;

//*
//[procedure TControl.LVSetItem]
procedure TControl.LVSetItem(Idx, Col: Integer; const aText: String;
  ImgIdx: Integer; State: TListViewItemState; StateImgIdx,
  OverlayImgIdx: Integer; Data: DWORD);
var LVI: TLVItem;
    I: Integer;
begin
  LVI.mask := LVIF_TEXT or {LVIF_STATE or} LVIF_DI_SETITEM;
  if Col = 0 then
  begin
    LVI.mask := LVIF_TEXT or LVIF_STATE or LVIF_PARAM
              or LVIF_DI_SETITEM;
    if ImgIdx <> I_SKIP then
       LVI.mask := LVI.mask or LVIF_IMAGE;
  end;
  if ImgIdx < I_SKIP then
    LVI.mask := LVIF_TEXT or LVIF_DI_SETITEM;
  LVI.iItem := Idx;
  LVI.iSubItem := Col;
  LVI.state := 0;
  if lvisBlend in State then
     LVI.state := LVIS_CUT;
  if lvisHighlight in State then
     LVI.state := LVI.state or LVIS_DROPHILITED;
  if lvisFocus in State then
     LVI.state := LVI.state or LVIS_FOCUSED;
  if lvisSelect in State then
     LVI.state := LVI.state or LVIS_SELECTED;
  LVI.stateMask := $FFFF;
  if StateImgIdx <> 0 then
     LVI.state := LVI.state or ((StateImgIdx and $F) shl 12);
  if StateImgIdx < 0 {= I_SKIP} then
     LVI.stateMask := $F0FF;
  if OverlayImgIdx <> 0 then
     LVI.state := LVI.state or ((OverlayImgIdx and $F) shl 8);
  if OverlayImgIdx < 0 {=I_SKIP} then
     LVI.stateMask := LVI.stateMask and $FFF;
  LVI.pszText := PChar( aText );
  LVI.iImage := ImgIdx;
  LVI.lParam := Data;
  I := Perform( LVM_SETITEM, 0, Integer( @LVI ) );
  if (I = 0) and (Col = 0) then
    Assert( False, 'Can not set item ' );
end;

//*
//[procedure LVGetItem]
procedure LVGetItem( Sender: PControl; Idx, Col: Integer; var LVI: TLVItem;
          TextBuf: PChar; TextBufSize: Integer );
begin
  LVI.mask := LVIF_STATE or LVIF_PARAM or LVIF_IMAGE;
  if Col > 0 then
  if not (lvoSubItemImages in Sender.fLVOptions) then
    LVI.mask := LVIF_STATE or LVIF_PARAM;
  LVI.iItem := Idx;
  LVI.iSubItem := Col;
  LVI.pszText := TextBuf;
  LVI.cchTextMax := TextBufSize;
  if TextBufSize <> 0 then
    LVI.mask := LVI.mask or LVIF_TEXT;
  Sender.Perform( LVM_GETITEM, 0, Integer( @LVI ) );
end;

{$IFNDEF _FPC}
{$IFNDEF _D2}
//[procedure LVGetItemW]
procedure LVGetItemW( Sender: PControl; Idx, Col: Integer; var LVI: TLVItemW;
          TextBuf: PWideChar; TextBufSize: Integer );
begin
  LVI.mask := LVIF_STATE or LVIF_PARAM or LVIF_IMAGE;
  if Col > 0 then
  if not (lvoSubItemImages in Sender.fLVOptions) then
    LVI.mask := LVIF_STATE or LVIF_PARAM;
  LVI.iItem := Idx;
  LVI.iSubItem := Col;
  LVI.pszText := TextBuf;
  LVI.cchTextMax := TextBufSize;
  if TextBufSize <> 0 then
    LVI.mask := LVI.mask or LVIF_TEXT;
  Sender.Perform( LVM_GETITEMW, 0, Integer( @LVI ) );
end;
{$ENDIF _D2}
{$ENDIF _FPC}

//*
//[function TControl.LVGetItemImgIdx]
function TControl.LVGetItemImgIdx(Idx: Integer): Integer;
var LVI: TLVItem;
begin
  LVI.iImage := -1;//= Result if image is not assigned {Andrzej Kubaszek}
  LVGetItem( Self, Idx, 0, LVI, nil, 0 );
  Result := LVI.iImage;
end;

//*
//[procedure TControl.LVSetItemImgIdx]
procedure TControl.LVSetItemImgIdx(Idx: Integer; const Value: Integer);
var LVI: TLVItem;
begin
  LVGetItem( Self, Idx, 0, LVI, nil, 0 );
  LVI.iImage := Value;
  Perform( LVM_SETITEM, 0, Integer( @LVI ) );
end;

//*
//[function TControl.LVGetItemText]
function TControl.LVGetItemText(Idx, Col: Integer): String;
var LVI: TLVItem;
    TextBuf: PChar;
    BufSize: DWORD;
begin
  BufSize := 0;
  TextBuf := nil;
  repeat
    if TextBuf <> nil then
       FreeMem( TextBuf );
    BufSize := BufSize * 2 + 100; // to vary in asm version
    GetMem( TextBuf, BufSize );
    TextBuf[ 0 ] := #0;
    LVGetItem( Self, Idx, Col, LVI, TextBuf, BufSize );
  until StrLen( TextBuf ) < BufSize - 1;
  Result := TextBuf;
  FreeMem( TextBuf );
end;

//*
//[procedure TControl.LVSetItemText]
procedure TControl.LVSetItemText(Idx, Col: Integer; const Value: String);
var LVI: TLVItem;
begin
  LVI.iSubItem := Col;
  LVI.pszText := PChar( Value );
  Perform( LVM_SETITEMTEXT, Idx, Integer( @LVI ) );
end;

{$IFNDEF _FPC}
{$IFNDEF _D2}
//[function TControl.LVGetItemTextW]
function TControl.LVGetItemTextW(Idx, Col: Integer): WideString;
var LVI: TLVItemW;
    TextBuf: PWideChar;
    BufSize: DWORD;
begin
  BufSize := 0;
  TextBuf := nil;
  repeat
    if TextBuf <> nil then
       FreeMem( TextBuf );
    BufSize := BufSize * 2 + 100; // to vary in asm version
    GetMem( TextBuf, BufSize * 2 );
    TextBuf[ 0 ] := #0;
    LVGetItemW( Self, Idx, Col, LVI, TextBuf, BufSize );
  until DWORD( WStrLen( TextBuf ) ) < BufSize - 1;
  Result := TextBuf;
  FreeMem( TextBuf );
end;

//[procedure TControl.LVSetItemTextW]
procedure TControl.LVSetItemTextW(Idx, Col: Integer;
  const Value: WideString);
var LVI: TLVItemW;
begin
  LVI.iSubItem := Col;
  LVI.pszText := PWideChar( Value );
  Perform( LVM_SETITEMTEXTW, Idx, Integer( @LVI ) );
end;
{$ENDIF _D2}
{$ENDIF _FPC}

//*
//[procedure TControl.LVColDelete]
procedure TControl.LVColDelete(ColIdx: Integer);
begin
  Perform( LVM_DELETECOLUMN, ColIdx, 0 );
  if fLVColCount > 0 then
    Dec( fLVColCount );
end;

//*
//[procedure TControl.SetLVOptions]
procedure TControl.SetLVOptions(const Value: TListViewOptions);
begin
  if fLVOptions = Value then Exit;
  fLVOptions := Value;
  ApplyImageLists2ListView( Self );
  PostMessage( fHandle, WM_SIZE, 0, 0 ); // to restore scrollers (otherwise its are lost)
end;

//*
//[procedure TControl.SetLVStyle]
procedure TControl.SetLVStyle(const Value: TListViewStyle);
begin
  if fLVStyle = Value then Exit;
  fLVStyle := Value;
  ApplyImageLists2ListView( Self );
end;

{$IFDEF ASM_VERSION}
//[function TControl.Perform]
function TControl.Perform(msgcode: DWORD; wParam, lParam: Integer): Integer; stdcall;
asm
        PUSH     [lParam]
        PUSH     [wParam]
        PUSH     [msgcode]
        MOV      EAX, [EBP+8]
        CALL     TControl.GetWindowHandle
        PUSH     EAX
        CALL     Windows.SendMessage
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.Perform(msgcode: DWORD; wParam, lParam: Integer): Integer; stdcall;
begin
  Result := SendMessage( GetWindowHandle, msgcode, wParam, lParam );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.GetChildCount]
function TControl.GetChildCount: Integer;
asm
        MOV      EAX, [EAX].fChildren
        MOV      EAX, [EAX].TList.fCount
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.GetChildCount: Integer;
begin
  Result := fChildren.fCount;
end;
{$ENDIF ASM_VERSION}

//[procedure TControl.LVDelete]
procedure TControl.LVDelete(Idx: Integer);
begin
  Perform( LVM_DELETEITEM, Idx, 0 );
end;

//[procedure TControl.LVEditItemLabel]
procedure TControl.LVEditItemLabel(Idx: Integer);
begin
  Perform( LVM_EDITLABEL, Idx, 0 );
end;

//*
//[function TControl.LVItemRect]
function TControl.LVItemRect(Idx: Integer; Part: TGetLVItemPart): TRect;
const Parts: array[ TGetLVItemPart ] of Byte = (
             LVIR_BOUNDS, LVIR_ICON, LVIR_LABEL, LVIR_SELECTBOUNDS );
begin
  Result := MakeRect( Parts[ Part ], 0, 0, 0 );
  if Perform( LVM_GETITEMRECT, Idx, Integer( @Result ) ) = 0 then
     Result := MakeRect( 0, 0, 0, 0 );
end;

//[function TControl.LVSubItemRect]
function TControl.LVSubItemRect(Idx, ColIdx: Integer): TRect;
var Hdr: HWnd;
    R, R1: TRect;
    ClassNameBuf: array[ 0..31 ] of Char;
    HdItem: THDItem;
begin
  Result.Top := ColIdx; // + 1; error in MSDN ?
  Result.Left := LVIR_BOUNDS;
  if Perform( LVM_GETSUBITEMRECT, Idx, Integer( @Result ) ) <> 0 then
    Exit;
  Result := MakeRect( 0, 0, 0, 0 );
  if ColIdx > 0 then R := LVSubItemRect( Idx, ColIdx - 1 )
                else R := LVItemRect( Idx, lvipBounds );
  if (R.Left = 0) and (R.Right = 0) and
     (R.Top = 0) and (R.Bottom = 0) then Exit;
  Hdr := GetWindow( GetWindowHandle, GW_CHILD );
  if Hdr <> 0 then
  begin
    if GetClassName( Hdr, ClassNameBuf, 32 ) > 0 then
    if ClassNameBuf = 'SysHeader32' then
    begin
      if ColIdx > 0 then R.Left := R.Right
                    else R.Left := 0;
      R1.Top := 0; R1.Left := 0;
      Windows.ClientToScreen( Hdr,{$IFDEF FPC} PPoint( @ R1.Left )^ {$ELSE} R1.TopLeft {$ENDIF} );
      Windows.ScreenToClient( fHandle, {$IFDEF FPC} PPoint( @ R1.Left )^ {$ELSE} R1.TopLeft {$ENDIF} );
      R1 := R;
      HdItem.Mask := HDI_WIDTH;
      if SendMessage( Hdr, HDM_GETITEM, ColIdx, Integer( @HdItem ) ) = 0 then Exit;
      R1.Right := R1.Left + HdItem.cxy;
      Result := R1;
    end;
  end;
end;

//*
//[function TControl.LVGetItemPos]
function TControl.LVGetItemPos(Idx: Integer): TPoint;
begin
  Perform( LVM_GETITEMPOSITION, Idx, Integer( @Result ) );
end;

//*
//[procedure TControl.LVSetItemPos]
procedure TControl.LVSetItemPos(Idx: Integer; const Value: TPoint);
begin
  Perform( LVM_SETITEMPOSITION32, Idx, Integer( @Value ) );
end;

//*
//[function TControl.LVItemAtPos]
function TControl.LVItemAtPos(X, Y: Integer): Integer;
var Dummy: TWherePosLVItem;
begin
  Result := LVItemAtPosEx( X, Y, Dummy );
end;

//*
//[function TControl.LVItemAtPosEx]
function TControl.LVItemAtPosEx(X, Y: Integer;
  var Where: TWherePosLVItem): Integer;
var HTI: TLVHitTestInfo;
begin
  HTI.pt.x := X;
  HTI.pt.y := Y;
  Perform( LVM_HITTEST, 0, Integer( @HTI ) );
  Result := HTI.iItem;
  Where := lvwpOnColumn;
  if HTI.flags = LVHT_ONITEMICON then
     Where := lvwpOnIcon
  else
  if HTI.flags = LVHT_ONITEMLABEL then
     Where := lvwpOnLabel
  else
  if HTI.flags = LVHT_ONITEMSTATEICON then
     Where := lvwpOnStateIcon
  else
  if HTI.flags = LVHT_ONITEM then
     Where := lvwpOnItem;
end;

//[procedure TControl.LVMakeVisible]
procedure TControl.LVMakeVisible(Item: Integer; PartiallyOK: Boolean);
begin
  if Item < 0 then Exit;
  Perform( LVM_ENSUREVISIBLE, Item, Integer( PartiallyOK ) );
end;

//*
//[procedure TControl.LVSetColorByIdx]
procedure TControl.LVSetColorByIdx(const Index: Integer;
  const Value: TColor);
var MsgCode: Integer;
    ColorValue: TColor;
begin
  MsgCode := Index + 1;
  case MsgCode of
  LVM_SETTEXTCOLOR:  fTextColor := Value;
  LVM_SETTEXTBKCOLOR: fLVTextBkColor := Value;
  LVM_SETBKCOLOR: fColor := Value;
  end;
  ColorValue := Color2RGB( Value );
  Perform( MsgCode, 0, ColorValue );
end;

{$IFDEF F_P}
//[function TControl.LVGetColorByIdx]
function TControl.LVGetColorByIdx(const Index: Integer): TColor;
begin
  CASE Index OF
  LVM_SETTEXTCOLOR:   Result := fTextColor;
  LVM_SETTEXTBKCOLOR: Result := fLVTextBkColor;
  LVM_SETBKCOLOR:     Result := fColor;
  END;
end;
{$ENDIF F_P}

//*
//[function TControl.GetIntVal]
function TControl.GetIntVal(const Index: Integer): Integer;
begin
  Result := GetItemVal( 0, Index );
end;

//*
//[procedure TControl.SetIntVal]
procedure TControl.SetIntVal(const Index, Value: Integer);
begin
  SetItemVal( Value, Index, 0 );
end;

//*
//[function TControl.GetItemVal]
function TControl.GetItemVal(Item: Integer; const Index: Integer): Integer;
begin
  Result := Perform( LoWord(Index), Item, 0 );
end;

{$IFDEF ASM_VERSION}
//[procedure TControl.SetItemVal]
procedure TControl.SetItemVal(Item: Integer; const Index: Integer; const Value: Integer);
asm
        PUSH     EAX
        PUSH     [Value]
        PUSH     EDX
        MOV      EDX, ECX
        SHR      EDX, 16
        JNZ      @@1
        MOV      EDX, ECX
        INC      EDX
@@1:
        MOV      EBP, EDX
        AND      EDX, 7FFFh
        PUSH     EDX
        PUSH     EAX
        CALL     Perform
        MOV      EAX, EBP
        ADD      AX, AX
        POP      EAX
        JNB      @@2
        CALL     Invalidate
@@2:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.SetItemVal(Item: Integer; const Index: Integer; const Value: Integer);
var MsgCode: Integer;
begin
  MsgCode := HiWord( Index );
  if MsgCode = 0 then
    MsgCode := Index + 1;
  Perform( MsgCode and $7FFF, Item, Value );
  if (MsgCode and $8000) <> 0 then
    Invalidate;
end;
{$ENDIF ASM_VERSION}

{ -- OpenSaveDialog -- }

//*
//[function NewOpenSaveDialog]
function NewOpenSaveDialog( const Title, StrtDir: String;
         Options: TOpenSaveOptions ): POpenSaveDialog;
begin
  Result := POpenSaveDialog.Create;
  Result.FOptions := Options;
  if Options = [] then
    Result.FOptions := DefOpenSaveDlgOptions;
  Result.fOpenDialog := True;
  Result.FTitle := Title;
  Result.FInitialDir := StrtDir;
end;
//[END NewOpenSaveDialog]

{ TOpenSaveDialog }

{$IFDEF ASM_VERSION}
//[destructor TOpenSaveDialog.Destroy]
destructor TOpenSaveDialog.Destroy;
asm     //cmd    //opd
        PUSH     EAX
        PUSH     0
        LEA      EDX, [EAX].FFilter
        PUSH     EDX
        LEA      EDX, [EAX].FInitialDir
        PUSH     EDX
        LEA      EDX, [EAX].FDefExtension
        PUSH     EDX
        LEA      EDX, [EAX].FFileName
        PUSH     EDX
        LEA      EAX, [EAX].FTitle
@@loo:
        CALL     System.@LStrClr
        POP      EAX
        TEST     EAX, EAX
        JNZ      @@loo
        POP      EAX
        CALL     TObj.Destroy
end;
{$ELSE ASM_VERSION} //Pascal
destructor TOpenSaveDialog.Destroy;
begin
  FFilter := '';
  FInitialDir := '';
  FDefExtension := '';
  FFileName := '';
  FTitle := '';
  {$IFDEF OpenSaveDialog_Extended}
  TemplateName := '';
  {$ENDIF}
  inherited;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TOpenSaveDialog.Execute]
function TOpenSaveDialog.Execute: Boolean;
asm
        PUSH     EBX
        XCHG     EBX, EAX

        XOR      ECX, ECX
        {$IFDEF OpenSaveDialog_Extended}
        PUSH     [EBX].TemplateName
        PUSH     [EBX].HookProc
        {$ELSE}
        PUSH     ECX                      // prepare lpTemplateName = nil
        PUSH     ECX                      // prepare lpfnHook = nil
        {$ENDIF}
        PUSH     EBX                      // prepare lCustData = Self
        MOV      EDX, [EBX].FDefExtension
        CALL     EDX2PChar
        PUSH     EDX                      // prepare lpstrDefExt = FDefExtension
        PUSH     ECX                      // prepare nFileExtension, nFileOffset: Word = 0, 0
        // prepare flags:
        LEA      EAX, [EBX].FOptions
        MOV      EDX, Offset[@@OpenSaveFlags]
        {$IFDEF OpenSaveDialog_Extended}
        MOV      CL, 14
        {$ELSE}
        MOV      CL, 12
        {$ENDIF}
        CALL     MakeFlags
        XOR      ECX, ECX
        OR       EAX, OFN_EXPLORER or OFN_LONGNAMES or OFN_ENABLESIZING
        PUSH     EAX                       // push Flags
        PUSH     [EBX].FTitle              // prepare lpstrTitle
        PUSH     [EBX].FInitialDir         // prepare lpstrInitialDir
        PUSH     ECX                       // prepare nMaxFileTitle = 0
        PUSH     ECX                       // prepare lpstrFileTitle = nil
        TEST     AH, 2      // MultiSelect?
        MOV      EAX, 65520
        JNZ      @@1
        MOV      AX, MAX_PATH+2
@@1:    PUSH     EAX                       // prepare nMaxFile
        CALL     System.@GetMem
        POP      ECX
        PUSH     ECX
        PUSH     EAX                       // prepare lpStrFile
        XOR      EDX, EDX

@@2:    //MOV      [EAX], DL  // clear it initially {Vadim Petrov: it is necessary}
        //INC      EAX
        //LOOP     @@2

        MOV      EDX, [EBX].fFileName // no, fill it initilly by FileName
        CALL     EDX2PChar
        DEC      ECX // added 5 october 2003 to prevent possible error if FileName too big
        CALL     StrLCopy
        XOR      EDX, EDX

        PUSH     [EBX].FFilterIndex        // prepare nFilterIndex
        PUSH     EDX                       // prepare nMaxCustFilter
        PUSH     EDX                       // prepare lpstrCustomFilter
        PUSH     EDX                       // prepare lpstrFilter = nil
        MOV      EAX, ESP
        OR       EDX, [EBX].FFilter
        JZ       @@5

        MOV      ECX, offset[@@0]
        CALL     System.@LStrCat3          // prepare lpStrFilter = FFilter + #0
        POP      EAX
        PUSH     EAX
        XOR      EDX, EDX
@@3:    INC      EAX   // filter is not starting from ';' or '|'...
        CMP      [EAX], DL
        JZ       @@5
        CMP      byte ptr [EAX], '|'
        JNZ      @@3
@@4:    MOV      [EAX], DL
        JMP      @@3
@@OpenSaveFlags:
        DD OFN_CREATEPROMPT, OFN_EXTENSIONDIFFERENT, OFN_FILEMUSTEXIST
        DD OFN_HIDEREADONLY, OFN_NOCHANGEDIR, OFN_NODEREFERENCELINKS
        DD OFN_ALLOWMULTISELECT, OFN_NONETWORKBUTTON, OFN_NOREADONLYRETURN
        DD OFN_OVERWRITEPROMPT, OFN_PATHMUSTEXIST, OFN_READONLY, OFN_NOVALIDATE
        {$IFDEF OpenSaveDialog_Extended}
        DD OFN_ENABLETEMPLATE, OFN_ENABLEHOOK
        {$ENDIF}

        DD       -1, 1
@@0:    DB       0


@@5:
        PUSH     [hInstance]               // prepare hInstance

        MOV      ECX, [EBX].TControl.fWnd
        INC      ECX
        LOOP     @@6
        MOV      ECX, [Applet]
        JECXZ    @@6
        MOV      ECX, [ECX].TControl.fHandle
@@6:    PUSH     ECX                       // prepare hWndOwner
        PUSH     76                        // prepare lStructSize

        PUSH     ESP
        CMP      [EBX].FOpenDialog, DL
        JZ       @@7
        CALL     GetOpenFileName
        JMP      @@8
@@7:    CALL     GetSaveFileName
@@8:
        PUSH     EAX
        XOR      EDX, EDX
        TEST     EAX, EAX
        JZ       @@10

        MOV      EAX, [ESP+4].TOpenFileName.nFilterIndex
        MOV      [EBX].FFilterIndex, EAX

        MOV      EAX, [ESP+4].TOpenFileName.lpstrFile
        MOV      EDX, EAX
        XOR      ECX, ECX

        TEST     [EBX].FOptions, 1 shl OSAllowMultiSelect
        JZ       @@10

        DEC      EAX
@@9:    INC      EAX
        CMP      byte ptr [EAX], CL
        JNZ      @@9
        CMP      byte ptr [EAX+1], CL
        JZ       @@10
        MOV      byte ptr [EAX], 13
        JMP      @@9

@@10:
        LEA      EAX, [EBX].FFileName
        CALL     System.@LStrFromPChar
        MOV      EAX, [ESP+4].TOpenFileName.lpstrFile
        CALL     System.@FreeMem // v1.86 +AK

        LEA      EAX, [ESP+4].TOpenFileName.lpstrFilter
        CALL     System.@LStrClr

        POP      EAX
        ADD      ESP, 76
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function TOpenSaveDialog.Execute: Boolean;
const OpenSaveFlags: array[ TOpenSaveOption ] of Integer = (
      OFN_CREATEPROMPT,
      OFN_EXTENSIONDIFFERENT,
      OFN_FILEMUSTEXIST,
      OFN_HIDEREADONLY,
      OFN_NOCHANGEDIR,
      OFN_NODEREFERENCELINKS,
      OFN_ALLOWMULTISELECT,
      OFN_NONETWORKBUTTON,
      OFN_NOREADONLYRETURN,
      OFN_OVERWRITEPROMPT,
      OFN_PATHMUSTEXIST,
      OFN_READONLY,
      OFN_NOVALIDATE
      //{$IFDEF OpenSaveDialog_Extended}
      ,
      OFN_ENABLETEMPLATE,
      OFN_ENABLEHOOK
      //{$ENDIF}
      );
var
  Ofn : TOpenFilename;
  Fltr : String;
  TempFilename : String;

  Function MakeFilter(s : string) : String;
  {
  format of filter for API call is following:
    'text files'#0'*.txt'#0
    'bitmap files'#0'*.bmp'#0#0
  }
  var Str: PChar;
  begin
    Result := s;
    if Result='' then
      exit;
    Result:=Result+#0; {Delphi string always end on #0 is this is #0#0}
    Str := PChar( Result );
    while Str^ <> #0 do
    begin
      if Str^ = '|' then
        Str^ := #0;
      Inc( Str );
    end;
  end;

begin
  Fillchar( ofn, sizeof( ofn ), 0 );

  ofn.lStructSize:= 76; //to provide correct work in Win9x
  //sizeof(ofn); - by suggestion of Michael Morozov, 28-Nov-2001
  if fWnd <> 0 then
    ofn.hWndOwner := fWnd
  else
  if assigned(applet) then
    ofn.hwndOwner:=applet.Handle;

  ofn.hInstance:=HInstance;

  Fltr:=MakeFilter(FFilter);
  if Fltr <> '' then
    ofn.lpstrFilter:=pchar(Fltr);

  //ofn.lpstrCustomFilter:=nil;
  //ofn.nMaxCustFilter:=0;
  ofn.nFilterIndex:=FFilterIndex;

  if OSAllowMultiSelect in FOptions then
    ofn.nMaxFile:=High(word)-14    // by V.K. (exchanged condition)
  else
    ofn.nMaxFile:=MAX_PATH+2;

  TempFileName:=StringOfChar(#0,ofn.nMaxFile); {Vadim Petrov}
  ofn.lpstrFile:=StrLCopy(pchar(TempFileName), pchar(fFileName),
                   Min(ofn.nMaxFile,Length(fFileName)));

  ofn.lpstrInitialDir:=Pointer(FInitialDir);
  ofn.lpstrTitle:=Pointer(FTitle);
  ofn.Flags := MakeFlags( @FOptions, OpenSaveFlags )
            or OFN_EXPLORER or OFN_LONGNAMES or OFN_ENABLESIZING;

  ofn.lpstrDefExt:=PChar(FDefExtension);
  ofn.lCustData:=integer(Self);
  {$IFDEF OpenSaveDialog_Extended}
  ofn.lpTemplateName := PChar( TemplateName );
  ofn.lpfnHook := HookProc;
  {$ELSE}
  ofn.lpTemplateName:=nil;
  ofn.lpfnHook:=nil;
  {$ENDIF}
  if fOpenDialog then
    result:=GetOpenFileName(ofn)
  else
    result:=GetSaveFileName(ofn);
  if result then begin
    fFilterIndex := ofn.nFilterIndex; // by Vadim
    if OSAllowMultiSelect in foptions then begin
      FFileName:=copy(TempFileName, 1, pos(#0#0, tempfilename)-1);
      while pos(#0, ffilename) > 0 do begin
        FFilename[pos(#0, ffilename)]:=#13;
      end;
    end else
      FFileName:=copy(tempFileName, 1, pos(#0, TempFilename)
      -1 // by X.Y.B.
      );
  end else
    FFilename:='';
end;
{$ENDIF ASM_VERSION}

{ -- OpenDirDialog -- }

//*
//[function NewOpenDirDialog]
function NewOpenDirDialog( const Title: String; Options: TOpenDirOptions ):
         POpenDirDialog;
begin
  Result := POpenDirDialog.Create;
  Result.FOptions := [ odOnlySystemDirs ];
  if Options <> [] then
    Result.FOptions := Options;
  Result.FTitle := Title;
end;
//[END NewOpenDirDialog]

{ TOpenDirDialog }

{$IFDEF ASM_VERSION}
//[destructor TOpenDirDialog.Destroy]
destructor TOpenDirDialog.Destroy;
asm     //cmd    //opd
        PUSH     EAX
        PUSH     0
        LEA      EDX, [EAX].FTitle
        PUSH     EDX
        LEA      EDX, [EAX].FInitialPath
        PUSH     EDX
        LEA      EAX, [EAX].FStatusText
@@loo:  CALL     System.@LStrClr
        POP      EAX
        TEST     EAX, EAX
        JNZ      @@loo
        POP      EAX
        CALL     TObj.Destroy
end;
{$ELSE ASM_VERSION} //Pascal
destructor TOpenDirDialog.Destroy;
begin
  FTitle := '';
  FInitialPath := '';
  FStatusText := '';
  inherited;
end;
{$ENDIF ASM_VERSION}

type
  {$IFNDEF _D2}
  (*IMalloc = interface(IUnknown)
    ['{00000002-0000-0000-C000-000000000046}']
    function Alloc(cb: Longint): Pointer; stdcall;
    function Realloc(pv: Pointer; cb: Longint): Pointer; stdcall;
    procedure Free(pv: Pointer); stdcall;
    function GetSize(pv: Pointer): Longint; stdcall;
    function DidAlloc(pv: Pointer): Integer; stdcall;
    procedure HeapMinimize; stdcall;
  end;*)
  {$ENDIF}

  PSHItemID = ^TSHItemID;
  TSHItemID = packed record
    cb: Word;                         { Size of the ID (including cb itself) }
    abID: array[0..0] of Byte;        { The item ID (variable length) }
  end;

  PItemIDList = ^TItemIDList;
  TItemIDList = record
     mkid: TSHItemID;
  end;

  PBrowseInfo = ^TBrowseInfo;
  TBrowseInfo = record
    hwndOwner: HWND;
    pidlRoot: PItemIDList;
    pszDisplayName: PAnsiChar;  { Return display name of item selected. }
    lpszTitle: PAnsiChar;      { text to go in the banner over the tree. }
    ulFlags: UINT;           { Flags that control the return stuff }
    lpfn: Pointer; //TFNBFFCallBack;
    lParam: LPARAM;          { extra info that's passed back in callbacks }
    iImage: Integer;         { output var: where to return the Image index. }
  end;

//[API SHXXXXXXXXXX]
function SHBrowseForFolder(var lpbi: TBrowseInfo): PItemIDList; stdcall;
  external 'shell32.dll' name 'SHBrowseForFolderA';
function SHGetPathFromIDList(pidl: PItemIDList; pszPath: PChar): BOOL; stdcall;
  external shell32 name 'SHGetPathFromIDListA';
{
function CoTaskMemAlloc(cb : DWORD) : pointer; stdcall; external 'ole32.dll'
  name 'CoTaskMemAlloc';
}
procedure CoTaskMemFree(pv: Pointer); stdcall; external 'ole32.dll'
  name 'CoTaskMemFree';

const
  BIF_RETURNONLYFSDIRS   = $0001;  { For finding a folder to start document searching }
  BIF_DONTGOBELOWDOMAIN  = $0002;  { For starting the Find Computer }
  BIF_STATUSTEXT         = $0004;
  BIF_RETURNFSANCESTORS  = $0008;
  BIF_EDITBOX            = $0010;
  BIF_VALIDATE           = $0020;  { insist on valid result (or CANCEL) }
  BIF_BROWSEFORCOMPUTER  = $1000;  { Browsing for Computers. }
  BIF_BROWSEFORPRINTER   = $2000;  { Browsing for Printers }
  BIF_BROWSEINCLUDEFILES = $4000;  { Browsing for Everything }

  BFFM_INITIALIZED       = 1;
  BFFM_SELCHANGED        = 2;

  BFFM_SETSTATUSTEXT     = WM_USER + 100;
  BFFM_ENABLEOK          = WM_USER + 101;
  BFFM_SETSELECTION      = WM_USER + 102;


{$IFDEF ASM_VERSION} // WndOwner
//[function TOpenDirDialog.Execute]
function TOpenDirDialog.Execute: Boolean;
asm
        PUSH     EBX
        XCHG     EBX, EAX

        XOR      ECX, ECX
        PUSH     ECX             // prepare iImage = 0
        PUSH     EBX             // prepare lParam = Self
        PUSH     [EBX].FCallBack // prepare lpfn = FCallBack
        LEA      EAX, [EBX].FOptions
        MOV      EDX, Offset[@@FlagsArray]
        MOV      CL, 5
        CALL     MakeFlags
        PUSH     EAX             // prepare ulFlags = Options
        PUSH     [EBX].FTitle    // prepare lpszTitle
        LEA      EAX, [EBX].FBuf
        PUSH     EAX             // prepare pszDisplayName
        PUSH     0               // prepare pidlRoot
        MOV      ECX, [EBX].fWnd
        INC      ECX
        LOOP     @@1
        MOV      ECX, Applet
        JECXZ    @@1
        MOV      ECX, [ECX].TControl.fHandle
@@1:    PUSH     ECX             // prepare hwndOwner

        PUSH     ESP
        CALL     SHBrowseForFolder
        ADD      ESP, 32
        TEST     EAX, EAX
        JZ       @@exit

        PUSH     EAX

        LEA      EDX, [EBX].FBuf
        PUSH     EDX
        PUSH     EAX
        CALL     SHGetPathFromIDList

        CALL     CoTaskMemFree

        MOV      AL, 1
        JMP      @@fin

@@FlagsArray:
        DD BIF_BROWSEFORCOMPUTER, BIF_BROWSEFORPRINTER, BIF_DONTGOBELOWDOMAIN
        DD BIF_RETURNFSANCESTORS, BIF_RETURNONLYFSDIRS, BIF_STATUSTEXT, BIF_BROWSEINCLUDEFILES

@@exit: XOR      EAX, EAX
@@fin:
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function TOpenDirDialog.Execute: Boolean;
const FlagsArray: array[ TOpenDirOption ] of Integer =
      ( BIF_BROWSEFORCOMPUTER, BIF_BROWSEFORPRINTER, BIF_DONTGOBELOWDOMAIN,
        BIF_RETURNFSANCESTORS, BIF_RETURNONLYFSDIRS, BIF_STATUSTEXT,
        BIF_BROWSEINCLUDEFILES );
var BI : TBrowseInfo;
    Browse : PItemIdList;
begin
  Result := False;
  if WndOwner <> 0 then
    BI.hwndOwner := WndOwner
  else
  if assigned( Applet ) then
    BI.hwndOwner := Applet.Handle
  else
    BI.hwndOwner := 0;
  BI.pidlRoot  := nil;
  BI.pszDisplayName := @FBuf[ 0 ];
  BI.lpszTitle := PChar( Title );
  BI.ulFlags   := MakeFlags( @FOptions, FlagsArray );
  BI.lpfn := FCallBack;
  BI.lParam := Integer( Self );
  Browse := SHBrowseForFolder( BI );
  if Browse <> nil then
  begin
    SHGetPathFromIDList( Browse, @FBuf[ 0 ] );
    CoTaskMemFree( Browse );
    Result := True;
  end;
end;
{$ENDIF ASM_VERSION}

//[function TOpenDirDialog.GetInitialPath]
function TOpenDirDialog.GetInitialPath: String;
begin
  Result := IncludeTrailingPathDelimiter( fInitialPath );
end;

//[function TOpenDirDialog.GetPath]
function TOpenDirDialog.GetPath: String;
begin
  Result := FBuf;
end;

//[FUNCTION OpenDirSelChangeCallBack]
{$IFDEF ASM_VERSION}
function OpenDirSelChangeCallBack( Wnd: HWnd; Msg: DWORD; lParam, lpData: LParam ):
         Integer; stdcall;
asm
        MOV      EAX, [lpData]
        MOV      ECX, [EAX].TOpenDirDialog.FOnSelChanged.TMethod.Code
        JECXZ    @@exit

        LEA      EDX, [EAX].TOpenDirDialog.FBuf
        PUSH     EDX
        PUSH     [lParam]
        CALL     SHGetPathFromIDList

        //EnableOK := 0;
        //Self_.FOnSelChanged( Self_, Self_.FBuf, EnableOK, Self_.FStatusText );

        MOV      EDX, [lpData]
        LEA      ECX, [EDX].TOpenDirDialog.FBuf
        PUSH     0
        PUSH     ESP
        LEA      EAX, [EDX].TOpenDirDialog.FStatusText
        PUSH     EAX
        MOV      EAX, [EDX].TOpenDirDialog.FOnSelChanged.TMethod.Data
        CALL     dword ptr [EDX].TOpenDirDialog.FOnSelChanged.TMethod.Code
        POP      ECX
        JECXZ    @@1

        INC      ECX
        PUSH     ECX
        PUSH     0
        PUSH     BFFM_ENABLEOK
        PUSH     [Wnd]
        CALL     SendMessage
@@1:
        MOV      EDX, [lpData]
        MOV      ECX, [EDX].TOpenDirDialog.FStatusText
        JECXZ    @@exit

        PUSH     ECX
        PUSH     0
        PUSH     BFFM_SETSTATUSTEXT
        PUSH     [Wnd]
        CALL     SendMessage

@@exit: XOR      EAX, EAX
end;
{$ELSE ASM_VERSION} //Pascal
function OpenDirSelChangeCallBack( Wnd: HWnd; Msg: DWORD; lParam, lpData: LParam ):
         Integer; stdcall;
var _Self_: POpenDirDialog;
    EnableOK: Integer;
begin
  _Self_ := Pointer( lpData );
  if assigned( _Self_.FOnSelChanged ) then
  begin
    SHGetPathFromIDList( PItemIDList( lParam ), @ _Self_.FBuf[ 0 ] );
    EnableOK := 0;
    _Self_.FOnSelChanged( _Self_, _Self_.FBuf, EnableOK, _Self_.FStatusText );
    if EnableOK <> 0 then
       SendMessage( Wnd, BFFM_ENABLEOK, 0, EnableOK + 1 );
    if _Self_.FStatusText <> '' then
       SendMessage( Wnd, BFFM_SETSTATUSTEXT, 0, Integer( PChar( _Self_.FStatusText ) ) );
  end;
  Result := 0;
end;
{$ENDIF ASM_VERSION}
//[END OpenDirSelChangeCallBack]

//[FUNCTION OpenDirCallBack]
{$IFDEF ASM_VERSION}
function OpenDirCallBack( Wnd: HWnd; Msg: DWORD; lParam, lpData: LParam ): Integer;
         stdcall;
asm
        MOV      EAX, [Wnd]
        MOV      EDX, [lpData]
        MOV      ECX, [Msg]
        LOOP     @@chk_sel_chg
        // Msg = 1 -> BFFM_Initialized

        MOV      ECX, [EDX].TOpenDirDialog.FCenterProc
        JECXZ    @@1
        PUSH     EDX
        CALL     ECX
        POP      EDX
@@1:    MOV      ECX, [EDX].TOpenDirDialog.FInitialPath
        JECXZ    @@exit
        PUSH     ECX
        PUSH     1
        PUSH     BFFM_SETSELECTION
        PUSH     [Wnd]
        CALL     SendMessage
        JMP      @@exit

@@chk_sel_chg:
        LOOP     @@exit
        // Msg = 2 -> BFFM_SelChanged

        MOV      ECX, [EDX].TOpenDirDialog.FDoSelChanged
        JECXZ    @@exit
        POP      EBP
        JMP      ECX

@@exit: XOR      EAX, EAX
end;
{$ELSE ASM_VERSION} //Pascal
function OpenDirCallBack( Wnd: HWnd; Msg: DWORD; lParam, lpData: LParam ): Integer;
         stdcall;
var Self_ : POpenDirDialog;
begin
  Self_ := Pointer( lpData );
  if Msg = BFFM_INITIALIZED then
  begin
    if assigned( Self_.FCenterProc ) then
       Self_.FCenterProc( Wnd );
    if Self_.FInitialPath <> '' then
      SendMessage( Wnd, BFFM_SETSELECTION, 1, Integer( PChar( Self_.FInitialPath ) ) );
  end
     else
  if Msg = BFFM_SELCHANGED then
  begin
    if assigned( Self_.FDoSelChanged ) then
      Self_.FDoSelChanged( Wnd, Msg, lParam, lpData );
  end;
  Result := 0;
end;
{$ENDIF ASM_VERSION}
//[END OpenDirCallBack]

//[PROCEDURE OpenDirDlgCenter]
{$IFDEF ASM_VERSION}
procedure OpenDirDlgCenter( Wnd: HWnd );
asm
        PUSH     EBX
        MOV      EBX, EAX

        ADD      ESP, -16
        PUSH     ESP
        PUSH     EAX
        CALL     GetWindowRect
        POP      EDX          // EDX = Left
        POP      ECX          // ECX = Top
        POP      EAX          // EAX = Right
        SUB      EAX, EDX     // EAX = W
        POP      EDX          // EDX = Bottom
        SUB      EDX, ECX     // EDX = H
        XOR      ECX, ECX
        INC      ECX
        PUSH     ECX  // prepare True
        PUSH     EDX  // prepare H
        PUSH     EAX  // prepare W

        INC      ECX
@@1:
        PUSH     ECX

        DEC      ECX
        PUSH     ECX
        CALL     GetSystemMetrics

        POP      ECX
        SUB      EAX, [ESP+4]
        SAR      EAX, 1
        PUSH     EAX

        LOOP     @@1

        {
        PUSH     SM_CYSCREEN
        CALL     GetSystemMetrics
        SUB      EAX, [ESP+4]
        SAR      EAX, 1
        PUSH     EAX

        PUSH     SM_CXSCREEN
        CALL     GetSystemMetrics
        SUB      EAX, [ESP+4]
        SAR      EAX, 1
        PUSH     EAX
        }

        PUSH     EBX
        CALL     MoveWindow
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure OpenDirDlgCenter( Wnd: HWnd );
var R: TRect;
    W, H: Integer;
begin
  GetWindowRect( Wnd, R );
  W := R.Right - R.Left;
  H := R.Bottom - R.Top;
  R.Left := (GetSystemMetrics( SM_CXSCREEN ) - W) div 2;
  R.Top := (GetSystemMetrics( SM_CYSCREEN ) - H) div 2;
  MoveWindow( Wnd, R.Left, R.Top, W, H, True );
end;
{$ENDIF ASM_VERSION}
//[END OpenDirDlgCenter]

{$IFDEF ASM_VERSION}
//[procedure TOpenDirDialog.SetCenterOnScreen]
procedure TOpenDirDialog.SetCenterOnScreen(const Value: Boolean);
asm
        MOV      [EAX].FCenterOnScreen, DL
        MOVZX    ECX, DL
        JECXZ    @@1
        MOV      ECX, Offset[OpenDirDlgCenter]
@@1:    MOV      [EAX].FCenterProc, ECX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TOpenDirDialog.SetCenterOnScreen(const Value: Boolean);
var P: procedure( Wnd: HWnd );
begin
  FCenterOnScreen := Value;
  P := nil;
  if Value then
    P := @OpenDirDlgCenter;
  FCenterProc := P;
end;
{$ENDIF ASM_VERSION}

//[procedure TOpenDirDialog.SetInitialPath]
procedure TOpenDirDialog.SetInitialPath(const Value: String);
begin
  FCallBack := @OpenDirCallBack;
  FInitialPath := ExcludeTrailingPathDelimiter( Value );
end;

//[procedure TOpenDirDialog.SetOnSelChanged]
procedure TOpenDirDialog.SetOnSelChanged(const Value: TOnODSelChange);
begin
  FOnSelChanged := Value;
  FCallBack := @OpenDirCallBack;
  FDoSelChanged := @OpenDirSelChangeCallBack;
end;


type
  PByteArray    =^TByteArray;
  TByteArray    = array[Word]of Byte;

//[API CreateMappedBitmap]
function CreateMappedBitmap(Instance: THandle; Bitmap: Integer;
  Flags: UINT; ColorMap: PColorMap; NumMaps: Integer): HBitmap; stdcall;
  external cctrl name 'CreateMappedBitmap';

//[function CreateMappedBitmapEx]
function CreateMappedBitmapEx(Instance: THandle; BmpRsrcName: PChar; Flags:
Cardinal; ColorMap: PColorMap; NumMaps: Integer): HBitmap;
var bi: TBITMAPINFO;
    DC, tmcl: Cardinal;
    Bits: PByteArray;
    i, j, k, CO, bps: Integer;
    tm: array [1..4] of byte absolute tmcl;
    bm: Windows.TBITMAP;
    CM: PColorMap;
    DW: HWnd;
begin
  Result := LoadBitmap( Instance, BmpRsrcName );
  if Result = 0 then
  begin
    {$IFDEF DEBUG}
    ShowMessage( 'Can not load bitmap ' + BmpRsrcName + ', error ' +
                 Int2Str( GetLastError ) + ': ' + SysErrorMessage( GetLastError ) );
    {$ENDIF}
    Exit;
  end;
  DW := GetDesktopWindow;
  DC := GetDC(DW);
  FillChar( bm, SizeOf(bm), 0 );
  GetObject( Result, SizeOf( bm ), @bm );

  FillChar( bi, SizeOf( bi ), 0 );
  bi.bmiHeader.biSize := SizeOf( bi.bmiHeader );
  bi.bmiHeader.biWidth := bm.bmWidth;
  bi.bmiHeader.biHeight := -bm.bmHeight;
  bi.bmiHeader.biPlanes := 1;
  bi.bmiHeader.biBitCount := 24;
// BitCout - always 24 for easy algorythm
  bi.bmiHeader.biCompression:=BI_RGB;
  bps := CalcScanLineSize( @bi.bmiHeader );

  GetMem( Bits, bps * bm.bmHeight );
  GetDIBits( DC, Result, 0, bm.bmHeight, @Bits[0], bi, DIB_RGB_COLORS );
  DeleteObject( Result );

  for i := 0 to bm.bmHeight - 1 do begin
      for j := 0 to bm.bmWidth - 1 do begin
          CO := bps * i + 3 * j;
          for k := 0 to NumMaps - 1 do begin
              CM := Pointer( Integer( ColorMap ) + SizeOf( TColorMap ) * k );
              if RGB( Bits[CO+2], Bits[CO+1], Bits[CO] ) = CM.cFrom then
              begin
                  tmcl := CM.cTo;
                  tm[4]:=tm[1];
                  tm[1]:=tm[3];
                  tm[3]:=tm[4];
                  Move( tmcl, Bits[CO], 3);
              end;
          end;
      end;
  end;
  Result := CreateDIBitmap( DC, bi.bmiHeader, CBM_INIT, @Bits[0], bi,
    DIB_RGB_COLORS );
  ReleaseDC( DW, DC );
  FreeMem( Bits );
end;

//*
//[function LoadMappedBitmap]
function LoadMappedBitmap( hInst: THandle; BmpResID: Integer; const Map: array of TColor )
         : HBitmap;
var Map2Pass: Pointer;
begin
  Map2Pass := nil;
  if High( Map ) > 0 then
    Map2Pass := PColorMap( @Map[ 0 ] );
  Result := CreateMappedBitmap( hInst, BmpResID, 0, Map2Pass, (High( Map ) + 1) div 2 );
end;

//[function LoadMappedBitmapEx]
function LoadMappedBitmapEx( MasterObj: PObj; hInst: THandle; BmpResName: PChar; const Map: array of TColor )
         : HBitmap;
var Map2Pass: Pointer;
begin
  Map2Pass := nil;
  if High( Map ) > 0 then
    Map2Pass := PColorMap( @Map[ 0 ] );
  Result := CreateMappedBitmapEx( hInst, BmpResName, 0, Map2Pass, (High( Map ) + 1) div 2 );
  if MasterObj <> nil then
    MasterObj.Add2AutoFreeEx( TObjectMethod( MakeMethod( Pointer( Result ), @ FreeBmp ) ) );
end;

{ -- Toolbar -- }

{$IFDEF ASM_noVERSION} // width
//[procedure TControl.TBAddBitmap]
procedure TControl.TBAddBitmap(Bitmap: HBitmap);
const szBI = sizeof(TBitmapInfo);
asm
        TEST     EDX, EDX
        JZ       @@exit
        JGE      @@1
        CMP      EDX, -6
        JL       @@1

        NEG      EDX
        DEC      EDX
        PUSH     EDX
        PUSH     -1
        XOR      EDX, EDX
        JMP      @@2

@@1:    PUSH     EDX    // AB.hInst = Bitmap
        PUSH     0      // AB.nID = 0

        PUSH     EAX    // > Self
        ADD      ESP, -szBI
        PUSH     ESP
        PUSH     szBI
        PUSH     EDX
        CALL     GetObject
        TEST     EAX, EAX
        JG       @@11

        ADD      ESP, szBI
        JMP      @@exit

@@11:   MOV      EAX, [ESP].TBitmapInfo.bmiHeader.biWidth
        MOV      ECX, [ESP].TBitmapInfo.bmiHeader.biHeight
        TEST     ECX, ECX
        JGE      @@12
        NEG      ECX
@@12:   ADD      ESP, szBI
        CDQ                  // EDX = 0
        DIV      ECX         // EAX = N
        XCHG     EAX, [ESP]  // > N
        PUSH     EAX         // > Self

        MOV      EDX, ECX
        SHL      EDX, 16
        OR       ECX, EDX
        CDQ
        PUSH     EDX
        PUSH     EDX
        PUSH     TB_AUTOSIZE
        PUSH     EAX

        PUSH     ECX
        PUSH     EDX
        PUSH     TB_SETBITMAPSIZE
        PUSH     EAX
        CALL     Perform
        CALL     Perform
        POP      EAX
        POP      EDX

@@2:    PUSH     ESP
        PUSH     EDX
        PUSH     TB_ADDBITMAP
        PUSH     EAX
        CALL     Perform
        POP      ECX
        POP      ECX
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.TBAddBitmap(Bitmap: HBitmap);
const NstdBitmaps: array[ 0..5 ] of DWORD = ( 15, 15, 0, 0, 13, 13 );
var BI: TBitmapInfo;
    AB: TTBAddBitmap;
    N, W: Integer;
begin
  if Bitmap = 0 then Exit;
  if (Integer( Bitmap ) >= -10) and (Integer( Bitmap ) <= -1) then
  begin
    AB.hInst := THandle(-1);
    AB.nID := -Integer(Bitmap) - 1;
    N := 0; //NstdBitmaps[ AB.nID ]; // (this value is ignored)
  end
     else
  if GetObject( Bitmap, sizeof( TBitmapInfo ), @BI ) > 0 then
  begin
    AB.hInst := 0;
    AB.nID := Bitmap;
    W := fTBBtnImgWidth;
    if W = 0 then
      W := Abs( BI.bmiHeader.biHeight );
    N := BI.bmiHeader.biWidth div W;
    Perform( TB_SETBITMAPSIZE, 0, MAKELONG( W, Abs(BI.bmiHeader.biHeight )) );
    Perform( TB_AUTOSIZE, 0, 0 );
  end
    else Exit;
  Perform( TB_ADDBITMAP, N, Integer( @AB ) );
end;
{$ENDIF ASM_VERSION}

var ToolbarsIDcmd: Integer = 100;
{$IFDEF ASM_VERSION}
//[function TControl.TBAddInsButtons]
function TControl.TBAddInsButtons(Idx: Integer; const Buttons: array of PChar;
  const BtnImgIdxArray: array of Integer): Integer; stdcall;
asm
        { [EBP+$8] = Self
          [EBP+$C] = Idx
          [EBP+$10] = Buttons
          [EBP+$14] = High(Butons)
          [EBP+$18] = BtnImgIdxArray
          [EBP+$1C] = High(BtnImgIdxArray)
        }
        PUSH     EBX
        PUSH     ESI
        PUSH     EDI
        OR       EBX, -1
        MOV      EAX, 20
        MOV      ECX, [EBP+$14]
        CMP      ECX, EBX
        JLE      @@fin
        INC      ECX
        MUL      ECX
        CALL     System.@GetMem
        PUSH     EAX           // save AB to FreeMem after
        MOV      EDX, EBX
        DEC      EDX           // nBmp := -2

        MOV      ECX, [EBP+$14]
        INC      ECX
        JZ       @@exit

        MOV      ECX, [EBP+$1C]
        INC      ECX
        JZ       @@1
        MOV      ECX, [BtnImgIdxArray]
        MOV      EDX, [ECX]
        DEC      EDX           // nBmp := BtnImgIdxArray[ 0 ] - 1
@@1:    MOV      ECX, [EBP+$14]
        INC      ECX
        MOV      ESI, [Buttons]
        MOV      EDI, EAX      // EDI = PAB
        PUSH     0             // N:=0 in [EBP-$14]
        // -- impossible?-- JZ       @@break
@@loop:
        LODSD
        TEST     EAX, EAX
        JZ       @@break
        //CMP      byte ptr [EAX], 0
        //JZ       @@break
        PUSH     ECX

        CMP      word ptr [EAX], '-'
        JNE      @@2

        OR       EAX, -1
        STOSD
        //INC      EAX   //=0
        MOV      EAX, [ToolbarsIDcmd]
        TEST     EBX, EBX
        JGE      @@b0
        MOV      EBX, EAX
@@b0:
        //INC      [ToolbarsIDcmd]
        STOSD
        XOR      EAX, EAX
        INC      AH  // TBSTYLE_SEP = 1
        STOSD
        DEC      AH
        STOSD
        DEC      EAX
        JMP      @@3

        DD       -1, 1
@@0:    DB       0

@@2:
        INC      EDX  // Inc( nBmp )
        PUSH     EAX

        MOV      EAX, [EBP+$1C]
        MOV      ECX, [EBP-$14]
        CMP      EAX, ECX
        MOV      EAX, EDX
        JL       @@21
        MOV      EAX, [BtnImgIdxArray]
        MOV      EAX, [EAX+ECX*4]
@@21:   STOSD

        TEST     EDX, EDX
        JGE      @@2a
        DEC      EDX
@@2a:

        MOV      EAX, [ToolbarsIDcmd]
        //INC      [ToolbarsIDcmd]
        STOSD
        TEST     EBX, EBX
        JGE      @@210
        MOV      EBX, EAX
@@210:

        POP      ECX
        MOV      AX, $1004 // AL=fsState=_ENABLED, AH=fsStyle=_AUTOSIZE
        CMP      byte ptr [ECX], '^'
        JNE      @@22
        MOV      AH, TBSTYLE_DROPDOWN or TBSTYLE_AUTOSIZE
        INC      ECX
@@22:   CMP      byte ptr [ECX], '-'
        JZ       @@23
        CMP      byte ptr [ECX], '+'
        JNZ      @@24
        MOV      AL, TBSTATE_ENABLED or TBSTATE_CHECKED
@@23:   INC      ECX
        OR       AH, TBSTYLE_CHECK
        CMP      byte ptr [ECX], '!'
        JNZ      @@24
        OR       AH, TBSTYLE_GROUP
        INC      ECX
@@24:   STOSD
        MOV      EAX, [EBP+8]
        STOSD
        OR       EAX, -1
        CMP      word ptr [ECX], ' '
        JZ       @@3
        CMP      byte ptr [ECX], 0
        JZ       @@3

        PUSH     EDX
        PUSH     0
        MOV      EDX, ECX
        MOV      EAX, ESP
        CALL     System.@LStrFromPChar
        MOV      EAX, ESP
        MOV      EDX, offset[@@0]
        CALL     System.@LStrCat
        PUSH     dword ptr [ESP]
        PUSH     0
        PUSH     TB_ADDSTRING
        PUSH     dword ptr [EBP+8]
        CALL     Perform
        STOSD

        CALL     RemoveStr
        POP      EDX
        JMP      @@30

@@3:    STOSD
@@30:   INC      dword ptr [EBP-$14]
        INC      [ToolbarsIDcmd]
        POP      ECX
        DEC      ECX
        JNZ      @@loop
@@break:
        POP      ECX
        JECXZ    @@exit
        PUSH     dword ptr [ESP]
        MOV      EAX, [Idx]
        TEST     EAX, EAX
        JGE      @@31

        PUSH     ECX
        PUSH     TB_ADDBUTTONS
        JMP      @@32
@@31:
        PUSH     EAX
        PUSH     TB_INSERTBUTTON
@@32:
        PUSH     dword ptr [EBP+8]
        CALL     Perform
@@exit:
        POP      EAX
        //TEST     EAX, EAX
        //JZ       @@fin
        CALL     System.@FreeMem

@@fin:
        POP      EDI
        POP      ESI
        XCHG     EAX, EBX
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.TBAddInsButtons(Idx: Integer; const Buttons: array of PChar;
  const BtnImgIdxArray: array of Integer): Integer; stdcall;

      function AddInsButtons: Integer;
      type TTBBtnArray = array[ 0..100000 ] of TTBButton;
           PTBBtnArray = ^TTBBtnArray;
      var AB: PTBBtnArray;
          I, N, nBmp: Integer;
          PAB: PTBButton;
          Str: PChar;
      begin
        Result := -1;
        AB := nil;
        if High( Buttons ) >= 0 then
          GetMem( AB, Sizeof( TTBButton ) * (High(Buttons) + 1) );
        N := 0;
        PAB := @AB[ 0 ];
        nBmp := -2;
        if High(BtnImgIdxArray) >= 0 then
          nBmp := BtnImgIdxArray[ 0 ] - 1;
        for I:= 0 to High( Buttons ) do
        begin
          if Buttons[ I ] = nil then break;

          {if High( BtnImgIdxArray ) >= 0 then
            if I > High( BtnImgIdxArray ) then
              nBmp := -3;}

          if Buttons[ I ] = {$IFDEF F_P}''+{$ENDIF} '-' then
          begin
            PAB.iBitmap := -1;
            //PAB.idCommand := 0;
            PAB.fsState := 0;
            PAB.fsStyle := TBSTYLE_SEP;
            PAB.iString := -1;
          end
             else
          begin
            Str := Buttons[ I ];
            Inc( nBmp );
            PAB.iBitmap := nBmp;
            if nBmp < 0 then
              Dec( nBmp );
            if High( BtnImgIdxArray ) >= N then
              PAB.iBitmap := BtnImgIdxArray[ N ];
            {PAB.idCommand := ToolbarsIDcmd;
            if Result < 0 then Result := PAB.idCommand;
            Inc( ToolbarsIDcmd );}
            PAB.fsState := TBSTATE_ENABLED;
            PAB.fsStyle := TBSTYLE_BUTTON or TBSTYLE_AUTOSIZE;
            if Str^ = '^' then
            begin
              PAB.fsStyle := TBSTYLE_DROPDOWN or TBSTYLE_AUTOSIZE;
              Inc( Str );
            end;
            if Str^ in [ '-', '+' ] then
            begin
              PAB.fsStyle := PAB.fsStyle or TBSTYLE_CHECK;
              if Str^ = '+' then
                PAB.fsState := PAB.fsState or TBSTATE_CHECKED;
              Inc( Str );
              if Str^ = '!' then
              begin
                PAB.fsStyle := PAB.fsStyle or TBSTYLE_GROUP;
                Inc( Str );
              end;
            end;
            if (Str =  {$IFDEF F_P}''+{$ENDIF} ' ') or (Str^ = #0) then
              PAB.iString := -1
            else
              PAB.iString :=
                Perform( TB_ADDSTRING, 0, Integer( PChar( '' + Str + #0 ) ) );
          end;

          PAB.idCommand := ToolbarsIDcmd;
          if Result < 0 then Result := PAB.idCommand;
          Inc( ToolbarsIDcmd );

          PAB.dwData := Integer( Self );
          Inc( N );
          Inc( PAB );
        end;
        if N > 0 then
        begin
          if Idx < 0 then
            Perform( TB_ADDBUTTONS, N, Integer( @AB[ 0 ] ) )
          else
            Perform( TB_INSERTBUTTON, Idx, Integer( @AB[ 0 ] ) );
        end;
        if AB <> nil then
          FreeMem( AB );
      end;
begin
  if High( Buttons ) < 0 then
    Result := -1
  else
    Result := AddInsButtons;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.TBAddButtons]
function TControl.TBAddButtons(const Buttons: array of PChar;
         const BtnImgIdxArray: array of Integer): Integer;
asm
        PUSH     dword ptr [EBP+8]
        PUSH     dword ptr [EBP+12]
        PUSH     ECX
        PUSH     EDX
        PUSH     -1
        PUSH     EAX
        CALL     TBAddInsButtons
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.TBAddButtons(const Buttons: array of PChar;
         const BtnImgIdxArray: array of Integer): Integer;
begin
  Result := TBAddInsButtons( -1, Buttons, BtnImgIdxArray );
end;
{$ENDIF ASM_VERSION}

//*
//[function TControl.TBInsertButtons]
function TControl.TBInsertButtons(BeforeIdx: Integer;
  Buttons: array of PChar; BtnImgIdxArray: array of Integer): Integer;
var I, J, K: Integer;
begin
  J := -1;
  Result := -1;
  for I := 0 to High( Buttons ) do
  begin
    if I <= High( BtnImgIdxArray ) then
      J := BtnImgIdxArray[ I ]
    else
      if J >= 0 then Inc( J );
    K := TBAddInsButtons( BeforeIdx, [ Buttons[ I ], '' ], [ J ] );
    if Result < 0 then Result := K;
  end;
end;

//[function GetTBBtnGoodID]
function GetTBBtnGoodID( Toolbar: PControl; BtnIDorIdx: Integer ): Integer;
// change by Alexander Pravdin (to fix toolbar with separator first):
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
var Btn1st, i: Integer; btn: TTBButton;
begin
  Result := BtnIDorIdx;
  Btn1st := 0;
  for i := 0 to Toolbar.TBButtonCount - 1 do begin
    Toolbar.Perform( TB_GETBUTTON, i, Integer( @btn ) );
    if btn.fsStyle <> TBSTYLE_SEP then begin
        Btn1st := i;
        Break;
    end;
  end;
  if Result < Toolbar.TBIndex2Item( Btn1st ) then
    Result := Toolbar.TBIndex2Item( Result );
end;

type
  TTBButtonEvent = packed Record
    BtnID: DWORD;
    Event: TOnToolbarButtonClick;
  end;
  PTBButtonEvent = ^TTBButtonEvent;

//[procedure TControl.TBFreeTBevents]
procedure TControl.TBFreeTBevents;
begin
  fTBevents.Release;
end;

//[function WndProcToolbarButtonsClicks]
function WndProcToolbarButtonsClicks( TB: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var Notify: PTBNotify;
    I: Integer;
    Event: PTBButtonEvent;
begin
  Result := FALSE;
  if Msg.message = WM_NOTIFY then
  begin
    Notify := Pointer( Msg.lParam );
    if Notify.hdr.code = NM_CLICK then
    begin
      for I := TB.fTBevents.fCount-1 downto 0 do
      begin
        Event := TB.fTBevents.fItems[ I ];
        if Integer( Event.BtnID ) = Notify.iItem then
        begin
          if Assigned( Event.Event ) then
          begin
            TB.RefInc;
            Rslt := DefWindowProc( Msg.hwnd, Msg.message, Msg.wParam, Msg.lParam );
            Event.Event( TB, Event.BtnID );
            //Rslt := TB.CallDefWndProc( Msg );
            TB.RefDec;
            Result := TRUE;
            Exit;
          end;
          break;
        end;
      end;
    end;
  end;
end;

//[procedure TControl.TBAssignEvents]
procedure TControl.TBAssignEvents(BtnID: Integer;
  Events: array of TOnToolbarButtonClick);
var I: Integer;
    EventRec: PTBButtonEvent;
begin
  if fTBevents = nil then
  begin
    fTBevents := NewList;
    Add2AutoFreeEx( TBFreeTBevents );
    AttachProc( WndProcToolbarButtonsClicks );
  end;
  BtnID := GetTBBtnGoodID( Self, BtnID );
  for I := 0 to High( Events ) do
  begin
    GetMem( EventRec, Sizeof( TTBButtonEvent ) );
    fTBevents.Add( EventRec );
    EventRec.Event := Events[ I ];
    EventRec.BtnID := BtnID;
    Inc( BtnID );
  end;
end;

//[procedure TControl.TBResetImgIdx]
procedure TControl.TBResetImgIdx( BtnID, BtnCount: Integer );
begin
  while BtnCount > 0 do
  begin
    TBButtonImage[ BtnID ] := -2;
    Inc( BtnID );
    Dec( BtnCount );
  end;
end;

//*
//[function TControl.TBGetButtonVisible]
function TControl.TBGetButtonVisible(BtnID: Integer): Boolean;
begin
  Result := Perform( TB_ISBUTTONHIDDEN, GetTBBtnGoodID( Self, BtnID ), 0 ) = 0;
end;

//*
//[function TControl.TBItem2Index]
function TControl.TBItem2Index(BtnID: Integer): Integer;
begin
  Result := Perform( TB_COMMANDTOINDEX, BtnID, 0 );
end;

//*
//[procedure TControl.TBSetButtonVisible]
procedure TControl.TBSetButtonVisible(BtnID: Integer;
  const Value: Boolean);
begin
  BtnID := GetTBBtnGoodID( Self, BtnID );
  Perform( TB_HIDEBUTTON, BtnID, Integer( not Value ) );
end;

{$IFDEF ASM_VERSION}
//[function TControl.TBGetBtnStt]
function TControl.TBGetBtnStt(BtnID: Integer; const Index: Integer): Boolean;
asm
        PUSH     0
        PUSH     ECX
        PUSH     EAX
        CALL     GetTBBtnGoodID
        POP      EDX
        POP      ECX
        PUSH     EAX
        ADD      ECX, 8
        PUSH     ECX
        PUSH     EDX
        CALL     Perform
        TEST     EAX, EAX
        SETNZ    AL
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.TBGetBtnStt(BtnID: Integer; const Index: Integer): Boolean;
begin
  BtnID := GetTBBtnGoodID( Self, BtnID );
  Result := Perform( Index + 8, BtnID, 0 ) <> 0;
end;
{$ENDIF ASM_VERSION}

//+
//[procedure TControl.TBSetBtnStt]
procedure TControl.TBSetBtnStt(BtnID: Integer; const Index: Integer; const Value: Boolean);
begin
  BtnID := GetTBBtnGoodID( Self, BtnID );
  Perform( Index, BtnID, Integer( Value ) );
end;

{$IFDEF ASM_VERSION}
//[function TControl.TBIndex2Item]
function TControl.TBIndex2Item(Idx: Integer): Integer;
//*/////////////////////////////////////////////////////
const                                                 //
  _sizeof_TTBButton = sizeof( TTBButton );            //
//*/////////////////////////////////////////////////////
asm
//*/////////////////////////////////////////////////////
//        ADD      ESP, -sizeof(TTBButton)
//*/////////////////////////////////////////////////////
        ADD      ESP, -_sizeof_TTBButton              //
//*/////////////////////////////////////////////////////
        PUSH     ESP
        PUSH     EDX
        PUSH     TB_GETBUTTON
        PUSH     EAX
        CALL     Perform
        TEST     EAX, EAX
        MOV      EAX, [ESP].TTBButton.idCommand
        JNZ      @@1
        OR       EAX, -1
//*/////////////////////////////////////////////////////
//@@1:    ADD      ESP, sizeof( TTBButton )
//*/////////////////////////////////////////////////////
@@1:    ADD      ESP, _sizeof_TTBButton               //
//*/////////////////////////////////////////////////////
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.TBIndex2Item(Idx: Integer): Integer;
var ButtonInfo: TTBButton;
begin
  Result := -1;
  if Perform( TB_GETBUTTON, Idx, Integer( @ButtonInfo ) ) <> 0 then
    Result := ButtonInfo.idCommand;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.TBGetButtonText]
function TControl.TBGetButtonText( BtnID: Integer ): String;
asm
        PUSH     ECX
        ADD      ESP, -1024
        PUSH     ESP
        PUSH     EAX
        CALL     GetTBBtnGoodID
        POP      EDX
        PUSH     EAX
        PUSH     TB_GETBUTTONTEXT
        PUSH     EDX
        CALL     Perform
        TEST     EAX, EAX
        JLE      @@2
        MOV      EDX, ESP
        JMP      @@1
@@2:    XOR      EDX, EDX
@@1:    MOV      EAX, [ESP+1024]
        CALL     System.@LStrFromPChar
        ADD      ESP, 1028
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.TBGetButtonText( BtnID: Integer ): String;
var Buffer: array[ 0..1023 ] of Char;
begin
  BtnID := GetTBBtnGoodID( Self, BtnID );
  if Perform( TB_GETBUTTONTEXT, BtnID, Integer( @Buffer[ 0 ] ) ) > 0 then
    Result := Buffer
  else
  Result := '';
end;
{$ENDIF ASM_VERSION}

//*
//[function TControl.TBGetButtonRect]
function TControl.TBGetButtonRect(BtnID: Integer): TRect;
begin
  BtnID := GetTBBtnGoodID( Self, BtnID );
  Perform( TB_GETITEMRECT, TBItem2Index( BtnID ), Integer( @Result ) );
end;

//*
//[function TControl.TBGetRows]
function TControl.TBGetRows: Integer;
begin
  Result := 1;
  UpdateWndStyles;
  if (TBSTYLE_WRAPABLE and fStyle) <> 0 then
    Result := Perform( TB_GETROWS, 0, 0 );
end;

//*
//[procedure TControl.TBSetRows]
procedure TControl.TBSetRows(const Value: Integer);
begin
  Perform( TB_SETROWS, Value, 0 );
end;

{$IFDEF ASM_VERSION}
//[procedure TControl.TBSetTooltips]
procedure TControl.TBSetTooltips(BtnID1st: Integer;
  Tooltips: array of PChar);
asm
        PUSH     EBX
        PUSH     ESI
        MOV      ESI, ECX
        MOV      EBX, EAX
        PUSHAD
        MOV      ECX, [EBX].fTBttCmd
        INC      ECX
        LOOP     @@1
        CALL     NewList
        MOV      [EBX].fTBttCmd, EAX
        CALL     NewStrList
        MOV      [EBX].fTBttTxt, EAX
@@1:    POPAD
        MOV      ECX, [EBP+8]
        INC      ECX
        JZ       @@exit
@@loop:
        PUSH     ECX
        PUSH     EDX
        PUSH     0
        LODSD
        MOV      EDX, EAX
        MOV      EAX, ESP
        CALL     System.@LStrFromPChar

        MOV      EDX, [ESP+4]
        MOV      EAX, [EBX].fTBttCmd
        CALL     TList.IndexOf
        TEST     EAX, EAX
        JGE      @@2

        MOV      EDX, [ESP+4]
        MOV      EAX, [EBX].fTBttCmd
        CALL     TList.Add
        POP      EDX
        PUSH     EDX
        MOV      EAX, [EBX].fTBttTxt
        CALL     TStrList.Add
        JMP      @@3

@@2:
        MOV      EDX, EAX
        POP      ECX
        PUSH     ECX
        MOV      EAX, [EBX].fTBttTxt
        CALL     TStrList.Put
@@3:
        CALL     RemoveStr

        POP      EDX
        POP      ECX
        INC      EDX
        LOOP     @@loop
@@exit:
        POP      ESI
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.TBSetTooltips(BtnID1st: Integer;
  Tooltips: array of PChar);
var I, J: Integer;
begin
  if not assigned( fTBttCmd ) then
  begin
    fTBttCmd := NewList;
    fTBttTxt := NewStrList;
  end;
  for I:= 0 to High( Tooltips ) do
  begin
    J := fTBttCmd.IndexOf( Pointer( BtnID1st ) );
    if J < 0 then
    begin
      fTBttCmd.Add( Pointer( BtnID1st ) );
      fTBttTxt.Add( Tooltips[ I ] );
    end
       else
      fTBttTxt.Items[ J ] := Tooltips[ I ];
    Inc( BtnID1st );
  end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.TBButtonAtPos]
function TControl.TBButtonAtPos(X, Y: Integer): Integer;
asm
        PUSH     EAX
        CALL     TBBtnIdxAtPos
        TEST     EAX, EAX
        MOV      EDX, EAX
        POP      EAX
        JGE      TBIndex2Item
        MOV      EAX, EDX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.TBButtonAtPos(X, Y: Integer): Integer;
var I: Integer;
begin
  I := TBBtnIdxAtPos( X, Y );
  if I >= 0 then
     I := TBIndex2Item( I );
  Result := I;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.TBBtnIdxAtPos]
function TControl.TBBtnIdxAtPos(X, Y: Integer): Integer;
asm
        PUSH     EBX
        PUSH     ECX
        PUSH     EDX
        MOV      EBX, EAX
        CALL     GetItemsCount
        MOV      ECX, EAX
        JECXZ    @@fin
@@1:    PUSH     ECX
        ADD      ESP, -16
        PUSH     ESP
        DEC      ECX
        PUSH     ECX
        PUSH     TB_GETITEMRECT
        PUSH     EBX
        CALL     Perform
        MOV      EDX, ESP
        LEA      EAX, [ESP+20]
        CALL     PointInRect
        ADD      ESP, 16
        POP      ECX
        TEST     AL, AL
        JZ       @@2
        MOV      EAX, ECX
        JMP      @@fin
@@2:    LOOP     @@1
@@fin:  DEC      EAX
        POP      EDX
        POP      EDX
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.TBBtnIdxAtPos(X, Y: Integer): Integer;
var I: Integer;
    R: TRect;
    P: TPoint;
begin
  P := MakePoint( X, Y );
  for I := TBButtonCount - 1 downto 0 do
  begin
    Perform( TB_GETITEMRECT, I, Integer( @R ) );
    if PointInRect( P, R ) then
    begin
      Result := I;
      Exit;
    end;
  end;
  Result := -1;
end;
{$ENDIF ASM_VERSION}

//*
//[procedure TControl.TBDeleteButton]
procedure TControl.TBDeleteButton(BtnID: Integer);
begin
  BtnID := GetTBBtnGoodID( Self, BtnID );
  Perform( TB_DELETEBUTTON, TBItem2Index( BtnID ), 0 );
end;

//*
//[procedure TControl.TBDeleteBtnByIdx]
procedure TControl.TBDeleteBtnByIdx(Idx: Integer);
begin
  Perform( TB_DELETEBUTTON, Idx, 0 );
end;

//*
//[procedure TControl.Clear]
procedure TControl.Clear;
begin
  fCommandActions.aClear( Self );
end;

{$IFDEF ASM_noVERSION}
//[function TControl.TBGetBtnImgIdx]
function TControl.TBGetBtnImgIdx(BtnID: Integer): Integer;
const szTBButton = sizeof( TTBButton );
asm
        ADD      ESP, -szTBButton
        PUSH     ESP
        PUSH     EAX
        CALL     TBItem2Index
        POP      EDX
        PUSH     EAX
        PUSH     TB_GETBUTTON
        PUSH     EDX
        CALL     Perform
        POP      EAX
        ADD      ESP, szTBButton-4
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.TBGetBtnImgIdx(BtnID: Integer): Integer;
var B: TTBButton;
begin
  Perform( TB_GETBUTTON, TBItem2Index( GetTBBtnGoodID( Self, BtnID ) ), Integer( @B ) );
  Result := B.iBitmap;
end;
{$ENDIF ASM_VERSION}

//*
//[procedure TControl.TBSetBtnImgIdx]
procedure TControl.TBSetBtnImgIdx(BtnID: Integer; const Value: Integer);
begin
  Perform( TB_CHANGEBITMAP, GetTBBtnGoodID( Self, BtnID ), Value );
end;

{$IFDEF ASM_VERSION}
//[procedure TControl.TBSetButtonText]
procedure TControl.TBSetButtonText(BtnID: Integer; const Value: String);
asm
        PUSH     0
        PUSH     ECX
        ADD      ESP, -16
        PUSH     TBIF_TEXT
        PUSH     32 //Sizeof( TTBButtonInfo )
        PUSH     ESP
        PUSH     EDX
        PUSH     TB_SETBUTTONINFO
        PUSH     EAX
        CALL     Perform
        ADD      ESP, 32 //sizeof( TTBButtonInfo )
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.TBSetButtonText(BtnID: Integer; const Value: String);
var BI: TTBButtonInfo;
begin
  BI.cbSize := Sizeof( BI );
  BI.dwMask := TBIF_TEXT;
  BI.pszText := PChar( Value );
  Perform( TB_SETBUTTONINFO, BtnID, Integer( @BI ) );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TControl.TBGetBtnWidth]
function TControl.TBGetBtnWidth(BtnID: Integer): Integer;
asm
        ADD      ESP, -16
        MOV      ECX, ESP
        CALL     TBGetButtonRect
        POP      EDX
        POP      ECX
        POP      EAX
        SUB      EAX, EDX
        POP      EDX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.TBGetBtnWidth(BtnID: Integer): Integer;
var R: TRect;
begin
  R := TBButtonRect[ BtnID ];
  Result := R.Right - R.Left;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TControl.TBSetBtnWidth]
procedure TControl.TBSetBtnWidth(BtnID: Integer; const Value: Integer);
asm
        PUSH     EBX
        MOV      EBX, ECX

        PUSH     EAX
        CALL     GetTBBtnGoodID
        POP      EDX

        ADD      ESP, -24
        PUSH     TBIF_SIZE or TBIF_STYLE
        PUSH     32
        MOV      ECX, ESP

        PUSH     ECX
        PUSH     EAX
        PUSH     TB_SETBUTTONINFO
        PUSH     EDX

        PUSH     ECX
        PUSH     EAX
        PUSH     TB_GETBUTTONINFO
        PUSH     EDX
        CALL     Perform

        MOV      [ESP+16+18], BX
        AND      byte ptr [ESP+16].TTBButtonInfo.fsStyle, not TBSTYLE_AUTOSIZE
        CALL     Perform
        ADD      ESP, 32
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.TBSetBtnWidth(BtnID: Integer; const Value: Integer);
var BI: TTBButtonInfo;
begin
  BI.cbSize := Sizeof( BI );
  BI.dwMask := TBIF_SIZE or TBIF_STYLE;
  BtnID := GetTBBtnGoodID( Self, BtnID );
  Perform( TB_GETBUTTONINFO, BtnID, Integer( @BI ) );
  BI.cx := Value;
  BI.fsStyle := BI.fsStyle and not TBSTYLE_AUTOSIZE;
  Perform( TB_SETBUTTONINFO, BtnID, Integer( @BI ) );
end;
{$ENDIF ASM_VERSION}

//[procedure TControl.TBSetBtMinMaxWidth]
procedure TControl.TBSetBtMinMaxWidth(const Idx: Integer; const Value: Integer);
begin
  case Idx of
  0: FTBBtMinWidth := Value;
  1: FTBBtMaxWidth := Value;
  end;
  Perform( TB_SETBUTTONWIDTH, 0, FTBBtMaxWidth or (FTBBtMinWidth shl 16) );
end;

{$IFDEF F_P}
//[function TControl.TBGetBtMinMaxWidth]
function TControl.TBGetBtMinMaxWidth(const Idx: Integer): Integer;
begin
  CASE Idx OF
  0: Result := FTBBtMinWidth;
  1: Result := FTBBtMaxWidth;
  END;
end;
{$ENDIF F_P}

//[procedure TControl.SetDroppedDown]
procedure TControl.SetDroppedDown(const Value: Boolean);
begin
  //fDropped := Value;
  Perform( CB_SHOWDROPDOWN, Integer( Value ), 0 );
end;

{$IFDEF ASM_VERSION}
//[procedure TControl.AddDirList]
procedure TControl.AddDirList(const Filemask: String; Attrs: DWORD);
asm
        CALL     EDX2PChar
        PUSH     EDX
        PUSH     ECX
        MOVZX    ECX, [EAX].fCommandActions.aDir
        JECXZ    @@exit
        PUSH     ECX
        PUSH     EAX
        CALL     Perform
        RET
@@exit:
        POP      ECX
        POP      ECX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.AddDirList(const Filemask: String; Attrs: DWORD);
begin
  if fCommandActions.aDir <> 0 then
  Perform( fCommandActions.aDir, Attrs, Integer( PChar( Filemask ) ) );
end;
{$ENDIF ASM_VERSION}

//[FUNCTION WndProcShowModal]
{$IFDEF ASM_VERSION}
function WndProcShowModal( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
asm
        CMP      word ptr [EDX].TMsg.message, WM_CLOSE
        JNZ      @@ret_false
{//++++++ AP
        PUSH     EBX
        MOV      EBX, 1
        CMP      [EAX].TControl.fOnClose.TMethod.Code, 0
        JZ       @@AP1
        PUSH     EAX
        PUSH     EDX
        PUSH     ECX
        XCHG     EDX, EAX
        PUSH     EBX
        MOV      ECX, ESP
        MOV      EAX, [EDX].TControl.fOnClose.TMethod.Data
        CALL     dword ptr [EDX].TControl.fOnClose.TMethod.Code
        POP      EBX
        POP      ECX
        POP      EDX
        POP      EAX
@@AP1:
//------ AP}

        XCHG     EDX, EAX
        XOR      EAX, EAX
        CMP      [EDX].TControl.fModalResult, EAX
        JNZ      @@1
        OR       [EDX].TControl.fModalResult, -1
@@1:
{//++++++ AP
        TEST     BL, BL
        JNZ      @@AP2
        MOV      [EDX].TControl.fModalResult, 0
@@AP2:
        POP      EBX
//------ AP}

        MOV      [ECX], EAX
        INC      EAX
        RET
@@ret_false:
        XOR      EAX, EAX

end;
{$ELSE ASM_VERSION} //Pascal
function WndProcShowModal( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
//var Accept: Boolean; // {Alexander Pravdin, AP}
begin
  if Msg.message = WM_CLOSE then
  begin
    //++++++++ {AP} +++++++++++++++++++++++++++++++++++++++++++++++++++++++//
    {Accept := True;                                                       //
    if Assigned( Self_.fOnClose ) then Self_.fOnClose( Self_, Accept );  //
    }//-------- {AP} ----------------------------------------------------//
    if Self_.ModalResult = 0 then { (Sergey Shishmintzev) }
      Self_.ModalResult := -1;
    //++++++++ {AP} +++++++++++++++++++++++++++++++++++++++++++++++++++++++//
    {if not Accept then                     //
      Self_.ModalResult := 0; //не закрываем форму, оставляя её на экране//
    }//-------- {AP} ----------------------------------------------------//
    Rslt := 0;
    Result := True; // Do not process !
  end
    else
    Result := False;
end;
{$ENDIF ASM_VERSION}
//[END WndProcShowModal]

{$IFDEF ASM_noVERSION}
//[function TControl.ShowModal]
function TControl.ShowModal: Integer;
asm
        MOV      ECX, [EAX].fParent
        JECXZ    @@show
        MOVZX    ECX, [EAX].fIsControl
        JECXZ    @@show_modal
@@show:
        CALL     Show
        XOR      EAX, EAX
        RET
@@show_modal:
        PUSHAD

        MOV      EBX, EAX
        MOV      EDI, [Applet]

        XOR      EBP, EBP  // CurCtl = nil

        MOV      EAX, [EDI].fCurrentControl
        CMP      [EDI].TControl.FIsApplet, 0
        JNZ      @@curctrl_save
        MOV      EAX, EDI
@@curctrl_save:
        PUSH     EAX

        MOV      EDX, offset[WndProcShowModal]
        PUSH     EDX

        MOV      EAX, EBX
        CALL     TControl.AttachProc
        XOR      EDX, EDX
        MOV      [EBX].fModalResult, EDX

        CALL     NewList
        XCHG     EAX, EBP

        XOR      ECX, ECX
        INC      ECX
        MOV      ESI, EDI

        CMP      [EDI].TControl.FIsApplet, 0
        JZ       @@isapplet

        MOV      EBP, [EDI].fCurrentControl // CurCtl = Applet.fCurrentControl

        MOV      ESI, [EDI].fChildren
        MOV      ECX, [ESI].TList.fCount
        MOV      ESI, [ESI].TList.fItems

@@1loo: LODSD

@@isapplet:

        PUSH     ECX
        CMP      EAX, EBX
        JE       @@1nx
        PUSH     EAX
        CALL     GetEnabled
        TEST     AL, AL
        POP      EAX
        JZ       @@1nx
        PUSH     EAX
        MOV      DL, 0
        CALL     SetEnabled
        POP      EDX
        MOV      EAX, EBP
        CALL     TList.Add
@@1nx:  POP      ECX
        LOOP     @@1loo

        INC      [EBX].fModal
        MOV      EAX, [Applet]
        MOV      [EAX].fModalForm, EBX

        MOV      EAX, EBX
        CALL     Show

@@msgloo:
        MOVZX    ECX, [AppletTerminated]
        OR       ECX, [EBX].fModalResult
        JNZ      @@e_msgloo
        CALL     WaitMessage
        MOV      EAX, EDI
        CALL     ProcessMessages
        {$IFNDEF NOT_USE_OnIdle}
        MOV      EAX, EBX
        CALL     [ProcessIdle]
        {$ENDIF}
        JMP      @@msgloo

@@e_msgloo:
        POP      EDX
        MOV      EAX, EBX
        CALL     TControl.DetachProc

        DEC      [EBX].fModal
        MOV      EAX, [Applet]
        XOR      ECX, ECX
        MOV      [EAX].fModalForm, ECX

        MOV      ECX, [EBP].TList.fCount
        JECXZ    @@2end
        MOV      ESI, [EBP].TList.fItems

@@2loo: LODSD
        PUSH     ECX
        MOV      DL, 1
        CALL     TControl.SetEnabled
        POP      ECX
        LOOP     @@2loo

@@2end:
        MOV      EAX, EBP
        CALL     TObj.Free

        POP      ECX
        JECXZ    @@exit
        PUSH     0
        PUSH     WA_ACTIVE
        PUSH     WM_ACTIVATE
        PUSH     [ECX].fHandle
        CALL     PostMessage

        TEST     EBP, EBP  // CurCtl = nil ?
        JZ       @@exit
        MOV      EAX, EBP
        MOV      DL, 1
        CALL     TControl.SetFocused

@@exit:
        POPAD
        MOV      EAX, [EAX].fModalResult
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.ShowModal: Integer;
var FL: PList;
var CurForm: PControl;
    I: Integer;
    F: PControl;
    CurCtl: PControl; // { Alexander Pravdin }
begin
  Result := 0;
  if (fIsControl) or (fParent = nil) then
  begin
    Show;
    Exit;
  end;
  AttachProc( WndProcShowModal );
  CurForm := Applet.fCurrentControl;
  FL := NewList;
  CurCtl := nil; // { Alexander Pravdin }

  if Applet.IsApplet then
  for I := 0 to Applet.ChildCount - 1 do
  begin
    F := Applet.fChildren.Items[ I ];
    if F <> Self then
    if F.Enabled then
    begin
       FL.Add( F );
       F.Enabled := FALSE;
    end;
  end
  else
    begin
      CurForm := Applet;
      if Applet.Enabled then
      begin
        FL.Add( Applet );
        CurCtl := Applet.fCurrentControl; { Alexander Pravdin }
        Applet.Enabled := FALSE;
      end;
    end;

  Inc( fModal );
  Applet.fModalForm := Self;
  Enabled := TRUE;

  Show;
  ModalResult := 0;
  while not AppletTerminated and (ModalResult = 0) do
  begin
    WaitMessage;
    Applet.ProcessMessages;
    {$IFNDEF NOT_USE_OnIdle}
    ProcessIdle( Self );
    {$ENDIF}
  end;

  Dec( fModal );
  Applet.fModalForm := nil;

  DetachProc( WndProcShowModal );
  for I := 0 to FL.Count - 1 do
  begin
    F := FL.Items[ I ];
    F.Enabled := TRUE;
    //EnableWindow( F.Handle, TRUE );
    //F.Perform( WM_ENABLE, 1, 0 );
  end;
  FL.Free;

  if CurForm <> nil then
    PostMessage( CurForm.Handle, WM_ACTIVATE, WA_ACTIVE, 0 );
  if CurCtl <> nil then CurCtl.SetFocused( TRUE ); { Alexander Pravdin }

  Result := ModalResult;
end;
{$ENDIF ASM_VERSION}

//[function TControl.ShowModalParented]
function TControl.ShowModalParented(const AParent: PControl): Integer;
var FL: PList;
    CurForm,
    OldParent,
    F: PControl;
    I: Integer;
    MainW,
    isAppl: Boolean;
begin
  Result := 0;
  if AParent = nil then Exit;

  Inc( fModal );
  CurForm := nil;
  FL := NewList;
  OldParent := Parent;
  Parent := AParent;
  AParent.fModalForm := Self;

  MainW := AParent.IsMainWindow and AParent.fIsForm;
  isAppl := AParent.fIsApplet;

  if isAppl or MainW then begin
    for I := 0 to AParent.ChildCount - 1 do
    begin
      F := AParent.fChildren.Items[ I ];
      if (F <> Self) and F.fIsForm and F.fEnabled and F.fVisible then
      begin
        FL.Add( F );
        F.Enabled := FALSE;
      end;
    end;
    CurForm := AParent.fCurrentControl;
  end;

  if (not isAppl) or MainW then
  begin
    CurForm := AParent;
    if AParent.Enabled then
    begin
      FL.Add( AParent );
      AParent.Enabled := FALSE;
    end;
  end;

  ModalResult := 0;
  Show;
  while not AppletTerminated and (ModalResult = 0) do
  begin
    WaitMessage;
    AParent.ProcessMessages;
    {$IFNDEF NOT_USE_OnIdle}
    ProcessIdle( Self );
    {$ENDIF}
  end;

  Parent := OldParent;
  AParent.fModalForm := nil;
  Dec( fModal );
  for I := 0 to FL.Count - 1 do
  begin
    F := FL.Items[ I ];
    F.Enabled := TRUE;
  end;
  FL.Free;
  if CurForm <> nil then
    CurForm.Perform( WM_ACTIVATE, WA_ACTIVE, 0 );
  Hide;
  Result := ModalResult;
end;

//[function DisableWindows]
function DisableWindows( W: hwnd; LPARAM: Integer ): Bool; stdcall;
var FL: PList;
    Buf: array[ 0..127 ] of Char;
begin
  FL := Pointer( LPARAM );
  if IsWindowEnabled( W ) and (W <> FL.Tag) then
  begin
    GetClassName( W, @ Buf[ 0 ], Sizeof( Buf ) );
    if Buf <> 'ComboLBox' then
    begin
      FL.Add( Pointer( W ) );
      EnableWindow( W, FALSE );
    end;
  end;
  Result := TRUE;
end;

//[function TControl.ShowModalEx]
function TControl.ShowModalEx: Integer;
var FL: PList;
var CurForm: PControl;
    I: Integer;
    W: HWnd;
    CurCtl: PControl; { Alexander Pravdin }
begin
  Result := 0;
  if (fIsControl) or (fParent = nil) then
  begin
    Show;
    Exit;
  end;
  AttachProc( WndProcShowModal );
  CurForm := Applet.fCurrentControl;
  FL := NewList;
  FL.Tag := fHandle;

  // ++++ { Alexander Pravdin }
  if not Applet.fIsApplet then CurCtl := Applet.fCurrentControl
                          else CurCtl := nil;
  // ----
  CreateWindow;

  EnumThreadWindows( GetCurrentThreadID, @ DisableWindows, Integer( FL ) );
  Enabled := TRUE;

  Inc( fModal );
  Applet.fModalForm := Self;
  Show;
  ModalResult := 0;
  while not AppletTerminated and (ModalResult = 0) do
  begin
    WaitMessage;
    Applet.ProcessMessages;
    {$IFNDEF NOT_USE_OnIdle}
    ProcessIdle( Self );
    {$ENDIF}
  end;

  Dec( fModal );
  Applet.fModalForm := Self;

  DetachProc( WndProcShowModal );

  for I := 0 to FL.Count - 1 do
  begin
    W := THandle( FL.Items[ I ] );
    EnableWindow( W, TRUE );
  end;
  FL.Free;

  if CurForm <> nil then
    PostMessage( CurForm.Handle, WM_ACTIVATE, WA_ACTIVE, 0 );
  if CurCtl <> nil then CurCtl.SetFocused( True ); { Alexander Pravdin }
  Result := ModalResult;
end;

//[function TControl.GetModal]
function TControl.GetModal: Boolean;
begin
  Result := fModal > 0;
end;

{$IFDEF NEW_MODAL}
//[procedure TControl.SetModalResult]
procedure TControl.SetModalResult(const Value: Integer);
begin
  //if fModal <= 0 then Exit;
  fModalResult := Value;
  if Value <> 0 then
    PostMessage( GetWindowHandle, 0, 0, 0 );
end;
{$ENDIF}




//////////////////////////////////////////////////////////////////
//
//                          T  I  M  E  R
//
//////////////////////////////////////////////////////////////////

var TimerOwnerWnd: PControl;
    TimerCount: Integer = 0;

{ -- Constructor of timer -- }

//[function NewTimer]
function NewTimer( Interval: Integer ): PTimer;
begin
  Result := PTimer.Create;
  if Interval <= 0 then Interval := 1000;
  Result.fInterval := Interval;
  Inc( TimerCount );
end;
//[END NewTimer]

{ -- Timer procedure -- }

//[FUNCTION TimerProc]
{$IFDEF ASM_VERSION}
function TimerProc( Wnd : HWnd; Msg : Integer; T : PTimer; CurrentTime : DWord ): Integer;
          stdcall;
asm     //cmd    //opd
        MOV      EDX, T
        MOV      ECX, [EDX].TTimer.fOnTimer.TMethod.Code
        JECXZ    @@exit
        MOV      EAX, [EDX].TTimer.fOnTimer.TMethod.Data
        CALL     ECX
@@exit: XOR      EAX, EAX
end;
{$ELSE ASM_VERSION} //Pascal
function TimerProc( Wnd : HWnd; Msg : Integer; T : PTimer; CurrentTime : DWord ): Integer;
          stdcall;
begin
  if Assigned( T.fOnTimer ) then
     T.fOnTimer( T );
   Result := 0;
end;
{$ENDIF ASM_VERSION}
//[END TimerProc]

{ TTimer }

{$IFDEF ASM_VERSION}
//[destructor TTimer.Destroy]
destructor TTimer.Destroy;
asm
        PUSH     EAX
        XOR      EDX, EDX
        CALL     TTimer.SetEnabled
        POP      EAX
        CALL     TObj.Destroy
        DEC      [TimerCount]
        JNZ      @@exit
        XOR      EAX, EAX
        XCHG     EAX, [TimerOwnerWnd]
        CALL     TObj.Free
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
destructor TTimer.Destroy;
begin
  Enabled := False;
  inherited;
  Dec( TimerCount );
  if TimerCount = 0 then
  begin
    TimerOwnerWnd.Free;
    TimerOwnerWnd := nil;
  end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TTimer.SetEnabled]
procedure TTimer.SetEnabled(const Value: Boolean);
asm
        PUSH     EBX
        XCHG     EBX, EAX

        CMP      [EBX].fEnabled, DL
        JZ       @@exit

        MOV      [EBX].fEnabled, DL

        TEST     DL, DL
        JZ       @@disable

        MOV      ECX, [TimerOwnerWnd]
        INC      ECX
        LOOP     @@owner_ready

        INC      ECX
        MOV      EDX, offset[EmptyString]
        XOR      EAX, EAX
        CALL     _NewWindowed
        MOV      [TimerOwnerWnd], EAX
        MOV      [EAX].TControl.fStyle, 0
        INC      [EAX].TControl.fIsControl
        XCHG     ECX, EAX

@@owner_ready:

        PUSH     offset[TimerProc]
        PUSH     [EBX].fInterval
        PUSH     EBX
        XCHG     EAX, ECX
        CALL     TControl.GetWindowHandle
        PUSH     EAX
        CALL     SetTimer
        MOV      [EBX].fHandle, EAX

        JMP      @@exit

@@disable:
        XOR      ECX, ECX
        XCHG     ECX, [EBX].TTimer.fHandle
        JECXZ    @@exit

        PUSH     ECX
        MOV      EAX, [TimerOwnerWnd]
        PUSH     [EAX].TControl.fHandle
        CALL     KillTimer

@@exit:
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TTimer.SetEnabled(const Value: Boolean);
begin
  if FEnabled = Value then Exit;
  fEnabled := Value;
  if Value then
  begin
    if TimerOwnerWnd = nil then
    begin
      TimerOwnerWnd := _NewWindowed( nil, '', TRUE );
      TimerOwnerWnd.fStyle := 0;
      TimerOwnerWnd.fIsControl := TRUE;
    end;
    fHandle := SetTimer( TimerOwnerWnd.GetWindowHandle, Integer( Self ),
                         fInterval, @TimerProc );
  end
     else
  begin
    if fHandle <> 0 then
    begin
      KillTimer( TimerOwnerWnd.fHandle, fHandle );
      fHandle := 0;
    end;
  end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TTimer.SetInterval]
procedure TTimer.SetInterval(const Value: Integer);
asm
        CMP      EDX, [EAX].fInterval
        JE       @@exit
        MOV      [EAX].fInterval, EDX
        PUSH     dword ptr [EAX].fEnabled
        PUSH     EAX
        XOR      EDX, EDX
        CALL     SetEnabled
        POP      EAX
        POP      EDX
        CALL     SetEnabled
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TTimer.SetInterval(const Value: Integer);
var WasEnabled : Boolean;
begin
  if fInterval = Value then Exit;
  fInterval := Value;
  WasEnabled := Enabled;
  Enabled := False;
  Enabled := WasEnabled;
end;
{$ENDIF ASM_VERSION}


{ TMMTimer }

{ ------------ declarations moved here from MMSystem -------------------- }
const
  TIME_ONESHOT    = 0;   { program timer for single event }
  TIME_PERIODIC   = 1;   { program for continuous periodic event }
  TIME_CALLBACK_FUNCTION    = $0000;  { callback is function }
  TIME_CALLBACK_EVENT_SET   = $0010;  { callback is event - use SetEvent }
  TIME_CALLBACK_EVENT_PULSE = $0020;  { callback is event - use PulseEvent }

type
  TFNTimeCallBack = procedure(uTimerID, uMessage: UINT;
    dwUser, dw1, dw2: DWORD) stdcall;
//[API timeSetEvent]
function timeSetEvent(uDelay, uResolution: UINT;
  lpFunction: TFNTimeCallBack; dwUser: DWORD; uFlags: UINT): THandle; stdcall;
  external 'winmm.dll' name 'timeSetEvent';
function timeKillEvent(uTimerID: UINT): Integer; stdcall;
  external 'winmm.dll' name 'timeKillEvent';
{ ----------------------------------------------------------------------- }

//[procedure MMTimerCallback]
procedure MMTimerCallback(uTimerID, uMessage: UINT; dwUser, dw1, dw2: DWORD);
          stdcall;
var MMTimer: PMMTimer;
begin
  MMTimer := Pointer( dwUser );
  if Assigned( MMTimer.FOnTimer ) then
    MMTimer.fOnTimer( MMTimer );
end;

//[function NewMMTimer]
function NewMMTimer( Interval: Integer ): PMMTimer;
begin
    Result := PMMTimer.Create;
  Result.fInterval := Interval;
  Result.FPeriodic := TRUE;
end;
//[END NewMMTimer]

//[destructor TMMTimer.Destroy]
destructor TMMTimer.Destroy;
begin
  Enabled := FALSE;
  Inc( TimerCount );
  inherited;
end;

//[procedure TMMTimer.SetEnabled]
procedure TMMTimer.SetEnabled(const Value: Boolean);
begin
  if Value xor (fHandle <> 0) then
  begin
    if fHandle = 0 then
      fHandle := timeSetEvent( Interval, Resolution, MMTimerCallback, DWORD( Self ),
              Integer( Periodic ) or TIME_CALLBACK_FUNCTION )
    else
    begin
      timeKillEvent( fHandle );
      fHandle := 0;
    end;
  end;
  fEnabled := Value;
end;











////////////////////////////////////////////////////////////////////////
//
//
//                         t  B  I  T  M  A  P
//
//
///////////////////////////////////////////////////////////////////////

{ -- bitmap -- }

//[FUNCTION PrepareBitmapHeader]
{$IFDEF ASM_VERSION}
function PrepareBitmapHeader( W, H, BitsPerPixel: Integer ): PBitmapInfo;
const szIH = sizeof(TBitmapInfoHeader);
      szHd = szIH + 256 * Sizeof(TRGBQuad);
asm
        PUSH     EDI

          PUSH     ECX  // BitsPerPixel
        PUSH     EDX    // H
        PUSH     EAX    // W

        MOV      EAX, szHd
        CALL     AllocMem

        MOV      EDI, EAX
        XCHG     ECX, EAX

        XOR      EAX, EAX
        MOV      AL, szIH
        STOSD           // biSize = Sizeof( TBitmapInfoHeader )
        POP      EAX    // ^ W
        STOSD           // -> biWidth
        POP      EAX    // ^ H
        STOSD           // -> biHeight
        XOR      EAX, EAX
        INC      EAX
        STOSW           // 1 -> biPlanes
          POP      EAX  // ^ BitsPerPixel
        STOSW           // -> biBitCount

        XCHG     EAX, ECX // EAX = Result
        POP      EDI
end;
{$ELSE ASM_VERSION} //Pascal
function PrepareBitmapHeader( W, H, BitsPerPixel: Integer ): PBitmapInfo;
begin
  Assert( W > 0, 'Width must be >0' );
  Assert( H > 0, 'Height must be >0' );

  Result := AllocMem( 256*Sizeof(TRGBQuad)+Sizeof(TBitmapInfoHeader) );
  Assert( Result <> nil, 'No memory' );

  Result.bmiHeader.biSize := Sizeof( TBitmapInfoHeader );
  Result.bmiHeader.biWidth := W;
  Result.bmiHeader.biHeight := H; // may be, -H ?
  Result.bmiHeader.biPlanes := 1;
  Result.bmiHeader.biBitCount := BitsPerPixel;
  //Result.bmiHeader.biCompression := BI_RGB; // BI_RGB = 0
end;
{$ENDIF ASM_VERSION}
//[END PrepareBitmapHeader]

const
  BitsPerPixel_By_PixelFormat: array[ TPixelFormat ] of Byte =
                               ( 0, 1, 4, 8, 16, 16, 24, 32, 0 );

//[FUNCTION Bits2PixelFormat]
{$IFDEF ASM_VERSION}
function Bits2PixelFormat( BitsPerPixel: Integer ): TPixelFormat;
asm
        PUSH     ESI
        MOV      ESI, offset[ BitsPerPixel_By_PixelFormat + 1 ]
        XOR      ECX, ECX
        XCHG     EDX, EAX
@@loo:  INC      ECX
        LODSB
        CMP      AL, DL
        JZ       @@exit
        TEST     AL, AL
        JNZ      @@loo
@@exit: XCHG     EAX, ECX
        POP      ESI
end;
{$ELSE ASM_VERSION} //Pascal
function Bits2PixelFormat( BitsPerPixel: Integer ): TPixelFormat;
var I: TPixelFormat;
begin
  for I := Low(I) to High(I) do
    if BitsPerPixel = BitsPerPixel_By_PixelFormat[ I ] then
    begin
      Result := I;
      Exit;
    end;
  Result := pfDevice;
end;
{$ENDIF ASM_VERSION}
//[END Bits2PixelFormat]

//[procedure DummyDetachCanvas]
procedure DummyDetachCanvas( Sender: PBitmap );
begin
end;

//[FUNCTION _NewBitmap]
{$IFDEF ASM_VERSION}
function _NewBitmap( W, H: Integer ): PBitmap;
begin
  New( Result, Create );
  Result.fDetachCanvas := DummyDetachCanvas;
  Result.fWidth := W;
  Result.fHeight := H;
end;
{$ENDIF ASM_VERSION}
//[END _NewBitmap]

//[FUNCTION NewBitmap]
{$IFDEF ASM_VERSION}
function NewBitmap( W, H: Integer ): PBitmap;
asm
        PUSH     EAX
        PUSH     EDX
        CALL     _NewBitmap
        POP      EDX
        POP      ECX
        PUSH     EAX
        INC      [EAX].TBitmap.fHandleType
        JECXZ    @@exit
        TEST     EDX, EDX
        JZ       @@exit
        PUSH     EBX
        PUSH     EAX
        PUSH     EDX
        PUSH     ECX
        PUSH     0
        CALL     GetDC
        PUSH     EAX
        XCHG     EBX, EAX
        CALL     CreateCompatibleBitmap
        POP      EDX
        MOV      [EDX].TBitmap.fHandle, EAX
        PUSH     EBX
        PUSH     0
        CALL     ReleaseDC
        POP      EBX
@@exit: POP      EAX
end;
{$ELSE ASM_VERSION} //Pascal
function NewBitmap( W, H: Integer ): PBitmap;
var DC: HDC;
begin
  Result := PBitmap.Create;
  Result.fHandleType := bmDDB;
  Result.fDetachCanvas := DummyDetachCanvas;
  Result.fWidth := W;
  Result.fHeight := H;
  if (W <> 0) and (H <> 0) then
  begin
    //DC := CreateCompatibleDC( 0 );
    DC := GetDC( 0 );
    Result.fHandle := CreateCompatibleBitmap( DC, W, H );
    Assert( Result.fHandle <> 0, 'Can not create bitmap handle' );
    //DeleteDC( DC );
    ReleaseDC( 0, DC );
  end;
end;
{$ENDIF ASM_VERSION}
//[END NewBitmap]

const InitColors: array[ 0..17 ] of DWORD = ( $F800, $7E0, $1F, 0, $800000, $8000,
      $808000, $80, $800080, $8080, $808080, $C0C0C0, $FF0000, $FF00, $FFFF00, $FF,
      $FF00FF, $FFFF );
//[PROCEDURE PreparePF16bit]
{$IFDEF ASM_VERSION}
procedure PreparePF16bit( DIBHeader: PBitmapInfo );
const szBIH = sizeof(TBitmapInfoHeader);
asm
        MOV      byte ptr [EAX].TBitmapInfoHeader.biCompression, BI_BITFIELDS
        ADD      EAX, szBIH
        XCHG     EDX, EAX
        MOV      EAX, offset[InitColors]
        XOR      ECX, ECX
        MOV      CL, 19*4
        CALL     System.Move
end;
{$ELSE ASM_VERSION} //Pascal
procedure PreparePF16bit( DIBHeader: PBitmapInfo );
begin
        DIBHeader.bmiHeader.biCompression := BI_BITFIELDS;
        Move( InitColors[ 0 ], DIBHeader.bmiColors[ 0 ], 19*Sizeof(TRGBQUAD) );
end;
{$ENDIF ASM_VERSION}
//[END PreparePF16bit]

//[FUNCTION NewDIBBitmap]
{$IFDEF ASM_VERSION}
function NewDIBBitmap( W, H: Integer; PixelFormat: TPixelFormat ): PBitmap;
asm
        PUSH     EBX

        PUSH     ECX
        PUSH     EDX
        PUSH     EAX
        CALL     _NewBitmap
        XCHG     EBX, EAX
        POP      EAX //W
        POP      EDX //H
        POP      ECX //PixelFormat

        TEST     EAX, EAX
        JZ       @@exit
        TEST     EDX, EDX
        JZ       @@exit

        PUSH     EAX
        MOVZX    EAX, CL
        JMP      @@loadBitsPixel
@@loadDefault:
        MOVZX    EAX, [DefaultPixelFormat]
@@loadBitsPixel:
        MOVZX    ECX, byte ptr [ BitsPerPixel_By_PixelFormat + EAX ]
        JECXZ    @@loadDefault
        MOV      [EBX].TBitmap.fNewPixelFormat, AL
        {$IFDEF PARANOIA}
        DB $3C, pf16bit
        {$ELSE}
        CMP      AL, pf16bit
        {$ENDIF}
        POP      EAX

        PUSHFD
        CALL     PrepareBitmapHeader
        MOV      [EBX].TBitmap.fDIBHeader, EAX
        POPFD
        JNZ      @@2

        CALL     PreparePF16bit

@@2:
        MOV      EAX, EBX
        CALL     TBitmap.GetScanLineSize
        MOV      EDX, [EBX].TBitmap.fHeight
        MUL      EDX
        MOV      [EBX].TBitmap.fDIBSize, EAX
        CALL     AllocMem
        MOV      [EBX].TBitmap.fDIBBits, EAX
@@exit:
        XCHG     EAX, EBX
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function NewDIBBitmap( W, H: Integer; PixelFormat: TPixelFormat ): PBitmap;
const BitsPerPixel: array[ TPixelFormat ] of Byte = ( 0, 1, 4, 8, 16, 16, 24, 32, 0 );
var BitsPixel: Integer;
    //AField: PDWORD;
    //DC0 : HDC;
begin
  Result := PBitmap.Create;
  Result.fDetachCanvas := DummyDetachCanvas;
  Result.fWidth := W;
  Result.fHeight := H;
  if (W <> 0) and (H <> 0) then
  begin
    BitsPixel := BitsPerPixel[ PixelFormat ];
    if BitsPixel = 0 then
    begin
       Result.fNewPixelFormat := DefaultPixelFormat;
       BitsPixel := BitsPerPixel[DefaultPixelFormat];
    end
       else
       Result.fNewPixelFormat := PixelFormat;
    ASSERT( Result.fNewPixelFormat in [ pf1bit..pf32bit ], 'Strange pixel format' );
    Result.fDIBHeader := PrepareBitmapHeader( W, H, BitsPixel );
    if PixelFormat = pf16bit then
    begin
      PreparePF16bit( Result.fDIBHeader );
      {
      Result.fDIBHeader.bmiHeader.biCompression := BI_BITFIELDS;
      AField := @Result.fDIBHeader.bmiColors[ 0 ];
      AField^ := $F800; Inc( AField );
      AField^ := $07E0; Inc( AField );
      AField^ := $001F; Inc( AField );
      DC0 := CreateCompatibleDC( 0 );
      GetSystemPaletteEntries( DC0, 0, 16, AField^ );
      DeleteDC( DC0 );
      }
    end;

    Result.fDIBSize := Result.ScanLineSize * H;
    Result.fDIBBits := AllocMem( Result.fDIBSize );
    ASSERT( Result.fDIBBits <> nil, 'No memory' );
  end;
end;
{$ENDIF ASM_VERSION}
//[END NewDIBBitmap]

{ TBitmap }

{$IFDEF ASM_VERSION}
//[procedure TBitmap.ClearData]
procedure TBitmap.ClearData;
asm
        PUSH     EBX
        MOV      EBX, EAX
        CALL     [EBX].fDetachCanvas
        XOR      ECX, ECX
        XCHG     ECX, [EBX].fHandle
        JECXZ    @@1
        PUSH     ECX
        CALL     DeleteObject
        XOR      ECX, ECX
        MOV      [EBX].fDIBBits, ECX
@@1:    XCHG     ECX, [EBX].fDIBBits
        JECXZ    @@2
        XCHG     EAX, ECX
        CALL     System.@FreeMem
@@2:    XOR      ECX, ECX
        XCHG     ECX, [EBX].fDIBHeader
        JECXZ    @@3
        XCHG     EAX, ECX
        CALL     System.@FreeMem
@@3:    XOR      EAX, EAX
        MOV      [EBX].fScanLineSize, EAX
        MOV      [EBX].fGetDIBPixels, EAX
        MOV      [EBX].fSetDIBPixels, EAX
        XCHG     EAX, EBX
        POP      EBX
        CALL     ClearTransImage
end;
{$ELSE ASM_VERSION} //Pascal
procedure TBitmap.ClearData;
begin
  fDetachCanvas( Self );
  if fHandle <> 0 then
  begin
    DeleteObject( fHandle );
    fHandle := 0;
    fDIBBits := nil;
    //fDIBHeader := nil;
  end;
  if fDIBBits <> nil then
  begin
    FreeMem( fDIBBits );
    fDIBBits := nil;
  end;
  if fDIBHeader <> nil then
  begin
    FreeMem( fDIBHeader );
    fDIBHeader := nil;
  end;
  fScanLineSize := 0;
  fGetDIBPixels := nil;
  fSetDIBPixels := nil;
  ClearTransImage;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TBitmap.Clear]
procedure TBitmap.Clear;
asm
        PUSH     EAX
        CALL     RemoveCanvas
        POP      EAX
        PUSH     EAX
        CALL     ClearData
        POP      EAX
        XOR      EDX, EDX
        MOV      [EAX].fWidth, EDX
        MOV      [EAX].fHeight, EDX
        MOV      [EAX].fDIBAutoFree, DL
end;
{$ELSE ASM_VERSION} //Pascal
procedure TBitmap.Clear;
begin
  RemoveCanvas;
  ClearData;
  fWidth := 0;
  fHeight := 0;
  fDIBAutoFree := FALSE;
end;
{$ENDIF ASM_VERSION}

//[function TBitmap.GetBoundsRect]
function TBitmap.GetBoundsRect: TRect;
begin
  Result := MakeRect( 0, 0, Width, Height );
end;

{$IFDEF ASM_VERSION}
//[destructor TBitmap.Destroy]
destructor TBitmap.Destroy;
asm
        PUSH     EAX
        CALL     Clear
        POP      EAX
        CALL     TObj.Destroy
end;
{$ELSE ASM_VERSION} //Pascal
destructor TBitmap.Destroy;
begin
  Clear;
  inherited;
end;
{$ENDIF ASM_VERSION}

//[function TBitmap.BitsPerPixel]
function TBitmap.BitsPerPixel: Integer;
var B: tagBitmap;
begin
  CASE PixelFormat OF
  pf1bit: Result := 1;
  pf4bit: Result := 4;
  pf8bit: Result := 8;
  pf15bit: Result := 15;
  pf16bit: Result := 16;
  pf24bit: Result := 24;
  pf32bit: Result := 32;
  else begin
         Result := 0;
         if fHandle <> 0 then
         if GetObject( fHandle, Sizeof( B ), @B ) > 0 then
           Result := B.bmBitsPixel * B.bmPlanes;
       end;
  END;
end;

{$IFDEF ASM_VERSION}
//[procedure TBitmap.Draw]
procedure TBitmap.Draw(DC: HDC; X, Y: Integer);
const szBitmap = sizeof( tagBitmap );
asm                       // [EBP+8] = Y
        PUSH     EDX      // [EBP-4] = DC
        PUSH     ECX      // [EBP-8] = X
        PUSH     EBX
        PUSH     ESI
@@try_again:
        MOV      EBX, EAX
        CALL     GetEmpty // GetEmpty must be assembler version !
        JZ       @@exit

        MOV      ECX, [EBX].fHandle
        JECXZ    @@2

        //MOV      EAX, EBX
        //CALL     [EBX].fDetachCanvas // detached in StartDC

        ADD      ESP, -szBitmap
        PUSH     ESP
        PUSH     szBitmap
        PUSH     [EBX].fHandle
        CALL     GetObject
        TEST     EAX, EAX
        MOV      ESI, [ESP].tagBitmap.bmHeight
        JNZ      @@1
        MOV      ESI, [EBX].fHeight
@@1:
        ADD      ESP, szBitmap
        CALL     StartDC

        PUSH     SRCCOPY
        PUSH     0
        PUSH     0
        PUSH     EAX
        CALL     @@prepare
        CALL     BitBlt
        CALL     FinishDC
        JMP      @@exit

@@prepare:
        XCHG     ESI, [ESP]
        PUSH     [EBX].fWidth
        PUSH     Y
        PUSH     dword ptr [EBP-8]
        PUSH     dword ptr [EBP-4]
        JMP      ESI

@@2:
        MOV      ECX, [EBX].fDIBHeader
        JECXZ    @@exit

        MOV      ESI, [ECX].TBitmapInfoHeader.biHeight
        TEST     ESI, ESI
        JGE      @@20
        NEG      ESI
@@20:
        PUSH     SRCCOPY
        PUSH     DIB_RGB_COLORS
        PUSH     ECX
        PUSH     [EBX].fDIBBits
        PUSH     ESI
        PUSH     [EBX].fWidth
        PUSH     0
        PUSH     0
        CALL     @@prepare
        CALL     StretchDIBits
        TEST     EAX, EAX
        JNZ      @@exit
        MOV      EAX, EBX
        CALL     GetHandle
        TEST     EAX, EAX
        XCHG     EAX, EBX
        JNZ      @@try_again
@@exit:
        POP      ESI
        POP      EBX
        MOV      ESP, EBP
end;
{$ELSE ASM_VERSION} //Pascal
procedure TBitmap.Draw(DC: HDC; X, Y: Integer);
var
    DCfrom, DC0: HDC;
    oldBmp: HBitmap;
    oldHeight: Integer;
    B: tagBitmap;
label
    TRYAgain;
begin
TRYAgain:
  if Empty then Exit;
  if fHandle <> 0 then
  begin
    fDetachCanvas( Self );
    oldHeight := fHeight;
    if GetObject( fHandle, sizeof( B ), @B ) <> 0 then
       oldHeight := B.bmHeight;
    ASSERT( oldHeight > 0, 'oldHeight must be > 0' );

    DC0 := GetDC( 0 );
    DCfrom := CreateCompatibleDC( DC0 );
    ReleaseDC( 0, DC0 );

    oldBmp := SelectObject( DCfrom, fHandle );
    ASSERT( oldBmp <> 0, 'Can not select bitmap to DC' );

    BitBlt( DC, X, Y, fWidth, oldHeight, DCfrom, 0, 0, SRCCOPY );
    {$IFDEF CHK_BITBLT} Chk_BitBlt; {$ENDIF}

    SelectObject( DCfrom, oldBmp );
    DeleteDC( DCfrom );
  end
     else
  if fDIBBits <> nil then
  begin
    oldHeight := Abs(fDIBHeader.bmiHeader.biHeight);
    ASSERT( oldHeight > 0, 'oldHeight must be > 0' );
    ASSERT( fWidth > 0, 'Width must be > 0' );
    if StretchDIBits( DC, X, Y, fWidth, oldHeight, 0, 0, fWidth, oldHeight,
                   fDIBBits, fDIBHeader^, DIB_RGB_COLORS, SRCCOPY ) = 0 then
    begin
      if GetHandle <> 0 then
        goto TRYAgain;
    end;
  end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TBitmap.StretchDraw]
procedure TBitmap.StretchDraw(DC: HDC; const Rect: TRect);
asm
        PUSH     EBX
        PUSH     EDI
        PUSH     EBP
        MOV      EBP, ESP
        PUSH     EDX
        PUSH     ECX
        MOV      EBX, EAX
        CALL     GetEmpty
        JZ       @@exit

        MOV      ECX, [EBX].fHandle
        JECXZ    @@2

@@0:
        CALL     StartDC
        PUSH     SRCCOPY
        PUSH     [EBX].fHeight
        PUSH     [EBX].fWidth
        PUSH     0
        PUSH     0
        PUSH     EAX

        CALL     @@prepare
        CALL     StretchBlt
        CALL     FinishDC
        JMP      @@exit

@@prepare:
        POP      EDI
        MOV      EAX, [EBP-8]
        MOV      EDX, [EAX].TRect.Bottom
        MOV      ECX, [EAX].TRect.Top
        SUB      EDX, ECX
        PUSH     EDX
        MOV      EDX, [EAX].TRect.Right
        MOV      EAX, [EAX].TRect.Left
        SUB      EDX, EAX
        PUSH     EDX
        PUSH     ECX
        PUSH     EAX
        PUSH     dword ptr [EBP-4]
        JMP      EDI


@@2:    MOV      ECX, [EBX].fDIBHeader
        JECXZ    @@exit

        PUSH     SRCCOPY
        PUSH     DIB_RGB_COLORS
        PUSH     ECX
        PUSH     [EBX].fDIBBits
        PUSH     [EBX].fHeight
        PUSH     [EBX].fWidth
        PUSH     0
        PUSH     0
        CALL     @@prepare
        CALL     StretchDIBits
        TEST     EAX, EAX
        JG       @@exit

        MOV      EAX, EBX
        CALL     GetHandle
        MOV      ECX, [EBX].fHandle
        JECXZ    @@exit
        JMP      @@0

@@exit: MOV      ESP, EBP
        POP      EBP
        POP      EDI
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TBitmap.StretchDraw(DC: HDC; const Rect: TRect);
var DCfrom: HDC;
    oldBmp: HBitmap;
label DrawHandle;
begin
  if Empty then Exit;
DrawHandle:
  if fHandle <> 0 then
  begin
    fDetachCanvas( Self );
    DCfrom := CreateCompatibleDC( 0 );
    oldBmp := SelectObject( DCfrom, fHandle );
    ASSERT( oldBmp <> 0, 'Can not select bitmap to DC' );
    StretchBlt( DC, Rect.Left, Rect.Top, Rect.Right - Rect.Left,
                Rect.Bottom - Rect.Top, DCfrom, 0, 0, fWidth, fHeight,
                SRCCOPY );
    SelectObject( DCfrom, oldBmp );
    DeleteDC( DCfrom );
  end
     else
  if fDIBBits <> nil then
  begin
    if StretchDIBits( DC, Rect.Left, Rect.Top, Rect.Right - Rect.Left,
                Rect.Bottom - Rect.Top, 0, 0, fWidth, fHeight,
                fDIBBits, fDIBHeader^, DIB_RGB_COLORS, SRCCOPY )<=0 then
    begin
      if GetHandle <> 0 then
        goto DrawHandle;
    end;
  end;
end;
{$ENDIF ASM_VERSION}

//[procedure TBitmap.DrawMasked]
procedure TBitmap.DrawMasked(DC: HDC; X, Y: Integer; Mask: HBitmap);
begin
  StretchDrawMasked( DC, MakeRect( X, Y, X + fWidth, Y + fHeight ), Mask );
end;

{$IFDEF ASM_VERSION}
//[procedure TBitmap.DrawTransparent]
procedure TBitmap.DrawTransparent(DC: HDC; X, Y: Integer; TranspColor: TColor);
asm
        PUSH     ECX
        MOV      ECX, TranspColor
        INC      ECX
        MOV      ECX, [Y]
        JNZ      @@2
        XCHG     ECX, [ESP]
        CALL     Draw
        JMP      @@exit
@@2:
        ADD      ECX, [EAX].fHeight
        PUSH     ECX
        MOV      ECX, [EBP-4]
        ADD      ECX, [EAX].fWidth
        PUSH     ECX
        PUSH     [Y]
        PUSH     dword ptr [EBP-4]
        MOV      ECX, ESP
        PUSH     [TranspColor]
        CALL     StretchDrawTransparent
@@exit:
        MOV      ESP, EBP
end;
{$ELSE ASM_VERSION} //Pascal
procedure TBitmap.DrawTransparent(DC: HDC; X, Y: Integer; TranspColor: TColor);
begin
  if TranspColor = clNone then
    Draw( DC, X, Y )
  else
    StretchDrawTransparent( DC, MakeRect( X, Y, X + fWidth, Y + fHeight ),
                            TranspColor );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TBitmap.StretchDrawTransparent]
procedure TBitmap.StretchDrawTransparent(DC: HDC; const Rect: TRect; TranspColor: TColor);
asm
        PUSH     EBX
        XCHG     EBX, EAX
        MOV      EAX, [TranspColor]
        INC      EAX
        MOV      EAX, EBX
        JNZ      @@2
        CALL     StretchDraw
        JMP      @@exit
@@2:
        PUSH     EDX
        PUSH     ECX
        CALL     GetHandle
        TEST     EAX, EAX
        JZ       @@exit2

        MOV      EAX, [TranspColor]
        CALL     Color2RGB
        MOV      ECX, [EBX].fTransMaskBmp
        JECXZ    @@makemask0
        CMP      EAX, [EBX].fTransColor
        JE       @@3
@@makemask0:
        MOV      [EBX].fTransColor, EAX
        INC      ECX
        LOOP     @@20
        //MOV      EAX, [EBX].fWidth
        //MOV      EDX, [EBX].fHeight
        XOR      EAX, EAX // pass height = 0
        // absolutely no matter what to pass as width
        CALL     NewBitmap
        MOV      [EBX].fTransMaskBmp, EAX
@@20:
        MOV      EAX, [EBX].fTransMaskBmp
        PUSH     EAX
        MOV      EDX, EBX
        CALL     Assign
        POP      EAX
        MOV      EDX, [EBX].fTransColor
        CALL     Convert2Mask
@@3:
        MOV      EAX, [EBX].fTransMaskBmp
        CALL     GetHandle
        POP      ECX
        POP      EDX
        PUSH     EAX
        XCHG     EAX, EBX
        CALL     StretchDrawMasked
        JMP      @@exit
@@exit2:
        POP      ECX
        POP      EDX
@@exit:
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TBitmap.StretchDrawTransparent(DC: HDC; const Rect: TRect; TranspColor: TColor);
begin
  if TranspColor = clNone then
     StretchDraw( DC, Rect )
  else
  begin
    if GetHandle = 0 then Exit;
    TranspColor := Color2RGB( TranspColor );
    if (fTransMaskBmp = nil) or (fTransColor <> TranspColor) then
    begin
      if fTransMaskBmp = nil then
        fTransMaskBmp := NewBitmap( 0, 0 {fWidth, fHeight} );
      fTransColor := TranspColor;
      // Create here mask bitmap:
      fTransMaskBmp.Assign( Self );
      fTransMaskBmp.Convert2Mask( TranspColor );
    end;
    StretchDrawMasked( DC, Rect, fTransMaskBmp.Handle );
  end;
end;
{$ENDIF ASM_VERSION}

const
  ROP_DstCopy = $00AA0029;
{$IFDEF ASM_VERSION}
//[procedure TBitmap.StretchDrawMasked]
procedure TBitmap.StretchDrawMasked(DC: HDC; const Rect: TRect; Mask: HBitmap);
asm
        PUSH     EDX                    // [EBP-4] = DC
        PUSH     ECX                    // [EBP-8] = Rect
        PUSH     EBX                    // save EBX
        MOV      EBX, EAX
        PUSH     ESI                    // save ESI
        CALL     GetHandle
        TEST     EAX, EAX
        JZ       @@to_exit

        PUSH     0
        CALL     CreateCompatibleDC
        PUSH     EAX                    // [EBP-20] = MaskDC

        PUSH     [Mask]
        PUSH     EAX
        CALL     SelectObject
        PUSH     EAX                    // [EBP-24] = Save4Mask

        CALL     StartDC                // [EBP-28] = DCfrom; [EBP-32] = Save4From

        PUSH     [EBX].fHeight
        PUSH     [EBX].fWidth
        PUSH     EAX
        CALL     CreateCompatibleBitmap
        PUSH     EAX                    // [EBP-36] = MemBmp

        PUSH     0
        CALL     CreateCompatibleDC
        PUSH     EAX                    // [EBP-40] = MemDC

        PUSH     dword ptr [EBP-36] //MemBmp
        PUSH     EAX
        CALL     SelectObject
        PUSH     EAX                    // [EBP-44] = Save4Mem

        PUSH     SRCCOPY
        MOV      EAX, [EBP-20] //MaskDC
        CALL     @@stretch1

        PUSH     SRCERASE
        MOV      EAX, [EBP-28] //DCfrom
        CALL     @@stretch1

        PUSH     0
        PUSH     dword ptr [EBP-4] //DC
        CALL     SetTextColor
        PUSH     EAX                    // [EBP-48] = crText

        PUSH     $FFFFFF
        PUSH     dword ptr [EBP-4] //DC
        CALL     Windows.SetBkColor
        PUSH     EAX                    // [EBP-52] = crBack

        PUSH     SRCAND
        MOV      EAX, [EBP-20] //MaskDC
        CALL     @@stretch2

        PUSH     SRCINVERT
        MOV      EAX, [EBP-40] //MemDC
        CALL     @@stretch2

        PUSH     dword ptr [EBP-4] //DC
        CALL     Windows.SetBkColor

        PUSH     dword ptr [EBP-4] //DC
        CALL     SetTextColor

        MOV      ESI, offset[FinishDC]
        CALL     ESI
        CALL     DeleteObject   // DeleteObject( MemBmp )

        CALL     ESI

        CALL     ESI
@@to_exit:
        STC
        JC       @@exit

@@stretch1:
        POP      ESI
        PUSH     [EBX].fHeight
        PUSH     [EBX].fWidth
        XOR      EDX, EDX
        PUSH     EDX
        PUSH     EDX
        PUSH     EAX
        PUSH     [EBX].fHeight
        PUSH     [EBX].fWidth
        PUSH     EDX
        PUSH     EDX
        PUSH     dword ptr [EBP-40] //MemDC
        JMP      @@stretch3

@@stretch2:
        POP      ESI
        PUSH     [EBX].fHeight
        PUSH     [EBX].fWidth
        PUSH     0
        PUSH     0
        PUSH     EAX
        MOV      EAX, [EBP-8] //Rect
        MOV      EDX, [EAX].TRect.Bottom
        MOV      ECX, [EAX].TRect.Top
        SUB      EDX, ECX
        PUSH     EDX
        MOV      EDX, [EAX].TRect.Right
        MOV      EAX, [EAX].TRect.Left
        SUB      EDX, EAX
        PUSH     EDX
        PUSH     ECX
        PUSH     EAX
        PUSH     dword ptr [EBP-4] //DC
@@stretch3:
        CALL     StretchBlt
        JMP      ESI

@@exit:
        POP      ESI
        POP      EBX
        MOV      ESP, EBP
end;
{$ELSE ASM_VERSION} //Pascal
procedure TBitmap.StretchDrawMasked(DC: HDC; const Rect: TRect; Mask: HBitmap);
var
  DCfrom, MemDC, MaskDC: HDC;
  MemBmp: HBITMAP;
  Save4From, Save4Mem, Save4Mask: THandle;
  crText, crBack: TColorRef;
  //SavePal: HPALETTE;
begin
  if GetHandle = 0 then Exit;
  fDetachCanvas( Self );
    //SavePal := 0;

  DCfrom := CreateCompatibleDC( 0 );
  Save4From := SelectObject( DCfrom, fHandle );
  ASSERT( Save4From <> 0, 'Can not select source bitmap to DC' );
  MaskDC := CreateCompatibleDC( 0 );
  Save4Mask := SelectObject( MaskDC, Mask );
  ASSERT( Save4Mask <> 0, 'Can not select mask bitmap to DC' );
  MemDC := CreateCompatibleDC( 0 );
    //try
      MemBmp := CreateCompatibleBitmap( DCfrom, fWidth, fHeight );
      Save4Mem := SelectObject( MemDC, MemBmp );
      ASSERT( Save4Mem <> 0, 'Can not select memory bitmap to DC' );
      //SavePal := SelectPalette(DCfrom, SystemPalette16, False);
      //SelectPalette(DCfrom, SavePal, False);
      //if SavePal <> 0 then
      //  SavePal := SelectPalette(MemDC, SavePal, True)
      //else
      //  SavePal := SelectPalette(MemDC, SystemPalette16, True);
      //RealizePalette(MemDC);

      StretchBlt( MemDC, 0, 0, fWidth, fHeight, MaskDC, 0, 0, fWidth, fHeight, SrcCopy);
      StretchBlt( MemDC, 0, 0, fWidth, fHeight, DCfrom, 0, 0, fWidth, fHeight, SrcErase);
      crText := SetTextColor(DC, $0);
      crBack := Windows.SetBkColor(DC, $FFFFFF);
      StretchBlt( DC, Rect.Left, Rect.Top, Rect.Right - Rect.Left, Rect.Bottom - Rect.Top,
                  MaskDC, 0, 0, fWidth, fHeight, SrcAnd);
      StretchBlt( DC, Rect.Left, Rect.Top, Rect.Right - Rect.Left, Rect.Bottom - Rect.Top,
                  MemDC, 0, 0, fWidth, fHeight, SrcInvert);
      Windows.SetBkColor( DC, crBack);
      SetTextColor( DC, crText);

      if Save4Mem <> 0 then
         SelectObject( MemDC, Save4Mem );
      DeleteObject(MemBmp);
    //finally
      //if SavePal <> 0 then SelectPalette(MemDC, SavePal, False);
      DeleteDC(MemDC);
      SelectObject( DCfrom, Save4From );
      DeleteDC( DCfrom );
      SelectObject( MaskDC, Save4Mask );
      DeleteDC( MaskDC );
    //end;
end;
{$ENDIF ASM_VERSION}

//[procedure ApplyBitmapBkColor2Canvas]
procedure ApplyBitmapBkColor2Canvas( Sender: PBitmap );
begin
  if Sender.fCanvas = nil then Exit;
  Sender.fCanvas.Brush.Color := Sender.BkColor;
end;

//[PROCEDURE DetachBitmapFromCanvas]
{$IFDEF ASM_VERSION}
procedure DetachBitmapFromCanvas( Sender: PBitmap );
asm
        XOR      ECX, ECX
        XCHG     ECX, [EAX].TBitmap.fCanvasAttached
        JECXZ    @@exit
        PUSH     ECX
        MOV      EAX, [EAX].TBitmap.fCanvas
        PUSH     [EAX].TCanvas.fHandle
        CALL     SelectObject
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure DetachBitmapFromCanvas( Sender: PBitmap );
begin
  if Sender.fCanvasAttached = 0 then Exit;
  SelectObject( Sender.fCanvas.fHandle, Sender.fCanvasAttached );
  Sender.fCanvasAttached := 0;
end;
{$ENDIF ASM_VERSION}
//[END DetachBitmapFromCanvas]

{$IFDEF ASM_VERSION}
//[function TBitmap.GetCanvas]
function TBitmap.GetCanvas: PCanvas;
asm
        PUSH     EBX
        MOV      EBX, EAX
        CALL     GetEmpty
        JZ       @@exit
        MOV      EAX, EBX
        CALL     GetHandle
        TEST     EAX, EAX
        JZ       @@exit
        MOV      ECX, [EBX].fCanvas
        INC      ECX
        LOOP     @@ret_Canvas

        MOV      [EBX].fApplyBkColor2Canvas, offset[ApplyBitmapBkColor2Canvas]
        PUSH     0
        CALL     CreateCompatibleDC
        CALL     NewCanvas
        MOV      [EBX].fCanvas, EAX
        MOV      [EAX].TCanvas.fOnChange.TMethod.Code, offset[CanvasChanged]
        MOV      [EAX].TCanvas.fOnChange.TMethod.Data, EBX
        CALL     TCanvas.GetBrush
        XOR      EDX, EDX
        MOV      ECX, [EBX].fBkColor
        CALL     TGraphicTool.SetInt

@@ret_Canvas:
        MOV      EAX, [EBX].fCanvas
        MOV      ECX, [EAX].TCanvas.fHandle
        INC      ECX
        LOOP     @@attach_Canvas
        PUSH     EAX
        MOV      [EBX].fCanvasAttached, ECX
        PUSH     ECX
        CALL     CreateCompatibleDC
        XCHG     EDX, EAX
        POP      EAX
        CALL     TCanvas.SetHandle

@@attach_Canvas:
        MOV      ECX, [EBX].fCanvasAttached
        INC      ECX
        LOOP     @@2
        PUSH     [EBX].fHandle
        MOV      EAX, [EBX].fCanvas
        CALL     TCanvas.GetHandle
        PUSH     EAX
        CALL     SelectObject
        MOV      [EBX].fCanvasAttached, EAX

@@2:    MOV      [EBX].fDetachCanvas, offset[DetachBitmapFromCanvas]
        MOV      EAX, [EBX].fCanvas
@@exit: POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function TBitmap.GetCanvas: PCanvas;
var DC: HDC;
begin
  Result := nil;
  if Empty then Exit;
  if GetHandle = 0 then Exit;
  if fCanvas = nil then
  begin
    fApplyBkColor2Canvas := ApplyBitmapBkColor2Canvas;
    DC := CreateCompatibleDC( 0 );
    fCanvas := NewCanvas( DC );
    fCanvas.fIsPaintDC := FALSE;
    fCanvas.OnChange := CanvasChanged;
    fCanvas.Brush.Color := fBkColor;
  end;
  Result := fCanvas;

  if fCanvas.fHandle = 0 then
  begin
    DC := CreateCompatibleDC( 0 );
    fCanvas.Handle := DC;
    fCanvasAttached := 0;
  end;

  if fCanvasAttached = 0 then
  begin
    fCanvasAttached := SelectObject( fCanvas.Handle, fHandle );
    ASSERT( fCanvasAttached <> 0, 'Can not select bitmap to DC of Canvas' );
  end;
  fDetachCanvas := DetachBitmapFromCanvas;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TBitmap.GetEmpty]
function TBitmap.GetEmpty: Boolean;
asm
        PUSH     ECX
        MOV      ECX, [EAX].fWidth
        JECXZ    @@1
        MOV      ECX, [EAX].fHeight
@@1:    TEST     ECX, ECX
        POP      ECX
        SETZ     AL
end;
{$ELSE ASM_VERSION} //Pascal
function TBitmap.GetEmpty: Boolean;
begin
  Result := (fWidth = 0) or (fHeight = 0);
  ASSERT( (fWidth >= 0) and (fHeight >= 0), 'Bitmap dimensions can be negative' );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_noVERSION}
//[function TBitmap.GetHandle]
function TBitmap.GetHandle: HBitmap;
asm
        PUSH     EBX
        MOV      EBX, EAX
        CALL     GetEmpty
        JZ       @@exit
        MOV      ECX, [EBX].fHandle
        INC      ECX
        LOOP     @@exit

        MOV      ECX, [EBX].fDIBBits
        JECXZ    @@exit

        PUSH     ECX
        PUSH     0
        CALL     GetDC
        PUSH     EAX
        PUSH     0
        PUSH     0
        LEA      EDX, [EBX].fDIBBits
        PUSH     EDX
        PUSH     DIB_RGB_COLORS
        PUSH     [EBX].fDIBHeader
        PUSH     EAX
        CALL     CreateDIBSection
        MOV      [EBX].fHandle, EAX
        PUSH     0
        CALL     ReleaseDC
        POP      EAX
        PUSH     EAX
        MOV      EDX, [EBX].fDIBBits
        MOV      ECX, [EBX].fDIBSize
        CALL     System.Move
        POP      EAX
        CMP      [EBX].fDIBAutoFree, 0
        JNZ      @@freed
        CALL     System.@FreeMem
@@freed:MOV      [EBX].fDIBAutoFree, 1
        XOR      EAX, EAX
        MOV      [EBX].fGetDIBPixels, EAX
        MOV      [EBX].fSetDIBPixels, EAX

@@exit: MOV      EAX, [EBX].fHandle
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function TBitmap.GetHandle: HBitmap;
var OldBits: Pointer;
    DC0: HDC;
    {$IFDEF DEBUG}
    B: tagBitmap;
    {$ENDIF}
begin
  Result := 0;
  if Empty then Exit;
  if fHandle = 0 then
  begin
    if fDIBBits <> nil then
    begin
      OldBits := fDIBBits;
      DC0 := GetDC( 0 );

      fDIBBits := nil;
      //fDIBHeader.bmiHeader.biCompression := 0;
      fHandle := CreateDIBSection( DC0, fDIBHeader^, DIB_RGB_COLORS,
                    fDIBBits, 0, 0 );
      {$IFDEF DEBUG}
      if fHandle = 0 then
        ShowMessage( 'Can not create DIB section, error: ' + Int2Str( GetLastError ) +
        ', ' + SysErrorMessage( GetLastError ) );
      GetObject( fHandle, Sizeof( B ), @ B );
      {$ELSE}
      ASSERT( fHandle <> 0, 'Can not create DIB section, error: ' + Int2Str( GetLastError ) +
      ', ' + SysErrorMessage( GetLastError ) );
      {$ENDIF}
      ReleaseDC( 0, DC0 );
      if fHandle <> 0 then
      begin
        Move( OldBits^, fDIBBits^, fDIBSize );
        if not fDIBAutoFree then
          FreeMem( OldBits );
        fDIBAutoFree := TRUE;

        fGetDIBPixels := nil;
        fSetDIBPixels := nil;
      end
        else
        fDIBBits := OldBits;
    end;
  end;
  Result := fHandle;
end;
{$ENDIF ASM_VERSION}

//[function TBitmap.GetHandleAllocated]
function TBitmap.GetHandleAllocated: Boolean;
begin
  Result := fHandle <> 0;
end;

{$IFDEF ASM_VERSION}
//[procedure TBitmap.LoadFromFile]
procedure TBitmap.LoadFromFile(const Filename: String);
asm
        PUSH     EAX
        XCHG     EAX, EDX
        CALL     NewReadFileStream
        XCHG     EDX, EAX
        POP      EAX
        PUSH     EDX
        CALL     LoadFromStream
        POP      EAX
        CALL     TObj.Free
end;
{$ELSE ASM_VERSION} //Pascal
procedure TBitmap.LoadFromFile(const Filename: String);
var Strm: PStream;
begin
  Strm := NewReadFileStream( Filename );
  LoadFromStream( Strm );
  Strm.Free;
end;
{$ENDIF ASM_VERSION}

//[procedure TBitmap.LoadFromResourceID]
procedure TBitmap.LoadFromResourceID(Inst: DWORD; ResID: Integer);
begin
  LoadFromResourceName( Inst, MAKEINTRESOURCE( ResID ) );
end;

{$IFDEF ASM_VERSION}
//[procedure TBitmap.LoadFromResourceName]
procedure TBitmap.LoadFromResourceName(Inst: DWORD; ResName: PChar);
asm
        PUSH     EBX
        MOV      EBX, EAX
        PUSHAD
        CALL     Clear
        POPAD
        XOR      EAX, EAX
        PUSH     ECX
        MOVZX    ECX, [EBX].fHandleType
        INC      ECX
        LOOP     @@1
        MOV      AH, LR_CREATEDIBSECTION shr 8 // = $2000
@@1:    MOV      AL, LR_DEFAULTSIZE // = $40
        POP      ECX
        PUSH     EAX
        PUSH     0
        PUSH     0
        PUSH     IMAGE_BITMAP
        PUSH     ECX
        PUSH     EDX
        CALL     LoadImage
        TEST     EAX, EAX
        JZ       @@exit
        XCHG     EDX, EAX
        XCHG     EAX, EBX
        CALL     SetHandle
@@exit: POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TBitmap.LoadFromResourceName(Inst: DWORD; ResName: PChar);
var ResHandle: HBitmap;
    Flg: DWORD;
begin
  Clear;
  //ResHandle := LoadBitmap( Inst, ResName );
  Flg := 0;
  if fHandleType = bmDIB then
    Flg := LR_CREATEDIBSECTION;
  ResHandle := LoadImage( Inst, ResName, IMAGE_BITMAP, 0, 0,
             LR_DEFAULTSIZE or Flg );
  if ResHandle = 0 then Exit;
  //Handle := CopyImage( ResHandle, IMAGE_BITMAP, 0, 0, LR_COPYRETURNORG );
  Handle := ResHandle;
end;
{$ENDIF ASM_VERSION}

{$IFDEF F_P}
type
  TBITMAPFILEHEADER = packed record
    bfType: Word;
    bfSize: DWORD;
    bfReserved1: Word;
    bfReserved2: Word;
    bfOffBits: DWORD;
  end;
{$ENDIF}

{$IFDEF ASM_noVERSION} // error + 16Colors->swap(Gray,Silver) + Core
//[procedure TBitmap.LoadFromStream]
procedure TBitmap.LoadFromStream(Strm: PStream);
type  tBFH = TBitmapFileHeader;
      tBIH = TBitmapInfoHeader;
const szBIH = Sizeof( tBIH );
      szBFH = Sizeof( tBFH );
asm
        PUSH     EBX
        PUSH     ESI
        MOV      EBX, EAX
        PUSH     EDX
        CALL     Clear
        POP      ESI
        MOV      EAX, ESI
        CALL     TStream.GetPosition
        PUSH     EAX     // [EBP+4] = Strm.Pos (starting pos)
        PUSH     EBP
        MOV      EBP, ESP
        ADD      ESP, -(szBIH + szBFH)

        // reading bitmap
        XOR      ECX, ECX
        MOV      [EBX].fHandleType, CL
        MOV      CL, szBFH
        MOV      EDX, ESP
        PUSH     ECX
        MOV      EAX, ESI
        CALL     TStream.Read
        POP      ECX
        SUB      ECX, EAX
        JNZ      @@eread1

        CMP      [ESP].tBFH.bfType, $4D42
        JE       @@1
        MOV      EDX, [EBP+4]
        MOV      EAX, ESI
        CALL     TStream.Seek
        XOR      EAX, EAX
        XOR      EDX, EDX
        JMP      @@2

@@1:
        MOV      EDX, [ESP].tBFH.bfSize
        MOV      EAX, [ESP].tBFH.bfOffBits
@@2:
        PUSH     EDX        // Push Size
        PUSH     EAX        // Push Off
        XOR      ECX, ECX
        MOV      CL, szBIH
        LEA      EDX, [EBP-szBIH]
        MOV      EAX, ESI
        PUSH     ECX
        CALL     TStream.Read   // read BIH
        POP      ECX
@@eread1:
        XOR      ECX, EAX
        JNZ      @@eread

        MOVZX    EAX, [EBP-szBIH].tBIH.biBitCount
        MOVZX    EDX, [EBP-szBIH].tBIH.biPlanes
        MUL      EDX
        CALL     Bits2PixelFormat
        {$IFDEF PARANOIA}
        DB $3C, pf15bit
        {$ELSE}
        CMP      AL, pf15bit
        {$ENDIF}
        JNZ      @@no15bit
        CMP      [EBP-szBIH].tBIH.biCompression, 0
        JZ       @@no15bit
        INC      AL // AL = pf16bit
@@no15bit:
        MOV      [EBX].fNewPixelFormat, AL

        MOV      EAX, szBIH + 1024
        CALL     System.@GetMem
        MOV      [EBX].fDIBHeader, EAX
        XCHG     EDX, EAX
        LEA      EAX, [EBP-szBIH]
        XOR      ECX, ECX
        MOV      CL, szBIH
        CALL     System.Move

        MOV      EAX, [EBP-szBIH].tBIH.biWidth
        MOV      [EBX].fWidth, EAX
        MOV      EAX, [EBP-szBIH].tBIH.biHeight
        TEST     EAX, EAX
        JGE      @@20
        NEG      EAX
@@20:   MOV      [EBX].fHeight, EAX

        MOV      EAX, EBX
        CALL     GetScanLineSize
        MOV      EDX, [EBX].fHeight
        MUL      EDX
        MOV      [EBX].fDIBSize, EAX
        CALL     AllocMem
        MOV      [EBX].fDIBBits, EAX

        MOVZX    EAX, [EBP-szBIH].tBIH.biBitCount
        {$IFDEF PARANOIA}
        DB $3C, 8
        {$ELSE}
        CMP      AL, 8
        {$ENDIF}
        JA       @@3
        MOV      AL, 4
        MOVZX    ECX, [EBP-szBIH].tBIH.biBitCount
        SAL      EAX, CL
        XCHG     ECX, EAX
@@3:
        CMP      [EBX].TBitmap.fNewPixelFormat, pf16bit
        JNE      @@30
        XOR      ECX, ECX
        MOV      CL, 12 // ColorCount = 12
@@30:
        POP      EAX  // EAX = off
        TEST     EAX, EAX
        JLE      @@4
        SUB      EAX, szBFH + szBIH
        CMP      EAX, ECX
        JZ       @@4
        XCHG     ECX, EAX
@@4:
        JECXZ    @@5
        PUSH     ECX
        MOV      EDX, [EBX].fDIBHeader
        ADD      EDX, szBIH
        MOV      EAX, ESI
        CALL     TStream.Read
        POP      ECX
        XOR      EAX, ECX
        JNZ      @@eread
@@5:
        MOV      ECX, [EBX].fDIBSize
@@7:
        PUSH     ECX
        MOV      EAX, ESI
        CALL     TStream.GetPosition
        PUSH     EAX
        MOV      EAX, ESI
        CALL     TStream.GetSize
        POP      EDX
        SUB      EAX, EDX
        POP      ECX      // Size = fDIBSize
        CMP      EAX, ECX // Strm.Size - Strm.Position > Size ?
        JL       @@8
        XCHG     ECX, EAX
@@8:
        // ++++++++++++++ 26-Oct-2003 VK see comment in Pascal
        MOV      EAX, [EBX].fDIBSize
        CMP      ECX, EAX
        JGE      @@9
        SUB      EAX, ECX
        PUSH     EAX
        MOV      EAX, ESI
        PUSH     ECX
        CALL     TStream.GetPosition
        POP      ECX
        POP      EDX
        CMP      EDX, EAX
        JG       @@9

        MOV      EAX, ESI
        NEG      EDX
        XOR      ECX, ECX
        INC      ECX
        CALL     TStream.Seek

        MOV      ECX, [EBX].fDIBSize
@@9:
        // ++++++++++++++

        PUSH     ECX
        MOV      EDX, [EBX].fDIBBits
        MOV      EAX, ESI
        CALL     TStream.Read
        POP      ECX
        XOR      EAX, ECX
        POP      EAX // Strm.Size - Position
        POP      ECX // fDIBSize
        //JNZ      @@eread

        // end of reading bitmap
@@eread:
        MOV      ESP, EBP
        POP      EBP
        POP      EDX
        JZ       @@exit
        // not success:
        XCHG     EAX, ESI
        XOR      ECX, ECX // ECX = spBegin
        CALL     TStream.Seek
        XCHG     EAX, EBX
        CALL     Clear
@@exit: POP      ESI
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TBitmap.LoadFromStream(Strm: PStream);
type
  TColorsArray = array[ 0..15 ] of TColor;
  PColorsArray = ^TColorsArray;
  PColor = ^TColor;
var Pos : Integer;
    BFH : TBitmapFileHeader;

    function ReadBitmap : Boolean;
    var Size, Size1: Integer;
        BCH: TBitmapCoreHeader;
        RGBSize: DWORD;
        C: PColor;
        Off, HdSz, ColorCount: DWORD;
    begin
      fHandleType := bmDIB;
      Result := False;
      if Strm.Read( BFH, Sizeof( BFH ) ) <> Sizeof( BFH ) then Exit;
      Off := 0; Size := 0;
      if BFH.bfType <> $4D42 then
         Strm.Seek( Pos, spBegin )
      else
      begin
         Off := BFH.bfOffBits - Sizeof( BFH );
         Size := BFH.bfSize; // don't matter, just <> 0 is good
         //Size := Min( BFH.bfSize, Strm.Size - Strm.Position );
      end;
      RGBSize := 4;
      HdSz := Sizeof( TBitmapInfoHeader );
      fDIBHeader := AllocMem( 256*sizeof(TRGBQuad) + HdSz );
      if Strm.Read( fDIBHeader.bmiHeader.biSize, Sizeof( DWORD ) ) <> Sizeof( DWORD ) then
         Exit;
      if fDIBHeader.bmiHeader.biSize = HdSz then
      begin
        if Strm.Read( fDIBHeader.bmiHeader.biWidth, HdSz - Sizeof( DWORD ) ) <>
           HdSz - Sizeof( DWORD ) then
           Exit;
      end
        else
      if fDIBHeader.bmiHeader.biSize = Sizeof( TBitmapCoreHeader ) then
      begin
        RGBSize := 3;
        HdSz := Sizeof( TBitmapCoreHeader );
        if Strm.Read( BCH.bcWidth, HdSz - Sizeof( DWORD ) ) <>
           HdSz - Sizeof( DWORD ) then
           Exit;
        fDIBHeader.bmiHeader.biSize := Sizeof( TBitmapInfoHeader );
        fDIBHeader.bmiHeader.biWidth := BCH.bcWidth;
        fDIBHeader.bmiHeader.biHeight := BCH.bcHeight;
        fDIBHeader.bmiHeader.biPlanes := BCH.bcPlanes;
        fDIBHeader.bmiHeader.biBitCount := BCH.bcBitCount;
      end
        else Exit;
      fNewPixelFormat := Bits2PixelFormat( fDIBHeader.bmiHeader.biBitCount
                         * fDIBHeader.bmiHeader.biPlanes );
      if (fNewPixelFormat = pf15bit) and (fDIBHeader.bmiHeader.biCompression <> BI_RGB) then
      begin
        ASSERT( fDIBHeader.bmiHeader.biCompression = BI_BITFIELDS, 'Unsupported bitmap format' );
        //fNewPixelFormat := pf16bit;
      end;
      fWidth := fDIBHeader.bmiHeader.biWidth;
      ASSERT( fWidth > 0, 'Bitmap width must be > 0' );
      fHeight := Abs(fDIBHeader.bmiHeader.biHeight);
      ASSERT( fHeight > 0, 'Bitmap height must be > 0' );

      fDIBSize := ScanLineSize * fHeight;
      fDIBBits := AllocMem( fDIBSize );
      ASSERT( fDIBBits <> nil, 'No memory' );

      ColorCount := 0;
      if fDIBHeader.bmiHeader.biBitCount <= 8 then
        ColorCount := (1 shl fDIBHeader.bmiHeader.biBitCount) * RGBSize
      else if fNewPixelFormat in [pf15bit,pf16bit] then
        ColorCount := 12;

      if Off > 0 then
      begin
         Off := Off - HdSz;
         if (Off <> ColorCount) then
         if not(fNewPixelFormat in [pf15bit,pf16bit])
         or (Off = 0) //+++ to fix loading 15- and 16-bit bmps with mask omitted
         then
            ColorCount := Off;
      end;
      if ColorCount <> 0 then
      begin
         if Off >= ColorCount then
           Off := Off - ColorCount;
         if RGBSize = 4 then
         begin
           if Strm.Read( fDIBheader.bmiColors[ 0 ], ColorCount )
              <> DWORD( ColorCount ) then Exit;
         end
           else
         begin
           C := @ fDIBHeader.bmiColors[ 0 ];
           while ColorCount > 0 do
           begin
             if Strm.Read( C^, RGBSize ) <> RGBSize then Exit;
             Dec( ColorCount, RGBSize );
             Inc( C );
           end;
         end;
      end;
      if Off > 0 then
        Strm.Seek( Off, spCurrent );

      if Size = 0 then
         Size := fDIBSize //ScanLineSize * fHeight
      else
         Size := Min( {Size - Sizeof( TBitmapFileHeader ) - Sizeof( TBitmapInfoHeader )
              - ColorCount} fDIBSize, Strm.Size - Strm.Position );

      Size1 := Min( Size, fDIBSize );

      // +++++++++++++++++++ 26-Oct-2003 by VK
      if (Size1 < fDIBSize)
         and (DWORD( fDIBSize - Size1 ) <= Strm.Position) then
      begin
        Strm.Seek( Size1 - fDIBSize, spCurrent );
        Size1 := fDIBSize;
      end;
      // +++++++++++++++++++ to fix some "incorrect" bitmaps while loading

      if Strm.Read( fDIBBits^, Size1 ) <> DWORD( Size1 ) then Exit;
      if Size > Size1 then
        Strm.Seek( Size - Size1, spCurrent );

      Result := True;
    end;
{var ColorsArray: PColorsArray;
    DC: HDC;
    Old: HBitmap;}
begin
  Clear;
  Pos := Strm.Position;
  if not ReadBitmap then
  begin
     Strm.Seek( Pos, spBegin );
     Clear;
  end;
    {else
  begin
    if (fDIBBits <> nil) and (fDIBHeader.bmiHeader.biBitCount >= 4) then
    begin
        ColorsArray := @ fDIBHeader.bmiColors[ 0 ];
        if ColorsArray[ 7 ] = $C0C0C0 then
        if ColorsArray[ 8 ] = $808080 then
        if GetHandle <> 0 then
        begin
          DC := CreateCompatibleDC( 0 );
          Old := SelectObject( DC, fHandle );
          SetDIBColorTable( DC, 0, 16, fDIBHeader.bmiColors[ 0 ] );
          SelectObject( DC, Old );
          DeleteDC( DC );
        end;
    end;
  end;}
end;
{$ENDIF ASM_VERSION}

////////////////// bitmap RLE-decoding and loading - by Vyacheslav A. Gavrik

//[procedure DecodeRLE4]
procedure DecodeRLE4(Bmp:PBitmap;Data:Pointer); // by Vyacheslav A. Gavrik
  procedure OddMove(Src,Dst:PByte;Size:Integer);
  begin
    if Size=0 then Exit;
    repeat
      Dst^:=(Dst^ and $F0)or(Src^ shr 4);
      Inc(Dst);
      Dst^:=(Dst^ and $0F)or(Src^ shl 4);
      Inc(Src);
      Dec(Size);
    until Size=0;
  end;
  procedure OddFill(Mem:PByte;Size,Value:Integer);
  begin
    Value:=(Value shr 4)or(Value shl 4);
    Mem^:=(Mem^ and $F0)or(Value and $0F);
    Inc(Mem);
    if Size>1 then FillChar(Mem^,Size,Value);
    Mem^:=(Mem^ and $0F)or(Value and $F0);
  end;
var
  pb: PByte;
  x,y,z,i: Integer;
begin
  pb:=Data; x:=0; y:=0;
  if Bmp.fScanLineSize = 0 then
     Bmp.ScanLineSize;
  while y<Bmp.Height do
  begin
    if pb^=0 then
    begin
      Inc(pb);
      z:=pb^;
      case pb^ of
        0: begin
             Inc(y);
             x:=0;
           end;
        1: Break;
        2: begin
             Inc(pb); Inc(x,pb^);
             Inc(pb); Inc(y,pb^);
           end;
        else
        begin
          Inc(pb);
          i:=(z+1)shr 1;
          if(z and 2)=2 then Inc(i);
          if((x and 1)=1)and(x+i<Bmp.Width)then
            OddMove(pb,@PByteArray(Integer( Bmp.fDIBBits ) + Bmp.fScanLineSize * y)[x shr 1],i)
          else
            Move(pb^,PByteArray(Integer( Bmp.fDIBBits ) + Bmp.fScanLineSize * y)[x shr 1],i);
          Inc(pb,i-1);
          Inc(x,z);
        end;
      end;
    end else
    begin
      z:=pb^;
      Inc(pb);
      if((x and 1)=1)and(x+z<Bmp.Width)then
        OddFill(@PByteArray(Integer( Bmp.fDIBBits ) + Bmp.fScanLineSize * y)[x shr 1],z shr 1,pb^)
      else
        FillChar(PByteArray(Integer( Bmp.fDIBBits ) + Bmp.fScanLineSize * y)[x shr 1],z shr 1,pb^);
      Inc(x,z);
    end;
    Inc(pb);
  end;
end;

//[procedure DecodeRLE8]
procedure DecodeRLE8(Bmp:PBitmap;Data:Pointer); // by Vyacheslav A. Gavrik
var
  pb: PByte;
  x,y,z,i: Integer;
begin
  pb:=Data; y:=0; x:=0;
  if Bmp.fScanLineSize = 0 then
     Bmp.ScanLineSize;

  while y<Bmp.Height do
  begin
    if pb^=0 then
    begin
      Inc(pb);
      case pb^ of
        0: begin
             Inc(y);
             x:=0;
           end;
        1: Break;
        2: begin
             Inc(pb); Inc(x,pb^);
             Inc(pb); Inc(y,pb^);
           end;
        else
        begin
          i:=pb^;
          z:=(i+1)and(not 1);
          Inc(pb);
          Move(pb^,PByteArray(Integer( Bmp.fDIBBits ) + Bmp.fScanLineSize * y)[x],z);
          Inc(pb,z-1);
          Inc(x,i);
        end;
      end;
    end else
    begin
      i:=pb^; Inc(pb);
      FillChar(PByteArray(Integer( Bmp.fDIBBits ) + Bmp.fScanLineSize * y)[x],i,pb^);
      Inc(x,i);
    end;
    Inc(pb);
  end;
end;

//[function TBitmap.LoadFromFileEx]
function TBitmap.LoadFromFileEx(const Filename: String): Boolean; // by Vyacheslav A. Gavrik
var Strm: PStream;
begin
  Strm := NewReadFileStream( Filename );
  Result := LoadFromStreamEx(Strm);
  Strm.Free;
end;

//[function TBitmap.LoadFromStreamEx]
function TBitmap.LoadFromStreamEx(Strm: PStream): Boolean; // by Vyacheslav A. Gavrik
var Pos : Integer;

    function ReadBitmap : Boolean;
    var Off, Size, ColorCount: Integer;
        BFH : TBitmapFileHeader;
        BFHValid: Boolean;
        Buffer: Pointer;
    begin
      fHandleType := bmDIB;
      Result := False;
      BFHValid := FALSE;
      if Strm.Read( BFH, Sizeof( BFH ) ) <> Sizeof( BFH ) then Exit;
      Off := 0; Size := 0;
      if BFH.bfType <> $4D42 then
         Strm.Seek( Pos, spBegin )
      else
      begin
         BFHValid := TRUE;
         Off := BFH.bfOffBits;
         Size := Strm.GetSize;
      end;
      GetMem( fDIBHeader, 256*sizeof(TRGBQuad) + sizeof(TBitmapInfoHeader) );
      if Strm.Read( fDIBHeader^, Sizeof(TBitmapInfoHeader) ) <> Sizeof(TBitmapInfoHeader) then
         Exit;
      if fDIBHeader.bmiHeader.biCompression = BI_BITFIELDS then
        Strm.Read( fDIBHeader.bmiColors[ 0 ], 3 * Sizeof( DWORD ) );

      fNewPixelFormat := Bits2PixelFormat( fDIBHeader.bmiHeader.biBitCount
                         * fDIBHeader.bmiHeader.biPlanes );

      fWidth := fDIBHeader.bmiHeader.biWidth;
      ASSERT( fWidth > 0, 'Bitmap width must be > 0' );
      fHeight := Abs(fDIBHeader.bmiHeader.biHeight);
      ASSERT( fHeight > 0, 'Bitmap height must be > 0' );

      fDIBSize := ScanLineSize * fHeight;
      GetMem( fDIBBits, fDIBSize );
      ASSERT( fDIBBits <> nil, 'No memory' );
      ASSERT( (fDIBHeader.bmiHeader.biCompression and
              (BI_RLE8 or BI_RLE4 or BI_RLE8 or BI_BITFIELDS) <> 0) or
              (fDIBHeader.bmiHeader.biCompression = BI_RGB),
              'Unknown compression algorithm');

      ColorCount := 0;
      if fDIBHeader.bmiHeader.biBitCount <= 8 then
        ColorCount := (1 shl fDIBHeader.bmiHeader.biBitCount) * Sizeof( TRGBQuad )
      else if fNewPixelFormat = pf16bit then
        ColorCount := 12;

      if Off > 0 then
      begin
         Off := Off - SizeOf( TBitmapFileHeader ) - Sizeof( TBitmapInfoHeader );
         if Off <> ColorCount then
            ColorCount := Off;
      end;
      if ColorCount <> 0 then
         if Strm.Read( fDIBheader.bmiColors[ 0 ], ColorCount )
            <> DWORD( ColorCount ) then Exit;

      if not BFHValid then
        Size := fDIBSize
      else
      if(fDIBHeader.bmiHeader.biCompression = BI_RLE8)
         or (fDIBHeader.bmiHeader.biCompression=BI_RLE4) then
            Size := BFH.bfSize - BFH.bfOffBits
         else
           if Integer( Strm.Size - BFH.bfOffBits) - Pos > Integer(Size) then
             Size := fDIBSize
           else
             Size := Strm.Size - BFH.bfOffBits - DWORD( Pos );

      if (fDIBHeader.bmiHeader.biCompression = BI_RGB) or
         (fDIBHeader.bmiHeader.biCompression = BI_BITFIELDS) then
      begin
        if Strm.Read( fDIBBits^, Size ) <> DWORD( Size ) then
          Exit;
      end
        else
      begin
        GetMem(Buffer,Size);
        if Strm.Read(Buffer^,Size) <> DWORD( Size ) then Exit;

        if fDIBHeader.bmiHeader.biCompression=BI_RLE8 then
           DecodeRLE8(Self,Buffer)
        else
           DecodeRLE4(Self,Buffer);

        fDIBHeader.bmiHeader.biCompression := BI_RGB;
        FreeMem(Buffer);
      end;

      Result := True;
    end;
begin
  Clear;
  Pos := Strm.Position;
  result := ReadBitmap;
  if not result then
  begin
     Strm.Seek( Pos, spBegin );
     Clear;
  end;
end;

///////////////////////////

{$IFDEF ASM_VERSION}
//[function TBitmap.ReleaseHandle]
function TBitmap.ReleaseHandle: HBitmap;
asm
        PUSH     EBX
        MOV      EBX, EAX
        XOR      EDX, EDX
        CALL     SetHandleType
        MOV      EAX, EBX
        CALL     GetHandle
        TEST     EAX, EAX
        JZ       @@exit

        CMP      [EBX].fDIBAutoFree, 0
        JZ       @@1
        MOV      EAX, [EBX].fDIBSize
        PUSH     EAX
        CALL     System.@GetMem
        MOV      EDX, EAX
        XCHG     EAX, [EBX].fDIBBits
        POP      ECX
        CALL     System.Move
@@1:
        XOR      EAX, EAX
        MOV      [EBX].fDIBAutoFree, AL
        XCHG     EAX, [EBX].fHandle

@@exit: POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function TBitmap.ReleaseHandle: HBitmap;
var OldBits: Pointer;
begin
  HandleType := bmDIB;
  Result := GetHandle;
  if Result = 0 then Exit; // only when bitmap is empty
  if fDIBAutoFree then
  begin
    OldBits := fDIBBits;
    GetMem( fDIBBits, fDIBSize );
    Move( OldBits^, fDIBBits^, fDIBSize );
    fDIBAutoFree := FALSE;
  end;
  fHandle := 0;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TBitmap.SaveToFile]
procedure TBitmap.SaveToFile(const Filename: String);
asm
        PUSH     EAX
        PUSH     EDX
        CALL     GetEmpty
        POP      EAX
        JZ       @@exit
        CALL     NewWriteFileStream
        XCHG     EDX, EAX
        POP      EAX
        PUSH     EDX
        CALL     SaveToStream
        POP      EAX
        CALL     TObj.Free
        PUSH     EAX
@@exit: POP      EAX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TBitmap.SaveToFile(const Filename: String);
var Strm: PStream;
begin
  if Empty then Exit;
  Strm := NewWritefileStream( Filename );
  SaveToStream( Strm );
  Strm.Free;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TBitmap.SaveToStream]
procedure TBitmap.SaveToStream(Strm: PStream);
type  tBFH = TBitmapFileHeader;
      tBIH = TBitmapInfoHeader;
const szBIH = Sizeof( tBIH );
      szBFH = Sizeof( tBFH );
asm
        PUSH     EBX
        PUSH     ESI
        MOV      EBX, EAX
        MOV      ESI, EDX
        CALL     GetEmpty
        JZ       @@exit
        MOV      EAX, ESI
        CALL     TStream.GetPosition
        PUSH     EAX

        MOV      EAX, EBX
        XOR      EDX, EDX // EDX = bmDIB
        CALL     SetHandleType
        XOR      EAX, EAX
        MOV      EDX, [EBX].fDIBHeader
        MOVZX    ECX, [EDX].TBitmapInfoHeader.biBitCount
        CMP      CL, 8
        JG       @@1
        MOV      AL, 4
        SHL      EAX, CL
@@1:
          PUSH     EAX                        // ColorsSize
        LEA      ECX, [EAX + szBFH + szBIH]
        CMP      [EDX].TBitmapInfoHeader.biCompression, 0
        JZ       @@10
        ADD      ECX, 74
@@10:
        PUSH     ECX                        // BFH.bfOffBits
        PUSH     0
        ADD      ECX, [EBX].fDIBSize
        PUSH     ECX
        MOV      CX, $4D42
        PUSH     CX
        XOR      ECX, ECX
        MOV      EDX, ESP
        MOV      CL, szBFH
          PUSH     ECX
        MOV      EAX, ESI
        CALL     TStream.Write
          POP      ECX
        ADD      ESP, szBFH
        XOR      EAX, ECX
          POP      ECX  // ColorsSize
        JNZ      @@ewrite

        MOV      EDX, [EBX].fDIBHeader
        CMP      [EDX].TBitmapInfoHeader.biCompression, 0
        JZ       @@11
        ADD      ECX, 74
@@11:

        ADD      ECX, szBIH
        PUSH     ECX
        MOV      EAX, ESI
        CALL     TStream.Write
        POP      ECX
        XOR      EAX, ECX
        JNZ      @@ewrite

        MOV      ECX, [EBX].fDIBSize
        MOV      EDX, [EBX].fDIBBits
        MOV      EAX, ESI
        PUSH     ECX
        CALL     TStream.Write
        POP      ECX
        XOR      EAX, ECX

@@ewrite:
        POP      EDX
        JZ       @@exit
        XCHG     EAX, ESI
        XOR      ECX, ECX
        CALL     TStream.Seek
@@exit:
        POP      ESI
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TBitmap.SaveToStream(Strm: PStream);
var BFH : TBitmapFileHeader;
    Pos : Integer;
   function WriteBitmap : Boolean;
   var ColorsSize, BitsSize, Size : Integer;
   begin
      Result := False;
      if Empty then Exit;
      HandleType := bmDIB; // convert to DIB if DDB
      FillChar( BFH, Sizeof( BFH ), 0 );
      ColorsSize := 0;
      with fDIBHeader.bmiHeader do
           if biBitCount <= 8 then
              ColorsSize := (1 shl biBitCount) * Sizeof( TRGBQuad )
           {else
           if biCompression <> 0 then
              ColorsSize := 12};
      BFH.bfOffBits := Sizeof( BFH ) + Sizeof( TBitmapInfoHeader ) + ColorsSize;
      BitsSize := fDIBSize; //ScanLineSize * fHeight;
      BFH.bfSize := BFH.bfOffBits + DWord( BitsSize );
      BFH.bfType := $4D42; // 'BM';
      if fDIBHeader.bmiHeader.biCompression <> 0 then
      begin
         ColorsSize := 12 + 16*sizeof(TRGBQuad);
         Inc( BFH.bfOffBits, ColorsSize );
      end;
      if Strm.Write( BFH, Sizeof( BFH ) ) <> Sizeof( BFH ) then Exit;
      Size := Sizeof( TBitmapInfoHeader ) + ColorsSize;
      if Strm.Write( fDIBHeader^, Size ) <> DWORD(Size) then Exit;
      if Strm.Write( fDIBBits^, BitsSize ) <> DWord( BitsSize ) then Exit;
      Result := True;
   end;
begin
  Pos := Strm.Position;
  if not WriteBitmap then
     Strm.Seek( Pos, spBegin );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TBitmap.SetHandle]
procedure TBitmap.SetHandle(const Value: HBitmap);
const szB = sizeof( tagBitmap );
asm
        PUSH     EAX
        PUSH     EDX
        CALL     Clear
        POP      ECX
        JECXZ    @@exit
        PUSH     ECX
        ADD      ESP, -szB
        PUSH     ESP
        PUSH     szB
        PUSH     ECX
        CALL     GetObject
        POP      EDX
        POP      EDX
        POP      ECX
        ADD      ESP, 12
        TEST     EAX, EAX
        POP      EAX
        JZ       @@exit
        XCHG     EAX, [ESP]
        MOV      [EAX].fWidth, EDX
        MOV      [EAX].fHeight, ECX
        POP      EDX
        MOV      [EAX].fHandle, EDX
        MOV      [EAX].fHandleType, 1
        PUSH     EAX
@@exit: POP      EAX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TBitmap.SetHandle(const Value: HBitmap);
var B: tagBitmap;
begin
  Clear;
  if Value = 0 then Exit;
  if GetObject( Value, Sizeof( B ), @B ) = 0 then Exit;
  fHandle := Value;
  fWidth := B.bmWidth;
  fHeight := B.bmHeight;
  fHandleType := bmDDB;
end;
{$ENDIF ASM_VERSION}

//[procedure TBitmap.SetWidth]
procedure TBitmap.SetWidth(const Value: Integer);
begin
  if fWidth = Value then Exit;
  fWidth := Value;
  FormatChanged;
end;

{$IFDEF ASM_VERSION}
//[procedure TBitmap.SetHeight]
procedure TBitmap.SetHeight(const Value: Integer);
asm
        CMP      EDX, [EAX].fHeight
        JE       @@exit
        PUSHAD
        XOR      EDX, EDX
        INC      EDX
        CALL     SetHandleType
        POPAD
        MOV      [EAX].fHeight, EDX
        CALL     FormatChanged
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TBitmap.SetHeight(const Value: Integer);
begin
  if fHeight = Value then Exit;

    HandleType := bmDDB;
    // Not too good, but provides correct changing of height
    // preserving previous image

  fHeight := Value;
  FormatChanged;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TBitmap.SetPixelFormat]
procedure TBitmap.SetPixelFormat(Value: TPixelFormat);
asm
        PUSH     EBX
        MOV      EBX, EAX
        //////////////////////
        CALL     GetEmpty   //   if Empty then Exit;
        JZ       @@exit     //
        MOV      EAX, EBX   //
        //////////////////////
        PUSH     EDX
        CALL     GetPixelFormat
        POP      EDX
        CMP      EAX, EDX
        JE       @@exit
        TEST     EDX, EDX
        MOV      EAX, EBX
        JNE      @@2
        // Value = pfDevice (=0)
        POP      EBX
        INC      EDX // EDX = bmDDB
        JMP      SetHandleType
@@2:
        MOV      [EBX].fNewPixelFormat, DL
        CMP      DL, pf16bit
        JNZ      @@3
        DEC      EDX
@@3:    PUSH     EDX
        XOR      EDX, EDX
        CALL     SetHandleType
        MOV      EAX, [EBX].fDIBHeader
        MOVZX    EAX, [EAX].TBitmapInfoHeader.biBitCount
        CALL     Bits2PixelFormat
        POP      EDX
        CMP      AL, DL
        XCHG     EAX, EBX
@@exit:
        POP      EBX
        JNE      FormatChanged
end;
{$ELSE ASM_VERSION} //Pascal
procedure TBitmap.SetPixelFormat(Value: TPixelFormat);
begin
  if PixelFormat = Value then Exit;
  if Empty then Exit;
  if Value = pfDevice then
    HandleType := bmDDB
  else
  begin
    fNewPixelFormat := Value;
    //if Value = pf16bit then Value := pf15bit;
    HandleType := bmDIB;
    if Value <> Bits2PixelFormat( fDIBHeader.bmiHeader.biBitCount ) then
      FormatChanged;
  end;
end;
{$ENDIF ASM_VERSION}

//[FUNCTION CalcScanLineSize]
{$IFDEF ASM_VERSION}
function CalcScanLineSize( Header: PBitmapInfoHeader ): Integer;
asm
        MOVZX    EDX, [EAX].TBitmapInfoHeader.biBitCount
        MOV      EAX, [EAX].TBitmapInfoHeader.biWidth
        MUL      EDX
        ADD      EAX, 31
        SHR      EAX, 3
        AND      EAX, -4
end;
{$ELSE ASM_VERSION} //Pascal
function CalcScanLineSize( Header: PBitmapInfoHeader ): Integer;
begin
  //Result := ((Header.biBitCount * Header.biWidth + 31)
  //          shr 5) * 4;
  Result := ((Header.biBitCount * Header.biWidth + 31) shr 3) and $FFFFFFFC;
end;
{$ENDIF ASM_VERSION}
//[END CalcScanLineSize]

//[PROCEDURE FillBmpWithBkColor]
{$IFDEF ASM_VERSION}
procedure FillBmpWithBkColor( Bmp: PBitmap; DC2: HDC; oldWidth, oldHeight: Integer );
asm
        PUSH     EBX
        PUSH     ESI
        XCHG     EAX, EBX
        PUSH     EDX // [EBP-12] = DC2
        PUSH     ECX // [EBP-16] = oldWidth
        MOV      EAX, [EBX].TBitmap.fBkColor
        CALL     Color2RGB
        TEST     EAX, EAX
        JZ       @@exit
        XCHG     ESI, EAX // ESI = Color2RGB( Bmp.fBkColor )
        MOV      EAX, EBX
        CALL     TBitmap.GetHandle
        TEST     EAX, EAX
        JZ       @@exit
        PUSH     EAX //fHandle
        PUSH     dword ptr [EBP-12] //DC2
        CALL     SelectObject
        PUSH     EAX // [EBP-20] = oldBmp
        PUSH     ESI
        CALL     CreateSolidBrush
        XCHG     ESI, EAX // ESI = Br
        PUSH     [EBX].TBitmap.fHeight
        PUSH     [EBX].TBitmap.fWidth
        MOV      EAX, [oldHeight]
        MOV      EDX, [EBP-16] //oldWidth
        CMP      EAX, [EBX].TBitmap.fHeight
        JL       @@fill
        CMP      EDX, [EBX].TBitmap.fWidth
        JGE      @@nofill
@@fill: CMP      EAX, [EBX].TBitmap.fHeight
        JNE      @@1
        XOR      EAX, EAX
@@1:
        CMP      EDX, [EBX].TBitmap.fWidth
        JNZ      @@2
        CDQ
@@2:    PUSH     EAX
        PUSH     EDX

        MOV      EDX, ESP
        PUSH     ESI
        PUSH     EDX
        PUSH     dword ptr [EBP-12] //DC2
        CALL     Windows.FillRect
        POP      ECX
        POP      ECX
@@nofill:
        POP      ECX
        POP      ECX
        PUSH     ESI //Br
        CALL     DeleteObject
        PUSH     dword ptr [EBP-12] //DC2
        CALL     SelectObject
@@exit:
        POP      ECX
        POP      EDX
        POP      ESI
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure FillBmpWithBkColor( Bmp: PBitmap; DC2: HDC; oldWidth, oldHeight: Integer );
var oldBmp: HBitmap;
    R: TRect;
    Br: HBrush;
begin
  with Bmp do
  if Color2RGB( fBkColor ) <> 0 then
  if (oldWidth < fWidth) or (oldHeight < fHeight) then
    if GetHandle <> 0 then
    begin
      oldBmp := SelectObject( DC2, fHandle );
      ASSERT( oldBmp <> 0, 'Can not select bitmap to DC' );
      Br := CreateSolidBrush( Color2RGB( fBkColor ) );
      R := MakeRect( oldWidth, oldHeight, fWidth, fHeight );
      if oldWidth = fWidth then
         R.Left := 0;
      if oldHeight = fHeight then
         R.Top := 0;
      Windows.FillRect( DC2, R, Br );
      DeleteObject( Br );
      SelectObject( DC2, oldBmp );
    end;
end;
{$ENDIF ASM_VERSION}
//[END FillBmpWithBkColor]

const BitCounts: array[ TPixelFormat ] of Byte = ( 0, 1, 4, 8, 16, 16, 24, 32, 0 );
{$IFDEF ASM_VERSION}
//[procedure TBitmap.FormatChanged]
procedure TBitmap.FormatChanged;
type  tBIH = TBitmapInfoHeader;
      tBmp = tagBitmap;
const szBIH = Sizeof( tBIH );
      szBmp = Sizeof( tBmp );
asm
        PUSH     EAX
        CALL     GetEmpty
        POP      EAX
        JZ       @@exit
        PUSHAD
        MOV      EBX, EAX
        CALL     [EBX].fDetachCanvas
        XOR      EAX, EAX
        MOV      [EBX].fScanLineSize, EAX
        MOV      [EBX].fGetDIBPixels, EAX
        MOV      [EBX].fSetDIBPixels, EAX
        MOV      ESI, [EBX].fWidth    // ESI := oldWidth
        MOV      EDI, [EBX].fHeight   // EDI := oldHeight
        MOV      ECX, [EBX].fDIBBits
        JECXZ    @@noDIBBits
        MOV      EAX, [EBX].fDIBHeader
        MOV      ESI, [EAX].TBitmapInfo.bmiHeader.biWidth
        MOV      EDI, [EAX].TBitmapInfo.bmiHeader.biHeight
        TEST     EDI, EDI
        JGE      @@1
        NEG      EDI
@@1:    JMP      @@createDC2
@@noDIBBits:
        MOV      ECX, [EBX].fHandle
        JECXZ    @@createDC2
        ADD      ESP, -24 // -szBmp
        PUSH     ESP
        PUSH     24 //szBmp
        PUSH     ECX
        CALL     GetObject
        XCHG     ECX, EAX
        JECXZ    @@2
        MOV      ESI, [ESP].tBmp.bmWidth
        MOV      EDI, [ESP].tBmp.bmHeight
@@2:    ADD      ESP, 24 //szBmp
@@createDC2:
        PUSH     0
        CALL     CreateCompatibleDC
        PUSH     EAX                         // > DC2
        CMP      [EBX].fHandleType, bmDDB
        JNE      @@DIB_handle_type
        PUSH     0
        CALL     GetDC
        PUSH     EAX                         // > DC0
        PUSH     [EBX].fHeight
        PUSH     [EBX].fWidth
        PUSH     EAX
        CALL     CreateCompatibleBitmap
        XCHG     EBP, EAX        // EBP := NewHandle
        PUSH     0
        CALL     ReleaseDC                   // <
        POP      EDX
        PUSH     EDX             // EDX := DC2
        PUSH     EBP
        PUSH     EDX
        CALL     SelectObject
        PUSH     EAX                         // > OldBmp
        PUSH     [EBX].fHeight   // prepare Rect(0,0,fWidth,fHeight)
        PUSH     [EBX].fWidth
        PUSH     0
        PUSH     0
        MOV      EAX, [EBX].fBkColor
        CALL     Color2RGB
        PUSH     EAX
        CALL     CreateSolidBrush
        MOV      EDX, ESP
        PUSH     EAX                         // > Br
        PUSH     EAX
        PUSH     EDX
        PUSH     dword ptr [ESP+32] // (DC2)
        CALL     Windows.FillRect
        CALL     DeleteObject                // <
        ADD      ESP, 16            // remove Rect
        MOV      ECX, [EBX].fDIBBits
        JECXZ    @@draw
        PUSH     dword ptr [ESP+4] // (DC2)
        CALL     SelectObject                // < (OldBmp)
        PUSH     DIB_RGB_COLORS    // : DIB_RGB_COLORS
        PUSH     [EBX].fDIBHeader  // : fDIBHeader
        PUSH     [EBX].fDIBBits    // : fDIBBits
        PUSH     [EBX].fHeight     // : fHeight
        PUSH     0                 // : 0
        PUSH     EBP               // : NewHandle
        PUSH     dword ptr [ESP+24] // (DC2)
        CALL     SetDIBits
        JMP      @@clearData
@@draw:
        MOV      EDX, [ESP+4]
        PUSH     EDX           // prepare DC2 for SelectObject
        MOV      EAX, EBX
        XOR      ECX, ECX
        PUSH     ECX
        CALL     Draw
        CALL     SelectObject
@@clearData:
        MOV      EAX, EBX
        CALL     ClearData
        MOV      [EBX].fHandle, EBP

        JMP      @@fillBkColor

@@DIB_handle_type:    // [ESP] = DC2
        MOVZX    EAX, [EBX].fNewPixelFormat
@@getBitsPixel:
        XCHG     ECX, EAX
        MOV      CL, [ECX] + offset BitCounts
        MOVZX    EAX, [DefaultPixelFormat]
        JECXZ    @@getBitsPixel
        XOR      EBP, EBP            // NewHandle := 0
        MOV      EAX, [EBX].fWidth   // EAX := fWidth
        MOV      EDX, [EBX].fHeight  // EDX := fHeight
        CALL     PrepareBitmapHeader
        PUSH     EAX                            // > NewHeader
        CMP      [EBX].fNewPixelFormat, pf16bit
        JNE      @@newHeaderReady
        CALL     PreparePF16bit
@@newHeaderReady:
        POP      EAX
        PUSH     EAX
        CALL     CalcScanLineSize
        MOV      EDX, [EBX].fHeight
        MUL      EDX
        PUSH     EAX                           // > sizeBits

        {$IFDEF _FP}
        CALL     GetMem
        {$ELSE}
        CALL     System.@GetMem
        {$ENDIF}
        PUSH     EAX                           // > NewBits
        PUSH     DIB_RGB_COLORS
        PUSH     dword ptr [ESP+12] // (NewHeader)
        PUSH     EAX
        MOV      EAX, [EBX].fHeight
        CMP      EAX, EDI
        JLE      @@3
        MOV      EAX, EDI
@@3:    PUSH     EAX
        PUSH     0
        MOV      EAX, EBX
        CALL     GetHandle
        PUSH     EAX
        PUSH     dword ptr [ESP+36] // (DC2)
        CALL     GetDIBits

        MOV      EDX, [EBX].fHeight
        CMP      EDX, EDI
        JLE      @@30
        MOV      EDX, EDI
@@30:

        CMP      EAX, EDX
        JE       @@2clearData

        POP      EAX
        {$IFDEF _FP}
        CALL     FreeMem
        {$ELSE}
        CALL     System.@FreeMem
        {$ENDIF}

        XOR      EAX, EAX
        PUSH     EAX

        MOV      EDX, ESP        // EDX = @NewBits
        MOV      ECX, [ESP+8]    // ECX = @NewHeader
        PUSH     EAX             // -> 0
        PUSH     EAX             // -> 0
        PUSH     EDX             // -> @NewBits
        PUSH     DIB_RGB_COLORS  // -> DIB_RGB_COLORS
        PUSH     ECX             // -> @NewHeader
        PUSH     dword ptr [ESP+32] // -> DC2
        CALL     CreateDIBSection

        XOR      ESI, -1 // use OldWidth to store NewDIBAutoFree flag

        XCHG     EBP, EAX        // EBP := NewHandle
        PUSH     EBP
        PUSH     dword ptr [ESP+16] // -> DC2
        CALL     SelectObject
        PUSH     EAX           // save oldBmp
        MOV      EDX, [ESP+16] // DC2 -> EDX (DC)
        XOR      ECX, ECX      // 0   -> ECX (X)
        PUSH     ECX           // 0   -> stack (Y)
        MOV      EAX, EBX
        CALL     TBitmap.Draw
        PUSH     dword ptr [ESP+16] // -> DC2
        CALL     SelectObject

@@2clearData:
        MOV      EAX, EBX
        CALL     ClearData

        POP      [EBX].fDIBBits
        POP      [EBX].fDIBSize
        POP      [EBX].fDIBHeader
        MOV      [EBX].fHandle, EBP

        TEST     ESI, ESI
        MOV      [EBX].fDIBAutoFree, 0
        JGE      @@noDIBautoFree
        INC      [EBX].fDIBAutoFree
@@noDIBautoFree:

@@fillBkColor:
        MOV      ECX, [EBX].fFillWithBkColor
        JECXZ    @@deleteDC2
        POP      EDX // (DC2)
        PUSH     EDX
        PUSH     EDI
        XCHG     ECX, ESI
        XCHG     EAX, EBX
        CALL     ESI
@@deleteDC2:
        CALL     DeleteDC
        POPAD
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TBitmap.FormatChanged;
// This method is used whenever Width, Height, PixelFormat or HandleType
// properties are changed.
// Old image will be drawn here to a new one (excluding cases when
// old width or height was 0, and / or new width or height is 0).
// To avoid inserting this code into executable, try not to change
// properties Width / Height of bitmat after it is created using
// NewBitmap( W, H ) function or after it is loaded from file, stream
// or resource.

var B: tagBitmap;
    oldBmp, NewHandle: HBitmap;
    DC0, DC2: HDC;
    NewHeader: PBitmapInfo;
    NewBits: Pointer;
    oldHeight, oldWidth, sizeBits, bitsPixel: Integer;
    Br: HBrush;
    N: Integer;
    NewDIBAutoFree: Boolean;
    Hndl: THandle;
begin
  if Empty then Exit;
  NewDIBAutoFree := FALSE;
  fDetachCanvas( Self );
  fScanLineSize := 0;
  fGetDIBPixels := nil;
  fSetDIBPixels := nil;

    oldWidth := fWidth;
    oldHeight := fHeight;
    if fDIBBits <> nil then
    begin
      oldWidth := fDIBHeader.bmiHeader.biWidth;
      oldHeight := Abs(fDIBHeader.bmiHeader.biHeight);
    end
      else
    if fHandle <> 0 then
    begin
      if GetObject( fHandle, Sizeof( B ), @ B ) <> 0 then
      begin
        oldWidth := B.bmWidth;
        oldHeight := B.bmHeight;
      end;
    end;

  DC2 := CreateCompatibleDC( 0 );

  if fHandleType = bmDDB then
  begin
    // New HandleType is bmDDB: old bitmap can be copied using Draw method
    DC0 := GetDC( 0 );
    NewHandle := CreateCompatibleBitmap( DC0, fWidth, fHeight );
    ASSERT( NewHandle <> 0, 'Can not create DDB' );
    ReleaseDC( 0, DC0 );

    oldBmp := SelectObject( DC2, NewHandle );
    ASSERT( oldBmp <> 0, 'Can not select bitmap to DC' );

    Br := CreateSolidBrush( Color2RGB( fBkColor ) );
    FillRect( DC2, MakeRect( 0, 0, fWidth, fHeight ), Br );
    DeleteObject( Br );

    if fDIBBits <> nil then
    begin
      SelectObject( DC2, oldBmp );
      SetDIBits( DC2, NewHandle, 0, fHeight, fDIBBits, fDIBHeader^, DIB_RGB_COLORS );
    end
       else
    begin
      Draw( DC2, 0, 0 );
      SelectObject( DC2, oldBmp );
    end;

    ClearData; // Image is cleared but fWidth and fHeight are preserved
    fHandle := NewHandle;
  end
     else
  begin
    // New format is DIB. GetDIBits applied to transform old data to new one.
    bitsPixel := BitCounts[ fNewPixelFormat ];
    if bitsPixel = 0 then
    begin
      bitsPixel := BitCounts[DefaultPixelFormat];
    end;

    NewHandle := 0;
    NewHeader := PrepareBitmapHeader( fWidth, fHeight, bitsPixel );
    if fNewPixelFormat = pf16bit then
      PreparePF16bit( NewHeader );

    sizeBits := CalcScanLineSize( @NewHeader.bmiHeader ) * fHeight;

      GetMem( NewBits, sizeBits );
      ASSERT( NewBits <> nil, 'No memory' );

      Hndl := GetHandle;
      if Hndl = 0 then Exit;
      N :=
      GetDIBits( DC2, Hndl, 0, Min( fHeight, oldHeight ),
                 NewBits, NewHeader^, DIB_RGB_COLORS );
      //Assert( N = Min( fHeight, oldHeight ), 'Can not get all DIB bits' );
      if N <> Min( fHeight, oldHeight ) then
      begin
        FreeMem( NewBits );
        NewBits := nil;
        NewHandle := CreateDIBSection( DC2, NewHeader^, DIB_RGB_COLORS, NewBits, 0, 0 );
        NewDIBAutoFree := TRUE;
        ASSERT( NewHandle <> 0, 'Can not create DIB secion for pf16bit bitmap' );
        oldBmp := SelectObject( DC2, NewHandle );
        ASSERT( oldBmp <> 0, 'Can not select pf16bit to DC' );
        Draw( DC2, 0, 0 );
        SelectObject( DC2, oldBmp );
      end;

    ClearData;
    fDIBSize := sizeBits;
    fDIBBits := NewBits;
    fDIBHeader := NewHeader;
    fHandle := NewHandle;
    fDIBAutoFree := NewDIBAutoFree;

  end;

  if Assigned( fFillWithBkColor ) then
     fFillWithBkColor( Self, DC2, oldWidth, oldHeight );

  DeleteDC( DC2 );

end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TBitmap.GetScanLine]
function TBitmap.GetScanLine(Y: Integer): Pointer;
asm
        MOV      ECX, [EAX].fDIBHeader
        JECXZ    @@exit
        MOV      ECX, [ECX].TBitmapInfoHeader.biHeight
        TEST     ECX, ECX
        JL       @@1

        SUB      ECX, EDX
        DEC      ECX
        MOV      EDX, ECX

@@1:    MOV      ECX, [EAX].fScanLineSize
        INC      ECX
        PUSH     [EAX].fDIBBits
        LOOP     @@2

        PUSH     EDX
        CALL     GetScanLineSize
        POP      EDX
        XCHG     ECX, EAX

@@2:    XCHG     EAX, ECX
        MUL      EDX
        POP      ECX
        ADD      ECX, EAX

@@exit: XCHG     EAX, ECX
end;
{$ELSE ASM_VERSION} //Pascal
function TBitmap.GetScanLine(Y: Integer): Pointer;
begin
  ASSERT( (Y >= 0) {and (Y < fHeight)}, 'ScanLine index out of bounds' );
  ASSERT( fDIBBits <> nil, 'No bits available' );
  Result := nil;
  if fDIBHeader = nil then Exit;

  if fDIBHeader.bmiHeader.biHeight > 0 then
     Y := fHeight - 1 - Y;
  if fScanLineSize = 0 then
     ScanLineSize;

  Result := Pointer( Integer( fDIBBits ) + fScanLineSize * Y );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TBitmap.GetScanLineSize]
function TBitmap.GetScanLineSize: Integer;
asm
        MOV      ECX, [EAX].fDIBHeader
        JECXZ    @@exit

        PUSH     EAX
        XCHG     EAX, ECX
        CALL     CalcScanLineSize
        XCHG     ECX, EAX
        POP      EAX
        MOV      [EAX].fScanLineSize, ECX

@@exit: XCHG     EAX, ECX
end;
{$ELSE ASM_VERSION} //Pascal
function TBitmap.GetScanLineSize: Integer;
begin
  Result := 0;
  if fDIBHeader = nil then Exit;
  FScanLineSize := CalcScanLineSize( @fDIBHeader.bmiHeader );
  Result := FScanLineSize;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TBitmap.CanvasChanged]
procedure TBitmap.CanvasChanged( Sender : PObj );
asm
        PUSH     EAX

          XCHG     EAX, EDX
          CALL     TCanvas.GetBrush
          MOV      EDX, [EAX].TGraphicTool.fData.Color

        POP      EAX
        MOV      [EAX].fBkColor, EAX
        CALL     ClearTransImage
end;
{$ELSE ASM_VERSION} //Pascal
procedure TBitmap.CanvasChanged( Sender : PObj );
begin
  fBkColor := PCanvas( Sender ).Brush.Color;
  ClearTransImage;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TBitmap.Dormant]
procedure TBitmap.Dormant;
asm
        PUSH     EAX
        CALL     RemoveCanvas
        POP      EAX
        MOV      ECX, [EAX].fHandle
        JECXZ    @@exit
        CALL     ReleaseHandle
        PUSH     EAX
        CALL     DeleteObject
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TBitmap.Dormant;
begin
  RemoveCanvas;
  if fHandle <> 0 then
    DeleteObject( ReleaseHandle );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TBitmap.SetBkColor]
procedure TBitmap.SetBkColor(const Value: TColor);
asm
        CMP      [EAX].fBkColor, EDX
        JE       @@exit
        MOV      [EAX].fBkColor, EDX
        MOV      [EAX].fFillWithBkColor, offset[FillBmpWithBkColor]
        MOV      ECX, [EAX].fApplyBkColor2Canvas
        JECXZ    @@exit
        CALL     ECX
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TBitmap.SetBkColor(const Value: TColor);
begin
  if fBkColor = Value then Exit;
  fBkColor := Value;
  fFillWithBkColor := FillBmpWithBkColor;
  if Assigned( fApplyBkColor2Canvas ) then
    fApplyBkColor2Canvas( Self );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TBitmap.Assign]
function TBitmap.Assign(SrcBmp: PBitmap): Boolean;
const szBIH = sizeof(TBitmapInfoHeader);
asm
        PUSHAD
        XCHG     EBX, EAX
@@clear:
        MOV      ESI, EDX
        MOV      EAX, EBX
        CALL     Clear
        MOV      EAX, ESI
        OR       EAX, EAX
        JZ       @@exit
        CALL     GetEmpty
        JZ       @@exit
        MOV      EAX, [ESI].fWidth
        MOV      [EBX].fWidth, EAX
        MOV      EAX, [ESI].fHeight
        MOV      [EBX].fHeight, EAX
        MOVZX    ECX, [ESI].fHandleType
        MOV      [EBX].fHandleType, CL
          JECXZ    @@fmtDIB

        DEC      ECX  // ECX = 0
        PUSH     ECX
        PUSH     ECX
        PUSH     ECX
        PUSH     ECX //IMAGE_BITMAP=0
        PUSH     [ESI].fHandle
        CALL     CopyImage
        MOV      [EBX].fHandle, EAX
        TEST     EAX, EAX
        XCHG     EDX, EAX
        JZ       @@clear
        JMP      @@exit

@@fmtDIB:
        XCHG     EAX, ECX
        MOV      AX, szBIH+1024
        PUSH     EAX
        CALL     System.@GetMem
        MOV      [EBX].fDIBHeader, EAX
        XCHG     EDX, EAX
        POP      ECX
        MOV      EAX, [ESI].fDIBHeader
        CALL     System.Move
        MOV      EAX, [ESI].fDIBSize
        MOV      [EBX].fDIBSize, EAX
        PUSH     EAX
        CALL     System.@GetMem
        MOV      [EBX].fDIBBits, EAX
        XCHG     EDX, EAX
        POP      ECX
        MOV      EAX, [ESI].fDIBBits
        CALL     System.Move

        INC      EBX // reset "ZF"

@@exit:
        POPAD
        SETNZ    AL
end;
{$ELSE ASM_VERSION} //Pascal
function TBitmap.Assign(SrcBmp: PBitmap): Boolean;
begin
  Clear;
  Result := False;
  if SrcBmp = nil then Exit;
  if SrcBmp.Empty then Exit;
  fWidth := SrcBmp.fWidth;
  fHeight := SrcBmp.fHeight;
  fHandleType := SrcBmp.fHandleType;
  if SrcBmp.fHandleType = bmDDB then
  begin
    fHandle := CopyImage( SrcBmp.fHandle, IMAGE_BITMAP, 0, 0, 0 {LR_COPYRETURNORG} );
    ASSERT( fHandle <> 0, 'Can not copy bitmap image' );
    Result := fHandle <> 0;
    if not Result then Clear;
  end
     else
  begin
    GetMem( fDIBHeader, Sizeof(TBitmapInfoHeader) + 256*sizeof(TRGBQuad) );
    ASSERT( fDIBHeader <> nil, 'No memory' );
    Move( SrcBmp.fDIBHeader^, fDIBHeader^, Sizeof(TBitmapInfoHeader) + 256*sizeof(TRGBQuad) );
    fDIBSize := SrcBmp.fDIBSize;
    GetMem( fDIBBits, fDIBSize );
    ASSERT( fDIBBits <> nil, 'No memory' );
    Move( SrcBmp.fDIBBits^, fDIBBits^, fDIBSize );
    //fDIBAutoFree := TRUE;
    Result := True;
  end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TBitmap.RemoveCanvas]
procedure TBitmap.RemoveCanvas;
asm
        PUSH     EAX
        CALL     [EAX].fDetachCanvas
        POP      EDX
        XOR      EAX, EAX
        XCHG     EAX, [EDX].fCanvas
        CALL     TObj.Free
end;
{$ELSE ASM_VERSION} //Pascal
procedure TBitmap.RemoveCanvas;
begin
  fDetachCanvas( Self );
  fCanvas.Free;
  fCanvas := nil;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TBitmap.DIBPalNearestEntry]
function TBitmap.DIBPalNearestEntry(Color: TColor): Integer;
const szBIH = sizeof(TBitmapInfoHeader);
asm
        PUSH     EBX
        PUSH     ESI
        PUSH     EDI
        XCHG     ESI, EAX
        XCHG     EAX, EDX
        CALL     Color2RGBQuad
        XCHG     EDI, EAX
        MOV      EAX, ESI
        CALL     GetDIBPalEntryCount
        XCHG     ECX, EAX
        XOR      EAX, EAX
        JECXZ    @@exit

        MOV      ESI, [ESI].fDIBHeader
        ADD      ESI, szBIH
        XOR      EDX, EDX
        PUSH     EDX
        DEC      DX

@@loo:  LODSD
        XOR      EAX, EDI
        MOV      EBX, EAX
        SHR      EBX, 16
        MOV      BH, 0
        ADD      AL, AH
        MOV      AH, 0
        ADC      AX, BX
        CMP      AX, DX
        JAE      @@1
        MOV      DX, AX
        POP      EBX
        PUSH     EDX // save better index (in high order word)
@@1:    ADD      EDX, $10000 // increment index
        LOOP     @@loo

        XCHG     EAX, ECX
        POP      AX
        POP      AX
@@exit:
        POP      EDI
        POP      ESI
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function TBitmap.DIBPalNearestEntry(Color: TColor): Integer;
var I, Diff, D: Integer;
    C : Integer;
begin
  Color := TColor( Color2RGBQuad( Color ) );
  Result := 0;
  Diff := MaxInt;
  for I := 0 to DIBPalEntryCount - 1 do
  begin
    C := Color xor PInteger( Integer( @fDIBHeader.bmiColors[ 0 ] )
                    + I * Sizeof( TRGBQuad ) )^;
    D := TRGBQuad( C ).rgbBlue + TRGBQuad( C ).rgbGreen + TRGBQuad( C ).rgbRed;
    if D < Diff then
    begin
      Diff := D;
      Result := I;
    end;
  end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TBitmap.GetDIBPalEntries]
function TBitmap.GetDIBPalEntries(Idx: Integer): TColor;
const szBIH = sizeof(TBitmapInfoHeader);
asm
        MOV      ECX, [EAX].fDIBHeader
        JECXZ    @@exit

        MOV      ECX, [EAX+szBIH+EDX*4]
        INC      ECX

@@exit: DEC      ECX
        XCHG     EAX, ECX
end;
{$ELSE ASM_VERSION} //Pascal
function TBitmap.GetDIBPalEntries(Idx: Integer): TColor;
begin
  Result := TColor(-1);
  if fDIBBits = nil then Exit;
  ASSERT( PixelFormat in [pf1bit..pf8bit], 'Format has no DIB palette entries available' );
  ASSERT( (Idx >= 0) and (Idx < (1 shl fDIBHeader.bmiHeader.biBitCount)),
          'DIB palette index out of bounds' );
  Result := PDWORD( Integer( @fDIBHeader.bmiColors[ 0 ] )
          + Idx * Sizeof( TRGBQuad ) )^;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TBitmap.GetDIBPalEntryCount]
function TBitmap.GetDIBPalEntryCount: Integer;
asm
        PUSH     EAX
        CALL     GetEmpty
        POP      EAX
        JZ       @@ret0
        CALL     GetPixelFormat
        MOVZX    ECX, AL
        MOV      EAX, ECX
        LOOP     @@1
        // pf1bit:
        INC      EAX
        RET
@@1:
        LOOP     @@2
        // pf4bit:
        MOV      AL, 16
        RET
@@2:
        LOOP     @@ret0
        // pf8bit:
        XOR      EAX, EAX
        INC      AH
        RET
@@ret0:
        XOR      EAX, EAX
end;
{$ELSE ASM_VERSION} //Pascal
function TBitmap.GetDIBPalEntryCount: Integer;
begin
  Result := 0;
  if Empty then Exit;
  case PixelFormat of
  pf1bit: Result := 2;
  pf4bit: Result := 16;
  pf8bit: Result := 256;
  else;
  end;
end;
{$ENDIF ASM_VERSION}

//[procedure TBitmap.SetDIBPalEntries]
procedure TBitmap.SetDIBPalEntries(Idx: Integer; const Value: TColor);
begin
  if fDIBBits = nil then Exit;
  Dormant;
  PDWORD( Integer( @fDIBHeader.bmiColors[ 0 ] )
                    + Idx * Sizeof( TRGBQuad ) )^ := Color2RGB( Value );
end;

//[procedure TBitmap.SetHandleType]
procedure TBitmap.SetHandleType(const Value: TBitmapHandleType);
{var B: tagBitmap;
    DC0: HDC;}
begin
  if fHandleType = Value then Exit;
  //++++++++++++++++ ?????????
  {if fHandleType = bmDDB then
    if PixelFormat = pfDevice then
    begin
      DC0 := GetDC( 0 );
      fNewPixelFormat := Bits2PixelFormat( GetDeviceCaps( DC0, BITSPIXEL ) );
      ReleaseDC( 0, DC0 );
    end
      else
    if FHandle <> 0 then
    begin
      if GetObject( FHandle, Sizeof( B ), @ B ) > 0 then
        fNewPixelFormat := Bits2PixelFormat( B.bmPlanes * B.bmBitsPixel );
    end;}
  //----------------
  fHandleType := Value;
  FormatChanged;
end;

//[function TBitmap.GetPixelFormat]
function TBitmap.GetPixelFormat: TPixelFormat;
begin
  if (HandleType = bmDDB) or (fDIBBits = nil) then
    Result := pfDevice
  else
  begin
    Result := Bits2PixelFormat( fDIBHeader.bmiHeader.biBitCount );
    if (Result = pf15bit) and (fDIBHeader.bmiHeader.biCompression <> 0) then
    begin
      Assert( fDIBHeader.bmiHeader.biCompression = BI_BITFIELDS, 'Unsupported bitmap format' );
      Result := pf16bit;
    end;
  end;
end;

{$IFDEF ASM_VERSION}
//[procedure TBitmap.ClearTransImage]
procedure TBitmap.ClearTransImage;
asm
        OR       [EAX].fTransColor, -1
        XOR      EDX, EDX
        XCHG     [EAX].fTransMaskBmp, EDX
        XCHG     EAX, EDX
        CALL     TObj.Free
end;
{$ELSE ASM_VERSION} //Pascal
procedure TBitmap.ClearTransImage;
begin
  fTransColor := clNone;
  fTransMaskBmp.Free;
  fTransMaskBmp := nil;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TBitmap.Convert2Mask]
procedure TBitmap.Convert2Mask(TranspColor: TColor);
asm
        PUSH     EBX
        PUSH     ESI
        MOV      EBX, EAX
        MOV      ESI, EDX
        CALL     GetHandle
        TEST     EAX, EAX
        JZ       @@exit

        PUSH     0
        PUSH     1
        PUSH     1
        PUSH     [EBX].fHeight
        PUSH     [EBX].fWidth
        CALL     CreateBitmap
        PUSH     EAX                // MonoHandle
        PUSH     0
        CALL     CreateCompatibleDC
        POP      EDX
        PUSH     EDX
        PUSH     EAX                // MonoDC

        PUSH     EDX
        PUSH     EAX
        CALL     SelectObject
        PUSH     EAX                // SaveMono

        CALL     StartDC            // DCfrom, SaveFrom
        XCHG     EAX, ESI
        CALL     Color2RGB
        PUSH     EAX // Color2RGB(TranspColor)
        PUSH     dword ptr [ESP+8] //DCfrom
        CALL     Windows.SetBkColor
        PUSH     EAX                // SaveBkColor

        PUSH     SRCCOPY
        PUSH     0
        PUSH     0
        PUSH     dword ptr [ESP+12+4+4] //DCfrom
        PUSH     [EBX].fHeight
        PUSH     [EBX].fWidth
        PUSH     0
        PUSH     0
        PUSH     dword ptr [ESP+32+16] //MonoDC
        CALL     BitBlt

        PUSH     dword ptr [ESP+8] //DCfrom
        CALL     Windows.SetBkColor // ESP-> SaveFrom
        CALL     FinishDC           // ESP-> SaveMono
        CALL     FinishDC           // ESP-> MonoHandle

        MOV      EAX, EBX
        CALL     ClearData
        POP      [EBX].fHandle
        MOV      [EBX].fHandleType, bmDDB
@@exit:
        POP      ESI
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TBitmap.Convert2Mask(TranspColor: TColor);
var MonoHandle: HBitmap;
    SaveMono, SaveFrom: THandle;
    MonoDC, {DC0,} DCfrom: HDC;
    SaveBkColor: TColorRef;
begin
  if GetHandle = 0 then Exit;
  fDetachCanvas( Self );
  ///DC0 := GetDC( 0 );
  MonoHandle := CreateBitmap( fWidth, fHeight, 1, 1, nil );
  ASSERT( MonoHandle <> 0, 'Can not create monochrome bitmap' );
  MonoDC := CreateCompatibleDC( 0 );
  SaveMono := SelectObject( MonoDC, MonoHandle );
  ASSERT( SaveMono <> 0, 'Can not select bitmap to DC' );
  DCfrom := CreateCompatibleDC( 0 );
  SaveFrom := SelectObject( DCfrom, fHandle );
  ASSERT( SaveFrom <> 0, 'Can not select source bitmap to DC' );
  TranspColor := Color2RGB( TranspColor );
  SaveBkColor := Windows.SetBkColor( DCfrom, TranspColor );
  BitBlt( MonoDC, 0, 0, fWidth, fHeight, DCfrom, 0, 0, SRCCOPY );
  {$IFDEF CHK_BITBLT} Chk_BitBlt; {$ENDIF}
  Windows.SetBkColor( DCfrom, SaveBkColor );
  SelectObject( DCfrom, SaveFrom );
  DeleteDC( DCfrom );
  SelectObject( MonoDC, SaveMono );
  DeleteDC( MonoDC );
  ///ReleaseDC( 0, DC0 );
  ClearData;
  fHandle := MonoHandle;
  fHandleType := bmDDB;
end;
{$ENDIF ASM_VERSION}

//[procedure TBitmap.Invert]
procedure TBitmap.Invert;
begin
  BitBlt( Canvas.Handle, 0, 0, Width, Height, Canvas.Handle, 0, 0, DSTINVERT  )
end;

//[procedure TBitmap.DIBDrawRect]
procedure TBitmap.DIBDrawRect( DC: HDC; X, Y: Integer; const R: TRect );
begin
  if fDIBBits = nil then Exit;
  StretchDIBits( DC, X, Y, R.Right - R.Left, R.Bottom - R.Top,
                 R.Left, fHeight - R.Bottom, R.Right - R.Left, R.Bottom - R.Top,
                 fDIBBits, fDIBHeader^, DIB_RGB_COLORS, SRCCOPY );
end;

//[PROCEDURE _PrepareBmp2Rotate]
{$IFDEF ASM_VERSION}
procedure _PrepareBmp2Rotate;
const szBIH = sizeof(TBitmapInfoHeader);
asm
        { <- BL = increment to height }
        XCHG     EDI, EAX
        MOV      ESI, EDX // ESI = SrcBmp

        XCHG     EAX, EDX
        CALL     TBitmap.GetPixelFormat
        MOVZX    ECX, AL
        PUSH     ECX

        MOV      EDX, [ESI].TBitmap.fWidth
        MOVZX    EBX, BL
        ADD      EDX, EBX

        MOV      EAX, [ESI].TBitmap.fHeight
        CALL     NewDIBBitmap
        STOSD
        XCHG     EDI, EAX

        MOV      EAX, [ESI].TBitmap.fDIBHeader
        ADD      EAX, szBIH
        MOV      EDX, [EDI].TBitmap.fDIBHeader
        ADD      EDX, szBIH
        XOR      ECX, ECX
        MOV      CH, 4
        CALL     System.Move

        MOV      EAX, EDI
        XOR      EDX, EDX
        CALL     TBitmap.GetScanLine
        MOV      EBX, [EDI].TBitmap.fWidth
        DEC      EBX // EBX = DstBmp.fWidth - 1
        XCHG     EDI, EAX // EDI = DstBmp.ScanLine[ 0 ]

        XOR      EDX, EDX
        INC      EDX
        CALL     TBitmap.GetScanLine
        XCHG     EDX, EAX
        SUB      EDX, EDI // EDX = BytesPerDstLine

        MOV      EBP, [ESI].TBitmap.fWidth
        DEC      EBP // EBP = SrcBmp.fWidth - 1

        POP      ECX // ECX = PixelFormat
end;
{$ENDIF ASM_VERSION}
//[END _PrepareBmp2Rotate]

//[PROCEDURE _RotateBitmapMono]
{$IFDEF ASM_VERSION}
procedure _RotateBitmapMono( var DstBmp: PBitmap; SrcBmp: PBitmap );
const szBIH = sizeof(TBitmapInfoHeader);
asm
        PUSHAD
        MOV      BL, 7
        CALL     _PrepareBmp2Rotate

        SHR      EBP, 3
        SHL      EBP, 8 // EBP = (WBytes-1) * 256

        MOV      ECX, EBX // ECX and 7 = Shf
        SHR      EBX, 3
        ADD      EDI, EBX // EDI = Dst

        XOR      EBX, EBX // EBX = temp mask
        XOR      EAX, EAX // Y = 0
@@looY:
        PUSH     EAX
        PUSH     EDI // Dst1 = Dst (Dst1 in EDI, Dst saved)
        PUSH     ESI // SrcBmp

        PUSH     EDX //BytesPerDstLine
        PUSH     ECX //Shf

        XCHG     EDX, EAX
        XCHG     EAX, ESI
        CALL     TBitmap.GetScanLine
        XCHG     ESI, EAX // ESI = Src

        POP      ECX // CL = Shf
        AND      ECX, 7 // ECX = Shf
        OR       ECX, EBP // ECX = (Wbytes-1)*8 + Shf
        POP      EDX // EDX = BytesPerDstLine

        MOV      BH, $80
        SHR      EBX, CL // BH = mask, BL = mask & Tmp
@@looX:
        XOR      EAX, EAX

        LODSB

        MOV      AH, AL
        SHR      EAX, CL
        OR       EAX,$01000000

@@looBits:
        MOV      BL, AH
        AND      BL, BH
        OR       [EDI], BL
        ADD      EDI, EDX
        ADD      EAX, EAX
        JNC      @@looBits

        SUB      ECX, 256
        JGE      @@looX

        POP      ESI // ESI = SrcBmp
        POP      EDI // EDI = Dst
        POP      EAX // EAX = Y

        ADD      ECX, 256-1
        JGE      @@1
        DEC      EDI
@@1:
        INC      EAX
        CMP      EAX, [ESI].TBitmap.fHeight
        JL       @@looY

        POPAD
end;
{$ELSE ASM_VERSION} //Pascal
procedure _RotateBitmapMono( var DstBmp: PBitmap; SrcBmp: PBitmap );
var X, Y, Z, Shf, Wbytes, BytesPerDstLine: Integer;
    Src, Dst, Dst1: PByte;
    Tmp: Byte;
begin

  DstBmp := NewDIBBitmap( SrcBmp.fHeight, (SrcBmp.fWidth + 7) and not 7, pf1bit );
  Move( SrcBmp.fDIBHeader.bmiColors[ 0 ], DstBmp.fDIBHeader.bmiColors[ 0 ], 2 * Sizeof( TRGBQuad ) );

  // Calculate ones:
  Dst := DstBmp.ScanLine[ 0 ];
  BytesPerDstLine := Integer( DstBmp.ScanLine[ 1 ]) - Integer( Dst );
  Wbytes := (SrcBmp.fWidth + 7) shr 3;

  Inc( Dst, (DstBmp.fWidth - 1) shr 3 );
  Shf := (DstBmp.fWidth - 1) and 7;

  // Rotating bits:
  for Y := 0 to SrcBmp.fHeight - 1 do
  begin
    Src := SrcBmp.ScanLine[ Y ];
    Dst1 := Dst;
    for X := Wbytes downto 1 do
    begin
      Tmp := Src^;
      Inc( Src );
      for Z := 8 downto 1 do
      begin
        Dst1^ := Dst1^ or ( (Tmp and $80) shr Shf );
        Tmp := Tmp shl 1;
        Inc( Dst1, BytesPerDstLine );
      end;
    end;
    Dec( Shf );
    if Shf < 0 then
    begin
      Shf := 7;
      Dec( Dst );
    end;
  end;
end;
{$ENDIF ASM_VERSION}
//[END _RotateBitmapMono]

//[PROCEDURE _RotateBitmap4bit]
{$IFDEF ASM_VERSION}
procedure _RotateBitmap4bit( var DstBmp: PBitmap; SrcBmp: PBitmap );
const szBIH = sizeof(TBitmapInfoHeader);
asm
        PUSHAD
        MOV      BL, 1
        CALL     _PrepareBmp2Rotate

        SHR      EBP, 1 // EBP = WBytes - 1
        SHL      EBP, 8 // EBP = (WBytes - 1) * 256

        // EBX = DstBmp.fWidth - 1
        MOV      ECX, EBX
        SHL      ECX, 2 // ECX and 7 = Shf (0 or 4)
        SHR      EBX, 1
        ADD      EDI, EBX // EDI = Dst

        XOR      EAX, EAX // Y = 0
        XOR      EBX, EBX

@@looY:
        PUSH     EAX // save Y
        PUSH     EDI // Dst1 = Dst (Dst1 in EDI, Dst saved)
        PUSH     ESI // SrcBmp

        PUSH     EDX // BytesPerDstLine
        PUSH     ECX // Shf

        XCHG     EDX, EAX
        XCHG     EAX, ESI
        CALL     TBitmap.GetScanLine
        XCHG     ESI, EAX // ESI = Src

        POP      ECX
        AND      ECX, 7 // CL = Shf
        OR       ECX, EBP // ECX = (WBytes-1)*256 + Shf
        POP      EDX // EDX = BytesPerDstLine

        MOV      BH, $F0
        SHR      EBX, CL // shift mask right 4 or 0

@@looX:
        XOR      EAX, EAX
        LODSB
        MOV      AH, AL
        SHR      EAX, CL

        MOV      BL, AH
        AND      BL, BH
        OR       [EDI], BL
        ADD      EDI, EDX

        SHL      EAX, 4
        AND      AH, BH
        OR       [EDI], AH
        ADD      EDI, EDX

        SUB      ECX, 256
        JGE      @@looX

        POP      ESI // ESI = SrcBmp
        POP      EDI // EDI = Dst
        POP      EAX // EAX = Y

        ADD      ECX, 256 - 4
        JGE      @@1

        DEC      EDI
@@1:
        INC      EAX
        CMP      EAX, [ESI].TBitmap.fHeight
        JL       @@looY

        POPAD
end;
{$ELSE ASM_VERSION} //Pascal
procedure _RotateBitmap4bit( var DstBmp: PBitmap; SrcBmp: PBitmap );
var X, Y, Shf, Wbytes, BytesPerDstLine: Integer;
    Src, Dst, Dst1: PByte;
    Tmp: Byte;
begin

  DstBmp := NewDIBBitmap( SrcBmp.fHeight, (SrcBmp.fWidth + 1) and not 1, pf4bit );
  Move( SrcBmp.fDIBHeader.bmiColors[ 0 ], DstBmp.fDIBHeader.bmiColors[ 0 ], 16 * Sizeof( TRGBQuad ) );

  // Calculate ones:
  Dst := DstBmp.ScanLine[ 0 ];
  BytesPerDstLine := Integer( DstBmp.ScanLine[ 1 ]) - Integer( Dst );
  Wbytes := (SrcBmp.fWidth + 1) shr 1;

  Inc( Dst, (DstBmp.fWidth - 1) shr 1 );
  Shf := ((DstBmp.fWidth - 1) and 1) shl 2;

  // Rotating bits:
  for Y := 0 to SrcBmp.fHeight - 1 do
  begin
    Src := SrcBmp.ScanLine[ Y ];
    Dst1 := Dst;
    for X := Wbytes downto 1 do
    begin
      Tmp := Src^;
      Inc( Src );
      Dst1^ := Dst1^ or ( (Tmp and $F0) shr Shf );
      Inc( Dst1, BytesPerDstLine );
      Dst1^ := Dst1^ or ( ((Tmp shl 4) and $F0) shr Shf );
      Inc( Dst1, BytesPerDstLine );
    end;
    Dec( Shf, 4 );
    if Shf < 0 then
    begin
      Shf := 4;
      Dec( Dst );
    end;
  end;
end;
{$ENDIF ASM_VERSION}
//[END _RotateBitmap4bit]

//[PROCEDURE _RotateBitmap8bit]
{$IFDEF ASM_VERSION}
procedure _RotateBitmap8bit( var DstBmp: PBitmap; SrcBmp: PBitmap );
const szBIH = sizeof(TBitmapInfoHeader);
asm
        PUSHAD
        XOR      EBX, EBX
        CALL     _PrepareBmp2Rotate

        ADD      EDI, EBX // EDI = Dst

        MOV      EBX, EDX // EBX = BytesPerDstLine
        DEC      EBX
        MOV      EBP, ESI // EBP = SrcBmp

        XOR      EDX, EDX // Y = 0

@@looY:
        PUSH     EDX
        PUSH     EDI

        MOV      EAX, EBP
        CALL     TBitmap.GetScanLine
        XCHG     ESI, EAX
        MOV      ECX, [EBP].TBitmap.fWidth

@@looX:
        MOVSB
        ADD      EDI, EBX
        LOOP     @@looX

        POP      EDI
        POP      EDX

        DEC      EDI
        INC      EDX
        CMP      EDX, [EBP].TBitmap.fHeight
        JL       @@looY

        POPAD
end;
{$ELSE ASM_VERSION} //Pascal
procedure _RotateBitmap8bit( var DstBmp: PBitmap; SrcBmp: PBitmap );
var X, Y, Wbytes, BytesPerDstLine: Integer;
    Src, Dst, Dst1: PByte;
    Tmp: Byte;
begin

  DstBmp := NewDIBBitmap( SrcBmp.fHeight, SrcBmp.fWidth, SrcBmp.PixelFormat );
  Move( SrcBmp.fDIBHeader.bmiColors[ 0 ], DstBmp.fDIBHeader.bmiColors[ 0 ], 256 * Sizeof( TRGBQuad ) );

  // Calculate ones:
  Wbytes := SrcBmp.fWidth;
  Dst := DstBmp.ScanLine[ 0 ];
  BytesPerDstLine := Integer( DstBmp.ScanLine[ 1 ]) - Integer( Dst );

  Inc( Dst, DstBmp.fWidth - 1 );

  // Rotating bits:
  for Y := 0 to SrcBmp.fHeight - 1 do
  begin
    Src := SrcBmp.ScanLine[ Y ];
    Dst1 := Dst;
    for X := Wbytes downto 1 do
    begin
      Tmp := Src^;
      Inc( Src );
      Dst1^ := Tmp;
      Inc( Dst1, BytesPerDstLine );
    end;
    Dec( Dst );
  end;

end;
{$ENDIF ASM_VERSION}
//[END _RotateBitmap8bit]

//[PROCEDURE _RotateBitmap16bit]
{$IFDEF ASM_VERSION}
procedure _RotateBitmap16bit( var DstBmp: PBitmap; SrcBmp: PBitmap );
asm
        PUSHAD
        XOR      EBX, EBX
        CALL     _PrepareBmp2Rotate

        ADD      EBX, EBX
        ADD      EDI, EBX // EDI = Dst
        MOV      EBX, EDX // EBX = BytesPerDstLine
        DEC      EBX
        DEC      EBX
        MOV      EBP, ESI // EBP = SrcBmp

        XOR      EDX, EDX // Y = 0

@@looY:
        PUSH     EDX
        PUSH     EDI

        MOV      EAX, EBP
        CALL     TBitmap.GetScanLine
        XCHG     ESI, EAX
        MOV      ECX, [EBP].TBitmap.fWidth

@@looX:
        MOVSW
        ADD      EDI, EBX
        LOOP     @@looX

        POP      EDI
        POP      EDX

        DEC      EDI
        DEC      EDI
        INC      EDX
        CMP      EDX, [EBP].TBitmap.fHeight
        JL       @@looY

        POPAD
end;
{$ELSE ASM_VERSION} //Pascal
procedure _RotateBitmap16bit( var DstBmp: PBitmap; SrcBmp: PBitmap );
var X, Y, Wwords, BytesPerDstLine: Integer;
    Src, Dst, Dst1: PWord;
    Tmp: Word;
begin

  DstBmp := NewDIBBitmap( SrcBmp.fHeight, SrcBmp.fWidth, SrcBmp.PixelFormat );

  // Calculate ones:
  Wwords := SrcBmp.fWidth;
  Dst := DstBmp.ScanLine[ 0 ];
  BytesPerDstLine := Integer( DstBmp.ScanLine[ 1 ]) - Integer( Dst );

  Inc( Dst, DstBmp.fWidth - 1 );

  // Rotating bits:
  for Y := 0 to SrcBmp.fHeight - 1 do
  begin
    Src := SrcBmp.ScanLine[ Y ];
    Dst1 := Dst;
    for X := Wwords downto 1 do
    begin
      Tmp := Src^;
      Inc( Src );
      Dst1^ := Tmp;
      Inc( PByte(Dst1), BytesPerDstLine );
    end;
    Dec( Dst );
  end;

end;
{$ENDIF ASM_VERSION}
//[END _RotateBitmap16bit]

//[PROCEDURE _RotateBitmap2432bit]
{$IFDEF ASM_VERSION}
procedure _RotateBitmap2432bit( var DstBmp: PBitmap; SrcBmp: PBitmap );
asm
        PUSHAD
        XOR      EBX, EBX
        CALL     _PrepareBmp2Rotate

        SUB      ECX, pf24bit
        JNZ      @@10
        LEA      EBX, [EBX+EBX*2]
        JMP      @@11
@@10:
        LEA      EBX, [EBX*4]
@@11:   ADD      EDI, EBX // EDI = Dst

        MOV      EBX, EDX // EBX = BytesPerDstLine
        DEC      EBX
        DEC      EBX
        DEC      EBX

        MOV      EBP, ESI // EBP = SrcBmp

        XOR      EDX, EDX // Y = 0

@@looY:
        PUSH     EDX
        PUSH     EDI
        PUSH     ECX // ECX = 0 if pf24bit (1 if pf32bit)

        MOV      EAX, EBP
        CALL     TBitmap.GetScanLine
        XCHG     ESI, EAX
        MOV      ECX, [EBP].TBitmap.fWidth
        POP      EAX
        PUSH     EAX

@@looX:
        MOVSW
        MOVSB
        ADD      ESI, EAX
        ADD      EDI, EBX
        LOOP     @@looX

        POP      ECX
        POP      EDI
        POP      EDX

        DEC      EDI
        DEC      EDI
        DEC      EDI
        SUB      EDI, ECX
        INC      EDX
        CMP      EDX, [EBP].TBitmap.fHeight
        JL       @@looY

        POPAD
end;
{$ELSE ASM_VERSION} //Pascal
procedure _RotateBitmap2432bit( var DstBmp: PBitmap; SrcBmp: PBitmap );
var X, Y, Wwords, BytesPerDstLine, IncW: Integer;
    Src, Dst, Dst1: PDWord;
    Tmp: DWord;
begin

  DstBmp := NewDIBBitmap( SrcBmp.fHeight, SrcBmp.fWidth, SrcBmp.PixelFormat );

  // Calculate ones:
  IncW := 4;
  if DstBmp.PixelFormat = pf24bit then
     IncW := 3;
  Wwords := SrcBmp.fWidth;
  Dst := DstBmp.ScanLine[ 0 ];
  BytesPerDstLine := Integer( DstBmp.ScanLine[ 1 ]) - Integer( Dst );

  Inc( PByte(Dst), (DstBmp.fWidth - 1) * IncW );

  // Rotating bits:
  for Y := 0 to SrcBmp.fHeight - 1 do
  begin
    Src := SrcBmp.ScanLine[ Y ];
    Dst1 := Dst;
    for X := Wwords downto 1 do
    begin
      Tmp := Src^ and $FFFFFF;
      Inc( PByte(Src), IncW );
      Dst1^ := Dst1^ or Tmp;
      Inc( PByte(Dst1), BytesPerDstLine );
    end;
    Dec( PByte(Dst), IncW );
  end;

end;
{$ENDIF ASM_VERSION}
//[END _RotateBitmap2432bit]

type
  TRotateBmpRefs = packed record
    proc_RotateBitmapMono: procedure( var Dst: PBitmap; Src: PBitmap );
    proc_RotateBitmap4bit: procedure( var Dst: PBitmap; Src: PBitmap );
    proc_RotateBitmap8bit: procedure( var Dst: PBitmap; Src: PBitmap );
    proc_RotateBitmap16bit: procedure( var Dst: PBitmap; Src: PBitmap );
    proc_RotateBitmap2432bit: procedure( var Dst: PBitmap; Src: PBitmap );
  end;

var
  RotateProcs: TRotateBmpRefs;

//[PROCEDURE _RotateBitmapRight]
{$IFDEF ASM_VERSION}
procedure _RotateBitmapRight( SrcBmp: PBitmap );
asm
        PUSH     EBX
        PUSH     EDI
        MOV      EBX, EAX
        CMP      [EBX].TBitmap.fHandleType, bmDIB
        JNZ      @@exit

        CALL     TBitmap.GetPixelFormat
        MOVZX    ECX, AL
        LOOP     @@not1bit
        MOV      EAX, [RotateProcs.proc_RotateBitmapMono]
@@not1bit:
        LOOP     @@not4bit
        MOV      EAX, [RotateProcs.proc_RotateBitmap4bit]
@@not4bit:
        LOOP     @@not8bit
        MOV      EAX, [RotateProcs.proc_RotateBitmap8bit]
@@not8bit:
        LOOP     @@not15bit
        INC      ECX
@@not15bit:
        LOOP     @@not16bit
        MOV      EAX, [RotateProcs.proc_RotateBitmap16bit]
@@not16bit:
        LOOP     @@not24bit
        INC      ECX
@@not24bit:
        LOOP     @@not32bit
        MOV      EAX, [RotateProcs.proc_RotateBitmap2432bit]
@@not32bit:
        TEST     EAX, EAX
        JZ       @@exit

        PUSH     ECX
        XCHG     ECX, EAX
        MOV      EAX, ESP
        MOV      EDX, EBX
        CALL     ECX

        POP      EDI
        MOV      EAX, [EBX].TBitmap.fWidth
        CMP      EAX, [EDI].TBitmap.fHeight
        JGE      @@noCutHeight

        MOV      EDX, [EDI].TBitmap.fScanLineSize
        MUL      EDX
        MOV      [EDI].TBitmap.fDIBSize, EAX

        MOV      EDX, [EDI].TBitmap.fDIBHeader
        MOV      EDX, [EDX].TBitmapInfoHeader.biHeight
        TEST     EDX, EDX
        JL       @@noCorrectImg

        PUSH     EAX

        MOV      EDX, [EDI].TBitmap.fHeight
        DEC      EDX
        MOV      EAX, EDI
        CALL     TBitmap.GetScanLine
        PUSH     EAX

        MOV      EDX, [EBX].TBitmap.fWidth
        DEC      EDX
        MOV      EAX, EDI
        CALL     TBitmap.GetScanLine
        POP      EDX

        POP      ECX
        CALL     System.Move

@@noCorrectImg:
        MOV      EAX, [EBX].TBitmap.fWidth
        MOV      [EDI].TBitmap.fHeight, EAX
        MOV      EDX, [EDI].TBitmap.fDIBHeader
        MOV      [EDX].TBitmapInfoHeader.biHeight, EAX

@@noCutHeight:
        MOV      EAX, EBX
        CALL     TBitmap.ClearData

        XOR      EAX, EAX
        XCHG     EAX, [EDI].TBitmap.fDIBHeader
        XCHG     [EBX].TBitmap.fDIBHeader, EAX

        XCHG     EAX, [EDI].TBitmap.fDIBBits
        XCHG     [EBX].TBitmap.fDIBBits, EAX

        MOV      AL, [EDI].TBitmap.fDIBAutoFree
        MOV      [EBX].TBitmap.fDIBAutoFree, AL

        MOV      EAX, [EDI].TBitmap.fDIBSize
        MOV      [EBX].TBitmap.fDIBSize, EAX

        MOV      EAX, [EDI].TBitmap.fWidth
        MOV      [EBX].TBitmap.fWidth, EAX

        MOV      EAX, [EDI].TBitmap.fHeight
        MOV      [EBX].TBitmap.fHeight, EAX

        XCHG     EAX, EDI
        CALL     TObj.Free
@@exit:
        POP      EDI
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure _RotateBitmapRight( SrcBmp: PBitmap );
var DstBmp: PBitmap;
    RotateProc: procedure( var DstBmp: PBitmap; SrcBmp: PBitmap );
begin
  if SrcBmp.fHandleType <> bmDIB then Exit;

  case SrcBmp.PixelFormat of
  pf1bit: RotateProc := RotateProcs.proc_RotateBitmapMono;
  pf4bit: RotateProc := RotateProcs.proc_RotateBitmap4bit;
  pf8bit: RotateProc := RotateProcs.proc_RotateBitmap8bit;
  pf15bit, pf16bit: RotateProc := RotateProcs.proc_RotateBitmap16bit;
  else RotateProc := RotateProcs.proc_RotateBitmap2432bit;
  end;

  if not Assigned( RotateProc ) then Exit;
  RotateProc( DstBmp, SrcBmp );

  if DstBmp.fHeight > SrcBmp.fWidth then
  begin
    DstBmp.fDIBSize := DstBmp.fScanLineSize * SrcBmp.fWidth;
    //if DWORD( DstBmp.ScanLine[ 0 ] ) > DWORD( DstBmp.ScanLine[ 1 ] ) then
    if DstBmp.fDIBHeader.bmiHeader.biHeight > 0 then
      Move( DstBmp.ScanLine[ SrcBmp.fWidth - 1 ]^, DstBmp.ScanLine[ DstBmp.fHeight - 1 ]^,
            DstBmp.fDIBSize );
    DstBmp.fHeight := SrcBmp.fWidth;
    DstBmp.fDIBHeader.bmiHeader.biHeight := DstBmp.fHeight;
  end;

  SrcBmp.ClearData;

  //SrcBmp.fNewPixelFormat := DstBmp.PixelFormat;
  SrcBmp.fDIBHeader := DstBmp.fDIBHeader;
  DstBmp.fDIBHeader := nil;

  SrcBmp.fDIBBits := DstBmp.fDIBBits;
  DstBmp.fDIBBits := nil;
  SrcBmp.fDIBAutoFree := DstBmp.fDIBAutoFree;

  SrcBmp.fDIBSize := DstBmp.fDIBSize;

  SrcBmp.fWidth := DstBmp.fWidth;
  SrcBmp.fHeight := DstBmp.fHeight;
  DstBmp.Free;
end;
{$ENDIF ASM_VERSION}
//[END _RotateBitmapRight]

//[procedure TBitmap.RotateRight]
procedure TBitmap.RotateRight;
const AllRotators: TRotateBmpRefs = (
        proc_RotateBitmapMono: _RotateBitmapMono;
        proc_RotateBitmap4bit: _RotateBitmap4bit;
        proc_RotateBitmap8bit: _RotateBitmap8bit;
        proc_RotateBitmap16bit: _RotateBitmap16bit;
        proc_RotateBitmap2432bit: _RotateBitmap2432bit );
begin
  RotateProcs := AllRotators;
  _RotateBitmapRight( Self );
end;

//[procedure _RotateBitmapLeft]
procedure _RotateBitmapLeft( Src: PBitmap );
begin
  _RotateBitmapRight( Src );
  _RotateBitmapRight( Src );
  _RotateBitmapRight( Src );
end;

//[procedure TBitmap.RotateLeft]
procedure TBitmap.RotateLeft;
begin
  RotateRight;
  _RotateBitmapRight( Self );
  _RotateBitmapRight( Self );
end;

//[procedure TBitmap.RotateLeftMono]
procedure TBitmap.RotateLeftMono;
begin
  if PixelFormat <> pf1bit then Exit;
  RotateProcs.proc_RotateBitmapMono := _RotateBitmapMono;
  _RotateBitmapRight( Self );
end;

//[procedure TBitmap.RotateRightMono]
procedure TBitmap.RotateRightMono;
begin
  if PixelFormat <> pf1bit then Exit;
  RotateProcs.proc_RotateBitmapMono := _RotateBitmapMono;
  _RotateBitmapLeft( Self );
end;

//[procedure TBitmap.RotateLeft16bit]
procedure TBitmap.RotateLeft16bit;
begin
  if PixelFormat <> pf16bit then Exit;
  RotateProcs.proc_RotateBitmap16bit := _RotateBitmap16bit;
  _RotateBitmapLeft( Self );
end;

//[procedure TBitmap.RotateLeft4bit]
procedure TBitmap.RotateLeft4bit;
begin
  if PixelFormat <> pf4bit then Exit;
  RotateProcs.proc_RotateBitmap4bit := _RotateBitmap4bit;
  _RotateBitmapLeft( Self );
end;

//[procedure TBitmap.RotateLeft8bit]
procedure TBitmap.RotateLeft8bit;
begin
  if PixelFormat <> pf8bit then Exit;
  RotateProcs.proc_RotateBitmap8bit := _RotateBitmap8bit;
  _RotateBitmapLeft( Self );
end;

//[procedure TBitmap.RotateLeftTrueColor]
procedure TBitmap.RotateLeftTrueColor;
begin
  if not (PixelFormat in [ pf24bit, pf32bit ]) then Exit;
  RotateProcs.proc_RotateBitmap2432bit := _RotateBitmap2432bit;
  _RotateBitmapLeft( Self );
end;

//[procedure TBitmap.RotateRight16bit]
procedure TBitmap.RotateRight16bit;
begin
  if PixelFormat <> pf16bit then Exit;
  RotateProcs.proc_RotateBitmap16bit := _RotateBitmap16bit;
  _RotateBitmapRight( Self );
end;

//[procedure TBitmap.RotateRight4bit]
procedure TBitmap.RotateRight4bit;
begin
  if PixelFormat <> pf4bit then Exit;
  RotateProcs.proc_RotateBitmap4bit := _RotateBitmap4bit;
  _RotateBitmapRight( Self );
end;

//[procedure TBitmap.RotateRight8bit]
procedure TBitmap.RotateRight8bit;
begin
  if PixelFormat <> pf8bit then Exit;
  RotateProcs.proc_RotateBitmap8bit := _RotateBitmap8bit;
  _RotateBitmapRight( Self );
end;

//[procedure TBitmap.RotateRightTrueColor]
procedure TBitmap.RotateRightTrueColor;
begin
  if not (PixelFormat in [ pf24bit, pf32bit ]) then Exit;
  RotateProcs.proc_RotateBitmap2432bit := _RotateBitmap2432bit;
  _RotateBitmapRight( Self );
end;

{$IFDEF ASM_VERSION}
//[function TBitmap.GetPixels]
function TBitmap.GetPixels(X, Y: Integer): TColor;
asm
        PUSH     EBX
        MOV      EBX, EAX
        PUSH     ECX
        PUSH     EDX
        CALL     GetEmpty
        PUSHFD
        OR       EAX, -1
        POPFD
        JZ       @@exit

        CALL     StartDC
        PUSH     dword ptr [ESP+12]
        PUSH     dword ptr [ESP+12]
        PUSH     EAX
        CALL     Windows.GetPixel
        XCHG     EBX, EAX
        CALL     FinishDC
        XCHG     EAX, EBX
@@exit:
        POP      EDX
        POP      EDX
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function TBitmap.GetPixels(X, Y: Integer): TColor;
var DC: HDC;
    Save: THandle;
begin
  Result := clNone;
  //if GetHandle = 0 then Exit;
  if Empty then Exit;
  fDetachCanvas( Self );
  DC := CreateCompatibleDC( 0 );
  Save := SelectObject( DC, GetHandle );
  ASSERT( Save <> 0, 'Can not select bitmap to DC' );
  Result := Windows.GetPixel( DC, X, Y );
  SelectObject( DC, Save );
  DeleteDC( DC );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TBitmap.SetPixels]
procedure TBitmap.SetPixels(X, Y: Integer; const Value: TColor);
asm
        PUSH     EBX
        MOV      EBX, EAX
        PUSH     ECX
        PUSH     EDX
        CALL     GetEmpty
        JZ       @@exit

        CALL     StartDC
        MOV      EAX, Value
        CALL     Color2RGB
        PUSH     EAX
        PUSH     dword ptr [ESP+16]
        PUSH     dword ptr [ESP+16]
        PUSH     dword ptr [ESP+16]
        CALL     Windows.SetPixel
        CALL     FinishDC
@@exit:
        POP      EDX
        POP      ECX
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TBitmap.SetPixels(X, Y: Integer; const Value: TColor);
var DC: HDC;
    Save: THandle;
begin
  //if GetHandle = 0 then Exit;
  if Empty then Exit;
  fDetachCanvas( Self );
  DC := CreateCompatibleDC( 0 );
  Save := SelectObject( DC, GetHandle );
  ASSERT( Save <> 0, 'Can not select bitmap to DC' );
  Windows.SetPixel( DC, X, Y, Color2RGB( Value ) );
  SelectObject( DC, Save );
  DeleteDC( DC );
end;
{$ENDIF ASM_VERSION}

//[FUNCTION _GetDIBPixelsPalIdx]
{$IFDEF ASM_VERSION}
function _GetDIBPixelsPalIdx( Bmp: PBitmap; X, Y: Integer ): TColor;
const szBIH = Sizeof(TBitmapInfoHeader);
asm
        PUSH     EBX
        PUSH     EDI
        PUSH     EDX
        XCHG     EBX, EAX

        XCHG     EAX, EDX
        MOV      EDI, [EBX].TBitmap.fPixelsPerByteMask
        INC      EDI
        CDQ
        DIV      EDI
        DEC      EDI
        XCHG     ECX, EAX // EAX = Y, ECX = X div (Bmp.fPixeldPerByteMask+1)

        MOV      EDX, [EBX].TBitmap.fScanLineDelta
        IMUL     EDX

        ADD      EAX, [EBX].TBitmap.fScanLine0
        MOVZX    EAX, byte ptr[EAX+ECX]

        POP      EDX
        MOV      ECX, [EBX].TBitmap.fPixelsPerByteMask
        AND      EDX, ECX
        SUB      ECX, EDX

        PUSH     EAX
        MOV      EDI, [EBX].TBitmap.fDIBHeader
        MOVZX    EAX, [EDI].TBitmapInfoHeader.biBitCount
        MUL      ECX
        XCHG     ECX, EAX
        POP      EAX
        SHR      EAX, CL
        AND      EAX, [EBX].TBitmap.fPixelMask

        MOV      EAX, [EDI+szBIH+EAX*4]
        CALL     Color2RGBQuad

        POP      EDI
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function _GetDIBPixelsPalIdx( Bmp: PBitmap; X, Y: Integer ): TColor;
var Pixel: Byte;
begin
  Pixel := PByte( Integer(Bmp.fScanLine0) + Y * Bmp.fScanLineDelta
             + (X div (Bmp.fPixelsPerByteMask + 1)) )^;
  Pixel := ( Pixel shr ( (Bmp.fPixelsPerByteMask - (X and Bmp.fPixelsPerByteMask))
                       * Bmp.fDIBHeader.bmiHeader.biBitCount ) )
           and Bmp.fPixelMask;
  Result := TColor( Color2RGBQuad( TColor( PRGBQuad( DWORD(@Bmp.fDIBHeader.bmiColors[ 0 ])
                           + Pixel * Sizeof( TRGBQuad ) )^ ) ) );
end;
{$ENDIF ASM_VERSION}
//[END _GetDIBPixelsPalIdx]

//[FUNCTION _GetDIBPixels16bit]
{$IFDEF ASM_VERSION}
function _GetDIBPixels16bit( Bmp: PBitmap; X, Y: Integer ): TColor;
asm
        PUSH     [EAX].TBitmap.fPixelMask
        PUSH     EDX // X
        PUSH     EAX
        MOV      EAX, [EAX].TBitmap.fScanLineDelta
        IMUL     ECX
        POP      EDX
        ADD      EAX, [EDX].TBitmap.fScanLine0
        POP      ECX
        MOVZX    EAX, word ptr [EAX+ECX*2]
        POP      EDX
        CMP      DL, 15
        JNE      @@16bit

        MOV      EDX, EAX
        SHR      EDX, 7
        SHL      EAX, 6
        MOV      DH, AH
        AND      DH, $F8
        SHL      EAX, 13
        JMP      @@1516bit

@@16bit:
        MOV      DL, AH
        SHL      EAX, 5
        MOV      DH, AH
        SHL      EAX, 14
@@1516bit:
        AND      EAX, $F80000
        OR       EAX, EDX
        AND      AX, $FCF8
end;
{$ELSE ASM_VERSION} //Pascal
function _GetDIBPixels16bit( Bmp: PBitmap; X, Y: Integer ): TColor;
var Pixel: Word;
begin
  Pixel := PWord( Integer(Bmp.fScanLine0) + Y * Bmp.fScanLineDelta + X * 2 )^;
  if Bmp.fPixelMask = 15 then
    Result := (Pixel shr 7) and $F8 or (Pixel shl 6) and $F800
           or (Pixel shl 19) and $F80000
  else
    Result := (Pixel shr 8) and $F8 or (Pixel shl 5) and $FC00
           or (Pixel shl 19) and $F80000;
end;
{$ENDIF ASM_VERSION}
//[END _GetDIBPixels16bit]

//[FUNCTION _GetDIBPixelsTrueColor]
{$IFDEF ASM_VERSION}
function _GetDIBPixelsTrueColor( Bmp: PBitmap; X, Y: Integer ): TColor;
asm
        PUSH     EBX
        XCHG     EBX, EAX
        PUSH     EDX
        MOV      EAX, [EBX].TBitmap.fScanLineDelta
        IMUL     ECX
        XCHG     ECX, EAX
        POP      EDX
        MOV      EAX, [EBX].TBitmap.fBytesPerPixel
        MUL      EDX
        ADD      EAX, [EBX].TBitmap.fScanLine0
        MOV      EAX, [EAX+ECX]
        AND      EAX, $FFFFFF
        CALL     Color2RGBQuad
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function _GetDIBPixelsTrueColor( Bmp: PBitmap; X, Y: Integer ): TColor;
var Pixel: DWORD;
begin
  Pixel := PDWORD( Integer(Bmp.fScanLine0) + Y * Bmp.fScanLineDelta +
                   X * Bmp.fBytesPerPixel )^ and $FFFFFF;
  Result := TColor( Color2RGBQuad( TColor( Pixel ) ) );
end;
{$ENDIF ASM_VERSION}
//[END _GetDIBPixelsTrueColor]

{$IFDEF ASM_VERSION}
//[function TBitmap.GetDIBPixels]
function TBitmap.GetDIBPixels(X, Y: Integer): TColor;
asm
        CMP      word ptr [EAX].fGetDIBPixels+2, 0
        JNZ      @@assigned

        // if not assigned, this preparing will be performed for first call:
        CMP      [EAX].fHandleType, bmDDB
        JZ       @@GetPixels

        PUSHAD
        MOV      EBX, EAX
        XOR      EDX, EDX
        CALL     GetScanLine
        MOV      [EBX].fScanLine0, EAX
        XOR      EDX, EDX
        INC      EDX
        MOV      EAX, EBX
        CALL     GetScanLine
        SUB      EAX, [EBX].fScanLine0
        MOV      [EBX].fScanLineDelta, EAX
        MOV      EAX, EBX
        CALL     GetPixelFormat
        MOVZX    ECX, AL
        MOV      DX, $0F00
        MOV      byte ptr [EBX].fBytesPerPixel, 4
        XOR      EAX, EAX
        LOOP     @@if4bit
        MOV      DX, $0107
        JMP      @@1bit4bit8bit
@@if4bit:
        LOOP     @@if8bit
        INC      EDX // MOV      DX, $0F01
        JMP      @@1bit4bit8bit
@@if8bit:
        LOOP     @@if15bit
        MOV      DH, $FF //MOV      DX, $FF00
@@1bit4bit8bit:
        MOV      EAX, offset[_GetDIBPixelsPalIdx]
@@if15bit:
        LOOP     @@if16bit
        //MOV      DH, $0F
        DEC      DH
        INC      ECX
@@if16bit:
        LOOP     @@if24bit
        INC      DH
        MOV      EAX, offset[_GetDIBPixels16bit]
@@if24bit:
        LOOP     @@if32bit
        DEC      [EBX].fBytesPerPixel
        INC      ECX
        DEC      EDX
@@if32bit:
        LOOP     @@iffin
        INC      EDX
        MOV      EAX, offset[_GetDIBPixelsTrueColor]
@@iffin:
        MOV      byte ptr [EBX].fPixelMask, DH
        MOV      byte ptr [EBX].fPixelsPerByteMask, DL
        MOV      [EBX].fGetDIBPixels, EAX
        TEST     EAX, EAX
        POPAD
@@GetPixels:
        JZ       GetPixels

@@assigned:
        JMP      [EAX].fGetDIBPixels
end;
{$ELSE ASM_VERSION} //Pascal
function TBitmap.GetDIBPixels(X, Y: Integer): TColor;
begin
  if not Assigned( fGetDIBPixels ) then
  begin
    if fHandleType = bmDIB then
    begin
      fScanLine0 := ScanLine[ 0 ];
      fScanLineDelta := Integer(ScanLine[ 1 ]) - Integer(fScanLine0);
      case PixelFormat of
      pf1bit:
        begin
          fPixelMask := $01;
          fPixelsPerByteMask := 7;
          fGetDIBPixels := _GetDIBPixelsPalIdx;
        end;
      pf4bit:
        begin
          fPixelMask := $0F;
          fPixelsPerByteMask := 1;
          fGetDIBPixels := _GetDIBPixelsPalIdx;
        end;
      pf8bit:
        begin
          fPixelMask := $FF;
          fPixelsPerByteMask := 0;
          fGetDIBPixels := _GetDIBPixelsPalIdx;
        end;
      pf15bit:
        begin
          fPixelMask := 15;
          fGetDIBPixels := _GetDIBPixels16bit;
        end;
      pf16bit:
        begin
          fPixelMask := 16;
          fGetDIBPixels := _GetDIBPixels16bit;
        end;
      pf24bit:
        begin
          fPixelsPerByteMask := 0;
          fBytesPerPixel := 3;
          fGetDIBPixels := _GetDIBPixelsTrueColor;
        end;
      pf32bit:
        begin
          fPixelsPerByteMask := 1;
          fBytesPerPixel := 4;
          fGetDIBPixels := _GetDIBPixelsTrueColor;
        end;
      else;
      end;
    end;
    if not Assigned( fGetDIBPixels ) then
    begin
      Result := Pixels[ X, Y ];
      Exit;
    end;
  end;
  Result := fGetDIBPixels( Self, X, Y );
end;
{$ENDIF ASM_VERSION}

//[PROCEDURE _SetDIBPixels1bit]
{$IFDEF ASM_VERSION}
procedure _SetDIBPixels1bit( Bmp: PBitmap; X, Y: Integer; Value: TColor );
asm
        PUSH     EDX
        PUSH     [EAX].TBitmap.fScanLine0
        PUSH     ECX
        PUSH     [EAX].TBitmap.fScanLineDelta
        MOV      EAX, Value
        CALL     Color2RGB
        MOV      EDX, EAX
        SHR      EAX, 16
        ADD      AL, DL
        ADC      AL, DH
        CMP      EAX, 170
        SETGE    CL
        AND      ECX, 1
        SHL      ECX, 7
        POP      EAX
        POP      EDX
        IMUL     EDX
        POP      EDX
        ADD      EAX, EDX
        POP      EDX
        PUSH     ECX
        MOV      ECX, EDX
        SHR      EDX, 3
        ADD      EAX, EDX
        AND      ECX, 7
        MOV      DX, $FF7F
        SHR      EDX, CL
        AND      byte ptr [EAX], DL
        POP      EDX
        SHR      EDX, CL
        OR       byte ptr [EAX], DL
end;
{$ELSE ASM_VERSION} //Pascal
procedure _SetDIBPixels1bit( Bmp: PBitmap; X, Y: Integer; Value: TColor );
var Pixel: Byte;
    Pos: PByte;
    Shf: Integer;
begin
  Value := Color2RGB( Value );
  if ((Value shr 16) and $FF) + ((Value shr 8) and $FF) + (Value and $FF)
     < 255 * 3 div 2 then Pixel := 0 else Pixel := $80;
  Pos := PByte( Integer(Bmp.fScanLine0) + Y * Bmp.fScanLineDelta + X div 8 );
  Shf := X and 7;
  Pos^ := Pos^ and ($FF7F shr Shf) or (Pixel shr Shf);
end;
{$ENDIF ASM_VERSION}
//[END _SetDIBPixels1bit]

//[PROCEDURE _SetDIBPixelsPalIdx]
{$IFDEF ASM_VERSION}
procedure _SetDIBPixelsPalIdx( Bmp: PBitmap; X, Y: Integer; Value: TColor );
asm
        XCHG     EAX, EBP
        PUSH     EDX // -> X
        PUSH     ECX // -> Y
        MOV      ECX, [EBP].TBitmap.fPixelsPerByteMask
        INC      ECX
        XCHG     EAX, EDX
        CDQ
        DIV      ECX
        XCHG     ECX, EAX // ECX = X div (fPixelsPerByteMask+1)
        POP      EAX // <- Y
        MOV      EDX, [EBP].TBitmap.fScanLineDelta
        IMUL     EDX
        ADD      ECX, EAX
        ADD      ECX, [EBP].TBitmap.fScanLine0 // ECX = Pos
        PUSH     ECX // -> Pos

        MOV      EDX, [ESP+16] // Value
        MOV      EAX, EBP
        CALL     TBitmap.DIBPalNearestEntry // EAX = Pixel

        POP      ECX // <- Pos
        POP      EDX // <- X

        PUSH     EAX // -> Pixel

        MOV      EAX, [EBP].TBitmap.fPixelsPerByteMask
        AND      EDX, EAX
        SUB      EAX, EDX
        MOV      EDX, [EBP].TBitmap.fDIBHeader
        MOVZX    EDX, [EDX].TBitmapInfoHeader.biBitCount
        MUL      EDX // EAX = Shf

        XCHG     ECX, EAX // ECX = Shf, EAX = Pos
        MOV      EDX, [EBP].TBitmap.fPixelMask
        SHL      EDX, CL
        NOT      EDX
        AND      byte ptr [EAX], DL

        POP      EDX // <- Pixel
        SHL      EDX, CL
        OR       byte ptr [EAX], DL
end;
{$ELSE ASM_VERSION} //Pascal
procedure _SetDIBPixelsPalIdx( Bmp: PBitmap; X, Y: Integer; Value: TColor );
var Pixel: Byte;
    Pos: PByte;
    Shf: Integer;
begin
  Pixel := Bmp.DIBPalNearestEntry( Value );
  Pos := PByte( Integer(Bmp.fScanLine0) + Y * Bmp.fScanLineDelta
                + X div (Bmp.fPixelsPerByteMask + 1) );
  Shf := (Bmp.fPixelsPerByteMask - (X and Bmp.fPixelsPerByteMask))
         * Bmp.fDIBHeader.bmiHeader.biBitCount;
  Pos^ := Pos^ and not (Bmp.fPixelMask shl Shf) or (Pixel shl Shf);
end;
{$ENDIF ASM_VERSION}
//[END _SetDIBPixelsPalIdx]

//[PROCEDURE _SetDIBPixels16bit]
{$IFDEF ASM_VERSION}
procedure _SetDIBPixels16bit( Bmp: PBitmap; X, Y: Integer; Value: TColor );
asm
        ADD      EDX, EDX
        ADD      EDX, [EAX].TBitmap.fScanLine0
        PUSH     EDX // -> X*2 + Bmp.fScanLine0
        PUSH     [EAX].TBitmap.fPixelMask
        MOV      EAX, [EAX].TBitmap.fScanLineDelta
        IMUL     ECX
        PUSH     EAX  // -> Y* Bmp.fScanLineDelta
        MOV      EAX, Value
        CALL     Color2RGB
        POP      EBP  // <- Y* Bmp.fScanLineDelta
        POP      EDX
        XOR      ECX, ECX
        SUB      DL, 16
        JZ       @@16bit

        MOV      CH, AL
        SHR      CH, 1
        SHR      EAX, 6
        MOV      EDX, EAX
        AND      DX, $3E0
        SHR      EAX, 13
        JMP      @@1516

@@16bit:
        {$IFDEF PARANOIA}
        DB $24, $F8
        {$ELSE}
        AND      AL, $F8
        {$ENDIF}
        MOV      CH, AL
        SHR      EAX, 5
        MOV      EDX, EAX
        AND      DX, $7E0
        SHR      EAX, 14

@@1516:
        MOV      AH, CH
        AND      AX, $FC1F
        OR       AX, DX

        POP      EDX
        MOV      [EBP+EDX], AX
end;
{$ELSE ASM_VERSION} //Pascal
procedure _SetDIBPixels16bit( Bmp: PBitmap; X, Y: Integer; Value: TColor );
var RGB16: Word;
    Pos: PWord;
begin
  Value := Color2RGB( Value );
  if Bmp.fPixelMask = 15 then
    RGB16 := (Value shr 19) and $001F or (Value shr 6) and $03E0
          or (Value shl 7) and $7C00
  else
    RGB16 := (Value shr 19) and $001F or (Value shr 5) and $07E0
          or (Value shl 8) and $F800;
  Pos := PWord( Integer(Bmp.fScanLine0) + Y * Bmp.fScanLineDelta + X * 2 );
  Pos^ := RGB16;
end;
{$ENDIF ASM_VERSION}
//[END _SetDIBPixels16bit]

//[PROCEDURE _SetDIBPixelsTrueColor]
{$IFDEF ASM_VERSION}
procedure _SetDIBPixelsTrueColor( Bmp: PBitmap; X, Y: Integer; Value: TColor );
asm
        PUSH     [EAX].TBitmap.fScanLineDelta
        PUSH     [EAX].TBitmap.fScanLine0
        MOV      EAX, [EAX].TBitmap.fBytesPerPixel
        MUL      EDX
        POP      EDX
        ADD      EDX, EAX
        POP      EAX
        PUSH     EDX
        IMUL     ECX
        POP      EDX
        ADD      EDX, EAX
        PUSH     EDX
        MOV      EAX, Value
        CALL     Color2RGBQuad
        POP      EDX
        AND      dword ptr [EDX], $FF000000
        OR       [EDX], EAX
end;
{$ELSE ASM_VERSION} //Pascal
procedure _SetDIBPixelsTrueColor( Bmp: PBitmap; X, Y: Integer; Value: TColor );
var RGB: TRGBQuad;
    Pos: PDWord;
begin
  //Value := Color2RGB( Value );
  RGB := Color2RGBQuad( Value );
  Pos := PDWORD( Integer(Bmp.fScanLine0) + Y * Bmp.fScanLineDelta
                 + X * Bmp.fBytesPerPixel );
  Pos^ := Pos^ and $FF000000 or DWORD(RGB);
end;
{$ENDIF ASM_VERSION}
//[END _SetDIBPixelsTrueColor]

{$IFDEF ASM_VERSION}
//[procedure TBitmap.SetDIBPixels]
procedure TBitmap.SetDIBPixels(X, Y: Integer; const Value: TColor);
asm
        CMP      word ptr [EAX].fSetDIBPixels+2, 0
        JNZ      @@assigned
        PUSHAD
        MOV      EBX, EAX
        XOR      EDX, EDX
        CMP      [EBX].fHandleType, DL // bmDIB = 0
        JNE      @@ddb
        CALL     GetScanLine
        MOV      [EBX].fScanLine0, EAX
        XOR      EDX, EDX
        INC      EDX
        MOV      EAX, EBX
        CALL     GetScanLine
        SUB      EAX, [EBX].fScanLine0
        MOV      [EBX].fScanLineDelta, EAX
        MOV      EAX, EBX
        CALL     GetPixelFormat
        MOVZX    ECX, AL
        MOV      DX, $0F01
        MOV      EAX, offset[_SetDIBPixelsPalIdx]
        MOV      byte ptr [EBX].fBytesPerPixel, 4
        LOOP     @@if4bit
        MOV      EAX, offset[_SetDIBPixels1bit]
@@if4bit:
        LOOP     @@if8bit
@@if8bit:
        LOOP     @@if15bit
        DEC      DL
        MOV      DH, $FF
@@if15bit:
        LOOP     @@if16bit
        DEC      DH
        INC      ECX
@@if16bit:
        LOOP     @@if24bit
        INC      DH
        MOV      EAX, offset[_SetDIBPixels16bit]
@@if24bit:
        LOOP     @@if32bit
        DEC      EDX
        DEC      [EBX].fBytesPerPixel
        INC      ECX
@@if32bit:
        LOOP     @@ifend
        INC      EDX
        MOV      EAX, offset[_SetDIBPixelsTrueColor]
@@ifend:
        MOV      byte ptr [EBX].fPixelMask, DH
        MOV      byte ptr [EBX].fPixelsPerByteMask, DL
        MOV      [EBX].fSetDIBPixels, EAX
        TEST     EAX, EAX
@@ddb:
        POPAD
        JNZ      @@assigned
        PUSH     Value
        CALL     SetPixels
        JMP      @@exit
@@assigned:
        PUSH     Value
        CALL     [EAX].fSetDIBPixels
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TBitmap.SetDIBPixels(X, Y: Integer; const Value: TColor);
begin
  if not Assigned( fSetDIBPixels ) then
  begin
    if fHandleType = bmDIB then
    begin
      fScanLine0 := ScanLine[ 0 ];
      fScanLineDelta := Integer(ScanLine[ 1 ]) - Integer(fScanLine0);
      case PixelFormat of
      pf1bit:
        begin
          //fPixelMask := $01;
          //fPixelsPerByteMask := 7;
          fSetDIBPixels := _SetDIBPixels1bit;
        end;
      pf4bit:
        begin
          fPixelMask := $0F;
          fPixelsPerByteMask := 1;
          fSetDIBPixels := _SetDIBPixelsPalIdx;
        end;
      pf8bit:
        begin
          fPixelMask := $FF;
          fPixelsPerByteMask := 0;
          fSetDIBPixels := _SetDIBPixelsPalIdx;
        end;
      pf15bit:
        begin
          fPixelMask := 15;
          fSetDIBPixels := _SetDIBPixels16bit;
        end;
      pf16bit:
        begin
          fPixelMask := 16;
          fSetDIBPixels := _SetDIBPixels16bit;
        end;
      pf24bit:
        begin
          fPixelsPerByteMask := 0;
          fBytesPerPixel := 3;
          fSetDIBPixels := _SetDIBPixelsTrueColor;
        end;
      pf32bit:
        begin
          fPixelsPerByteMask := 1;
          fBytesPerPixel := 4;
          fSetDIBPixels := _SetDIBPixelsTrueColor;
        end;
      else;
      end;
    end;
    if not Assigned( fSetDIBPixels ) then
    begin
      Pixels[ X, Y ] := Value;
      Exit;
    end;
  end;
  fSetDIBPixels( Self, X, Y, Value );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TBitmap.FlipVertical]
procedure TBitmap.FlipVertical;
asm
        PUSH     EBX
        MOV      EBX, EAX
        MOV      ECX, [EBX].fHandle
        JECXZ    @@noHandle

        CALL     StartDC
        PUSH     SrcCopy
        MOV      EDX, [EBX].fHeight
        PUSH     EDX
        MOV      ECX, [EBX].fWidth
        PUSH     ECX
        PUSH     0
        PUSH     0
        PUSH     EAX
        NEG      EDX
        PUSH     EDX
        PUSH     ECX
        NEG      EDX
        DEC      EDX
        PUSH     EDX
        PUSH     0
        PUSH     EAX
        CALL     StretchBlt
        CALL     FinishDC
        POP      EBX
        RET

@@noHandle:
        MOV      ECX, [EBX].fDIBBits
        JECXZ    @@exit

        PUSHAD   //----------------------------------------\
        XOR      EBP, EBP // Y = 0
        //+++++++++++++++++++++++++++ provide fScanLineSize
        MOV      EAX, EBX
        MOV      EDX, EBP
        CALL     GetScanLine //
        SUB      ESP, [EBX].fScanLineSize

@@loo:  LEA      EAX, [EBP*2]
        CMP      EAX, [EBX].fHeight
        JG       @@finloo

        MOV      EAX, EBX
        MOV      EDX, EBP
        CALL     GetScanLine
        MOV      ESI, EAX // ESI = ScanLine[ Y ]
        MOV      EDX, ESP
        MOV      ECX, [EBX].fScanLineSize
        PUSH     ECX
        CALL     System.Move

        MOV      EAX, EBX
        MOV      EDX, [EBX].fHeight
        SUB      EDX, EBP
        DEC      EDX
        CALL     GetScanLine
        MOV      EDI, EAX
        MOV      EDX, ESI
        POP      ECX
        PUSH     ECX
        CALL     System.Move

        POP      ECX
        MOV      EAX, ESP
        MOV      EDX, EDI
        CALL     System.Move

        INC      EBP
        JMP      @@loo

@@finloo:
        ADD      ESP, [EBX].fScanLineSize
        POPAD
@@exit:
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TBitmap.FlipVertical;
var DC: HDC;
    Save: THandle;
    TmpScan: PByte;
    Y: Integer;
begin
  if fHandle <> 0 then
  begin
    fDetachCanvas( Self );
    DC := CreateCompatibleDC( 0 );
    Save := SelectObject( DC, fHandle );
    StretchBlt( DC, 0, fHeight - 1, fWidth, -fHeight, DC, 0, 0, fWidth, fHeight, SRCCOPY );
    SelectObject( DC, Save );
    DeleteDC( DC );
  end
     else
  if fDIBBits <> nil then
  begin
    GetMem( TmpScan, ScanLineSize );
    for Y := 0 to fHeight div 2 do
    begin
      Move( ScanLine[ Y ]^, TmpScan^, fScanLineSize );
      Move( ScanLine[ fHeight - Y - 1 ]^, ScanLine[ Y ]^, fScanLineSize );
      Move( TmpScan^, ScanLine[ fHeight - Y - 1 ]^, fScanLineSize );
    end;
  end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TBitmap.FlipHorizontal]
procedure TBitmap.FlipHorizontal;
asm
        PUSH     EBX
        MOV      EBX, EAX
        CALL     GetHandle
        TEST     EAX, EAX
        JZ       @@exit

        CALL     StartDC
        PUSH     SrcCopy
        MOV      EDX, [EBX].fHeight
        PUSH     EDX
        MOV      ECX, [EBX].fWidth
        PUSH     ECX
        PUSH     0
        PUSH     0
        PUSH     EAX
        PUSH     EDX
        NEG      ECX
        PUSH     ECX
        PUSH     0
        NEG      ECX
        DEC      ECX
        PUSH     ECX
        PUSH     EAX
        CALL     StretchBlt
        CALL     FinishDC
@@exit:
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TBitmap.FlipHorizontal;
var DC: HDC;
    Save: THandle;
begin
  if GetHandle <> 0 then
  begin
    fDetachCanvas( Self );
    DC := CreateCompatibleDC( 0 );
    Save := SelectObject( DC, fHandle );
    StretchBlt( DC, fWidth - 1, 0, -fWidth, fHeight, DC, 0, 0, fWidth, fHeight, SRCCOPY );
    SelectObject( DC, Save );
    DeleteDC( DC );
  end;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TBitmap.CopyRect]
procedure TBitmap.CopyRect(const DstRect: TRect; SrcBmp: PBitmap;
  const SrcRect: TRect);
asm
        PUSHAD
        MOV      EBX, EAX
        MOV      ESI, ECX
        MOV      EDI, EDX
        CALL     GetHandle
        TEST     EAX, EAX
        JZ       @@exit
        MOV      EAX, ESI
        CALL     GetHandle
        TEST     EAX, EAX
        JZ       @@exit
        CALL     StartDC
        XCHG     EBX, ESI
        CMP      EBX, ESI
        JNZ      @@diff1
        PUSH     EAX
        PUSH     0
        JMP      @@nodiff1
@@diff1:
        CALL     StartDC
@@nodiff1:
        PUSH     SrcCopy                  // ->
        MOV      EBP, [SrcRect]
        MOV      EAX, [EBP].TRect.Bottom
        MOV      EDX, [EBP].TRect.Top
        SUB      EAX, EDX
        PUSH     EAX                      // ->
        MOV      EAX, [EBP].TRect.Right
        MOV      ECX, [EBP].TRect.Left
        SUB      EAX, ECX
        PUSH     EAX                      // ->
        PUSH     EDX                      // ->
        PUSH     ECX                      // ->
        PUSH     dword ptr [ESP+24]       // -> DCsrc
        MOV      EAX, [EDI].TRect.Bottom
        MOV      EDX, [EDI].TRect.Top
        SUB      EAX, EDX
        PUSH     EAX                      // ->
        MOV      EAX, [EDI].TRect.Right
        MOV      ECX, [EDI].TRect.Left
        SUB      EAX, ECX
        PUSH     EAX                      // ->
        PUSH     EDX                      // ->
        PUSH     ECX                      // ->
        PUSH     dword ptr [ESP+13*4]     // -> DCdst
        CALL     StretchBlt
        CMP      EBX, ESI
        JNE      @@diff2
        POP      ECX
        POP      ECX
        JMP      @@nodiff2
@@diff2:
        CALL     FinishDC
@@nodiff2:
        CALL     FinishDC
@@exit:
        POPAD
end;
{$ELSE ASM_VERSION} //Pascal
procedure TBitmap.CopyRect(const DstRect: TRect; SrcBmp: PBitmap;
  const SrcRect: TRect);
var DCsrc, DCdst: HDC;
    SaveSrc, SaveDst: THandle;
begin
  if (GetHandle = 0) or (SrcBmp.GetHandle = 0) then Exit;
  fDetachCanvas( Self );
  fDetachCanvas( SrcBmp );
  DCsrc := CreateCompatibleDC( 0 );
  SaveSrc := SelectObject( DCsrc, SrcBmp.fHandle );
  DCdst := DCsrc;
  SaveDst := 0;
  if SrcBmp <> Self then
  begin
    DCdst := CreateCompatibleDC( 0 );
    SaveDst := SelectObject( DCdst, fHandle );
  end;
  StretchBlt( DCdst, DstRect.Left, DstRect.Top, DstRect.Right - DstRect.Left,
              DstRect.Bottom - DstRect.Top, DCsrc, SrcRect.Left, SrcRect.Top,
              SrcRect.Right - SrcRect.Left, SrcRect.Bottom - SrcRect.Top,
              SRCCOPY );
  if SrcBmp <> Self then
  begin
    SelectObject( DCdst, SaveDst );
    DeleteDC( DCdst );
  end;
  SelectObject( DCsrc, SaveSrc );
  DeleteDC( DCsrc );
end;
{$ENDIF ASM_VERSION}


//[function TBitmap.CopyToClipboard]
function TBitmap.CopyToClipboard: Boolean;
var DibMem: PChar;
    HdrSize: Integer;
    Gbl: HGlobal;
begin
  Result := FALSE;
  if Applet = nil then Exit;
  if not OpenClipboard( Applet.GetWindowHandle ) then
    Exit;
  if EmptyClipboard then
  begin
    HandleType := bmDIB;
    HdrSize := sizeof( TBitmapInfoHeader );
    if fDIBHeader.bmiHeader.biBitCount <= 8 then
       Inc( HdrSize,
       (1 shl fDIBHeader.bmiHeader.biBitCount) * Sizeof( TRGBQuad ) );
    Gbl := GlobalAlloc( GMEM_MOVEABLE, HdrSize + fDIBSize );
    DibMem := GlobalLock( Gbl );
    if DibMem <> nil then
    begin
      Move( fDIBHeader^, DibMem^, HdrSize );
      Move( fDIBBits^, Pointer( Integer( DibMem ) + HdrSize )^, fDIBSize );
      if not GlobalUnlock( Gbl ) and (GetLastError = NO_ERROR) then
      begin
        Result := SetClipboardData( CF_DIB, Gbl ) <> 0;
      end;
    end;
  end;
  CloseClipboard;
end;

//[function TBitmap.PasteFromClipboard]
function TBitmap.PasteFromClipboard: Boolean;
var Gbl: HGlobal;
    //DIBPtr: PChar;
    Size {, HdrSize}: Integer;
    Mem: PChar;
    Strm: PStream;
begin
  Result := FALSE;
  if Applet = nil then Exit;
  if not OpenClipboard( Applet.GetWindowHandle ) then Exit;
  TRY
  if IsClipboardFormatAvailable( CF_DIB ) then
  begin
    Gbl := GetClipboardData( CF_DIB );
    if Gbl <> 0 then
    begin
      Size := GlobalSize( Gbl );
      Mem := GlobalLock( Gbl );
      TRY
      if (Size > 0) and (Mem <> nil) then
      begin
        Strm := NewMemoryStream;
        Strm.Write( Mem^, Size );
        Strm.Position := 0;
        LoadFromStreamEx( Strm );
        Strm.Free;
        Result := not Empty;
      end;
      FINALLY
      GlobalUnlock( Gbl );
      END;
    end;
  end;
  FINALLY
  CloseClipboard;
  END;
end;









///////////////////////////////////////////////////////////////////////
//
//
//                             I  C  O  N
//
//
///////////////////////////////////////////////////////////////////////

{ -- icon -- }

//[function NewIcon]
function NewIcon: PIcon;
begin
  Result := TIcon.Create;
  Result.FSize := 32;
end;

{ TIcon }

//[PROCEDURE asmIconEmpty]
{$IFDEF ASM_VERSION}
procedure asmIconEmpty( Icon: PIcon );
asm
        CMP      [EAX].TIcon.fHandle, 0
end;
{$ENDIF ASM_VERSION}
//[END asmIconEmpty]

{$IFDEF ASM_VERSION}
//[procedure TIcon.Clear]
procedure TIcon.Clear;
asm     //cmd    //opd
        XOR      ECX, ECX
        XCHG     ECX, [EAX].fHandle
        JECXZ    @@1
        CMP      [EAX].fShareIcon, 0
        JNZ      @@1
        PUSH     EAX
        PUSH     ECX
        CALL     DestroyIcon
        POP      EAX
@@1:    MOV      [EAX].fShareIcon, 0
end;
{$ELSE ASM_VERSION} //Pascal
procedure TIcon.Clear;
begin
  if fHandle <> 0 then
  begin
    if not FShareIcon then
      //DeleteObject( fHandle );
      DestroyIcon( fHandle );
    fHandle := 0;
  end;
  fShareIcon := False;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[function TIcon.Convert2Bitmap]
function TIcon.Convert2Bitmap(TranColor: TColor): HBitmap;
asm     //cmd    //opd
        PUSH     EBX
        PUSH     ESI
        PUSH     EDI
        PUSH     EBP
        MOV      EBX, EAX
        MOV      EBP, EDX
        XOR      EDX, EDX
        CALL     asmIconEmpty
        JZ       @@ret_0
        PUSH     0
        CALL     GetDC
        PUSH     EAX //> DC0
        PUSH     EAX
        CALL     CreateCompatibleDC
        XCHG     EDI, EAX
        MOV      EDX, [EBX].fSize

        POP      EAX
        PUSH     EAX
        PUSH     EDX //>Bottom
        PUSH     EDX //>Right
        PUSH     0   //>Top
        PUSH     0   //>Left

        PUSH     EDX
        PUSH     EDX
        PUSH     EAX
        CALL     CreateCompatibleBitmap
        XCHG     EBP, EAX

        CALL     Color2RGB
        PUSH     EAX

        PUSH     EBP
        PUSH     EDI
        CALL     SelectObject
        XCHG     ESI, EAX

        CALL     CreateSolidBrush

        MOV      EDX, ESP
        PUSH     EAX
        PUSH     EAX
        PUSH     EDX
        PUSH     EDI
        CALL     Windows.FillRect
        CALL     DeleteObject

        XCHG     EAX, EBX
        MOV      EDX, EDI
        XOR      ECX, ECX
        PUSH     ECX
        CALL     Draw

        PUSH     EDI
        PUSH     ESI
        CALL     FinishDC

        ADD      ESP, 16
        PUSH     0
        CALL     ReleaseDC
        MOV      EDX, EBP

@@ret_0:
        XCHG     EAX, EDX
        POP      EBP
        POP      EDI
        POP      ESI
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function TIcon.Convert2Bitmap(TranColor: TColor): HBitmap;
var DC0, DC2: HDC;
    Save: THandle;
    Br: HBrush;
begin
  Result := 0;
  if Empty then Exit;
  DC0 := GetDC( 0 );
  DC2 := CreateCompatibleDC( DC0 );
  Result := CreateCompatibleBitmap( DC0, fSize, fSize );
  Save := SelectObject( DC2, Result );
  Br := CreateSolidBrush( Color2RGB( TranColor ) );
  FillRect( DC2, MakeRect( 0, 0, fSize, fSize ), Br );
  DeleteObject( Br );
  Draw( DC2, 0, 0 );
  SelectObject( DC2, Save );
  DeleteDC( DC2 );
  ReleaseDC( 0, DC0 );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[destructor TIcon.Destroy]
destructor TIcon.Destroy;
asm     //cmd    //opd
        PUSH     EAX
        CALL     Clear
        POP      EAX
        CALL     TObj.Destroy
end;
{$ELSE ASM_VERSION} //Pascal
destructor TIcon.Destroy;
begin
  Clear;
  inherited;
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TIcon.Draw]
procedure TIcon.Draw(DC: HDC; X, Y: Integer);
asm     //cmd    //opd
        CALL     asmIconEmpty
        JZ       @@exit
        PUSH     DI_NORMAL
        PUSH     0
        PUSH     0
        PUSH     [EAX].fSize
        PUSH     [EAX].fSize
        PUSH     [EAX].fHandle
        PUSH     Y
        PUSH     ECX
        PUSH     EDX
        CALL     DrawIconEx
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TIcon.Draw(DC: HDC; X, Y: Integer);
begin
  if Empty then Exit;
  DrawIconEx( DC, X, Y, fHandle, fSize, fSize, 0, 0, DI_NORMAL );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TIcon.StretchDraw]
procedure TIcon.StretchDraw(DC: HDC; Dest: TRect);
asm     //cmd    //opd
        CALL     asmIconEmpty
        JZ       @@exit
        PUSH     DI_NORMAL
        PUSH     0
        PUSH     0
        PUSH     ECX
        PUSH     ECX
        PUSH     [EAX].fHandle
        PUSH     [ECX].TRect.Top
        PUSH     [ECX].TRect.Left
        PUSH     EDX
        MOV      EAX, [ECX].TRect.Bottom
        SUB      EAX, [ECX].TRect.Top
        MOV      [ESP+20], EAX
        MOV      EAX, [ECX].TRect.Right
        SUB      EAX, [ECX].TRect.Left
        MOV      [ESP+16], EAX
        CALL     DrawIconEx
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TIcon.StretchDraw(DC: HDC; Dest: TRect);
begin
  if Empty then Exit;
  DrawIconEx( DC, Dest.Left, Dest.Top, FHandle, Dest.Right - Dest.Left,
              Dest.Bottom - Dest.Top, 0, 0, DI_NORMAL );
end;
{$ENDIF ASM_VERSION}

//[function TIcon.GetEmpty]
function TIcon.GetEmpty: Boolean;
begin
  Result := fHandle = 0;
end;

//*
//[function TIcon.GetHotSpot]
function TIcon.GetHotSpot: TPoint;
var II : TIconInfo;
begin
  Result := MakePoint( 0, 0 );
  if FHandle = 0 then Exit;
  GetIconInfo( FHandle, II );
  Result.x := II.xHotspot;
  Result.y := II.yHotspot;
  if II.hbmMask <> 0 then
    DeleteObject( II.hbmMask );
  if II.hbmColor <> 0 then
    DeleteObject( II.hbmColor );
end;

//*
//[procedure TIcon.LoadFromFile]
procedure TIcon.LoadFromFile(const FileName: String);
var Strm : PStream;
begin
  Strm := NewReadFileStream( Filename );
  LoadFromStream( Strm );
  Strm.Free;
end;

//*
//[procedure TIcon.LoadFromStream]
procedure TIcon.LoadFromStream(Strm: PStream);
var DesiredSize : Integer;
    Pos : DWord;
    Mem : PStream;
    ImgBmp, MskBmp : PBitmap;
    TmpBmp: PBitmap;
  function ReadIcon : Boolean;
  var IH : TIconHeader;
      IDI, FoundIDI : TIconDirEntry;
      I, SumSz, FoundSz, D : Integer;
      II : TIconInfo;
      BIH : TBitmapInfoheader;
  begin
     Result := False;
     if Strm.Read( IH, Sizeof( IH ) ) <> Sizeof( IH ) then Exit;
     if (IH.idReserved <> 0) or ((IH.idType <> 1) and (IH.idType <> 2)) or
        (IH.idCount < 1) then Exit;
     SumSz := Sizeof( IH );
     FoundSz := 1000;
     for I := 1 to IH.idCount do
     begin
        if Strm.Read( IDI, Sizeof( IDI ) ) <> Sizeof( IDI ) then Exit;
        if (IDI.bWidth <> IDI.bHeight) and
           (IDI.bWidth * 2 <> IDI.bHeight) or
           (IDI.bWidth = 0) {or
           (IDI.bReserved <> 0) or (IDI.wPlanes <> 0) or (IDI.wBitCount <> 0)} then
           Exit;
        Inc( SumSz, IDI.dwBytesInRes + Sizeof( IDI ) );
        D := IDI.bWidth - DesiredSize;
        if D < 0 then D := -D;
        if D < FoundSz then
        begin
           FoundSz := D;
           FoundIDI := IDI;
        end;
     end;
     if FoundSz = 1000 then Exit;
     Strm.Seek( Integer( Pos ) + FoundIDI.dwImageOffset, spBegin );
     fSize := FoundIDI.bWidth;

     if Strm.Read( BIH, Sizeof( BIH ) ) <> Sizeof( BIH ) then Exit;
     if (BIH.biWidth <> fSize) or
        (BIH.biHeight <> fSize * 2) and
        (BIH.biHeight <> fSize) then Exit;
     BIH.biHeight := fSize;

     Mem := NewMemoryStream;
     Mem.Write( BIH, Sizeof( BIH ) );
     if (FoundIDI.bColorCount >= 2) or (FoundIDI.bReserved = 1) or
        (FoundIDI.bColorCount = 0) then
     begin
       I := 0;
       if BIH.biBitCount <= 8 then
          I := (1 shl BIH.biBitCount) * Sizeof( TRGBQuad );
       if I > 0 then
          if Stream2Stream( Mem, Strm, I ) <> DWORD(I) then Exit;
       I := ((BIH.biBitCount * fSize + 31) div 32) * 4 * fSize;
       if Stream2Stream( Mem, Strm, I ) <> DWORD(I) then Exit;
       ImgBmp := NewBitmap( fSize, fSize );
       Mem.Seek( 0, spBegin );
       ImgBmp.LoadFromStream( Mem );
       if ImgBmp.Empty then Exit;
     end;

     BIH.biBitCount := 1;
     Mem.Seek( 0, spBegin );
     Mem.Write( BIH, Sizeof( BIH ) );
     I := 0;
     Mem.Write( I, Sizeof( I ) );
     I := $FFFFFF;
     Mem.Write( I, Sizeof( I ) );
     I := ((fSize + 31) div 32) * 4 * fSize;
     if Stream2Stream( Mem, Strm, I ) <> DWORD(I) then Exit;

     MskBmp := NewBitmap( fSize, fSize );
     Mem.Seek( 0, spBegin );
     MskBmp.LoadFromStream( Mem );
     if MskBmp.Empty then Exit;

     II.fIcon := True;
     II.xHotspot := 0;
     II.yHotspot := 0;
     II.hbmMask := MskBmp.Handle;
     II.hbmColor := 0;
     if ImgBmp <> nil then
     begin
        II.hbmColor := ImgBmp.Handle;
        {TmpBmp := NewBitmap( ImgBmp.Width, ImgBmp.Height );
        TmpBmp.HandleType := bmDIB;
        ImgBmp.Draw( TmpBmp.Canvas.Handle, 0, 0 );
        II.hbmColor := TmpBmp.Handle;}
     end;
     fHandle := CreateIconIndirect( II );
     //fShareIcon := False;
     Strm.Seek( Integer( Pos ) + SumSz, spBegin );
     Result := fHandle <> 0;
  end;
begin
  DesiredSize := fSize;
  if DesiredSize = 0 then
     DesiredSize := GetSystemMetrics( SM_CXICON );
  Clear;
  Pos := Strm.Position;

  Mem := nil;
  ImgBmp := nil;
  MskBmp := nil;
  TmpBmp := nil;

  if not ReadIcon then
  begin
     Clear;
     Strm.Seek( Pos, spBegin );
  end;

  Mem.Free;
  ImgBmp.Free;
  MskBmp.Free;
  TmpBmp.Free;
end;

{$IFDEF ASM_VERSION}
//[procedure TIcon.SaveToFile]
procedure TIcon.SaveToFile(const FileName: String);
asm     //cmd    //opd
        PUSH     EAX
        MOV      EAX, ESP
        MOV      ECX, EDX
        XOR      EDX, EDX
        CALL     SaveIcons2File
        POP      EAX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TIcon.SaveToFile(const FileName: String);
begin
  SaveIcons2File( [ Self ], FileName );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_VERSION}
//[procedure TIcon.SaveToStream]
procedure TIcon.SaveToStream(Strm: PStream);
asm     //cmd    //opd
        PUSH     EAX
        MOV      EAX, ESP
        MOV      ECX, EDX
        XOR      EDX, EDX
        CALL     SaveIcons2Stream
        POP      EAX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TIcon.SaveToStream(Strm: PStream);
begin
  SaveIcons2Stream( [ Self ], Strm );
end;
{$ENDIF ASM_VERSION}

{$IFDEF ASM_noVERSION}
//[procedure TIcon.SetHandle]
procedure TIcon.SetHandle(const Value: HIcon);
const szII = sizeof( TIconInfo );
      szBIH = sizeof(TBitmapInfoHeader);
asm     //cmd    //opd
        CMP      EDX, [EAX].fHandle
        JE       @@exit
        PUSHAD
        PUSH     EDX
        MOV      EBX, EAX
        CALL     Clear
        POP      ECX
        MOV      [EBX].fHandle, ECX
        JECXZ    @@fin
        ADD      ESP, -szBIH
        PUSH     ESP
        PUSH     ECX
        CALL     GetIconInfo
        MOV      ESI, [ESP].TIconInfo.hbmMask
        MOV      EDI, [ESP].TIconInfo.hbmColor
        PUSH     ESP
        PUSH     szBIH
        PUSH     ESI
        CALL     GetObject
        POP      EAX
        POP      [EBX].fSize
        ADD      ESP, szBIH-8
        TEST     ESI, ESI
        JZ       @@1
        PUSH     ESI
        CALL     DeleteObject
@@1:    TEST     EDI, EDI
        JZ       @@fin
        PUSH     EDI
        CALL     DeleteObject
@@fin:  POPAD
@@exit:
end;
{$ELSE ASM_VERSION} //Pascal
procedure TIcon.SetHandle(const Value: HIcon);
var II : TIconInfo;
    B: TagBitmap;
begin
  if FHandle = Value then Exit;
  Clear;
  FHandle := Value;
  if Value <> 0 then
  begin
     GetIconInfo( FHandle, II );
     GetObject( II.hbmMask, Sizeof( B ), @B );
     fSize := B.bmWidth;
     if II.hbmMask <> 0 then
       DeleteObject( II.hbmMask );
     if II.hbmColor <> 0 then
       DeleteObject( II.hbmColor );
  end;
end;
{$ENDIF ASM_VERSION}

//*
//[procedure TIcon.SetSize]
procedure TIcon.SetSize(const Value: Integer);
begin
  if FSize = Value then Exit;
  Clear;
  FSize := Value;
end;

const PossibleColorBits : array[1..7] of Byte = ( 1, 4, 8, 16, 24, 32, 0 );
//[FUNCTION ColorBits]
{$IFDEF ASM_VERSION}
function ColorBits( ColorsCount : Integer ) : Integer;
asm     //cmd    //opd
        PUSH     EBX
        MOV      EDX, offset[PossibleColorBits]
@@loop: MOVZX    ECX, byte ptr [EDX]
        JECXZ    @@e_loop
        INC      EDX
        XOR      EBX, EBX
        INC      EBX
        SHL      EBX, CL
        CMP      EBX, EAX
        JL       @@loop
@@e_loop:
        XCHG     EAX, ECX
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function ColorBits( ColorsCount : Integer ) : Integer;
var I : Integer;
begin
   for I := 1 to 6 do
   begin
      Result := PossibleColorBits[ I ];
      if (1 shl Result) >= ColorsCount then break;
   end;
end;
{$ENDIF ASM_VERSION}
//[END ColorBits]

//[function SaveIcons2StreamEx]
function SaveIcons2StreamEx( const BmpHandles: array of HBitmap; Strm: PStream ): Boolean;
var I, Off : Integer;
   IDI : TIconDirEntry;
   BIH : TBitmapInfoHeader;
   B: TagBitmap;
  function RGBArraySize : Integer;
  begin
     Result := 0;
     if (IDI.bColorCount >= 2) or (IDI.bReserved = 1) then
        Result := (IDI.bColorCount + (IDI.bReserved shl 8)) * Sizeof( TRGBQuad );
  end;
  function ColorDataSize( W, H: Integer ) : Integer;
  var N: Integer;
  begin
     if (IDI.bColorCount >= 2) or (IDI.bReserved = 1) then
       N := (ColorBits( IDI.bColorCount + (IDI.bReserved shl 8) ) )
     else
       N := IDI.wBitCount;
     Result := ((N * W + 31) div 32) * 4
                   * H;
  end;
  function MaskDataSize( W, H: Integer ) : Integer;
  begin
     Result := ((W + 31) div 32) * 4 * H;
  end;
var BColor, BMask: HBitmap;
    W, H: Integer;
    ImgBmp, MskBmp: PBitmap;
    IH : TIconHeader;
    Colors : PList;
begin
  Assert( (High(BmpHandles) >= 0) and (High(BmpHandles) and 1 <> 0),
          'Incorrect parameters count in call to SaveIcons2StreamEx' );
  Result := False;
  IH.idReserved := 0;
  IH.idType := 1;
  IH.idCount := (High( BmpHandles )+1) div 2;
  if Strm.Write( IH, Sizeof( IH ) ) <> Sizeof( IH ) then Exit;
  Off := Sizeof( IH ) + IH.idCount * Sizeof( IDI );
  Colors := NewList;
  ImgBmp := NewBitmap( 0, 0 );
  MskBmp := NewBitmap( 0, 0 );
  TRY

    for I := 0 to High( BmpHandles ) div 2 do
    begin
      BColor := BmpHandles[ I * 2 ];
      BMask  := BmpHandles[ I * 2 + 1 ];
      if (BColor = 0) and (BMask = 0) then break;
      Assert( BMask <> 0, 'Mask bitmap not provided for saving icons in SaveIcons2StreamEx' );
      GetObject( BMask, Sizeof( B ), @ B );
      W := B.bmWidth;
      H := B.bmHeight;
      if BColor <> 0 then
      begin
        GetObject( BColor, Sizeof( B ), @B );
        Assert( (B.bmWidth = W) and (B.bmHeight = H),
                'Mask bitmap size must much color bitmap size in SaveIcons2StreamEx' );
      end;
      FillChar( IDI, Sizeof( IDI ), 0 );

      IDI.bWidth := W;
      IDI.bHeight := H;
      if BColor = 0 then
        IDI.bColorCount := 2
      else
      begin
        ImgBmp.Handle := CopyImage( BColor, IMAGE_BITMAP, W, H,
                         LR_CREATEDIBSECTION );
        FillChar( BIH, Sizeof( BIH ), 0 );
        BIH.biSize := Sizeof( BIH );
        GetObject( ImgBmp.Handle, Sizeof( B ), @B );
        //if ImgBmp.HandleType = bmDDB then
        begin
          if (B.bmPlanes = 1) and (B.bmBitsPixel >= 15) then
          begin
            //ImgBmp.PixelFormat := pf24bit;
            IDI.bColorCount := 0;
            IDI.bReserved := 0;
            IDI.wBitCount := B.bmBitsPixel;
          end
            else
          if B.bmPlanes * (1 shl B.bmBitsPixel) < 16 then
          begin
             ImgBmp.PixelFormat := pf1bit;
             IDI.bColorCount := 2;
          end
             else
          if B.bmPlanes * (1 shl B.bmBitsPixel) < 256 then
          begin
             ImgBmp.PixelFormat := pf4bit;
             IDI.bColorCount := 16;
          end
             else
          begin
             ImgBmp.PixelFormat := pf8bit;
             IDI.bColorCount := 0;
             IDI.bReserved := 1;
          end;
          //GetObject( ImgBmp.Handle, Sizeof( BIH ), @BIH );
        end;
        //IDI.bColorCount := (1 shl BIH.biBitCount) * BIH.biPlanes;
      end;
      Colors.Add( Pointer(IDI.bColorCount + (IDI.bReserved shl 8)) );
      IDI.dwBytesInRes := Sizeof( BIH ) +  RGBArraySize +
                          ColorDataSize( W, H ) + MaskDataSize( W, H );
      IDI.dwImageOffset := Off;
      if Strm.Write( IDI, Sizeof( IDI ) ) <> Sizeof( IDI ) then Exit;
      Inc( Off, IDI.dwBytesInRes );
    end;
    for I := 0 to High( BmpHandles ) div 2 do
    begin
      BColor := BmpHandles[ I * 2 ];
      BMask  := BmpHandles[ I * 2 + 1 ];
      if (BColor = 0) and (BMask = 0) then break;
      GetObject( BMask, Sizeof( B ), @ B );
      W := B.bmWidth;
      H := B.bmHeight;

      FillChar( BIH, Sizeof( BIH ), 0 );
      BIH.biSize := Sizeof( BIH );
      BIH.biWidth := W;
      BIH.biHeight := H;
      if BColor <> 0 then
        BIH.biHeight := W * 2;
      BIH.biPlanes := 1;
      PWord( @ IDI.bColorCount )^ := DWord( Colors.Items[ I ] );
      if IDI.wBitCount = 0 then
        IDI.wBitCount := ColorBits( PWord( @ IDI.bColorCount )^ );
      BIH.biBitCount := IDI.wBitCount;
      BIH.biSizeImage := Sizeof( BIH ) + ColorDataSize( W, H ) + MaskDataSize( W, H );
      if Strm.Write( BIH, Sizeof( BIH ) ) <> Sizeof( BIH ) then Exit;
      if BColor <> 0 then
      begin

        ImgBmp.Handle := CopyImage( BColor, IMAGE_BITMAP, W, H, 0 );
        case BIH.biBitCount of
        1 : ImgBmp.PixelFormat := pf1bit;
        4 : ImgBmp.PixelFormat := pf4bit;
        8 : ImgBmp.PixelFormat := pf8bit;
        16: ImgBmp.PixelFormat := pf16bit;
        24: ImgBmp.PixelFormat := pf24bit;
        32: ImgBmp.PixelFormat := pf32bit;
        end;
      end
        else
      begin
        ImgBmp.Handle := CopyImage( BMask, IMAGE_BITMAP, W, H, 0 );
        ImgBmp.PixelFormat := pf1bit;
      end;
      if ImgBmp.FDIBBits <> nil then
      begin
        if Strm.Write( Pointer(Integer(ImgBmp.FDIBHeader) + Sizeof(TBitmapInfoHeader))^,
           PWord( @ IDI.bColorCount )^ * Sizeof( TRGBQuad ) ) <>
           PWord( @ IDI.bColorCount )^ * Sizeof( TRGBQuad ) then Exit;
        if Strm.Write( ImgBmp.FDIBBits^, ColorDataSize( W, H ) ) <>
           DWord( ColorDataSize( W, H ) ) then Exit;
      end;
    MskBmp.Handle := CopyImage( BMask, IMAGE_BITMAP, W, H, 0 );

    MskBmp.PixelFormat := pf1bit;
    if Strm.Write( MskBmp.FDIBBits^, MaskDataSize( W, H ) ) <>
      DWord( MaskDataSize( W, H ) ) then Exit;
    end;

  FINALLY
    Colors.Free;
    ImgBmp.Free;
    MskBmp.Free;
  END;
  Result := True;
end;

{$IFDEF FPC}
  {$DEFINE _D3orFPC}
{$ENDIF}
{$IFDEF _D2orD3}
  {$DEFINE _D3orFPC}
{$ENDIF}
//[procedure SaveIcons2Stream]
procedure SaveIcons2Stream( const Icons : array of PIcon; Strm : PStream );
var I, J, Pos : Integer;
    {$IFDEF _D3orFPC}
    Bitmaps: array[ 0..63 ] of HBitmap;
    {$ELSE DELPHI}
    Bitmaps: array of HBitmap;
    {$ENDIF FPC/DELPHI}
    II: TIconInfo;
    Bmp: HBitmap;
begin
  for I := 0 to High( Icons ) do
  begin
     if Icons[ I ].Handle = 0 then Exit;
     for J := I + 1 to High( Icons ) do
        if Icons[ I ].Size = Icons[ J ].Size then Exit;
  end;
  Pos := Strm.Position;

  {$IFDEF _D3orFPC}
  for I := 0 to High( Bitmaps ) do
    Bitmaps[ I ] := 0;
  {$ELSE DELPHI}
  SetLength( Bitmaps, Length( Icons ) * 2 );
  {$ENDIF FPC/DELPHI}
  for I := 0 to High( Icons ) do
  begin
    GetIconInfo( Icons[ I ].Handle, II );
    Bitmaps[ I * 2 ] := II.hbmColor;
    Bitmaps[ I * 2 + 1 ] := II.hbmMask;
  end;

  if not SaveIcons2StreamEx( Bitmaps, Strm ) then
     Strm.Seek( Pos, spBegin );

  for I := 0 to High( Bitmaps ) do
  begin
    Bmp := Bitmaps[ I ];
    if Bmp <> 0 then
      DeleteObject( Bmp );
  end;
end;
(*
var I, J, Pos : Integer;
    IH : TIconHeader;
    Colors : PList;
    ImgBmp,
    MskBmp : PBitmap;
   function WriteIcons : Boolean;
   var I, Off : Integer;
       IDI : TIconDirEntry;
       BIH : TBitmapInfoHeader;
       II : TIconInfo;
       B: TagBitmap;
      function RGBArraySize : Integer;
      begin
         Result := 0;
         if (IDI.bColorCount >= 2) or (IDI.bReserved = 1) then
            Result := (IDI.bColorCount + (IDI.bReserved shl 8)) * Sizeof( TRGBQuad );
      end;
      function ColorDataSize : Integer;
      var N: Integer;
      begin
         //Result := 0;
         if (IDI.bColorCount >= 2) or (IDI.bReserved = 1) then
           N := (ColorBits( IDI.bColorCount + (IDI.bReserved shl 8) ) )
         else
           N := IDI.wBitCount;
         Result := ((N * Icons[ I ].Size + 31) div 32) * 4
                       * Icons[ I ].Size;
      end;
      function MaskDataSize : Integer;
      begin
         Result := ((Icons[ I ].Size + 31) div 32) * 4
                   * Icons[ I ].Size;
      end;
   begin
     Result := False;
     if Strm.Write( IH, Sizeof( IH ) ) <> Sizeof( IH ) then Exit;
     Off := Sizeof( IH ) + IH.idCount * Sizeof( IDI );
     for I := Low( Icons ) to High( Icons ) do
     begin
       FillChar( IDI, Sizeof( IDI ), 0 );
       IDI.bWidth := Icons[ I ].Size;
       IDI.bHeight := Icons[ I ].Size;
       GetIconInfo( Icons[ I ].Handle, II );
       if II.hbmColor = 0 then
          IDI.bColorCount := 2
       else
       begin
         {ImgBmp.Handle := CopyImage( II.hbmColor, IMAGE_BITMAP, Icons[ I ].Size,
                          Icons[ I ].Size, LR_CREATEDIBSECTION );}
         ImgBmp.Handle := II.hbmColor;
         II.hbmColor := 0;
         FillChar( BIH, Sizeof( BIH ), 0 );
         BIH.biSize := Sizeof( BIH );
         GetObject( ImgBmp.Handle, Sizeof( B ), @B );
         //if ImgBmp.HandleType = bmDDB then
         begin
            if (B.bmPlanes = 1) and (B.bmBitsPixel >= 15) then
            begin
              //ImgBmp.PixelFormat := pf24bit;
              IDI.bColorCount := 0;
              IDI.bReserved := 0;
              IDI.wBitCount := B.bmBitsPixel;
            end
              else
            if B.bmPlanes * (1 shl B.bmBitsPixel) < 16 then
            begin
               ImgBmp.PixelFormat := pf1bit;
               IDI.bColorCount := 2;
            end
               else
            if B.bmPlanes * (1 shl B.bmBitsPixel) < 256 then
            begin
               ImgBmp.PixelFormat := pf4bit;
               IDI.bColorCount := 16;
            end
               else
            begin
               ImgBmp.PixelFormat := pf8bit;
               IDI.bColorCount := 0;
               IDI.bReserved := 1;
            end;
            //GetObject( ImgBmp.Handle, Sizeof( BIH ), @BIH );
         end;
         //IDI.bColorCount := (1 shl BIH.biBitCount) * BIH.biPlanes;
         //--//DeleteObject( II.hbmColor );
       end;
       if II.hbmMask <> 0 then
         DeleteObject( II.hbmMask );
       Colors.Add( Pointer(IDI.bColorCount + (IDI.bReserved shl 8)) );
       IDI.dwBytesInRes := Sizeof( BIH ) +  RGBArraySize +
                           ColorDataSize + MaskDataSize;
       IDI.dwImageOffset := Off;
       if Strm.Write( IDI, Sizeof( IDI ) ) <> Sizeof( IDI ) then Exit;
       Inc( Off, IDI.dwBytesInRes );
     end;
     for I := Low( Icons ) to High( Icons ) do
     begin
       FillChar( BIH, Sizeof( BIH ), 0 );
       BIH.biSize := Sizeof( BIH );
       BIH.biWidth := Icons[ I ].Size;
       BIH.biHeight := Icons[ I ].Size;
       //GetObject( Icons[ I ].Handle, Sizeof( II ), @II );
       GetIconInfo( Icons[ I ].Handle, II );
       if II.hbmColor <> 0 then
          BIH.biHeight := Icons[ I ].Size * 2;
       BIH.biPlanes := 1;
       PWord( @ IDI.bColorCount )^ := DWord( Colors.Items[ I - Low( Icons ) ] );
       if IDI.wBitCount = 0 then
         IDI.wBitCount := ColorBits( PWord( @ IDI.bColorCount )^ );
       BIH.biBitCount := IDI.wBitCount;
       BIH.biSizeImage := Sizeof( BIH ) + ColorDataSize + MaskDataSize;
       if Strm.Write( BIH, Sizeof( BIH ) ) <> Sizeof( BIH ) then Exit;
       if II.hbmColor <> 0 then
       begin

          ImgBmp.Handle := {CopyImage( II.hbmColor, IMAGE_BITMAP, Icons[ I ].Size,
                          Icons[ I ].Size, 0 );}
                          II.hbmColor;
                          II.hbmColor := 0;
          case BIH.biBitCount of
          1 : ImgBmp.PixelFormat := pf1bit;
          4 : ImgBmp.PixelFormat := pf4bit;
          8 : ImgBmp.PixelFormat := pf8bit;
          16: ImgBmp.PixelFormat := pf16bit;
          24: ImgBmp.PixelFormat := pf24bit;
          32: ImgBmp.PixelFormat := pf32bit;
          end;
       end
          else
       begin
          ImgBmp.Handle := CopyImage( II.hbmMask, IMAGE_BITMAP, Icons[ I ].Size,
                          Icons[ I ].Size, 0 );
          ImgBmp.PixelFormat := pf1bit;
       end;
       if ImgBmp.FDIBBits <> nil then
       begin
          if Strm.Write( Pointer(Integer(ImgBmp.FDIBHeader) + Sizeof(TBitmapInfoHeader))^,
             PWord( @ IDI.bColorCount )^ * Sizeof( TRGBQuad ) ) <>
             PWord( @ IDI.bColorCount )^ * Sizeof( TRGBQuad ) then Exit;
          if Strm.Write( ImgBmp.FDIBBits^, ColorDataSize ) <>
             DWord( ColorDataSize ) then Exit;
       end;
       MskBmp.Handle := CopyImage( II.hbmMask, IMAGE_BITMAP, Icons[ I ].Size,
                          Icons[ I ].Size, 0 {LR_COPYRETURNORG} );
       //***
       if II.hbmMask <> 0 then
         DeleteObject( II.hbmMask );
       if II.hbmColor <> 0 then
         DeleteObject( II.hbmColor );
       //***

       MskBmp.PixelFormat := pf1bit;
       if Strm.Write( MskBmp.FDIBBits^, MaskDataSize ) <>
          DWord( MaskDataSize ) then Exit;
     end;
     Result := True;
   end;
begin
  for I := Low( Icons ) to High( Icons ) do
  begin
     if Icons[ I ].Handle = 0 then Exit;
     for J := I + 1 to High( Icons ) do
        if Icons[ I ].Size = Icons[ J ].Size then Exit;
  end;
  IH.idReserved := 0;
  IH.idType := 1;
  IH.idCount := High( Icons ) - Low( Icons ) + 1;
  Pos := Strm.Position;
  Colors := NewList;
  ImgBmp := NewBitmap( 0, 0 );
  MskBmp := NewBitmap( 0, 0 );

  if not WriteIcons then
     Strm.Seek( Pos, spBegin );

  ImgBmp.Free;
  MskBmp.Free;
  Colors.Free;
end;
*)

//[procedure SaveIcons2File]
procedure SaveIcons2File( const Icons : array of PIcon; const FileName : String );
var Strm: PStream;
begin
  Strm := NewWriteFileStream( FileName );
  SaveIcons2Stream( Icons, Strm );
  Strm.Free;
end;

//[procedure TIcon.LoadFromExecutable]
procedure TIcon.LoadFromExecutable(const FileName: String; IconIdx: Integer);
var I: Integer;
begin
  Clear;
  I := ExtractIcon( hInstance, PChar( FileName ), IconIdx );
  if I > 1 then
    Handle := I;
end;

//[function GetFileIconCount]
function GetFileIconCount( const FileName: String ): Integer;
begin
  Result := ExtractIcon( hInstance, PChar( FileName ), DWORD(-1) );
end;

//[procedure TIcon.LoadFromResourceID]
procedure TIcon.LoadFromResourceID(Inst, ResID, DesiredSize: Integer);
begin
  LoadFromResourceName( Inst, MAKEINTRESOURCE( ResID ), DesiredSize );
end;

//[procedure TIcon.LoadFromResourceName]
procedure TIcon.LoadFromResourceName(Inst: Integer; ResName: PChar; DesiredSize: Integer);
begin
  Handle := LoadImage( Inst, ResName, IMAGE_ICON, DesiredSize, DesiredSize,
                       $8000 {LR_SHARED} );
  {if Handle = 0 then
    Handle := LoadIcon( Inst, ResName )
  else}
  if fHandle <> 0 then FShareIcon := True;
end;

//[function LoadImgIcon]
function LoadImgIcon( RsrcName: PChar; Size: Integer ): HIcon;
begin
  Result := LoadImage( hInstance, RsrcName, IMAGE_ICON, Size, Size, $8000 {LR_SHARED} );
end;


////////////////////////////////////////////////////////////////////////
//
//
//                         M  E T A F I L E
//
//
////////////////////////////////////////////////////////////////////////


//[API SetEnhMetaFileBits]
function SetEnhMetaFileBits; external gdi32 name 'SetEnhMetaFileBits';
function PlayEnhMetaFile; external gdi32 name 'PlayEnhMetaFile';


//[function NewMetafile]
function NewMetafile: PMetafile;
begin
  Result := PMetafile.Create;
end;
//[END NewMetafile]

{ TMetafile }

//[procedure TMetafile.Clear]
procedure TMetafile.Clear;
begin
  if fHandle <> 0 then
    DeleteEnhMetaFile( fHandle );
  fHandle := 0;
end;

//[destructor TMetafile.Destroy]
destructor TMetafile.Destroy;
begin
  if fHeader <> nil then
    FreeMem( fHeader );
  Clear;
  inherited;
end;

//[procedure TMetafile.Draw]
procedure TMetafile.Draw(DC: HDC; X, Y: Integer);
begin
  StretchDraw( DC, MakeRect( X, Y, X + Width, Y + Height ) );
end;

//[function TMetafile.Empty]
function TMetafile.Empty: Boolean;
begin
  Result := fHandle = 0;
end;

//[function TMetafile.GetHeight]
function TMetafile.GetHeight: Integer;
begin
  Result := 0;
  if Empty then Exit;
  RetrieveHeader;
  Result := fHeader.rclBounds.Bottom - fHeader.rclBounds.Top;
end;

//[function TMetafile.GetWidth]
function TMetafile.GetWidth: Integer;
begin
  Result := 0;
  if Empty then Exit;
  RetrieveHeader;
  Result := fHeader.rclBounds.Right - fHeader.rclBounds.Left;
end;

//[function TMetafile.LoadFromFile]
function TMetafile.LoadFromFile(const Filename: String): Boolean;
var Strm: PStream;
begin
  Strm := NewReadFileStream( FileName );
  Result := LoadFromStream( Strm );
  Strm.Free;
end;

//[function ComputeAldusChecksum]
function ComputeAldusChecksum(var WMF: TMetafileHeader): Word;
type
  PWord = ^Word;
var
  pW: PWord;
  pEnd: PWord;
begin
  Result := 0;
  pW := @WMF;
  pEnd := @WMF.CheckSum;
  while Longint(pW) < Longint(pEnd) do
  begin
    Result := Result xor pW^;
    Inc(Longint(pW), SizeOf(Word));
  end;
end;

//[function TMetafile.LoadFromStream]
function TMetafile.LoadFromStream(Strm: PStream): Boolean;
var WMF: TMetaFileHeader;
    WmfHdr: TMetaHeader;
    EnhHdr: TEnhMetaHeader;
    Pos, Pos1: Integer;
    Sz: Integer;
    MemStrm: PStream;
    MFP: TMetafilePict;
begin
  Result := FALSE;
  Pos := Strm.Position;

  if Strm.Read( WMF, Sizeof( WMF ) ) <> Sizeof( WMF ) then
  begin
    Strm.Position := Pos;
    Exit;
  end;

  MemStrm := NewMemoryStream;

  if WMF.Key = WMFKey then
  begin // Windows metafile

    if WMF.CheckSum <> ComputeAldusChecksum( WMF ) then
    begin
      Strm.Position := Pos;
      Exit;
    end;

    Pos1 := Strm.Position;
    if Strm.Read( WmfHdr, Sizeof( WmfHdr ) ) <> Sizeof( WmfHdr ) then
    begin
      Strm.Position := Pos;
      Exit;
    end;

    Strm.Position := Pos1;
    Sz := WMFHdr.mtSize * 2;
    Stream2Stream( MemStrm, Strm, Sz );
    FillChar( MFP, Sizeof( MFP ), 0 );
    MFP.mm := MM_ANISOTROPIC;
    fHandle := SetWinMetafileBits( Sz, MemStrm.Memory, 0, MFP );

  end
    else
  begin // may be enchanced?

    Strm.Position := Pos;
    if Strm.Read( EnhHdr, Sizeof( EnhHdr ) ) < 8 then
    begin
      Strm.Position := Pos;
      Exit;
    end;
    // yes, enchanced
    Strm.Position := Pos;
    Sz := EnhHdr.nBytes;
    Stream2Stream( MemStrm, Strm, Sz );
    fHandle := SetEnhMetaFileBits( Sz, MemStrm.Memory );

  end;

  MemStrm.Free;
  Result := fHandle <> 0;
  if not Result then
    Strm.Position := Pos;

end;

//[procedure TMetafile.RetrieveHeader]
procedure TMetafile.RetrieveHeader;
var SzHdr: Integer;
begin
  if fHeader <> nil then
    FreeMem( fHeader );
  SzHdr := GetEnhMetaFileHeader( fHandle, 0, nil );
  GetMem( fHeader, SzHdr );
  GetEnhMetaFileHeader( fHandle, SzHdr, fHeader );
end;

//[procedure TMetafile.SetHandle]
procedure TMetafile.SetHandle(const Value: THandle);
begin
  Clear;
  fHandle := Value;
end;

//[procedure TMetafile.StretchDraw]
procedure TMetafile.StretchDraw(DC: HDC; const R: TRect);
begin
  if Empty then Exit;
  PlayEnhMetaFile( DC, fHandle, R );
end;












//*
//[procedure AlignChildrenProc]
procedure AlignChildrenProc( Sender: PObj );
type
  TAligns = set of TControlAlign;
var P: PControl;
    CR: TRect;
  procedure DoAlign( Allowed: TAligns );
  var I: Integer;
      C: PControl;
      R, R1: TRect;
      W, H: Integer;
      ChgPos, ChgSiz: Boolean;
  begin
    for I := 0 to P.fChildren.fCount - 1 do
    begin
      C := P.fChildren.fItems[ I ];
      if not C.ToBeVisible then continue;
      // important: not fVisible, and even not Visible, but ToBeVisible!
      if C.fNotUseAlign then continue;
      if C.FAlign in Allowed then
      begin
        R := C.BoundsRect;
        R1 := R;
        W := R.Right - R.Left;
        H := R.Bottom - R.Top;
        case C.FAlign of
        caTop:
          begin
            OffsetRect( R, 0, -R.Top + CR.Top + P.Margin );
            Inc( CR.Top, H + P.Margin );
            R.Left := CR.Left + P.Margin;
            R.Right := CR.Right - P.Margin;
          end;
        caBottom:
          begin
            OffsetRect( R, 0, -R.Bottom + CR.Bottom - P.Margin );
            Dec( CR.Bottom, H + P.Margin );
            R.Left := CR.Left + P.Margin;
            R.Right := CR.Right - P.Margin;
          end;
        caLeft:
          begin
            OffsetRect( R, -R.Left + CR.Left + P.Margin, 0 );
            Inc( CR.Left, W + P.Margin );
            R.Top := CR.Top + P.Margin;
            R.Bottom := CR.Bottom - P.Margin;
          end;
        caRight:
          begin
            OffsetRect( R, -R.Right + CR.Right - P.Margin, 0 );
            Dec( CR.Right, W + P.Margin );
            R.Top := CR.Top + P.Margin;
            R.Bottom := CR.Bottom - P.Margin;
          end;
        caClient:
          begin
            R := CR;
            InflateRect( R, -P.Margin, -P.Margin );
          end;
        end;
        if R.Right < R.Left then R.Right := R.Left;
        if R.Bottom < R.Top then R.Bottom := R.Top;
        ChgPos := (R.Left <> R1.Left) or (R.Top <> R1.Top);
        ChgSiz := (R.Right - R.Left <> W) or (R.Bottom - R.Top <> H);
        if ChgPos or ChgSiz then
        begin
          C.BoundsRect := R;
          if ChgSiz then
            AlignChildrenProc( C );
        end;
      end;
    end;
  end;
begin
  P := Pointer( Sender );
  if P = nil then Exit; // Called for form - ignore.
  CR := P.ClientRect;
  DoAlign( [ caTop, caBottom ] );
  DoAlign( [ caLeft, caRight ] );
  DoAlign( [ caClient ] );
end;

//*
//[procedure TControl.Set_Align]
procedure TControl.Set_Align(const Value: TControlAlign);
begin
  Global_Align := AlignChildrenProc;
  if fNotUseAlign then Exit;
  if FAlign = Value then Exit;
  FAlign := Value;
  //Global_Align( Parent );
  AlignChildrenProc( Parent );
end;

//*
//[function TControl.SetAlign]
function TControl.SetAlign(AAlign: TControlAlign): PControl;
begin
  Set_Align( AAlign );
  Result := Self;
end;

//*
//[function WndProcPreventResizeFlicks]
function WndProcPreventResizeFlicks( Sender: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
type TRectsArray = array[0..2] of TRect;
     PRectsArray = ^TRectsArray;
     TChange = ( ChgL, ChgT, ChgR, ChgB );
     TChanges = Set of TChange;
var Rects : PRectsArray;
    Changes : Set of TChange;
    Resizing : Boolean;
    X, Y, DX, DY : Integer;
    EntireRect, Src, Dst : TRect;

    function GetClientAfter : TRect;
    var R : TRect;
    begin
      R := Rects[ 2 ];
      OffsetRect( R, Rects[ 0 ].Left - Rects[ 1 ].Left,
                  Rects[ 0 ].Top - Rects[ 1 ].Top );
      if Rects[ 0 ].Right - Rects[ 0 ].Left <> Rects[ 1 ].Right - Rects[ 1 ].Left then
         R.Right := R.Left + (R.Right - R.Left)
                           + (Rects[ 0 ].Right - Rects[ 0 ].Left)
                           - (Rects[ 1 ].Right - Rects[ 1 ].Left);
      if Rects[ 0 ].Bottom - Rects[ 0 ].Top <> Rects[ 1 ].Bottom - Rects[ 1 ].Top then
         R.Bottom := R.Top + (R.Bottom - R.Top)
                           + (Rects[ 0 ].Bottom - Rects[ 0 ].Top)
                           - (Rects[ 1 ].Bottom - Rects[ 1 ].Top);
      Result := R;
    end;

    procedure DoResize( F : PControl; Changes : TChanges );
    var ClientAfter : TRect;

        procedure CollectClipRgn( V : PControl; Changes : TChanges );
        var C : PControl;
            I : Integer;
        begin
           for I := 0 to V.FChildren.FCount - 1 do
           begin
               C := V.FChildren.FItems[ I ];
               if not C.Visible then Continue;

               if C.fNotUseAlign then
               begin
                 C.Update;
               end;
           end;
        end; // of CollectClipRgn


    begin // DoResize
         ClientAfter := GetClientAfter;
         //ClipRgn := CreateRectRgn( ClientAfter.Left, ClientAfter.Top,
         //           ClientAfter.Right, ClientAfter.Bottom );
         CollectClipRgn( F, Changes );
         //ScrollWithoutClipRgn;
         //DeleteObject( ClipRgn );
    end; // of DoResize

var PR: PRect;
    R: TRect;
begin // Procedure WndProcResizeFlicks
  Result := False;
  case Msg.message of
  WM_NCCALCSIZE:
    if Msg.wParam <> 0 then
    begin
      Rects := Pointer( Msg.lParam );
      Changes := [];
      if Rects[ 0 ].Left <> Rects[ 1 ].Left then
         Changes := Changes + [ ChgL ];
      if Rects[ 0 ].Top <> Rects[ 1 ].Top then
         Changes := Changes + [ ChgT ];
      if Rects[ 0 ].Right <> Rects[ 1 ].Right then
         Changes := Changes + [ ChgR ];
      if Rects[ 0 ].Bottom <> Rects[ 1 ].Bottom then
         Changes := Changes + [ ChgB ];
      Resizing := Changes * [ ChgL, ChgT ] <> [ ];
      if Resizing and not Sender.fNotUseAlign then
      begin
        EntireRect := GetClientAfter;
        OffsetRect( EntireRect, -EntireRect.Left, -EntireRect.Top );
        if EntireRect.Right - EntireRect.Left < Rects[ 2 ].Right - Rects[ 2 ].Left then
           EntireRect.Right := Rects[ 2 ].Right - Rects[ 2 ].Left;
        if EntireRect.Bottom - EntireRect.Top < Rects[ 2 ].Bottom - Rects[ 2 ].Top then
           EntireRect.Bottom := Rects[ 2 ].Bottom - Rects[ 2 ].Top;
        X := Min( Rects[ 0 ].Left, Rects[ 1 ].Left ) + Rects[ 2 ].Left - Rects[ 1 ].Left;
        Y := Min( Rects[ 0 ].Top, Rects[ 1 ].Top ) + Rects[ 2 ].Top - Rects[ 2 ].Top;
        OffsetRect( EntireRect, X, Y );
        DX := 0; DY := 0;
        if ChgL in Changes then
          DX := Rects[ 0 ].Left - Rects[ 1 ].Left;
        if ChgR in Changes then
          DX := Rects[ 0 ].Right - Rects[ 1 ].Right;
        if ChgT in Changes then
          DY := Rects[ 0 ].Top - Rects[ 1 ].Top;
        if ChgB in Changes then
          DY := Rects[ 0 ].Bottom - Rects[ 1 ].Bottom;
        DoResize( Sender, Changes );
        if (Changes = [ChgL]) {and (Rects[0].Left <> Rects[1].Left)} then
        begin
          Rslt := WVR_VALIDRECTS;
          Src := Rects[ 2 ];
          Dst := GetClientAfter;
          Src.Right := Src.Left - DX;
          Dst.Right := Dst.Left - DX;
          Rects[ 1 ] := Src;
          Rects[ 2 ] := Dst;
        end
          else
        if (Changes = [ChgR]) {and (Rects[0].Right > Rects[1].Right)} then
        begin
          Rslt := WVR_VALIDRECTS;
          Src := Rects[ 2 ];
          Dst := GetClientAfter;
          Src.Left := Src.Right - DX;
          Dst.Left := Dst.Right - DX;
          Rects[ 1 ] := Src;
          Rects[ 2 ] := Dst;
        end
           else
        if (Changes = [ChgT]) {and (Rects[0].Top <> Rects[1].Top)} then
        begin
          Rslt := WVR_VALIDRECTS;
          Src := Rects[ 2 ];
          Dst := GetClientAfter;
          Src.Bottom := Src.Top - DY;
          Dst.Bottom := Dst.Top - DY;
          Rects[ 1 ] := Src;
          Rects[ 2 ] := Dst;
        end
           else
        if Changes = [ChgL,ChgT] then
        begin
          Rslt := WVR_VALIDRECTS;
          Src := Rects[ 2 ];
          Dst := GetClientAfter;
          Src.Left := Src.Right - DX;
          Dst.Left := Dst.Right - DX;
          Src.Bottom := Src.Top - DY;
          Dst.Bottom := Dst.Top - DY;
          Rects[ 1 ] := Src;
          Rects[ 2 ] := Dst;
        end;
        PostMessage( Sender.fHandle, CM_UPDATE, 0, 0 );
      end
         {else
      if Sender.fNotUseAlign then
      begin
      end};
    end;
  CM_UPDATE:
    begin
      if Sender.fNotUpdate then
      begin
        Sender.fNotUpdate := False;
        Sender.Invalidate;
      end;
      Sender.Update;
    end;
  WM_SIZING:
    begin
      if (Msg.wParam = WMSZ_TOPLEFT) or (Msg.wParam = WMSZ_BOTTOMLEFT) or (Msg.wParam = WMSZ_TOPRIGHT) then
      begin
        PR := Pointer( Msg.lParam );
        GetWindowRect( Sender.fHandle, R );
        PostMessage( Sender.fHandle, CM_SIZEPOS, LoWord( PR.Left) or (PR.Top shl 16),
                     LoWord( PR.Right - PR.Left ) or ( (PR.Bottom - PR.Top) shl 16) );
        if Msg.wParam = WMSZ_TOPLEFT then
          if Abs( R.Top - PR.Top ) < Abs( R.Left - PR.Left ) then
            PR.Top := R.Top
          else
            PR.Left := R.Left
        else
        if Msg.wParam = WMSZ_BOTTOMLEFT then
          if Abs( R.Bottom - PR.Bottom ) < Abs( R.Left - PR.Left ) then
            PR.Bottom := R.Bottom
          else
            PR.Left := R.Left
        else // WMSZ_TOPRIGHT
          if Abs( R.Top - PR.Top ) < Abs( R.Right - PR.Right ) then
            PR.Top := R.Top
          else
            PR.Right := R.Right;
        Sender.fNotUpdate := True;
        Rslt := 1;
        Result := TRUE;
      end;
    end;
  CM_SIZEPOS:
    begin
      Sender.fNotUpdate := False;
      SetWindowPos( Sender.fHandle, 0, SmallInt( LoWord( Msg.wParam ) ),
                    SmallInt( HiWord( Msg.wParam ) ), SmallInt( LoWord( Msg.lParam ) ),
                    SmallInt( HiWord( Msg.lParam ) ), SWP_NOZORDER or SWP_NOACTIVATE );
    end;
  WM_PAINT:
    begin
      if Sender.fNotUpdate then
      begin
        Rslt := 0;
        Result := True;
      end;
    end;
  WM_ERASEBKGND:
    begin
      if Sender.fNotUpdate then
      begin
        Rslt := 1;
        Result := True;
      end;
    end;
  end;
end;

//*
//[function TControl.PreventResizeFlicks]
function TControl.PreventResizeFlicks: PControl;
begin
  fWndProcResizeFlicks := WndProcPreventResizeFlicks;
  Result := Self;
end;

//*
//[procedure TControl.Update]
procedure TControl.Update;
var I: Integer;
    C: PControl;
begin
  if fUpdateCount > 0 then
    Exit;
  if fNotUpdate then Exit;
  if fHandle = 0 then Exit;
  UpdateWindow( fHandle );
  for I := 0 to fChildren.fCount - 1 do
  begin
    C := fChildren.fItems[ I ];
    C.Update;
  end;
end;

//[FUNCTION WndProcUpdate]
{$IFDEF ASM_VERSION}
function WndProcUpdate( Sender: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
asm     //cmd    //opd
        PUSH     EBX
        XCHG     EBX, EAX
        MOV      EAX, [EBX].TControl.fUpdateCount
        TEST     EAX, EAX
        JZ       @@exit

        XOR      EAX, EAX
        MOV      EDX, [EDX].TMsg.message
        CMP      DX, WM_PAINT
        JNE      @@chk_erasebkgnd

        MOV      [ECX], EAX
        PUSH     EAX
        PUSH     [EBX].TControl.fHandle
        CALL     ValidateRect
        JMP      @@rslt_1
@@chk_erasebkgnd:
        CMP      DX, WM_ERASEBKGND
        JNE      @@exit
        INC      EAX
        MOV      [ECX], EAX
@@rslt_1:
        MOV      AL, 1
@@exit:
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
function WndProcUpdate( Sender: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
begin
  if Sender.fUpdateCount > 0 then
  begin
    case Msg.message of
    WM_PAINT:
      begin
        ValidateRect( Sender.Handle, nil );
        Rslt := 0;
      end;
    WM_ERASEBKGND: Rslt := 1;
    else begin
           Result := FALSE;
           Exit;
         end;
    end;
    Result := TRUE;
  end
    else Result := FALSE;
end;
{$ENDIF ASM_VERSION}
//[END WndProcUpdate]

//[procedure TControl.BeginUpdate]
procedure TControl.BeginUpdate;
begin
  Inc( fUpdateCount );
  AttachProc( @WndProcUpdate );
end;

//[procedure TControl.EndUpdate]
procedure TControl.EndUpdate;
begin
  Dec( fUpdateCount );
  if fUpdateCount <= 0 then
  begin
    Invalidate;
    //Update;
  end;
end;

//*
//[function TControl.GetSelection]
function TControl.GetSelection: String;
var L: Integer;
begin
  if fCommandActions.aGetSelection <> 0 then
  begin
    L := SelLength;
    SetString( Result, nil, L + 1 );
    Perform( fCommandActions.aGetSelection, 0, Integer( @Result[ 1 ] ) );
  end
     else
  Result := Copy( Text, SelStart + 1, SelLength );
end;

//*
//[procedure TControl.SetSelection]
procedure TControl.SetSelection(const Value: String);
begin
  ReplaceSelection( Value, True );
end;

//*
//[procedure TControl.ReplaceSelection]
procedure TControl.ReplaceSelection(const Value: String; aCanUndo: Boolean);
begin
  if fCommandActions.aReplaceSel <> 0 then
  begin
    Perform( fCommandActions.aReplaceSel, Integer( aCanUndo ), Integer( Pchar( Value ) ) );
  end;
end;

//[procedure TControl.DeleteLines]
procedure TControl.DeleteLines(FromLine, ToLine: Integer);
var I1, I2: Integer;
    SStart, SLength: Integer;
begin
  if FromLine > ToLine then Exit;
  Assert( FromLine >= 0, 'Incorrect line index' );
  I1 := Item2Pos( FromLine );
  I2 := Item2Pos( ToLine+1 );
  SStart := SelStart;
  SLength := SelLength;
  SelStart := I1;
  SelLength := I2 - I1;
  ReplaceSelection( '', TRUE );
  if SStart >= I2 then
  begin
    SStart := SStart - (I2 - I1);
  end
    else
  if SStart >= I1 then
  begin
    SLength := SLength - (I2 - SStart);
    SStart := I1;
  end
    else
  if SStart + SLength >= I2 then
  begin
    SLength := SLength - (I2 - I1);
  end
    else
  if SStart + SLength >= I1 then
  begin
    SLength := I1 - SLength;
  end;
  SelStart := SStart;
  SelLength := Max( 0, SLength );
end;

//*
//[procedure TControl.SetTabOrder]
procedure TControl.SetTabOrder(const Value: Integer);
var CL: PList;
    I : Integer;
    C: PControl;
begin
  if Value = fTabOrder then Exit;
  CL := CollectTabControls( ParentForm );
  for I := 0 to CL.fCount - 1 do
  begin
    C := CL.fItems[ I ];
    if C.fTabOrder >= Value then
      Inc( C.fTabOrder );
  end;
  fTabOrder := Value;
  CL.Free;
end;

//*
//[function TControl.GetFocused]
function TControl.GetFocused: Boolean;
begin
  if fIsControl then
    Result := ParentForm.fCurrentControl = Self
  else
    Result := GetForegroundWindow = fHandle;
end;

//*
//[procedure TControl.SetFocused]
procedure TControl.SetFocused(const Value: Boolean);
begin
  if not Value then Exit;
  if fIsControl then
  begin
    ParentForm.fCurrentControl := Self;
    SetFocus( GetWindowHandle );
  end
    else
  begin
    SetForegroundWindow( GetWindowHandle );
  end;
end;

type
  PCharFormat = ^TCharFormat;






//////////////////////////////////////////////////////////////////////
//
//
//                  R  I  C  H     E  D  I  T
//
//
//////////////////////////////////////////////////////////////////////

{ -- rich edit -- }

//*
//[function TControl.REGetFont]
function TControl.REGetFont: PGraphicTool;
var CF: PCharFormat;
    FS: TFontStyle;
begin
  CF := @fRECharFormatRec;
  FillChar( CF^, 82 {sizeof( TCharFormat2 )}, 0 );
  CF.cbSize := sizeof( RichEdit.TCharFormat ) + fCharFmtDeltaSz;
  if fTmpFont = nil then
    fTmpFont := NewFont;
  Result := fTmpFont;
  Result.OnChange := nil;
  Perform( EM_GETCHARFORMAT, 1, Integer( CF ) );
  Result.FontHeight := CF.yHeight;
  FS := [ ];
  if LongBool(CF.dwEffects and CFE_BOLD) then
    FS := [ fsBold ];
  if LongBool(CF.dwEffects and CFE_ITALIC) then
    FS := FS + [ fsItalic ];
  if LongBool(CF.dwEffects and CFE_STRIKEOUT) then
    FS := FS + [ fsStrikeOut ];
  if LongBool(CF.dwEffects and CFE_UNDERLINE) then
    FS := FS + [ fsUnderline ];
  Result.FontStyle := FS;
  if not LongBool(CF.dwEffects and CFE_AUTOCOLOR) then
    Result.Color := CF.crTextColor;
  Result.FontPitch := TFontPitch( CF.bPitchAndFamily and 3 );
  Result.FontCharset := CF.bCharSet;
  Result.FontName := CF.szFaceName;
  Result.OnChange := RESetFont;
end;

const RichAreas: array[ TRichFmtArea ] of Integer = ( SCF_SELECTION,
      SCF_WORD, 4 {SCF_ALL} );

//*
//[procedure TControl.RESetFontEx]
procedure TControl.RESetFontEx(const Index: Integer);
var CF: PCharFormat;
    FS: TFontStyle;
begin
  CF := @fRECharFormatRec;
  FillChar( CF^, {82} sizeof( TCharFormat2 ), 0 );
  CF.cbSize := 60 { sizeof( TCharFormat ) } + fCharFmtDeltaSz;
  CF.dwMask := CFM_BOLD or CFM_COLOR or CFM_FACE or CFM_ITALIC
            or CFM_SIZE or CFM_STRIKEOUT or CFM_UNDERLINE;
  CF.yHeight := fTmpFont.FontHeight;
  FS := fTmpFont.FontStyle;
  if fsBold in FS then CF.dwEffects := CFE_BOLD;
  if fsItalic in FS then CF.dwEffects := CF.dwEffects or CFE_ITALIC;
  if fsStrikeOut in FS then CF.dwEffects := CF.dwEffects or CFE_STRIKEOUT;
  if fsUnderline in FS then CF.dwEffects := CF.dwEffects or CFE_UNDERLINE;
  CF.crTextColor := Color2RGB(fTmpFont.Color);
  CF.bCharSet := fTmpFont.FontCharset;
  CF.bPitchAndFamily := Ord( fTmpFont.FontPitch );
  StrLCopy( CF.szFaceName, PChar( fTmpFont.FontName ), 31 );
  Perform( EM_SETCHARFORMAT, RichAreas[ fRECharArea ], Integer( CF ) );
end;

//*
//[procedure TControl.RESetFont]
procedure TControl.RESetFont(Value: PGraphicTool);
var H: Integer;
begin
  if Value <> fTmpFont then
    REGetFont;
  H := fTmpFont.fData.Font.Height;
  fTmpFont := fTmpFont.Assign( Value );
  if fTmpFont.fData.Font.Height = 0 then
    fTmpFont.fData.Font.Height := H;
  RESetFontEx( Integer( CFM_BOLD or CFM_COLOR or CFM_FACE or CFM_ITALIC
            or CFM_SIZE or CFM_STRIKEOUT or CFM_UNDERLINE ) );
end;

//*
//[function TControl.REGetFontMask]
function TControl.REGetFontMask( const Index: Integer ): Boolean;
begin
  REGetFont;
  Result := LongBool( fRECharFormatRec.dwMask and Index );
end;

//*
//[function TControl.REGetFontEffects]
function TControl.REGetFontEffects(const Index: Integer): Boolean;
begin
  REGetFont;
  Result := LongBool( fRECharFormatRec.dwEffects and Index );
end;

//*
//[procedure TControl.RESetFontEffect]
procedure TControl.RESetFontEffect(const Index: Integer;
  const Value: Boolean);
var CF: PCharFormat;
begin
  ReGetFont;
  CF := @fRECharFormatRec;
  CF.dwEffects := $FFFFFFFF and Index;
  if not Value then CF.dwEffects := 0;
  CF.dwMask := Index;
  Perform( EM_SETCHARFORMAT, RichAreas[ fRECharArea ], Integer( CF ) );
end;

//*
//[function TControl.REGetFontAttr]
function TControl.REGetFontAttr(const Index: Integer): Integer;
var CF: PDWORD;
    Mask: DWORD;
begin
  REGetFont;
  CF := Pointer( Integer( @fRECharFormatRec ) + (HiWord(Index) and $7E) );
  Mask := $FFFFFFFF;
  if LongBool( HiWord(Index) and $1 ) then
    Mask := $FF;
  Result := CF^ and Mask;
end;

//*
//[procedure TControl.RESetFontAttr]
procedure TControl.RESetFontAttr(const Index, Value: Integer);
{const
  CFE_MASK = CFE_AUTOCOLOR or CFE_BOLD or CFE_ITALIC or CFE_PROTECTED or CFE_STRIKEOUT or
             CFE_UNDERLINE or CFE_LINK or CFE_SUBSCRIPT or CFE_SUPERSCRIPT or}
var CF: PDWORD;
    Mask: DWORD;
begin
  REGetFont;
  CF := Pointer( Integer( @fRECharFormatRec ) + (HiWord(Index) and $7E) );
  Mask := 0;
  if LongBool( HiWord(Index) and $1 ) then
    Mask := $FFFFFF00;
  CF^ := CF^ and Mask or DWORD(Value);
  fRECharFormatRec.dwMask := Index and $FF81FFFF;
  if LongBool( fRECharFormatRec.dwMask and (CFM_COLOR or CFM_BACKCOLOR) ) then
    fRECharFormatRec.dwEffects := fRECharFormatRec.dwEffects and
                               not (CFE_AUTOCOLOR or CFE_AUTOBACKCOLOR);
  {fRECharFormatRec.dwEffects := fRECharFormatRec.dwEffects and CFE_MASK;}
  Perform( EM_SETCHARFORMAT, RichAreas[ fRECharArea ], Integer( @fRECharFormatRec ) );
end;

//[procedure TControl.RESetFontAttr1]
procedure TControl.RESetFontAttr1(const Index, Value: Integer);
begin
  RESetFontAttr( Index, Color2RGB( Value ) );
end;

//*
//[function TControl.REGetFontSizeValid]
function TControl.REGetFontSizeValid: Boolean;
begin
  Result := REGetFontMask( Integer( CFM_SIZE ) );
end;

//*
//[function TControl.REGetFontName]
function TControl.REGetFontName: String;
begin
  ReGetFont;
  Result := fRECharFormatRec.szFaceName;
end;

//*
//[procedure TControl.RESetFontName]
procedure TControl.RESetFontName(const Value: String);
begin
  ReGetFont;
  StrLCopy( fRECharFormatRec.szFaceName, PChar( Value ), Sizeof( fRECharFormatRec.szFaceName ) - 1 );
  fRECharFormatRec.dwMask := CFM_FACE;
  Perform( EM_SETCHARFORMAT, RichAreas[ fRECharArea ], Integer( @fRECharFormatRec ) );
end;

//*
//[procedure TControl.SelectAll]
procedure TControl.SelectAll;
begin
  SelStart := 0;
  SelLength := -1; // this can be not working for some controls... //*//*
end;

//*
//[function TControl.REGetCharformat]
function TControl.REGetCharformat: TCharFormat;
begin
  REGetFont;
  Result := fRECharFormatRec;
end;

//*
//[procedure TControl.RESetCharFormat]
procedure TControl.RESetCharFormat(const Value: TCharFormat);
begin
  Perform( EM_SETCHARFORMAT, RichAreas[ fRECharArea ], Integer( @Value ) );
end;

//*
//[function REOut2Stream]
function REOut2Stream( Sender: PControl; Buf: PByte; Sz: DWORD; pSz: PInteger )
  :DWORD; stdcall;
begin
  if Sz + Sender.fREStream.Position > Sender.fREStream.Size then
    Sender.fREStream.Size := Sender.fREStream.Size + DWORD( {Min(} Sz {, 8192 )} );
  pSz^ := Sender.fREStream.Write( Buf^, Sz );
  if Assigned( Sender.fOnProgress ) then
    Sender.fOnProgress( Sender );
  Result := 0;
end;

const TextTypes: array[ TRETextFormat ] of WORD = ( SF_RTF, SF_TEXT,
      SF_RTF or SFF_PLAINRTF, SF_RTFNOOBJS, SF_RTFNOOBJS or SFF_PLAINRTF,
      SF_TEXTIZED );

//*
//[function TControl.RE_SaveToStream]
function TControl.RE_SaveToStream(Stream: PStream; Format: TRETextFormat;
  SelectionOnly: Boolean): Boolean;
var ES: TEditStream;
    SelFlag: Integer;
begin
  fREStream := Stream;
  ES.dwCookie := Integer( Self );
  ES.dwError := 0;
  ES.pfnCallback := @REOut2Stream;
  SelFlag := 0;
  if SelectionOnly then
    SelFlag := SFF_SELECTION;
  Perform( EM_STREAMOUT, TextTypes[ Format ] or SelFlag, Integer( @ES ) );
  fREStream := nil;
  fREError := ES.dwError;
  Result := fREError = 0;
end;

//[procedure RE_AddText]
procedure RE_AddText( Self_: PControl; const S: String );
begin
  Self_.SelStart := Self_.TextSize;
  Self_.RE_Text[ reText, True ] := S;
end;

//*
//[function TControl.REReadText]
function TControl.REReadText(Format: TRETextFormat;
  SelectionOnly: Boolean): String;
var B0: Integer;
    MS: PStream;
begin
  fCommandActions.aAddText := RE_AddText;
  MS := NewMemoryStream;
  RE_SaveToStream( MS, Format, SelectionOnly );
  B0 := 0;
  MS.Write( B0, 1 );
  Result := PChar( MS.fMemory );
  MS.Free;
end;

//*
//[function REInFromStream]
function REInFromStream( Sender: PControl; Buf: PByte; Sz: DWORD; pSz: PInteger )
  :DWORD; stdcall;
begin
  {$IFDEF _D3} if Sender.fREStrLoadLen >= 0 then {$ENDIF}
  if Sz > Sender.fREStrLoadLen then
    Sz := Sender.fREStrLoadLen;
  pSz^ := Sender.fREStream.Read( Buf^, Sz );
  Dec( Sender.fREStrLoadLen, pSz^ );
  if Assigned( Sender.fOnProgress ) then
    Sender.fOnProgress( Sender );
  Result := 0;
end;

//*
//[function TControl.RE_LoadFromStream]
function TControl.RE_LoadFromStream(Stream: PStream; Length: Integer;
  Format: TRETextFormat; SelectionOnly: Boolean): Boolean;
var ES: TEditStream;
    SelFlag: Integer;
begin
  fREStream := Stream;
  fREStrLoadLen := DWORD( Length );
  ES.dwCookie := Integer( Self );
  ES.dwError := 0;
  ES.pfnCallback := @REInFromStream;
  SelFlag := 0;
  if SelectionOnly then
    SelFlag := SFF_SELECTION;
  Perform( EM_STREAMIN, TextTypes[ Format ] or SelFlag, Integer( @ES ) );
  fREStream := nil;
  fREError := ES.dwError;
  Result := fREError = 0;
end;

//*
//[procedure TControl.REWriteText]
procedure TControl.REWriteText(Format: TRETextFormat;
  SelectionOnly: Boolean; const Value: String);
var MS: PStream;
begin
  fCommandActions.aAddText := RE_AddText;
  MS := NewMemoryStream;
  MS.fMemory := PChar( Value );
  MS.fData.fSize := Length( Value );
  MS.fData.fCapacity := MS.fData.fSize;
  RE_LoadFromStream( MS, MS.fData.fSize, Format, SelectionOnly );
  MS.fMemory := nil;
  MS.Free;
end;

//*
//[function TControl.RE_LoadFromFile]
function TControl.RE_LoadFromFile(const Filename: String;
  Format: TRETextFormat; SelectionOnly: Boolean): Boolean;
var Strm: PStream;
begin
  Strm := NewReadFileStream( Filename );
  Result := RE_LoadFromStream( Strm, -1, Format, SelectionOnly );
  Strm.Free;
end;

//*
//[function TControl.RE_SaveToFile]
function TControl.RE_SaveToFile(const Filename: String;
  Format: TRETextFormat; SelectionOnly: Boolean): Boolean;
var Strm: PStream;
begin
  Strm := NewWriteFileStream( Filename );
  Result := RE_SaveToStream( Strm, Format, SelectionOnly );
  Strm.Free;
end;

//*
//[function TControl.REGetParaFmt]
function TControl.REGetParaFmt: TParaFormat;
begin
  FillChar( Result, sizeof( TParaFormat2 ), 0 );
  Result.cbSize := sizeof( RichEdit.TParaFormat ) + fParaFmtDeltaSz;
  Perform( EM_GETPARAFORMAT, 0, Integer( @Result ) );
end;

//*
//[procedure TControl.RESetParaFmt]
procedure TControl.RESetParaFmt(const Value: TParaFormat);
begin
  //Value.cbSize := szTParaFmtRec;
  Perform( EM_SETPARAFORMAT, 0, Integer( @Value ) );
end;

//*
//[function TControl.REGetNumbering]
function TControl.REGetNumbering: Boolean;
begin
  Result := LongBool( ReGetParaAttr( 9 shl 16 ) );
end;

//*
//[function TControl.REGetParaAttr]
function TControl.REGetParaAttr( const Index: Integer ): Integer;
var pDw : PDWORD;
begin
  fREParaFmtRec := REGetParaFmt;
  pDw := Pointer( Integer( @fREParaFmtRec ) + ( HiWord( Index ) and $7E ) );
  Result := pDw^;
  if LongBool( HiWord( Index ) and 1 ) then
    Result := Result and $FFFF;
end;

//*
//[function TControl.REGetParaAttrValid]
function TControl.REGetParaAttrValid( const Index: Integer ): Boolean;
begin
  Result := LongBool( ReGetParaAttr( 4 shl 16 ) and Index );
end;

//*
//[function TControl.REGetTabCount]
function TControl.REGetTabCount: Integer;
begin
  Result := ReGetParaAttr( 27 shl 16 );
end;

//*
//[function TControl.REGetTabs]
function TControl.REGetTabs(Idx: Integer): Integer;
begin
  Result := ReGetParaAttr( (28 + 4 * Idx) shl 16 );
end;

//*
//[function TControl.REGetTextAlign]
function TControl.REGetTextAlign: TRichTextAlign;
begin
  Result := TRichTextAlign( ReGetParaAttr( 25 shl 16 ) - 1 );
end;

//*
//[procedure TControl.RESetNumbering]
procedure TControl.RESetNumbering(const Value: Boolean);
begin
  RESetParaAttr( (9 shl 16) or PFM_NUMBERING, Integer( Value ) );
end;

//*
//[procedure TControl.RESetParaAttr]
procedure TControl.RESetParaAttr(const Index, Value: Integer);
var pDw: PDWORD;
    Mask: Integer;
begin
  REGetParaAttr( 0 );
  pDw := Pointer( Integer( @fREParaFmtRec ) + ( HiWord( Index ) and $7E ) );
  Mask := 0;
  if LongBool( HiWord( Index ) and 1 ) then
    Mask := Integer( $FFFF0000 );
  pDw^ := pDw^ and Mask or DWORD(Value);
  //////////////////////////////////////////////////////////////////////////////
    fREParaFmtRec.dwMask := Index and $8000FFFF;
  //////////////////////////////////////////////////////////////////////////////
  //fREParaFmtRec.dwMask := DWORD( Index ) or $8000FFFF;                      //
  //////////////////////////////////////////////////////////////////////////////
  RESetParaFmt( fREParaFmtRec );
end;

//*
//[procedure TControl.RESetTabCount]
procedure TControl.RESetTabCount(const Value: Integer);
begin
  REGetParaAttr( 0 );
  RESetParaAttr( (27 shl 16) or PFM_TABSTOPS, Value );
end;

//*
//[procedure TControl.RESetTabs]
procedure TControl.RESetTabs(Idx: Integer; const Value: Integer);
begin
  REGetParaAttr( 0 );
  RESetParaAttr( (28 + 4 * Idx) or PFM_TABSTOPS, Value );
end;

//*
//[procedure TControl.RESetTextAlign]
procedure TControl.RESetTextAlign(const Value: TRichTextAlign);
begin
  RESetParaAttr( (25 shl 16) or PFM_ALIGNMENT, Ord( Value ) + 1 );
end;

//*
//[function TControl.REGetStartIndentValid]
function TControl.REGetStartIndentValid: Boolean;
begin
  Result := REGetParaAttrValid( Integer( PFM_STARTINDENT ) );
end;

//*
//[procedure TControl.RE_HideSelection]
procedure TControl.RE_HideSelection(aHide: Boolean);
begin
  Perform( EM_HIDESELECTION, Integer( aHide ), 1 );
end;

//*
//[function TControl.RE_SearchText]
function TControl.RE_SearchText(const Value: String; MatchCase,
  WholeWord, ScanForward: Boolean; SearchFrom, SearchTo: Integer): Integer;
var Flags: Integer;
    FT: TFindText;
begin
  Flags := Integer( ScanForward );
  if WholeWord then Flags := Flags or FT_WHOLEWORD;
  if MatchCase then Flags := Flags or FT_MATCHCASE;
  FT.chrg.cpMin := SearchFrom;
  FT.chrg.cpMax := SearchTo;
  FT.lpstrText := PChar( Value );
  Result := Perform( EM_FINDTEXT, Flags, Integer( @FT ) );
end;

//*
//[function TControl.CanUndo]
function TControl.CanUndo: Boolean;
begin
  Result := LongBool( Perform( EM_CANUNDO, 0, 0 ) );
end;

//*
//[procedure TControl.EmptyUndoBuffer]
procedure TControl.EmptyUndoBuffer;
begin
  Perform( EM_EMPTYUNDOBUFFER, 0, 0 );
end;

//*
//[function TControl.Undo]
function TControl.Undo: Boolean;
begin
  Result := LongBool( Perform( EM_UNDO, 0, 0 ) );
end;

//*
//[function TControl.RE_Redo]
function TControl.RE_Redo: Boolean;
begin
  Result := LongBool( Perform( EM_REDO, 0, 0 ) );
end;

//*
//[function TControl.REGetAutoURLDetect]
function TControl.REGetAutoURLDetect: Boolean;
begin
  Result := LongBool( Perform( EM_GETAUTOURLDETECT, 0, 0 ) );
end;

//*
//[procedure TControl.RESetAutoURLDetect]
procedure TControl.RESetAutoURLDetect(const Value: Boolean);
begin
  AttachProc( WndProc_RE_LinkNotify );
  Perform( EM_AUTOURLDETECT, Integer( Value ), 0 );
end;

//*
//[function TControl.GetMaxTextSize]
function TControl.GetMaxTextSize: DWORD;
begin
  Result := Perform( EM_GETLIMITTEXT, 0, 0 );
end;

//*
//[procedure TControl.SetMaxTextSize]
procedure TControl.SetMaxTextSize(const Value: DWORD);
var V1, V2: Integer;
begin
  if fCommandActions.aSetLimit <> 0 then
  begin
    V1 := 0; V2 := Value;
    if fCommandActions.aSetLimit = EM_SETLIMITTEXT then
    begin
      V1 := Value; V2 := 0;
    end;
    Perform( fCommandActions.aSetLimit, V1, V2 );
  end;
end;

//*
//[function WndProc_REFmt]
function WndProc_REFmt( _Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var Mask: Integer;
    Shft, Flg: Boolean;
    Delta: Integer;
    TA: TRichTextAlign;
    ChgTA: Boolean;
    US: TRichUnderline;
    NS: TRichNumbering;
    NB: TRichNumBrackets;
    Side: TBorderEdge;
    Param: DWORD;
begin
  Result := False;
  if Msg.message = WM_CHAR then
  if _Self_.FSupressTab then
  begin
    _Self_.FSupressTab := FALSE;
    if Msg.wParam = 9 then
    begin
      Result := TRUE;
      Exit;
    end;
  end;

  if Msg.message = WM_KEYDOWN then
  if GetKeyState( VK_CONTROL ) < 0 then
  begin
    Shft := GetKeyState( VK_SHIFT ) < 0;
    Rslt := 0;
    Result := True;
    Mask := 0;
    ChgTA := False; TA := raLeft;
    Param := Msg.wParam;
    //Msg.wParam := 0;
    case Param of
    Integer('Z'):
      begin
        if Shft then
        begin
          _Self_.RE_Redo;
          Exit;
        end;
        Result := False;
      end;

    Integer('L'): begin ChgTA := True; TA := raLeft; end;
    Integer('R'): begin ChgTA := True; TA := raRight; end;
    Integer('E'): begin ChgTA := True; TA := raCenter; end;
    Integer('J'): begin ChgTA := True; TA := raJustify; end;
    Integer('N'): begin
                    if Shft then
                    begin
                      NS := _Self_.RE_NumStyle;
                      NB := _Self_.RE_NumBrackets;
                      if NS = rnBullets then
                      begin
                        _Self_.RE_NumStyle := rnNone;
                        Exit;
                      end;
                      if NS = rnNone then
                      begin
                        _Self_.RE_NumStyle := rnBullets;
                        //NB := rnbPlain;
                        Exit;
                      end
                         else
                      if Ord( NB ) = 0  then
                        NB := High(NB)  else
                        NB := Pred(NB);
                      _Self_.RE_NumBrackets := NB;
                    end
                       else
                    begin
                      NS := _Self_.RE_NumStyle;
                      if Ord( NS ) = 0 then
                      begin
                        NS := rnURoman; //rnULetter; //High( NS );
                        { because rnLRoman, rnURoman, rnNoNumber are not shown
                          in RichEdit. }
                        _Self_.RE_NumBrackets := rnbPeriod;
                      end              else
                        NS := Pred(NS);
                      _Self_.RE_NumStyle := NS;
                      if NS in [ rnLRoman, rnURoman, rnArabic ] then
                        _Self_.RE_NumStart := 1;
                    end;
                    Exit;
                  end;
    Integer('W'): begin
                    Delta := _Self_.RE_BorderWidth[ beLeft ] + 4;
                    if Shft then Delta := -1;
                    for Side := Low(Side) to High(Side) do
                    begin
                      if Delta < 0 then
                        _Self_.RE_BorderStyle[ Side ] := _Self_.RE_BorderStyle[ Side ] + 1
                      else
                      begin
                        _Self_.RE_BorderWidth[ Side ] := Delta;
                        _Self_.RE_BorderSpace[ Side ] := Delta;
                      end;
                    end;
                    Exit;
                  end;
    (* TABLES STUFF -- to try, uncomment it and press CTRL+T in RichEdit.
       (and uncomment declaration for Tmp above).

       Not finished, and seems no way to figure it out - even RichEdit20.dll
       (i.e. Rich Edit v3.0) can not display tables properly formatted. :(((

    Integer('T'): begin
                    if _Self_.RE_Table then
                    begin
                      //MsgOK( 'table' );
                    end;
                    Tmp := _Self_.REReadText( reRTF, True );
                    if StrIsStartingFrom( PChar(Tmp), '{\rtf' )
                    and (CopyTail( Tmp, 3 ) = '}'#$D#$A) then
                    begin
                      //Tmp := Copy( Tmp, 1, Length(Tmp) - 3 );
                      _Self_.RE_Text[ reRTF, True ] :=  '{\rtf1' + //Copy( Tmp, 1, 6 ) +
    '\trowd' +
    //'\lytcalctblwd' +
    //'\oldlinewrap' +
    //'\alntblind' +
    //'\trgaph108' +
    '\trleft-108' +
    {'\trbrdrt\brdrs\brdrw10' +
    '\trbrdrl\brdrs\brdrw10' +
    '\trbrdrb\brdrs\brdrw10' +
    '\trbrdrr\brdrs\brdrw10' +
    '\trbrdrh\brdrs\brdrw10' +
    '\trbrdrv\brdrs\brdrw10' +}
    //'\clvertalt' +
    {'\clbrdrt\brdrs\brdrw10' +
    '\clbrdrl\brdrs\brdrw10' +
    '\clbrdrb\brdrs\brdrw10' +
    '\clbrdrr\brdrs\brdrw10' +}
    //'\cltxlrtb' +
    '\cellx1414' +
    //'\pard' +
    //'\plain' +
    //'\widctlpar' +
    '\trautofit1' +
    '\intbl' +
    //'\adjustright' +
    //'\fs20\lang1049' +
    //'\cgrid' +
    '\trrh0' +
    '{\clFitText{{\box\brdrs\brdrw20\brsp20}'+
    '\par}\cell\row}' +
    //'\pard\widctlpar' +
    //'\intbl'+
    //'\adjustright'+
    //'{\row}' +
    '\pard\widctlpar' +
                             '}'#$D#$A;
                      _Self_.Perform( WM_KEYDOWN, VK_UP, 0 );
                      _Self_.Perform( WM_KEYUP, VK_UP, 0 );
                    end;
                    Exit;
                  end;
    *)
    Integer('B'): Mask := CFM_BOLD;
    Integer('I'):
      begin
        Mask := CFM_ITALIC;
        _Self_.FSupressTab := TRUE;
      end;
    Integer('U'):
      begin
        if Shft then
        begin
          US := _Self_.RE_FmtUnderlineStyle;
          if Ord(US) = 0 then US := High(TRichUnderLine)
          else US := Pred( US );
          _Self_.RE_FmtUnderlineStyle := US;
          Exit;
        end;
        Mask := CFM_UNDERLINE;
      end;
    Integer('O'): Mask := CFM_STRIKEOUT;
    VK_SUBTRACT, VK_ADD: Mask := Integer( CFM_SIZE );
    else
      begin
        Result := False;
        Msg.wParam := Param;
      end;
    end;
    if not Result then Exit;

    if ChgTA then
      begin
        if Shft then Result := False
        else _Self_.RE_TextAlign := TA;
        Exit;
      end;

    _Self_.REGetFont;
    if Mask > 0 then
    begin
      if Shft then Result := False
      else begin
             Flg := _Self_.REGetFontEffects( Mask );
             if not Flg then
               _Self_.fRECharFormatRec.dwEffects := _Self_.fRECharFormatRec.dwEffects and not Mask;
             _Self_.fRECharFormatRec.dwEffects := _Self_.fRECharFormatRec.dwEffects xor DWORD(Mask);
           end;
    end
       else
    begin
      if Msg.wParam = VK_SUBTRACT then
        Delta := -1
      else
        Delta := 1;
      if Shft then
        Mask := CFM_OFFSET;
      if Shft then
        Inc( _Self_.fRECharFormatRec.yOffset, Delta * _Self_.fRECharFormatRec.yHeight div 3 )
      else
        Inc( _Self_.fRECharFormatRec.yHeight, Delta * _Self_.fRECharFormatRec.yHeight div 8 );
      Flg := LongBool( _Self_.fRECharFormatRec.dwMask and Mask );
      if not Flg then
        _Self_.fRECharFormatRec.yOffset := 0;
    end;
    _Self_.fRECharFormatRec.dwMask := Mask;
    _Self_.Perform( EM_SETCHARFORMAT, SCF_SELECTION { RichAreas[ _Self_.fRECharArea ] }, Integer( @_Self_.fRECharFormatRec ) );
  end;
end;

//*
//[function TControl.RE_FmtStandard]
function TControl.RE_FmtStandard: PControl;
begin
  AttachProc( WndProc_REFmt );
  Result := Self;
end;

//[FUNCTION EnumDynHandlers]
{$IFDEF ASM_VERSION}
function EnumDynHandlers( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
asm     //cmd    //opd
        CMP      [EAX].TControl.fRefCount, 0
        JL       @@fin_false
        PUSHAD
        MOV      EBX, EAX
        MOV      EBP, ECX
        MOV      ECX, [EBX].TControl.fDynHandlers
        JECXZ    @@ret_false
        MOV      ESI, ECX
        MOV      ECX, [ESI].TList.fCount
        JECXZ    @@ret_false
        MOV      EDI, ECX
        SHR      EDI, 1
        CALL     TControl.RefInc
@@loo:  DEC      EDI
        JS       @@e_loo
        PUSH     EDX
        PUSH     EBX
{$IFNDEF ENUM_DYN_HANDLERS_AFTER_RUN}
        XOR      EAX, EAX
        CMP      [AppletTerminated], AL
        JZ       @@do_call
        MOV      ECX, [ESI].TList.fItems
        MOV      ECX, [ECX+EDI*8+4]
        JECXZ    @@skip_call
{$ENDIF}
@@do_call:
        MOV      EAX, [ESI].TList.fItems
        MOV      EAX, [EAX+EDI*8]
        XCHG     EAX, EBX
        MOV      ECX, EBP
        CALL     EBX
@@skip_call:
        POP      EBX
        POP      EDX
        TEST     AL, AL
        JZ       @@loo
@@ret_true:
        MOV      EAX, EBX
        CALL     TControl.RefDec
        POPAD
        MOV      AL, 1
        RET
@@e_loo:
        XOR      EAX, EAX
        INC      EAX
        CMP      [EBX].TControl.fRefCount, EAX
        JE       @@ret_true
        MOV      EAX, EBX
        CALL     TControl.RefDec
@@ret_false:
        POPAD
@@fin_false:
        XOR      EAX, EAX
end;
{$ELSE ASM_VERSION} //Pascal
function EnumDynHandlers( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var I: Integer;
    Proc: TWindowFunc;
begin
  Result := False;
  if Self_.fRefCount < 0 then Exit;
  if (Self_.fDynHandlers = nil) or (Self_.fDynHandlers.fCount = 0) then Exit;
  Self_.RefInc; // Prevent destroying Self_
  for I := Self_.fDynHandlers.fCount div 2 - 1 downto 0 do
  begin
    Proc := Self_.fDynHandlers.fItems[ I * 2 ];
{$IFNDEF ENUM_DYN_HANDLERS_AFTER_RUN}
    if not AppletTerminated or (Self_.fDynHandlers.fItems[ I * 2 + 1 ] <> nil) then
{$ENDIF}
    if Proc( Self_, Msg, Rslt ) then
    begin
      Result := True;
      break;
    end;
  end;
  {$IFDEF DEBUG_ENDSESSION}
  if EndSession_Initiated then
  begin
    LogFileOutput( GetStartDir + 'es_debug.txt',
                   'ENUM_DYN_HANDLERS: Self_:' + Int2Hex( DWORD( Self_ ), 8 ) );
    LogFileOutput( GetStartDir + 'es_debug.txt',
                   'ENUM_DYN_HANDLERS: Self_.fRefCount:' + Int2Str( Self_.fRefCount ) );
  end;
  {$ENDIF}
  if LongBool(Self_.fRefCount and 1) then
    Result := True; // If Self_ will be destroyed now, stop further processing
  Self_.RefDec; // Destroy Self_, if Free was called for it while processing attached procedures
end;
{$ENDIF ASM_VERSION}
//[END EnumDynHandlers]

{$IFDEF ASM_VERSION}
//[procedure TControl.AttachProcEx]
procedure TControl.AttachProcEx( Proc: TWindowFunc; ExecuteAfterAppletTerminated: Boolean );
asm     //cmd    //opd
        PUSH     EBX
        PUSH     EDI
        PUSH     ECX
        XCHG     EBX, EAX
        MOV      EDI, EDX
        MOV      [EBX].fOnDynHandlers, offset[EnumDynHandlers]
        MOV      ECX, [EBX].TControl.fDynHandlers
        INC      ECX
        LOOP     @@1
        CALL     NewList
        XCHG     ECX, EAX
        MOV      [EBX].TControl.fDynHandlers, ECX
@@1:
        PUSH     ECX
        MOV      EAX, EBX
        MOV      EDX, EDI
        CALL     TControl.IsProcAttached
        TEST     AL, AL
        POP      EBX
        JNZ      @@exit
        MOV      EAX, EBX
        MOV      EDX, EDI
        CALL     TList.Add
        XCHG     EAX, EBX
        POP      EDX
        PUSH     EDX
        CALL     TList.Add
@@exit:
        POP      ECX
        POP      EDI
        POP      EBX
end;
{$ELSE ASM_VERSION} //Pascal
procedure TControl.AttachProcEx( Proc: TWindowFunc; ExecuteAfterAppletTerminated: Boolean );
begin
  if fDynHandlers = nil then
    fDynHandlers := NewList;
  if not IsProcAttached( Proc ) then
  begin
    fDynHandlers.Add( @Proc );
    fDynHandlers.Add( Pointer( Integer( ExecuteAfterAppletTerminated ) ) );
  end;
  fOnDynHandlers := EnumDynHandlers;
end;
{$ENDIF ASM_VERSION}

//[procedure TControl.AttachProc]
procedure TControl.AttachProc(Proc: TWindowFunc);
begin
  AttachProcEx( Proc, FALSE );
end;

//*
//[procedure TControl.DetachProc]
procedure TControl.DetachProc(Proc: TWindowFunc);
var I: Integer;
begin
  if fDynHandlers = nil then Exit;
  I := fDynHandlers.IndexOf( @Proc );
  if I >=0 then
  begin
    fDynHandlers.Delete( I );
    fDynHandlers.Delete( I );
  end;
end;

{$IFDEF ASM_VERSION}
//[function TControl.IsProcAttached]
function TControl.IsProcAttached(Proc: TWindowFunc): Boolean;
asm     //cmd    //opd
        MOV      ECX, [EAX].TControl.fDynHandlers
        JECXZ    @@exit
        XCHG     EAX, ECX
        CALL     TList.IndexOf
        TEST     EAX, EAX
        SETGE    CL
@@exit: XCHG     EAX, ECX
end;
{$ELSE ASM_VERSION} //Pascal
function TControl.IsProcAttached(Proc: TWindowFunc): Boolean;
var I: Integer;
begin
  Result := False;
  if fDynHandlers = nil then Exit;
  I := fDynHandlers.IndexOf( @Proc );
  Result := I >=0;
end;
{$ENDIF ASM_VERSION}

//[function WndProcAutoPopupMenu]
function WndProcAutoPopupMenu( Control: PControl; var Msg: TMsg; var MsgRslt: Integer ): Boolean;
begin
  if (Msg.message = WM_CONTEXTMENU) and
     (Control.fAutoPopupMenu <> nil) then
  begin
    {$IFDEF USE_MENU_CURCTL}
    PMenu( Control.fAutoPopupMenu ).fCurCtl := Control;
    {$ENDIF USE_MENU_CURCTL}
    PMenu( Control.fAutoPopupMenu ).Popup( SmallInt( LoWord( Msg.lParam ) ),
           SmallInt( HiWord( Msg.lParam ) ) );
    Result := TRUE;
  end
    else
  Result := FALSE;
end;

//[procedure TControl.SetAutoPopupMenu]
procedure TControl.SetAutoPopupMenu(PopupMenu: PObj);
{ new version - by Alexander Pravdin. Allows to attach a submenu (e.g. of the
  main menu) as a popup menu to a control, to avoid duplicating menu object,
  if it is the same already as desired. }
var pm: PMenu;
begin
  if PopupMenu <> nil then begin
      pm := PMenu( PopupMenu );
      while pm.FControl = nil do pm := pm.Parent;
      PMenu( PopupMenu ).FControl := pm.FControl;
  end;
  fAutoPopupMenu := PopupMenu;
  AttachProc( WndProcAutoPopupMenu );
end;

//[function SearchAnsiMnemonics]
function SearchAnsiMnemonics( const S: String ): String;
var I: Integer;
    Sh: ShortInt;
begin
  Result := S;
  for I := 1 to Length( Result ) do
  begin
    Sh := VkKeyScanEx( Result[ I ], MnemonicsLocale );
    if Sh <> -1 then
      Result[ I ] := Char( Sh );
  end;
end;

//[procedure SupportAnsiMnemonics]
procedure SupportAnsiMnemonics( LocaleID: Integer );
begin
  MnemonicsLocale := LocaleID;
  SearchMnemonics := SearchAnsiMnemonics;
end;

//[function WndProcMnemonics]
function WndProcMnemonics( Sender: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var Form: PControl;

  function HandleMnenonic( Prnt: PControl ): Boolean;
  var C: PControl;
      XY: Integer;
      procedure DoPressMnemonic;
      begin
        if Msg.message = WM_SYSKEYDOWN then
        begin
          Form.FPressedMnemonic := Msg.wParam;
          C.Perform( WM_LBUTTONDOWN, MK_LBUTTON, XY );
        end
          else
        begin
          Form.FPressedMnemonic := 0;
          C.Perform( WM_LBUTTONUP, MK_LBUTTON, XY );
        end;
      end;
  var I, J: Integer;
      R: TRect;
  begin
    for I := 0 to Prnt.ChildCount-1 do
    begin
      C := Prnt.Children[ I ];
      if C.IsButton then
      if C.Enabled then
      begin
        if C.fCommandActions.aGetCount = TB_BUTTONCOUNT then
        for J := 0 to C.Count-1 do
        begin
          if C.TBButtonEnabled[ J ] then
          if pos( '&' + Char( Msg.wParam ), SearchMnemonics( C.TBButtonText[ J ] ) ) > 0 then
          begin
            C.fCurIndex := J;
            C.fCurItem := C.TBIndex2Item( J );
            R := C.TBButtonRect[ J ];
            XY := R.Left or (R.Top shl 16);
            DoPressMnemonic;
            Result := TRUE;
            Exit;
          end;
        end;
        if pos( '&' + Char( Msg.wParam ), SearchMnemonics( C.Caption ) ) > 0 then
        begin
          XY := 0;
          DoPressMnemonic;
          Result := TRUE;
          Exit;
        end;
      end;
      if HandleMnenonic( C ) then
      begin
        Result := TRUE;
        Exit;
      end;
    end;
    Result := FALSE;
  end;

begin
  Result := FALSE;
  if (Msg.message >= WM_KEYFIRST) and (Msg.message <= WM_KEYLAST) then
  begin
    if Sender.fAccelTable <> 0 then
      Result := LongBool( TranslateAccelerator( Sender.fHandle, Sender.fAccelTable, Msg ) );
    if not Result then
    begin
      if Sender.fCurrentControl <> nil then
      if Sender.fCurrentControl.fAccelTable <> 0 then
        Result := LongBool( TranslateAccelerator( Sender.fCurrentControl.fHandle,
                            Sender.fCurrentControl.fAccelTable, Msg ) );
    end;
    if not Result then
    begin
      Form := Sender.ParentForm;
      if Form <> nil then
      if Form.fAccelTable <> 0 then
        Result := LongBool( TranslateAccelerator( Form.fHandle,
                            Form.fAccelTable, Msg ) );
    end;
  end;
  if Result then Exit;
  if (Msg.message = WM_SYSKEYUP) or
     (Msg.message = WM_SYSKEYDOWN) and (GetKeyState( VK_MENU ) < 0) then
  begin
    Rslt := 0;
    Form := Sender.ParentForm;
    if Form <> nil then
    begin
      { ----------------------- }
      //Form.Caption := Form.Caption + '<';
        if Char( Msg.wParam ) in [ 'A'..'Z', '0'..'9' ] then
        begin
          if HandleMnenonic( Form ) then
          begin
            Result := TRUE;
            Exit;
          end
            else
          begin
            { ---------------------- }
            //Form.Caption := Form.Caption + '?';
          end;
        end;
    end;
  end
    else
  if Msg.message = WM_KEYUP then
  begin
    Rslt := 0;
    Form := Sender.ParentForm;
    if Form <> nil then
    begin
      { ------------------------ }
      //Form.Caption := Form.Caption + '>';
        if Msg.wParam = VK_MENU then
        begin
              if Form.FPressedMnemonic <> 0 then
                Form.FPressedMnemonic := Form.FPressedMnemonic or $80000000;
        end
          else
        if Char( Msg.wParam ) in [ 'A'..'Z', '0'..'9' ] then
        begin
            if HandleMnenonic( Form ) then
            begin
              Result := TRUE;
              Exit;
            end
              else
            begin
              { --------------------- }
              //Form.Caption := form.Caption + '-';
            end;
        end;
    end;
  end;
  Result := FALSE;
end;

//[function TControl.SupportMnemonics]
function TControl.SupportMnemonics: PControl;
begin
  fGlobalProcKeybd := WndProcMnemonics;
  Result := Self;
end;

//*
//[API RevokeDragDrop]
function RevokeDragDrop(wnd: HWnd): HResult; stdcall;
  external 'ole32.dll' name 'RevokeDragDrop';

//*
//[function TControl.RE_NoOLEDragDrop]
function TControl.RE_NoOLEDragDrop: PControl;
begin
  RevokeDragDrop( Handle );
  Result := Self;
end;

//*
//[function WndProcOnResize]
function WndProcOnResize( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
begin
  if Msg.message = WM_SIZE then
  begin
    if Assigned( Self_.fOnResize ) then
      Self_.fOnResize( Self_ );
  end;
  Result := False;
end;

//*
//[procedure TControl.SetOnResize]
procedure TControl.SetOnResize(const Value: TOnEvent);
begin
  FOnResize := Value;
  AttachProc( WndProcOnResize );
end;

//[function WndProcMove]
function WndProcMove( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
begin
  if Msg.message = WM_MOVE then
  begin
    if Assigned( Self_.FOnMove ) then
      Self_.FOnMove( Self_ );
  end;
  Result := False;
end;

//[procedure TControl.SetOnMove]
procedure TControl.SetOnMove(const Value: TOnEvent);
begin
  FOnMove := Value;
  AttachProc( WndProcMove );
end;

//[function WndProc_REBottomless]
function WndProc_REBottomless( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
begin
  if Msg.message = WM_SIZE then
    Self_.Perform( EM_REQUESTRESIZE, 0, 0 );
  Result := False;
end;

//*
//[function TControl.RE_Bottomless]
function TControl.RE_Bottomless: PControl;
begin
  AttachProc( WndProc_REBottomless );
  Result := Self;
end;

//*
//[procedure TControl.RE_Append]
procedure TControl.RE_Append(const S: String; ACanUndo: Boolean);
begin
  SelStart := TextSize;
  if S <> '' then
  begin
    ReplaceSelection( S, ACanUndo );
    SelStart := TextSize;
  end;
end;

//*
//[procedure TControl.RE_InsertRTF]
procedure TControl.RE_InsertRTF(const S: String);
var MS: PStream;
begin
  MS := NewMemoryStream;
  MS.Size := Length( S ) + 1;
  Move( S[ 1 ], MS.Memory^, Length( S ) + 1 );
  RE_LoadFromStream( MS, Length( S ), reRTF, TRUE );
  MS.Free;
end;

//*
//[procedure TControl.DoSelChange]
procedure TControl.DoSelChange;
begin
  if Assigned( fOnSelChange ) then fOnSelChange( Self )
  else
  if Assigned( fOnChange ) then fOnChange( Self );
end;

//*
//[function TControl.REGetUnderlineEx]
function TControl.REGetUnderlineEx: TRichUnderline;
begin
  Result := TRichUnderline( REGetFontAttr( (81 shl 16) or CFM_UNDERLINETYPE ) - 1 );
end;

//*
//[procedure TControl.RESetUnderlineEx]
procedure TControl.RESetUnderlineEx(const Value: TRichUnderline);
begin
  RESetFontAttr( (81 shl 16) or CFM_UNDERLINETYPE, Ord( Value ) + 1 );
  RESetFontEffect( CFM_UNDERLINE, True );
end;

//*
//[function TControl.GetTextSize]
function TControl.GetTextSize: Integer;
begin
  Result := 0;
  if fHandle <> 0 then
    Result := GetWindowTextLength( fHandle );
end;

//*
//[function TControl.REGetTextSize]
function TControl.REGetTextSize(Units: TRichTextSize): Integer;
const TextLengthFlags: array[ TRichTextSizes ] of Integer =
      ( not GTL_UseCRLF, not GTL_Precise, GTL_Close, GTL_NUMBytes );
var GTL: TGetTextLengthEx;
begin
  GTL.flags := MakeFlags( @Units, TextLengthFlags );
  if not(rtsBytes in Units) then
    GTL.flags := GTL.flags or GTL_NUMCHARS;
  GTL.codepage := CP_ACP;
  Result := Perform( EM_GETTEXTLENGTHEX, Integer( @GTL ), 0 );
end;

//[function TControl.RE_TextSizePrecise]
function TControl.RE_TextSizePrecise: Integer;
var gtlex : TGetTextLengthEx;
begin
  gtlex.flags := GTL_PRECISE;
  gtlex.codepage := CP_ACP;
  Result := Perform(EM_GETTEXTLENGTHEX,WPARAM(@gtlex), 0 );
end;

//*
//[function TControl.REGetNumStyle]
function TControl.REGetNumStyle: TRichNumbering;
begin
  Result := TRichNumbering( ReGetParaAttr( 9 shl 16 ) );
end;

//*
//[procedure TControl.RESetNumStyle]
procedure TControl.RESetNumStyle(const Value: TRichNumbering);
begin
  RESetParaAttr( (9 shl 16) or PFM_NUMBERING, Ord( Value ) );
end;

//*
//[function TControl.REGetNumBrackets]
function TControl.REGetNumBrackets: TRichNumBrackets;
begin
  REGetParaAttr( 0 );
  Result := TRichNumBrackets( (fREParaFmtRec.wNumberingStyle shr 8) {and 3} );
end;

//*
//[procedure TControl.RESetNumBrackets]
procedure TControl.RESetNumBrackets(const Value: TRichNumBrackets);
begin
  REGetParaAttr( 0 );
  fREParaFmtRec.wNumberingStyle := fREParaFmtRec.wNumberingStyle and $F8FF
                                or Word( Ord( Value ) shl 8 );
  fREParaFmtRec.dwMask := PFM_NUMBERINGSTYLE;
  RE_ParaFmt := fREParaFmtRec;
end;

//*
//[function TControl.REGetNumTab]
function TControl.REGetNumTab: Integer;
begin
  REGetParaAttr( 0 );
  Result := fREParaFmtRec.wNumberingTab;
end;

//*
//[procedure TControl.RESetNumTab]
procedure TControl.RESetNumTab(const Value: Integer);
begin
  REGetParaAttr( 0 );
  fREParaFmtRec.wNumberingTab := Value;
  fREParaFmtRec.dwMask := PFM_NUMBERINGTAB;
  RE_ParaFmt := fREParaFmtRec;
end;

//*
//[function TControl.REGetNumStart]
function TControl.REGetNumStart: Integer;
begin
  REGetParaAttr( 0 );
  Result := fREParaFmtRec.wNumberingStart;
end;

//*
//[procedure TControl.RESetNumStart]
procedure TControl.RESetNumStart(const Value: Integer);
begin
  REGetParaAttr( 0 );
  fREParaFmtRec.wNumberingStart := Value;
  fREParaFmtRec.dwMask := PFM_NUMBERINGSTART;
  RE_ParaFmt := fREParaFmtRec;
end;

//*
//[function TControl.REGetSpacing]
function TControl.REGetSpacing( const Index: Integer ): Integer;
begin
  REGetParaAttr( 0 );
  Result := PInteger( Integer(@fREParaFmtRec.dySpaceBefore) + (Index and $F) )^;
end;

//*
//[procedure TControl.RESetSpacing]
procedure TControl.RESetSpacing(const Index, Value: Integer);
begin
  REGetParaAttr( 0 );
  PInteger( Integer(@fREParaFmtRec.dySpaceBefore) + (Index and $F) )^ := Value;
  fREParaFmtRec.dwMask := Index and not $F;
  RE_ParaFmt := fREParaFmtRec;
end;

//*
//[function TControl.REGetSpacingRule]
function TControl.REGetSpacingRule: Integer;
begin
  REGetParaAttr( 0 );
  Result := fREParaFmtRec.bLineSpacingRule;
end;

//*
//[procedure TControl.RESetSpacingRule]
procedure TControl.RESetSpacingRule(const Value: Integer);
begin
  REGetParaAttr( 0 );
  fREParaFmtRec.bLineSpacingRule := Value;
  fREParaFmtRec.dwMask := PFM_LINESPACING;
  RE_ParaFmt := fREParaFmtRec;
end;

//*
//[function TControl.REGetLevel]
function TControl.REGetLevel: Integer;
begin
  REGetParaAttr( 0 );
  Result := fREParaFmtRec.bCRC;
end;

//*
//[function TControl.REGetBorder]
function TControl.REGetBorder(Side: TBorderEdge; const Index: Integer): Integer;
begin
  REGetParaAttr( 0 );
  Result := PWORD( Integer(@fREParaFmtRec.wBorderSpace) + Index )^ shr (Ord(Side) * 4);
end;

//*
//[procedure TControl.RESetBorder]
procedure TControl.RESetBorder(Side: TBorderEdge; const Index: Integer;
  const Value: Integer);
var Mask: Word;
    pW : PWord;
begin
  REGetParaAttr( 0 );
  pw := PWORD( Integer(@fREParaFmtRec.wBorderSpace) + Index );
  Mask := $F shl (Ord(Side) * 4);
  pw^ := pw^ and not Mask or (Value shl (4 * Ord(Side)) );
  fREParaFmtRec.dwMask := PFM_BORDER;
  RE_ParaFmt := fREParaFmtRec;
end;

//*
//[function TControl.REGetParaEffect]
function TControl.REGetParaEffect(const Index: Integer): Boolean;
begin
  Result := LongBool( HiWord( REGetParaAttr( 8 shl 16 ) ) and Index );
end;

//*
//[procedure TControl.RESetParaEffect]
procedure TControl.RESetParaEffect(const Index: Integer;
  const Value: Boolean);
var Idx: Integer;
begin
  REGetParaAttr( 0 );
  fREParaFmtRec.wReserved := Index;
  Idx := Index;
  //if Idx >= $4000 then Idx := $4000;
  fREParaFmtRec.dwMask := Idx shl 16;
  RE_ParaFmt := fREParaFmtRec;
end;

//*
//[function WndProc_REMonitorIns]
function WndProc_REMonitorIns( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
begin
  Result := False;
  if (Msg.message = WM_KEYDOWN) and (Msg.wParam = VK_INSERT) and
     ((GetKeyState(VK_CONTROL) or GetKeyState(VK_SHIFT) or GetKeyState(VK_MENU)) >= 0) then
  begin
    if not Self_.fReOvrDisable then
      Self_.fREOvr := not Self_.fREOvr
    else
      Result := True;
    if assigned( Self_.fOnREInsModeChg ) then
       Self_.fOnREInsModeChg( Self_ );
  end;
end;

//*
//[function TControl.REGetOverwite]
function TControl.REGetOverwite: Boolean;
begin
  AttachProc( WndProc_REMonitorIns );
  Result := fREOvr;
end;

//*
//[procedure TControl.RESetOverwrite]
procedure TControl.RESetOverwrite(const Value: Boolean);
begin
  if fREOvr = Value then Exit;
  Perform( WM_KEYDOWN, VK_INSERT, 0 );
  Perform( WM_KEYUP, VK_INSERT, 0 );
end;

//*
//[procedure TControl.RESetOvrDisable]
procedure TControl.RESetOvrDisable(const Value: Boolean);
begin
  REGetOverwite;
  fReOvrDisable := Value;
end;

//*
//[function WndProc_RichEdTransp_ParentPaint]
function WndProc_RichEdTransp_ParentPaint( Self_:PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var I: Integer;
    C: PControl;
begin
  if (Msg.message = WM_PAINT) and (Msg.wParam = 0) then
  begin
    for I := 0 to Self_.fChildren.fCount - 1 do
    begin
      C := Self_.fChildren.fItems[ I ];
      if C.fIsCommonControl then
      begin
        Inc( C.fUpdCount );
        PostMessage( C.fHandle, CM_NCUPDATE, C.fUpdCount, WM_PAINT );
        InvalidateRect( C.fHandle, nil, False );
      end;
    end;
  end;
  Result := False;
end;

//*
//[function WndProc_RichEdTransp_Update]
function WndProc_RichEdTransp_Update( Self_:PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var Rgn, Rgn1: HRgn;
    R, CR: TRect;
    Pt: TPoint;
    VW, HH, VH, HW: Integer;
begin
  case Msg.message of
  WM_CHAR, WM_KILLFOCUS, WM_SETFOCUS:
    begin
      PostMessage( Self_.fHandle, CM_INVALIDATE, 0, 0 );
    end;
  WM_PAINT:
    if Msg.wParam = 0 then
    begin
      Inc( Self_.fUpdCount );
      PostMessage( Self_.fHandle, CM_NCUPDATE, Self_.fUpdCount, Msg.message );
    end;
  WM_SIZE:
    begin
      Inc( Self_.fUpdCount );
      PostMessage( Self_.fHandle, CM_NCUPDATE, Self_.fUpdCount, Msg.message );
      PostMessage( Self_.fHandle, CM_INVALIDATE, 0, 0 );
    end;
  WM_ERASEBKGND:
    if Msg.wParam = 0 then
    begin
      Inc( Self_.fUpdCount );
      PostMessage( Self_.fHandle, CM_NCUPDATE, Self_.fUpdCount, Msg.message );
    end;
  WM_HSCROLL, WM_VSCROLL:
    begin
      Self_.fREScrolling := LoWord( Msg.wParam ) <> SB_ENDSCROLL;
      Inc( Self_.fUpdCount );
      PostMessage( Self_.fHandle, CM_NCUPDATE, Self_.fUpdCount, Msg.message );
      if Self_.fREScrolling then
        Self_.Invalidate;
    end;
  CM_INVALIDATE:
    begin
      //Self_.Update;
      Self_.Parent.Invalidate;
      Self_.Invalidate;
      //Inc( Self_.fUpdCount );
      //PostMessage( Self_.fHandle, CM_NCUPDATE, Self_.fUpdCount, Msg.message );
    end;
  CM_NCUPDATE:
    if Msg.wParam = Self_.fUpdCount then
    begin
      //if Msg.lParam = WM_PAINT then
      //  UpdateWindow( Self_.fHandle );
      GetWindowRect( Self_.fHandle, R );
      Windows.GetClientRect( Self_.fHandle, CR );
      Pt.x := 0; Pt.y := 0;
      Pt := Self_.Client2Screen( Pt );
      OffsetRect( CR, Pt.x, Pt.y );
      Rgn := CreateRectRgn( R.Left, R.Top, R.Right, R.Bottom );
      if Self_.fREScrolling then
      begin
        VW := GetSystemMetrics( SM_CXVSCROLL );
        HH := GetSystemMetrics( SM_CYHSCROLL );
        VH := GetSystemMetrics( SM_CYVSCROLL );
        HW := GetSystemMetrics( SM_CXHSCROLL );
        if CR.Right + VW <= R.Right then
        begin
          Rgn1 := CreateRectRgn( CR.Right, CR.Top + VH, CR.Right + VW, CR.Bottom - VH );
          CombineRgn( Rgn, Rgn, Rgn1, RGN_DIFF );
          DeleteObject( Rgn1 );
        end;
        if CR.Bottom + HH <= R.Bottom then
        begin
          Rgn1 := CreateRectRgn( CR.Left + HW, CR.Bottom, CR.Right - HW, CR.Bottom + HH );
          CombineRgn( Rgn, Rgn, Rgn1, RGN_DIFF );
          DeleteObject( Rgn1 );
        end;
      end;
      Self_.Perform( WM_NCPAINT, Rgn, 0 );
      DeleteObject( Rgn ); // Unremarked By M.Gerasimov
    end;
  end;
  Result := False;
end;

//*
//[function TControl.REGetTransparent]
function TControl.REGetTransparent: Boolean;
begin
  Result := Longbool(ExStyle and WS_EX_TRANSPARENT);
end;

//*
//[procedure TControl.RESetTransparent]
procedure TControl.RESetTransparent(const Value: Boolean);
begin
  ExStyle := ExStyle or WS_EX_TRANSPARENT;
  fParent.AttachProc( WndProc_RichEdTransp_ParentPaint );
  AttachProc( WndProc_RichEdTransp_Update );
  fTransparent := Value;
end;

//*
//[procedure TControl.RESetOnURL]
procedure TControl.RESetOnURL(const Index: Integer; const Value: TOnEvent);
begin
  if Index = 0 then
    fOnREOverURL := Value
  else
    fOnREURLClick := Value;
  RE_AutoURLDetect := assigned(fOnREOverURL) or assigned(fOnREURLClick);
end;

{$IFDEF F_P}
//[function TControl.REGetOnURL]
function TControl.REGetOnURL(const Index: Integer): TOnEvent;
begin
  CASE Index OF
  0:   Result := fOnREOverURL;
  else Result := fOnREURLClick;
  END;
end;
{$ENDIF F_P}

//*
//[function TControl.REGetLangOptions]
function TControl.REGetLangOptions(const Index: Integer): Boolean;
begin
  Result := LongBool( Perform( EM_GETLANGOPTIONS, 0, 0 ) and Index);
end;

//*
//[procedure TControl.RESetLangOptions]
procedure TControl.RESetLangOptions(const Index: Integer;
  const Value: Boolean);
var Mask: Integer;
begin
  Mask := -1;
  if not Value then Inc( Mask );
  Perform( EM_SETLANGOPTIONS, 0, Perform( EM_GETLANGOPTIONS, 0, 0 ) and
           not Index or (Mask and Index) );
end;

//[API _TrackMouseEvent]
function _TrackMouseEvent(lpEventTrack: PTrackMouseEvent): BOOL;
external cctrl name '_TrackMouseEvent';

//[function DoTrackMouseEvent]
function DoTrackMouseEvent(lpEventTrack: PTrackMouseEvent): BOOL;
var FunTrack: function(lpEventTrack: PTrackMouseEvent): BOOL; stdcall;
    ComCtlModule: THandle;
begin
  Result := FALSE;
  ComCtlModule := GetModuleHandle( cctrl );
  if ComCtlModule = 0 then Exit;
  FunTrack := GetProcAddress( ComCtlModule, '_TrackMouseEvent' );
  if not Assigned( FunTrack ) then Exit;
  Result := FunTrack( lpEventTrack );
end;

//*
//[function WndProcMouseEnterLeave]
function WndProcMouseEnterLeave( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var P: TPoint;
    MouseWasInControl: Boolean;
    Yes: Boolean;
    Track: TTrackMouseEvent;
begin
  case Msg.message of
    WM_MOUSEFIRST..WM_MOUSELAST:
      begin
        MouseWasInControl := Self_.MouseInControl;
        if Assigned( Self_.fOnTestMouseOver ) then
          Yes := Self_.fOnTestMouseOver( Self_ )
        else
        begin
          GetCursorPos( P );
          P := Self_.Screen2Client( P );
          Yes := PointInRect( P, Self_.ClientRect );
        end;
        if MouseWasInControl <> Yes then
        begin
          Self_.Invalidate;
          if Yes then
          begin
            Self_.fMouseInControl := TRUE;
            if Assigned( Self_.fOnMouseEnter ) then
              Self_.fOnMouseEnter( Self_ );
            Track.cbSize := Sizeof( Track );
            Track.dwFlags := TME_LEAVE;
            Track.hwndTrack := Self_.Handle;
            //Track.dwHoverTime := 0;
            DoTrackMouseEvent( @ Track );
            Self_.Invalidate;
          end
             else
          begin
            Self_.fMouseInControl := FALSE;
            Track.cbSize := Sizeof( Track );
            Track.dwFlags := TME_LEAVE or TME_CANCEL;
            Track.hwndTrack := Self_.Handle;
            //Track.dwHoverTime := 0;
            DoTrackMouseEvent( @ Track );
            if Assigned( Self_.fOnMouseLeave ) then
              Self_.fOnMouseLeave( Self_ );
            Self_.Invalidate;
          end;
        end;
      end;
    WM_MOUSELEAVE:
      begin
        if Self_.fMouseInControl then
        begin
          Self_.fMouseInControl := FALSE;
          if Assigned( Self_.fOnMouseLeave ) then
            Self_.fOnMouseLeave( Self_ );
          Self_.Invalidate;
        end;
      end;
  end;
  Result := False;
end;

//[procedure ProvideMouseEnterLeave]
procedure ProvideMouseEnterLeave( Self_: PControl );
begin
  InitCommonControls;
  Self_.AttachProc( WndProcMouseEnterLeave );
  Self_.Invalidate;
end;

//[procedure TControl.SetFlat]
procedure TControl.SetFlat(const Value: Boolean);
begin
  //if fFlat = Value then Exit;
  fFlat := Value;
  fMouseInControl := FALSE;
  ProvideMouseEnterLeave( Self );
  Invalidate;
end;

//[procedure TControl.SetOnMouseEnter]
procedure TControl.SetOnMouseEnter(const Value: TOnEvent);
begin
  fOnMouseEnter := Value;
  ProvideMouseEnterLeave( Self );
end;

//[procedure TControl.SetOnMouseLeave]
procedure TControl.SetOnMouseLeave(const Value: TOnEvent);
begin
  fOnMouseLeave := Value;
  ProvideMouseEnterLeave( Self );
end;

//[procedure TControl.SetOnTestMouseOver]
procedure TControl.SetOnTestMouseOver(const Value: TOnTestMouseOver);
begin
  fOnTestMouseOver := Value;
  ProvideMouseEnterLeave( Self );
end;

//[function WndProcEdTransparent]
function WndProcEdTransparent( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
begin
  if (Msg.message = WM_KEYDOWN) or
     (Msg.message = WM_MOUSEMOVE) and (GetKeyState( VK_LBUTTON ) < 0) or
     (Msg.message = WM_LBUTTONUP) or (Msg.message = WM_LBUTTONDOWN) then
    Self_.Invalidate;
  Result := False; // continue handling of a message anyway
end;

//[procedure TControl.EdSetTransparent]
procedure TControl.EdSetTransparent(const Value: Boolean);
begin
  Transparent := Value;
  AttachProc( WndProcEdTransparent );
end;

//[function WndProcSpeedButton]
function WndProcSpeedButton( Self_: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
begin
  Result := False;
  if Msg.message = WM_SETFOCUS then
  begin
    Result := TRUE;
    Rslt := 0;
  end;
end;

//[function TControl.LikeSpeedButton]
function TControl.LikeSpeedButton: PControl;
var Form: PControl;
begin
  AttachProc( WndProcSpeedButton );
  fTabstop := False;
  Style := Style and not WS_TABSTOP;
  Form := ParentForm;
  if Form <> nil then
    if Form.fCurrentControl = Self then
    begin
      Form.GotoControl( VK_TAB );
      if Form.fCurrentControl = Self then
        Form.fCurrentControl := nil;
    end;
  Result := Self;
end;

{ -- Unicode -- }
//[function TControl.SetUnicode]
function TControl.SetUnicode(Unicode: Boolean): PControl;
begin
  Perform( CCM_SETUNICODEFORMAT, Integer( Unicode ), 0 );
  Result := Self;
end;

{ -- TabControl -- }

//[function TControl.GetPages]
function TControl.GetPages(Idx: Integer): PControl;
var Item: TTCItem;
begin
  Item.mask := TCIF_PARAM;
  if Perform( TCM_GETITEM, Idx, Integer( @Item ) ) = 0 then
    Result := nil
  else
    Result := Pointer( Item.lParam );
end;

//[function TControl.TCGetItemText]
function TControl.TCGetItemText(Idx: Integer): String;
var TI: TTCItem;
    Buffer: array[ 0..1023 ] of Char;
begin
  TI.mask := TCIF_TEXT;
  TI.pszText := @Buffer[ 0 ];
  TI.cchTextMax := sizeof( Buffer );
  Buffer[ 0 ] := #0;
  Perform( TCM_GETITEM, Idx, Integer( @TI ) );
  Result := Buffer;
end;

//[procedure TControl.TCSetItemText]
procedure TControl.TCSetItemText(Idx: Integer; const Value: String);
var TI: TTCItem;
begin
  TI.mask := TCIF_TEXT;
  TI.pszText := PChar( Value );
  Perform( TCM_SETITEM, Idx, Integer( @TI ) );
end;

//[function TControl.TCGetItemImgIDx]
function TControl.TCGetItemImgIDx(Idx: Integer): Integer;
var TI: TTCItem;
begin
  TI.mask := TCIF_IMAGE;
  if Perform( TCM_GETITEM, Idx, Integer( @TI ) ) = 0 then
    Result := -1
  else
    Result := TI.iImage;
end;

//[procedure TControl.TCSetItemImgIdx]
procedure TControl.TCSetItemImgIdx(Idx: Integer; const Value: Integer);
var TI: TTCItem;
begin
  TI.mask := TCIF_IMAGE;
  TI.iImage := Value;
  Perform( TCM_SETITEM, Idx, Integer( @TI ) );
end;

//[function TControl.TCGetItemRect]
function TControl.TCGetItemRect(Idx: Integer): TRect;
begin
  if Perform( TCM_GETITEMRECT, Idx, Integer( @Result ) ) = 0 then
  begin
    Result.Left := 0;
    Result.Right := 0;
    Result.Top := 0;
    Result.Bottom := 0;
  end;
end;

//[procedure TControl.TC_SetPadding]
procedure TControl.TC_SetPadding(cx, cy: Integer);
begin
  Perform( TCM_SETPADDING, 0, cx or (cy shl 16) );
end;

//[function TControl.TC_TabAtPos]
function TControl.TC_TabAtPos(x, y: Integer): Integer;
type TTCHittestInfo = packed record
       Pt: TPoint;
       Fl: DWORD;
     end;
var HTI: TTCHitTestInfo;
begin
  HTI.Pt.x := x;
  HTI.Pt.y := y;
  Result := Perform( TCM_HITTEST, 0, Integer( @HTI ) );
end;

//[function TControl.TC_DisplayRect]
function TControl.TC_DisplayRect: TRect;
begin
  Windows.GetClientRect( fHandle, Result );
  Perform( TCM_ADJUSTRECT, 0, Integer( @Result ) );
end;

//[function TControl.TC_IndexOf]
function TControl.TC_IndexOf(const S: String): Integer;
begin
  Result := TC_SearchFor( S, -1, FALSE );
end;

//[function TControl.TC_SearchFor]
function TControl.TC_SearchFor(const S: String; StartAfter: Integer;
  Partial: Boolean): Integer;
var I: Integer;
begin
  Result := -1;
  for I := StartAfter+1 to Count-1 do
  begin
    if Partial and ( Copy( TC_Items[ I ], 1, Length( S ) ) = S ) or
       ( TC_Items[ I ] = S ) then
    begin
      Result := I;
      break;
    end;
  end;
end;

//[function TControl.TC_Insert]
function TControl.TC_Insert(Idx: Integer; const TabText: String;
  TabImgIdx: Integer): PControl;
var TI: TTCItem;
begin
  Result := NewPanel( Self, esNone );
  Result.FAlign := caClient;
  Result.fNotUseAlign := True;
  Result.fVisibleWoParent := TRUE;
  Result.Visible := Count = 0;
  TI.mask := TCIF_TEXT or TCIF_IMAGE or TCIF_PARAM;
  TI.iImage := TabImgIdx;
  TI.pszText := PChar( TabText );
  TI.lParam := Integer( Result );
  Perform( TCM_INSERTITEM, Idx, Integer( @TI ) );
  Result.BoundsRect := TC_DisplayRect;
end;

//[procedure TControl.TC_Delete]
procedure TControl.TC_Delete(Idx: Integer);
var Page: PControl;
begin
  Page := TC_Pages[ Idx ];
  if Page = nil then Exit;
  Perform( TCM_DELETEITEM, Idx, 0 );
  Page.Free;
end;

{ -- TreeView -- }

//[function TControl.TVGetItemIdx]
function TControl.TVGetItemIdx(const Index: Integer): THandle;
begin
  Result := Perform( TVM_GETNEXTITEM, Index, 0 );
end;

//[procedure TControl.TVSetItemIdx]
procedure TControl.TVSetItemIdx(const Index: Integer;
  const Value: THandle);
begin
  Perform( TVM_SELECTITEM, Index, Value );
end;

//[function TControl.TVGetItemNext]
function TControl.TVGetItemNext(Item: THandle; const Index: Integer): THandle;
begin
  Result := Perform( TVM_GETNEXTITEM, Index, Item );
end;

//[function TControl.TVGetItemRect]
function TControl.TVGetItemRect(Item: THandle; TextOnly: Boolean): TRect;
begin
  Result.Left := Item;
  if Perform( TVM_GETITEMRECT, Integer( TextOnly ), Integer( @Result ) ) = 0 then
  begin
    Result.Left := 0;
    Result.Right := 0;
    Result.Top := 0;
    Result.Bottom := 0;
  end;
end;

//[function TControl.TVGetItemVisible]
function TControl.TVGetItemVisible(Item: THandle): Boolean;
var R: TRect;
begin
  R := TVItemRect[ Item, False ];
  Result := R.Bottom > R.Top;
end;

//[procedure TControl.TVSetItemVisible]
procedure TControl.TVSetItemVisible(Item: THandle; const Value: Boolean);
begin
  if Value then
    Perform( TVM_ENSUREVISIBLE, 0, Item );
end;

//[function TControl.TVGetItemStateFlg]
function TControl.TVGetItemStateFlg(Item: THandle; const Index: Integer): Boolean;
var TVI: TTVItem;
begin
  TVI.mask := TVIF_HANDLE or TVIF_STATE;
  TVI.hItem := Item;
  TVI.stateMask := Index;
  Result := False;
  if Perform( TVM_GETITEM, 0, Integer( @TVI ) ) <> 0 then
    Result := (TVI.state and Index) <> 0;
end;

//[procedure TControl.TVSetItemStateFlg]
procedure TControl.TVSetItemStateFlg(Item: THandle; const Index: Integer;
  const Value: Boolean);
var TVI: TTVItem;
begin
  TVI.mask := TVIF_HANDLE or TVIF_STATE;
  TVI.hItem := Item;
  TVI.stateMask := Index;
  TVI.state := $FFFFFFFF and Index;
  if not Value then
    TVI.state := 0;
  Perform( TVM_SETITEM, 0, Integer( @TVI ) );
end;

//[function TControl.TVGetItemImage]
function TControl.TVGetItemImage(Item: THandle; const Index: Integer): Integer;
var TVI: TTVItem;
begin
  TVI.mask := TVIF_HANDLE or Loword( Index );
  TVI.hItem := Item;
  if Hiword( Index ) <> 0 then
  begin
    TVI.mask := TVIF_STATE or TVIF_HANDLE;
    TVI.stateMask := Loword( Index );
  end;
  Result := -1;
  if Perform( TVM_GETITEM, 0, Integer( @TVI ) ) <> 0 then
  begin
    if Hiword( Index ) <> 0 then
      Result := (TVI.state shr Hiword( Index )) and $F
    else
    if Loword( Index ) = TVIF_IMAGE then
      Result := TVI.iImage
    else
      Result := TVI.iSelectedImage;
  end;
end;

//[procedure TControl.TVSetItemImage]
procedure TControl.TVSetItemImage(Item: THandle; const Index: Integer;
  const Value: Integer);
var TVI: TTVItem;
begin
  TVI.mask := TVIF_HANDLE or Loword( Index );
  TVI.hItem := Item;
  TVI.iImage := Value;
  TVI.iSelectedImage := Value;
  if Hiword( Index ) <> 0 then
  begin
    TVI.mask := TVIF_STATE or TVIF_HANDLE;
    TVI.stateMask := Loword( Index );
    TVI.state := Value shl Hiword( Index );
  end;
  Perform( TVM_SETITEM, 0, Integer( @TVI ) );
end;

//[function TControl.TVGetItemText]
function TControl.TVGetItemText(Item: THandle): String;
var TVI: TTVItem;
    Buffer: array[ 0..4095 ] of Char;
begin
  TVI.mask := TVIF_HANDLE or TVIF_TEXT;
  TVI.hItem := Item;
  TVI.pszText := @Buffer[ 0 ];
  Buffer[ 0 ] := #0;
  TVI.cchTextMax := Sizeof( Buffer );
  Perform( TVM_GETITEM, 0, Integer( @TVI ) );
  Result := Buffer;
end;

//[procedure TControl.TVSetItemText]
procedure TControl.TVSetItemText(Item: THandle; const Value: String);
var TVI: TTVItem;
begin
  TVI.mask := TVIF_HANDLE or TVIF_TEXT;
  TVI.hItem := Item;
  TVI.pszText := PChar( Value );
  Perform( TVM_SETITEM, 0, Integer( @TVI ) );
end;

{$IFNDEF _FPC}
{$IFNDEF _D2}
//[function TControl.TVGetItemTextW]
function TControl.TVGetItemTextW(Item: THandle): WideString;
var TVI: TTVItemW;
    Buffer: array[ 0..4095 ] of WideChar;
begin
  TVI.mask := TVIF_HANDLE or TVIF_TEXT;
  TVI.hItem := Item;
  TVI.pszText := @Buffer[ 0 ];
  Buffer[ 0 ] := #0;
  TVI.cchTextMax := High( Buffer ) + 1;
  Perform( TVM_GETITEMW, 0, Integer( @TVI ) );
  Result := Buffer;
end;

//[procedure TControl.TVSetItemTextW]
procedure TControl.TVSetItemTextW(Item: THandle; const Value: WideString);
var TVI: TTVItemW;
begin
  TVI.mask := TVIF_HANDLE or TVIF_TEXT;
  TVI.hItem := Item;
  TVI.pszText := PWideChar( Value );
  Perform( TVM_SETITEMW, 0, Integer( @TVI ) );
end;
{$ENDIF _D2}
{$ENDIF _FPC}

//[function TControl.TVItemPath]
function TControl.TVItemPath(Item: THandle; Delimiter: Char): String;
begin
  if Item = 0 then
    Item := TVSelected;
  Result := '';
  while Item <> 0 do
  begin
    if Result <> '' then
      Result := Delimiter + Result;
    Result := TVItemText[ Item ] + Result;
    Item := TVItemParent[ Item ];
  end;
end;

{$IFNDEF _FPC}
{$IFNDEF _D2}
//[function TControl.TVItemPathW]
function TControl.TVItemPathW(Item: THandle;
  Delimiter: WideChar): WideString;
begin
  if Item = 0 then
    Item := TVSelected;
  Result := '';
  while Item <> 0 do
  begin
    if Result <> '' then
      Result := {$IFDEF _D3} '' + {$ENDIF} Delimiter + Result;
    Result := TVItemTextW[ Item ] + Result;
    Item := TVItemParent[ Item ];
  end;
end;
{$ENDIF _D2}
{$ENDIF _FPC}

//[function TControl.TV_GetItemHasChildren]
function TControl.TV_GetItemHasChildren(Item: THandle): Boolean;
var TVI: TTVItem;
begin
  TVI.mask := TVIF_HANDLE or TVIF_CHILDREN;
  TVI.hItem := Item;
  Perform( TVM_GETITEM, 0, Integer( @TVI ) );
  Result := TVI.cChildren = 1;
end;

//[procedure TControl.TV_SetItemHasChildren]
procedure TControl.TV_SetItemHasChildren(Item: THandle;
  const Value: Boolean);
var TVI: TTVItem;
begin
  TVI.mask := TVIF_HANDLE or TVIF_CHILDREN;
  TVI.hItem := Item;
  TVI.cChildren := 1 and Integer( Value );
  Perform( TVM_SETITEM, 0, Integer( @TVI ) );
end;

//[function TControl.TVItemAtPos]
function TControl.TVItemAtPos(x, y: Integer; var Where: DWORD): THandle;
var HTI: TTVHitTestInfo;
begin
  HTI.pt.x := x;
  HTI.pt.y := y;
  Result := Perform( TVM_HITTEST, 0, Integer( @HTI ) );
  Where := HTI.fl;
end;

type
  TTVInsertStruct = packed Record
    hParent: THandle;
    hAfter : THandle;
    item: TTVItem;
  end;
  TTVInsertStructEx = packed Record
    hParent: THandle;
    hAfter : THandle;
    item: TTVItemEx;
  end;

//[function TControl.TVInsert]
function TControl.TVInsert(nParent, nAfter: THandle;
  const Txt: String): THandle;
var TVIns: TTVInsertStruct;
begin
  TVIns.hParent := nParent;
  TVIns.hAfter := nAfter;
  TVIns.item.mask := TVIF_TEXT;
  TVIns.item.pszText := PChar( Txt );
  Result := Perform( TVM_INSERTITEM, 0, Integer( @TVIns ) );
  Invalidate;
end;

{$IFNDEF _FPC}
{$IFNDEF _D2}
type
  TTVInsertStructW = packed Record
    hParent: THandle;
    hAfter : THandle;
    item: TTVItemW;
  end;
  TTVInsertStructExW = packed Record
    hParent: THandle;
    hAfter : THandle;
    item: TTVItemExW;
  end;

//[function TControl.TVInsertW]
function TControl.TVInsertW(nParent, nAfter: THandle;
  const Txt: WideString): THandle;
var TVIns: TTVInsertStructW;
begin
  TVIns.hParent := nParent;
  TVIns.hAfter := nAfter;
  TVIns.item.mask := TVIF_TEXT;
  if Txt = '' then TVIns.item.pszText := nil
              else TVIns.item.pszText := PWideChar( @ Txt[ 1 ] );
  Result := Perform( TVM_INSERTITEMW, 0, Integer( @ TVIns ) );
  Invalidate;
end;
{$ENDIF _D2}
{$ENDIF _FPC}

//[procedure TControl.TVExpand]
procedure TControl.TVExpand(Item: THandle; Flags: DWORD);
begin
  Perform( TVM_EXPAND, Flags, Item );
end;

//[procedure TControl.TVSort]
procedure TControl.TVSort( N: THandle );
var a: Cardinal;
begin
  if N = 0 then
  begin
    N := TVRoot;
    Perform(TVM_SORTCHILDREN, 0, 0);  //+ by YS
  end;
  while N <> 0 do
    begin
      a := TVItemChild[N];
      if a > 0 then
        TVSort(a);
      Perform(TVM_SORTCHILDREN, 0, N);
      N := TVItemNext[N];
    end;
end;

//[procedure TControl.TVDelete]
procedure TControl.TVDelete(Item: THandle);
begin
  Perform( TVM_DELETEITEM, 0, Item );
  Invalidate;
end;

//[function TControl.TVGetItemData]
function TControl.TVGetItemData(Item: THandle): Pointer;
var TVI: TTVItem;
begin
  TVI.mask := TVIF_HANDLE or TVIF_PARAM;
  TVI.hItem := Item;
  Result := nil;
  if Perform( TVM_GETITEM, 0, Integer( @TVI ) ) <> 0 then
    Result := Pointer( TVI.lParam );
end;

//[procedure TControl.TVSetItemData]
procedure TControl.TVSetItemData(Item: THandle; const Value: Pointer);
var TVI: TTVItem;
begin
  TVI.mask := TVIF_HANDLE or TVIF_PARAM;
  TVI.hItem := Item;
  TVI.lParam := Integer( Value );
  Perform( TVM_SETITEM, 0, Integer( @TVI ) );
end;

//[procedure TControl.TVEditItem]
procedure TControl.TVEditItem(Item: THandle);
begin
  Perform( TVM_EDITLABEL, 0, Item );
end;

//[procedure TControl.TVStopEdit]
procedure TControl.TVStopEdit(Cancel: Boolean);
begin
  Perform( TVM_ENDEDITLABELNOW, Integer( Cancel ), 0 );
end;

//[function WndProcTVRightClickSelect]
function WndProcTVRightClickSelect( Sender: PControl; var Msg: TMsg; var R: Integer ): Boolean;
var I: Integer;
    Where: DWORD;
begin
  if Msg.message = WM_RBUTTONDOWN then
  begin
    I := Sender.TVItemAtPos( SmallInt( Msg.lParam and $FFFF ),
         SmallInt( Msg.lParam shr 16 ), Where  );
    if I <> 0 then
      Sender.TVSelected := I;
  end;
  Result := FALSE;
end;

//[procedure TControl.SetTVRightClickSelect]
procedure TControl.SetTVRightClickSelect(const Value: Boolean);
begin
  fTVRightClickSelect := Value;
  if Value then
    AttachProc( @WndProcTVRightClickSelect );
end;

//[procedure TControl.SetOnTVDelete]
procedure TControl.SetOnTVDelete( const Value: TOnTVDelete );
begin
  fOnTVDelete := Value;
  if fParent <> nil then
  begin
    fParent.Add2AutoFreeEx( Clear );
    fParent.DetachProc( WndProcNotify );
    fParent.AttachProcEx( WndProcNotify, TRUE );
  end;
  AttachProcEx( ProcTVDeleteItem, TRUE );
end;

//[function Clipboard2Text]
function Clipboard2Text: String;
var gbl: THandle;
    str: PChar;
begin
  Result := '';
  if OpenClipboard( 0 ) then
  begin
    if IsClipboardFormatAvailable( CF_TEXT ) then
    begin
      gbl := GetClipboardData( CF_TEXT );
      if gbl <> 0 then
      begin
        str := GlobalLock( gbl );
        if str <> nil then
        begin
          Result := str;
          GlobalUnlock( gbl );
        end;
      end;
    end;
    CloseClipboard;
  end;
end;


//[function Text2Clipboard]
function Text2Clipboard( const S: String ): Boolean;
var gbl: THandle;
    str: PChar;
begin
  Result := False;
  if not OpenClipboard( 0 ) then Exit;
  EmptyClipboard;
  if S <> '' then
  begin
    gbl := GlobalAlloc( GMEM_DDESHARE, Length( S ) + 1 );
    if gbl <> 0 then
    begin
      str := GlobalLock( gbl );
      Move( S[ 1 ], str^, Length( S ) + 1 );
      GlobalUnlock( gbl );
      Result := SetClipboardData( CF_TEXT, gbl ) <> 0;
    end;
  end
    else
      Result := True;
  CloseClipboard;
end;


//[function TControl.Size]
function TControl.Size(W, H: Integer): PControl;
var C, P: PControl;
    dW, dH: Integer;
begin
  C := Self;
  while True do
  begin
    dW := 0; dH := 0;
    P := C.FParent;
    if C.ToBeVisible {or C.fCreateHidden {or (P <> nil) and (P.fVisible)} then
    begin
      if C.fAlign in [caLeft, caRight, caClient] then
      begin
        if H > 0 then
        begin
          dH := H - C.Height; H := 0;
        end;
      end;
      if C.fAlign in [caTop, caBottom, caClient] then
      begin
        if W > 0 then
        begin
          dW := W - C.Width; W := 0;
        end;
      end;
    end;
    if (W > 0) or (H > 0) then
    begin
      C.SetSize( W, H );
      if (P <> nil) // {Ralf Junker}
         and not P.IsApplet then
        C.ResizeParent;
      {
      if P <> nil then
      begin
        if not (C.FAlign in [caLeft,caRight,caClient]) then
          C.ResizeParentRight;
        if not (C.FAlign in [caTop,caBottom,caClient]) then
          C.ResizeParentBottom;
      end;
      }
    end;
    if (dW = 0) and (dH = 0) then break;
    C := P; //C.FParent;
    if C = nil then break;
    //if not C.fIsControl then break;
    if C.IsApplet then break;
    W := C.Width + dW;
    H := C.Height + dH;
  end;
  Result := Self;
end;

//[procedure AutoSzProc]
procedure AutoSzProc( Self_: PControl );
var DeltaX, DeltaY: Integer;
    SZ: TSize; PT: TPoint;
    Txt: String;
    Chg: Boolean;
begin
  Txt := Self_.fCaption;
  SZ.cx := 0;
  SZ.cy := 0;
  if Txt <> '' then
  begin
    if Assigned( Self_.fFont ) then
    if Self_.fFont.fData.Font.Italic then
       Txt := Txt + ' ';
    Self_.GetWindowHandle; // this line must be here.
    //-- otherwise, when handle is not yet allocated,
    // it is requested in TCanvas.GetHandle, and in result
    // of unpredictable recursion some memory can be currupted.
    Self_.Canvas.TextArea( Txt, SZ, PT );
  end;
  Chg := FALSE;
  if Self_.FAlign in [ caNone, caLeft, caRight ] then
  begin
    DeltaX := Self_.fCommandActions.aAutoSzX;
    if DeltaX > 0 then
    begin
      Self_.Width := SZ.cx + DeltaX;
      Chg := TRUE;
    end;
  end;
  if Self_.FAlign in [ caNone, caTop, caBottom ] then
  begin
    DeltaY := Self_.fCommandActions.aAutoSzY;
    if DeltaY > 0 then
    begin
      Self_.Height := SZ.cy + DeltaY;
      Chg := TRUE;
    end;
  end;
  if Chg then
  begin
    if Self_.fParent <> nil then
      Global_Align( Self_.fParent );
    Global_Align( Self_ );
  end;
end;

//[function TControl.AutoSize]
function TControl.AutoSize(AutoSzOn: Boolean): PControl;
begin
  if AutoSzOn then
  begin
    fAutoSize := AutoSzProc;
    fAutoSize( Self );
  end
  else
    fAutoSize := nil;
  Result := Self;
end;

//[function TControl.IsAutoSize]
function TControl.IsAutoSize: Boolean;
begin
  Result := Assigned( fAutoSize );
end;

//*
//[function TControl.GetToBeVisible]
function TControl.GetToBeVisible: Boolean;
begin
  Result := fVisible or fCreateHidden or fVisibleWoParent;
  if fIsControl then
  if Parent <> nil then
  begin
    if fVisibleWoParent then
      Result := fVisible
    else
    begin
      Parent.Visible; // needed to provide correct fVisible for a form!
      Result := Result and Parent.ToBeVisible;
    end;
  end;
end;

{ -- TTree -- }

{$IFDEF USE_CONSTRUCTORS}
//[function NewTree]
function NewTree( AParent: PTree; const AName: String ): PTree;
begin
  New( Result, CreateTree(  AParent, AName ) );
end;
//[END NewTree]
{$ELSE not_USE_CONSTRUCTORS}
//[function NewTree]
function NewTree( AParent: PTree; const AName: String ): PTree;
begin
  Result := PTree.Create;
  if AParent <> nil then
    AParent.Add( Result );
  Result.fParent := AParent;
  Result.fName := AName;
end;
//[END NewTree]
{$ENDIF USE_CONSTRUCTORS}

{ TTree }

//[procedure TTree.Add]
procedure TTree.Add(Node: PTree);
var Previous: PTree;
begin
  Node.Unlink;
  if fChildren = nil then
    fChildren := NewList;
  Previous := nil;
  if fChildren.fCount > 0 then
    Previous := fChildren.fItems[ fChildren.fCount - 1 ];
  if Previous <> nil then
  begin
    Previous.fNext := Node;
    Node.fPrev := Previous;
  end;
  fChildren.Add( Node );
  Node.fParent := Self;
end;

//[procedure TTree.Clear]
procedure TTree.Clear;
var I: Integer;
begin
  if fChildren = nil then Exit;
  for I := fChildren.fCount - 1 downto 0 do
    PTree( fChildren.fItems[ I ] ).Free;
end;

{$IFDEF USE_CONSTRUCTORS}
//[constructor TTree.CreateTree]
constructor TTree.CreateTree(AParent: PTree; const AName: String);
begin
  inherited Create;
  if AParent <> nil then
    AParent.Add( Self );
  fParent := AParent;
  fName := AName;
end;
{$ENDIF}

//[destructor TTree.Destroy]
destructor TTree.Destroy;
begin
  Unlink;
  Clear;
  fName := '';
  inherited;
end;

//[function TTree.GetCount]
function TTree.GetCount: Integer;
begin
  Result := 0;
  if fChildren = nil then Exit;
  Result := fChildren.fCount;
end;

//[function TTree.GetIndexAmongSiblings]
function TTree.GetIndexAmongSiblings: Integer;
begin
  Result := -1;
  if fParent = nil then Exit;
  Result := fParent.fChildren.IndexOf( Self );
end;

//[function TTree.GetItems]
function TTree.GetItems(Idx: Integer): PTree;
begin
  Result := nil;
  if fChildren = nil then Exit;
  Result := fChildren.Items[ Idx ];
end;

//[function TTree.GetLevel]
function TTree.GetLevel: Integer;
var Node: PTree;
begin
  Result := 0;
  Node := fParent;
  while Node <> nil do
  begin
    Inc( Result );
    Node := Node.fParent;
  end;
end;

//[function TTree.GetRoot]
function TTree.GetRoot: PTree;
begin
  Result := Self;
  while Result.fParent <> nil do
    Result := Result.fParent;
end;

//[function TTree.GetTotal]
function TTree.GetTotal: Integer;
var I: Integer;
begin
  Result := Count;
  if Result <> 0 then
  begin
    for I := 0 to Count - 1 do
      Result := Result + Items[ I ].Total;
  end;
end;

//[procedure TTree.Init]
procedure TTree.Init;
begin
  if FParent <> nil then
    FParent.Add( Self );
end;

//[procedure TTree.Insert]
procedure TTree.Insert(Before, Node: PTree);
var Previous: PTree;
begin
  Node.Unlink;
  if fChildren = nil then
    fChildren := NewList;
  Previous := nil;
  if Before <> nil then
    Previous := Before.fPrev;
  if Previous <> nil then
  begin
    Previous.fNext := Node;
    Node.fPrev := Previous;
  end;
  if Before <> nil then
  begin
    Node.fNext := Before;
    Before.fPrev := Node;
    fChildren.Insert( fChildren.IndexOf( Before ), Node );
  end
    else
  fChildren.Add( Node );
  Node.fParent := Self;
end;

//[function CompareTreeNodes]
function CompareTreeNodes( const Data: Pointer; const e1, e2: DWORD ): Integer;
var List: PList;
begin
  List := Data;
  Result := AnsiCompareStr( PTree( List.fItems[ e1 ] ).fName,
                            PTree( List.fItems[ e2 ] ).fName );
end;

//[procedure SwapTreeNodes]
procedure SwapTreeNodes( const Data: Pointer; const e1, e2: DWORD );
var List: PList;
begin
  List := Data;
  List.Swap( e1, e2 );
end;

//[procedure TTree.SwapNodes]
procedure TTree.SwapNodes( i1, i2: Integer );
begin
  fChildren.Swap( i1, i2 );
end;

//[procedure TTree.SortByName]
procedure TTree.SortByName;
begin
  if Count <= 1 then Exit;
  SortData( fChildren, fChildren.fCount, CompareTreeNodes, SwapTreeNodes );
end;

//[procedure TTree.Unlink]
procedure TTree.Unlink;
var I: Integer;
begin
  if fPrev <> nil then
    fPrev.fNext := fNext;
  if fNext <> nil then
    fNext.fPrev := fPrev;
  if (fParent <> nil) then
  begin
    I := fParent.fChildren.IndexOf( Self );
    fParent.fChildren.Delete( I );
    if fParent.fChildren.fCount = 0 then
    begin
      fParent.fChildren.Free;
      fParent.fChildren := nil;
    end;
  end;
  fPrev := nil;
  fNext := nil;
  fParent := nil;
end;

//[function TTree.IsParentOfNode]
function TTree.IsParentOfNode(Node: PTree): Boolean;
begin
  Result := TRUE;
  while Node <> nil do
  begin
    if Node = Self then Exit;
    Node := Node.Parent;
  end;
  Result := FALSE;
end;

//[function TTree.IndexOf]
function TTree.IndexOf(Node: PTree): Integer;
begin
  Result := -1;
  if not IsParentOfNode( Node ) then Exit;
  while Node <> Self do
  begin
    Inc( Result );
    while Node.PrevSibling <> nil do
    begin
      Node := Node.PrevSibling;
      Inc( Result, 1 + Node.Total );
    end;
    Node := Node.Parent;
  end;
end;

//-
//[procedure TControl.ProcessPendingMessages]
procedure TControl.ProcessPendingMessages;
var Msg: TMsg;
begin
  if LOWORD( GetQueueStatus( QS_ALLINPUT ) ) <> 0 then
  if PeekMessage( Msg, 0, 0, 0, PM_NOREMOVE {or PM_NOYIELD} )
  or PeekMessage( Msg, HWnd(-1), 0, 0, PM_NOREMOVE {or PM_NOYIELD} )
  then
    Applet.ProcessMessages;
end;

//[procedure TControl.ProcessPaintMessages]
procedure TControl.ProcessPaintMessages;
var Msg: TMsg;
begin
  while PeekMessage( Msg, Handle, 15, 15, PM_NOREMOVE ) do
  //while GetQueueStatus( QS_PAINT ) <> 0 do
    Applet.ProcessMessage;
end;









///////////////////////////////////////////////////////////////////////
//
//
//                         W  I  N  D  O  W  S
//
//
///////////////////////////////////////////////////////////////////////



{ -- Set of window-related utility functions. -- }
type
  PGUIThreadInfo = ^TGUIThreadInfo;
  tagGUITHREADINFO = packed record
    cbSize: DWORD;
    flags: DWORD;
    hwndActive: HWND;
    hwndFocus: HWND;
    hwndCapture: HWND;
    hwndMenuOwner: HWND;
    hwndMoveSize: HWND;
    hwndCaret: HWND;
    rcCaret: TRect;
  end;
  TGUIThreadInfo = tagGUITHREADINFO;

const
  GUI_CARETBLINKING  = $00000001;
  GUI_INMOVESIZE     = $00000002;
  GUI_INMENUMODE     = $00000004;
  GUI_SYSTEMMENUMODE = $00000008;
  GUI_POPUPMENUMODE  = $00000010;

{function GetGUIThreadInfo (idThread: DWORD; var pgui: TGUIThreadinfo): BOOL; stdcall;
         external user32 name 'GetGUIThreadInfo';}

type TGUIThreadInfo_Proc = function( ThreadID: THandle; var GTI: TGUIThreadInfo )
                          : Boolean; stdcall;

var Proc_GetGUIThreadInfo: TGuiThreadInfo_Proc;

//[function GetWindowChild]
function GetWindowChild( Wnd: HWnd; Kind: TWindowChildKind ): HWnd;
var GTI: TGuiThreadInfo;
    ThreadID: THandle;
    Module: THandle;
begin
  if not Assigned( Proc_GetGUIThreadInfo ) then
  begin
    Module := GetModuleHandle( 'User32' );
    Proc_GetGUIThreadInfo := GetProcAddress( Module, 'GetGUIThreadInfoA' );
    if not Assigned( Proc_GetGUIThreadInfo ) then
      Proc_GetGUIThreadInfo := Pointer( -1 );
  end;
  Result := Wnd;
  if Integer( @Proc_GetGUIThreadInfo ) = -1 then
    Exit;
  Result := 0;
  if Wnd = 0 then
    ThreadID := GetCurrentThreadID
  else
    ThreadID := GetWindowThreadProcessID( Wnd, nil );
  if ThreadID = 0 then Exit;
  GTI.cbSize := Sizeof( GTI );
  if Proc_GetGUIThreadInfo( ThreadId, GTI ) then
  begin
    case Kind of
    wcActive:  Result := GTI.hwndActive;
    wcFocus:   Result := GTI.hwndFocus;
    wcCapture: Result := GTI.hwndCapture;
    wcMenuOwner: Result := GTI.hwndMenuOwner;
    wcMoveSize:  Result := GTI.hwndMoveSize;
    wcCaret:     Result := GTI.hwndCaret;
    end;
  end;
end;

//[function GetFocusedChild]
function GetFocusedChild( Wnd: HWnd ): HWnd;
var Tr1, Tr2: THandle;
begin
  Result := 0;
  Tr1 := GetCurrentThreadId;
  Tr2 := GetWindowThreadProcessId( Wnd, nil );
  if Tr1 = Tr2 then
    Result := GetFocus
  else
  if AttachThreadInput( Tr2, Tr1, True ) then
  begin
    Result := GetFocus;
    AttachThreadInput( Tr2, Tr1, False );
  end;
end;

//[function WaitFocusedWndChild]
function WaitFocusedWndChild( Wnd: HWnd ): HWnd;
var T1, T2: Integer;
    W: HWnd;
begin
  Sleep( 50 );
  T1 := GetTickCount;
  while True do
  begin
    W := GetTopWindow( Wnd );
    if W = 0 then W := Wnd;
    W := GetFocusedChild( W );
    if W <> 0 then
    begin
      Wnd := W;
      break;
    end;
    T2 := GetTickCount;
    if Abs( T1 - T2 ) > 100 then break;
  end;
  Result := Wnd;
end;

//[function Stroke2Window]
function Stroke2Window( Wnd: HWnd; const S: String ): Boolean;
var P: PChar;
begin
  Result := False;
  //Wnd := GetTopWindow( Wnd );
  Wnd := WaitFocusedWndChild( Wnd );
  if Wnd = 0 then Exit;
  P := PChar( S );
  while P^ <> #0 do
  begin
    PostMessage( Wnd, WM_CHAR, Integer( P^ ), 1 );
    Inc( P );
  end;
  Result := True;
end;

//[function Stroke2WindowEx]
function Stroke2WindowEx( Wnd: HWnd; const S: String; Wait: Boolean ): Boolean;
var P: PChar;
    EndChar: Char;
    MsgDn, MsgUp, SCA: Integer;

    function Compare( Pattern: PChar ): Boolean;
    var Pos: PChar;
        C1, C2: Char;
    begin
      Pos := P;
      while Pattern^ <> #0 do
      begin
        C1 := Pattern^;
        C2 := Pos^;
        if C1 in [ 'a'..'z' ] then
          C1 := Char( Ord( C1 ) - $20 );
        if C2 in [ 'a'..'z' ] then
          C2 := Char( Ord( C2 ) - $20 );
        if C1 <> C2 then
        begin
          Result := False;
          Exit;
        end;
        Inc( Pos );
        Inc( Pattern );
      end;
      while Pos^ = ' ' do Inc( Pos );
      P := Pos;
      Result := True;
    end;

    procedure Send( Msg, KeyCode: Integer );
    var lParam: Integer;
    begin
      Wnd := WaitFocusedWndChild( Wnd );
      if Wnd = 0 then Exit;
      lParam := 1;
      if longBool( SCA and 4 ) then
        lParam := $20000001;
      if Msg = MsgUp then
        lParam := lParam or Integer($D0000000);
      PostMessage( Wnd, Msg, KeyCode, lParam );
      Applet.ProcessMessages;
      if Wait then
        Sleep( 50 );
    end;

    function CompareSend( Pattern: PChar; Value2Send: Integer ): Boolean;
    begin
      if Compare( Pattern ) then
      begin
        Send( MsgDn, Value2Send );
        Send( MsgUp, Value2Send );
        Result := True;
      end
         else
        Result := False;
    end;

    function ParseKeys( EndChar: Char ): PChar;
    var FN: Integer;
    begin
      SCA := 0;
      while not (P^ in [ #0, EndChar ]) do
      begin
        if Compare( 'Shift' ) then SCA := SCA or 1
        else
        if Compare( 'Ctrl' ) then SCA := SCA or 2
        else
        if Compare( 'Alt' ) then SCA := SCA or 4
        else
          break;
      end;
      MsgDn := WM_KEYDOWN;
      MsgUp := WM_KEYUP;
      if LongBool( SCA and 4 ) then
      begin
        MsgDn := WM_SYSKEYDOWN;
        MsgUp := WM_SYSKEYUP;
        keybd_event( VK_MENU, 0, 0, 0 );
        Send( WM_SYSKEYDOWN, VK_MENU );
      end;
      if LongBool( SCA and 2 ) then
      begin
        keybd_event( VK_CONTROL, 0, 0, 0 );
        Send( WM_KEYDOWN, VK_CONTROL );
      end;
      if Longbool( SCA and 1 ) then
      begin
        keybd_event( VK_SHIFT, 0, 0, 0 );
        Send( WM_KEYDOWN, VK_SHIFT );
      end;
      while not (P^ in [ #0, EndChar ]) do
      begin
        if (P^ = 'F') and (P[ 1 ] in [ '1'..'9' ]) then
        begin
          Inc( P );
          FN := Ord( P^ ) - Ord( '0' );
          if (FN = 1) and (P[ 1 ] in [ '0'..'2' ]) then
          begin
            Inc( P );
            FN := 10 + Ord( P^ ) - Ord( '0' );
          end;
          repeat Inc( P ) until P^ <> ' ';
          FN := FN + $6F;
          Send( MsgDn, FN );
          Send( MsgUp, FN );
        end
           else
        if Compare( 'Numpad' ) then
        begin
          if P^ in [ '0'..'9' ] then
          begin
            FN := Ord( P^ ) - Ord( '0' ) + $60;
            repeat Inc( P^ ) until P^ <> ' ';
            Send( MsgDn, FN );
            Send( MsgUp, FN );
          end;
        end
           else
        if not (CompareSend( 'Add', $6B ) or
                CompareSend( 'Gray+', $6B ) or
                CompareSend( 'Apps', $5D ) or
                CompareSend( 'BackSpace', $08 ) or
                CompareSend( 'BkSp', $08 ) or
                CompareSend( 'BS', $08 ) or
                CompareSend( 'Break', $13 ) or
                CompareSend( 'CapsLock', $14 ) or
                CompareSend( 'Clear', $0C ) or
                CompareSend( 'Decimal', $6E ) or
                CompareSend( 'Del', $2E ) or
                CompareSend( 'Delete', $2E ) or
                CompareSend( 'Divide', $6F ) or
                CompareSend( 'Gray/', $6F ) or
                CompareSend( 'Down', $28 ) or
                CompareSend( 'End', $23 ) or
                CompareSend( 'Enter', $0D ) or
                CompareSend( 'Return', $0D ) or
                CompareSend( 'CR', $0D ) or
                CompareSend( 'Esc', $1B ) or
                CompareSend( 'Escape', $1B ) or
                CompareSend( 'Help', $2F ) or
                CompareSend( 'Home', $24 ) or
                CompareSend( 'Ins', $2D ) or
                CompareSend( 'Insert', $2D ) or
                CompareSend( 'Left', $25 ) or
                CompareSend( 'LWin', $5B ) or
                CompareSend( 'Multiply', $6A ) or
                CompareSend( 'Gray*', $6A ) or
                CompareSend( 'NumLock', $90 ) or
                CompareSend( 'PgDn', $22 ) or
                CompareSend( 'PgUp', $21 ) or
                CompareSend( 'PrintScrn', $2C ) or
                CompareSend( 'Right', $27 ) or
                CompareSend( 'RWin', $5C ) or
                CompareSend( 'Separator', $6C ) or
                CompareSend( 'ScrollLock', $91 ) or
                CompareSend( 'Subtract', $6D ) or
                CompareSend( 'Tab', $09 ) or
                CompareSend( 'Gray-', $6D ) or
                CompareSend( 'Up', $26 )) then break;
      end;
      while not (P^ in [ #0, EndChar ]) do
      begin
        if P^ in [ 'A'..'Z', '0'..'9' ] then
        begin
          Send( MsgDn, Integer( P^ ) );
          Send( MsgUp, Integer( P^ ) );
        end
        else
        if P^ in [ #1..#255 ] then
          Stroke2Window( Wnd, '' + P^ );
        repeat Inc( P ) until (P^ <> ' ');
      end;
      if P^ = EndChar then
        Inc( P );
      if Longbool( SCA and 1 ) then
      begin
        Send( WM_KEYUP, VK_SHIFT );
        keybd_event( VK_SHIFT, 0, KEYEVENTF_KEYUP, 0 );
      end;
      if LongBool( SCA and 2 ) then
      begin
        Send( WM_KEYUP, VK_CONTROL );
        keybd_event( VK_CONTROL, 0, KEYEVENTF_KEYUP, 0 );
      end;
      if LongBool( SCA and 4 ) then
      begin
        Send( WM_SYSKEYUP, VK_MENU );
        keybd_event( VK_MENU, 0, KEYEVENTF_KEYUP, 0 );
      end;
      Result := P;
    end;

begin
  Result := False;
  Wnd := GetTopWindow( Wnd );
  Wnd := GetFocusedChild( Wnd );
  if Wnd = 0 then Exit;
  P := PChar( S );
  while P^ <> #0 do
  begin
    if not (P^ in [ '[', '{' ]) then
    begin
      Stroke2Window( Wnd, '' + P^ );
      Inc( P );
    end
      else
    begin
      if P^ = '[' then
        EndChar := ']'
      else
        EndChar := '}';
      Inc( P );
      P := ParseKeys( EndChar );
    end;
  end;
  Result := True;
end;

type
  PHWnd = ^HWnd;

  TFindWndRec = packed Record
    ThreadID : DWord;
    WndFound : HWnd;
  end;
  PFindWndRec = ^TFindWndRec;

//[function EnumWindowsProc]
function EnumWindowsProc( Wnd : HWnd; Find : PFindWndRec ) : Boolean;
stdcall;
var Id : DWord;
begin
  Result := True;
  Id := GetWindowThreadProcessId( Wnd, @Id );
  if Id = Find.ThreadID then
  begin
    Find.WndFound := Wnd;
    Result := False;
  end;
end;

//[function FindWindowByThreadID]
function FindWindowByThreadID( ThreadID : DWORD ) : HWnd;
var Find : TFindWndRec;
begin
  Find.ThreadID := ThreadID;
  Find.WndFound := 0;
  EnumWindows( @EnumWindowsProc, Integer( @Find ) );
  Result := Find.WndFound;
end;

//[function GetDesktopRect]
function GetDesktopRect : TRect;
var W1, W2 : HWnd;
begin
  Result := MakeRect( 0, 0, GetSystemMetrics( SM_CXSCREEN ), GetSystemMetrics( SM_CYSCREEN ) );
  W2 := findwindow(nil,'Program Manager');
  W1 := findwindowex(W2,0,'SHELLDLL_DefView',nil);
  if W1 = 0 then Exit;
  GetWindowRect( W1, Result );
end;

//[function GetWorkArea]
function GetWorkArea: TRect;
begin
  SystemParametersInfo( SPI_GETWORKAREA, 0, @ Result, 0 );
end;

//[function ExecuteWait]
function ExecuteWait( const AppPath, CmdLine, DfltDirectory: String;
         Show: DWORD; TimeOut: DWORD; ProcID: PDWORD ): Boolean;
var Flags: DWORD;
    Startup: TStartupInfo;
    ProcInf: TProcessInformation;
    DfltDir: PChar;
    App: String;
begin
  Result := FALSE;
  Flags := CREATE_NEW_CONSOLE;
  if Show = SW_HIDE then
    Flags := Flags or {$IFDEF F_P}$08000000{$ELSE}CREATE_NO_WINDOW{$ENDIF};
  FillChar( Startup, SizeOf( Startup ), 0 );
  Startup.cb := Sizeof( Startup );
  Startup.wShowWindow := Show;
  Startup.dwFlags := STARTF_USESHOWWINDOW;
  if ProcID <> nil then
    ProcID^ := 0;
  DfltDir := nil;
  if DfltDirectory <> '' then
    DfltDir := PChar( DfltDirectory );
  if ProcID <> nil then
    ProcID^ := 0;
  App := AppPath;
  if (pos( ' ', App ) > 0) and (pos( '"', App ) <= 0) then
    App := '"' + App + '"';
  if (App <> '') and (CmdLine <> '') then
    App := App + ' ';
  if CreateProcess( nil, PChar( App + CmdLine ), nil,
     nil, FALSE, Flags, nil, DfltDir, Startup,
     ProcInf ) then
  begin
    if WaitForSingleObject( ProcInf.hProcess, TimeOut ) = WAIT_OBJECT_0 then
    begin
      CloseHandle( ProcInf.hProcess );
      Result := TRUE;
    end
      else
    begin
      if ProcID <> nil then
        ProcID^ := ProcInf.hProcess;
    end;
    CloseHandle( ProcInf.hThread );
  end;
end;

//[function ExecuteIORedirect]
function ExecuteIORedirect( const AppPath, CmdLine, DfltDirectory: String;
         Show: DWORD; ProcID: PDWORD; InPipe, OutPipeWr, OutPipeRd: PHandle ): Boolean;
var Flags: DWORD;
    Startup: TStartupInfo;
    ProcInf: TProcessInformation;
    DfltDir: PChar;
    SecurityAttributes: TSecurityAttributes;
    SaveStdOut, SaveStdIn: THandle;
    ChildStdOutRd, ChildStdOutWr: THandle;
    ChildStdInRd, ChildStdInWr: THandle;
    ChildStdOutRdDup: THandle;
    ChildStdInWrDup: THandle;

    procedure Do_CloseHandle( var Handle: THandle );
    begin
      if Handle <> 0 then
      begin
        CloseHandle( Handle );
        Handle := 0;
      end;
    end;

    procedure Close_Handles;
    begin
      Do_CloseHandle( ChildStdOutRd );
      Do_CloseHandle( ChildStdOutWr );
      Do_CloseHandle( ChildStdInRd );
      Do_CloseHandle( ChildStdInWr );
    end;

    function RedirectInputOutput: Boolean;
    begin
      Result := FALSE;
      if (OutPipeRd <> nil) or (OutPipeWr <> nil) then
      begin
        // redirect output
        SaveStdOut := GetStdHandle(STD_OUTPUT_HANDLE);
        if not CreatePipe( ChildStdOutRd, ChildStdOutWr, @ SecurityAttributes, 0 ) then
          Exit;
        if not SetStdHandle( STD_OUTPUT_HANDLE, ChildStdOutWr ) then
          Exit;
        if not DuplicateHandle( GetCurrentProcess, ChildStdOutRd,
           GetCurrentProcess, @ ChildStdOutRdDup, 0, FALSE,
           2 {DUPLICATE_SAME_ACCESS} ) then
          Exit;
        Do_CloseHandle( ChildStdOutRd );
        if OutPipeRd <> nil then
          OutPipeRd^ := ChildStdOutRdDup;
        if OutPipeWr <> nil then
          OutPipeWr^ := ChildStdOutWr;
      end;
      if InPipe <> nil then
      begin
        // redirect input
        SaveStdIn := GetStdHandle(STD_INPUT_HANDLE);
        if not CreatePipe( ChildStdInRd, ChildStdInWr, @ SecurityAttributes, 0 ) then
          Exit;
        if not SetStdHandle( STD_INPUT_HANDLE, ChildStdInRd ) then
          Exit;
        if not DuplicateHandle( GetCurrentProcess, ChildStdInWr,
           GetCurrentProcess, @ ChildStdInWrDup, 0, FALSE,
           2 {DUPLICATE_SAME_ACCESS} ) then
          Exit;
        Do_CloseHandle( ChildStdInWr );
        if InPipe <> nil then
          InPipe^ := ChildStdInWrDup;
        Do_CloseHandle( ChildStdInRd );
      end;
      Result := TRUE;
    end;

    procedure Restore_Saved_StdInOut;
    begin
      //if SaveStdOut <> 0 then
        SetStdHandle( STD_OUTPUT_HANDLE, SaveStdOut );
      //if SaveStdin <> 0 then
        SetStdHandle( STD_INPUT_HANDLE, SaveStdIn );
    end;

begin
  Result := FALSE;
  Flags := 0;
  if Show = SW_HIDE then
    Flags := Flags or {$IFDEF F_P}$08000000{$ELSE}CREATE_NO_WINDOW{$ENDIF};
  FillChar( Startup, SizeOf( Startup ), 0 );
  Startup.cb := Sizeof( Startup );
  {Startup.wShowWindow := Show;
  Startup.dwFlags := STARTF_USESHOWWINDOW;}
  if ProcID <> nil then
    ProcID^ := 0;
  DfltDir := nil;
  SecurityAttributes.nLength := Sizeof( SecurityAttributes );
  SecurityAttributes.lpSecurityDescriptor := nil;
  SecurityAttributes.bInheritHandle := TRUE;
  SaveStdOut := 0;
  SaveStdIn := 0;
  ChildStdOutRd := 0;
  ChildStdOutWr := 0;
  ChildStdInRd := 0;
  ChildStdInWr := 0;
  if not RedirectInputOutput then
  begin
    Close_Handles;
    Exit;
  end;;
  if DfltDirectory <> '' then
    DfltDir := PChar( DfltDirectory );
  if CreateProcess( nil, PChar( '"' + AppPath + '" ' + CmdLine ),
     nil, nil, TRUE, Flags, nil, DfltDir, Startup,
     ProcInf ) then
  begin
    if ProcID <> nil then
      ProcID^ := ProcInf.hProcess
    else
      CloseHandle( ProcInf.hProcess );
    CloseHandle( ProcInf.hThread );
    Restore_Saved_StdInOut;
    Result := TRUE;
  end
    else
  begin
    Restore_Saved_StdInOut;
    Close_Handles;
    Exit;
  end;
end;

//[function ExecuteConsoleAppIORedirect]
function ExecuteConsoleAppIORedirect( const AppPath, CmdLine, DfltDirectory: String;
         Show: DWORD; const InStr: String; var OutStr: String; WaitTimeout: DWORD ): Boolean;
var PipeIn, PipeOutRd, PipeOutWr: THandle;
    ProcID: DWORD;
    BytesCount: DWORD;
    Buffer: array[ 0..4096 ] of Char;
    BufStr: String;
    PPipeIn: PHandle;
begin
  Result := FALSE;
  PPipeIn := @ PipeIn;
  if InStr = '' then
    PPipeIn := nil;
  PipeOutRd := 0;
  PipeOutWr := 0;
  if not ExecuteIORedirect( AppPath, CmdLine, DfltDirectory, Show, @ ProcID,
                     PPipeIn, @ PipeOutWr, @ PipeOutRd ) then Exit;
  if PPipeIn <> nil then
  begin
    if InStr <> '' then
      WriteFile( PipeIn, InStr[ 1 ], Length( InStr ), BytesCount, nil );
    CloseHandle( PipeIn );
  end;
  OutStr := '';
  if WaitForSingleObject( ProcID, WaitTimeOut ) = WAIT_OBJECT_0 then
  begin
    CloseHandle( ProcID );
    CloseHandle( PipeOutWr );
    while ReadFile( PipeOutRd, Buffer, Sizeof( Buffer ), BytesCount, nil ) do
    begin
      SetLength( BufStr, BytesCount );
      Move( Buffer[ 0 ], BufStr[ 1 ], BytesCount );
      OutStr := OutStr + BufStr;
    end;
  end
    else
    CloseHandle( PipeOutWr );
  CloseHandle( PipeOutRd );
  Result := TRUE;
end;

{$IFDEF _D2}
//[API OpenProcessToken]
function OpenProcessToken(ProcessHandle: THandle; DesiredAccess: DWORD;
  var TokenHandle: THandle): BOOL; stdcall;
  external advapi32 name 'OpenProcessToken';
{$ENDIF}

//[function WindowsShutdown]
function WindowsShutdown( const Machine : String; Force, Reboot : Boolean ) : Boolean;
var
  hToken: THandle;
  tkp, tkp_prev: TTokenPrivileges;
  dwRetLen :DWORD;
  Flags: Integer;
begin
  Result := False;
  if Integer( GetVersion ) < 0 then // Windows95/98/Me
  begin
    if Machine <> '' then Exit;
    Flags := EWX_SHUTDOWN;
    if Reboot then
      Flags := Flags or EWX_REBOOT;
    if Force then
      Flags := Flags or EWX_FORCE;
    Result := ExitWindowsEx( Flags, 0 );
    Exit;
  end;

  OpenProcessToken(GetCurrentProcess(),
                   TOKEN_ADJUST_PRIVILEGES or TOKEN_QUERY,
                   hToken);

  if not LookupPrivilegeValue(PChar(Machine),
'SeShutdownPrivilege',tkp.Privileges[0].Luid)
     then
         Exit;

  tkp_prev:=tkp;
  tkp.PrivilegeCount:=1;
  tkp.Privileges[0].Attributes:=SE_PRIVILEGE_ENABLED;
  AdjustTokenPrivileges(hToken, FALSE, tkp, sizeof(tkp), tkp_prev,
dwRetLen);

  if not LookupPrivilegeValue(PChar(Machine),
                              'SeRemoteShutdownPrivilege',
                              tkp.Privileges[0].Luid)
     then
         Exit;

  tkp.PrivilegeCount:=1;
  tkp.Privileges[0].Attributes:=SE_PRIVILEGE_ENABLED;
  AdjustTokenPrivileges(hToken, FALSE, tkp, sizeof(tkp), tkp_prev,
dwRetLen);

  Result := InitiateSystemShutdown(PChar(Machine),nil, 0, Force, Reboot);
end;

//[function WinVer]
function WinVer : TWindowsVersion;
{* Returns Windows version. }
var OVI: TOsVersionInfo;
begin
  OVI.dwOSVersionInfoSize := Sizeof( OVI );
  GetVersionEx( OVI );
  with OVI do
  if dwPlatformId = VER_PLATFORM_WIN32_NT then
  begin
    Result := wvNT;
    if dwMajorVersion >= 6 then
      Result := wvLongHorn
    else begin
           if dwMajorVersion >= 5 then
             if dwMinorVersion >=1 then
               Result := wvXP
             else
               Result := wvY2K;
         end;
  end
  {if dwPlatformId = VER_PLATFORM_WIN32_NT then
  begin
    Result := wvNT;
    if dwMajorVersion >= 5 then
      Result := wvY2K;
  end}
     else
  if dwPlatformId = VER_PLATFORM_WIN32_WINDOWS then
  begin
    Result := wv95;
    if (dwMajorVersion > 4) or (dwMajorVersion = 4)
    and (dwMinorVersion >= 10)  then
      Result := wv98;
  end
     else
     Result := wv31; // Windows 3.1 (WIN32s)
end;

//[function IsWinVer]
function IsWinVer( Ver : TWindowsVersions ) : Boolean;
{* Returns True if Windows version is in given range of values. }
begin
  Result := WinVer in Ver;
end;

//[procedure TControl.SetAlphaBlend]
procedure TControl.SetAlphaBlend(const Value: Integer);
const
  LWA_COLORKEY=$00000001;
  LWA_ALPHA=$00000002;
  ULW_COLORKEY=$00000001;
  ULW_ALPHA=$00000002;
  ULW_OPAQUE=$00000004;
  WS_EX_LAYERED=$00080000;
type
  TSetLayeredWindowAttributes=
    function( hwnd: Integer; crKey: TColor; bAlpha: Byte; dwFlags: DWORD )
    : Boolean; stdcall;
var
  SetLayeredWindowAttributes: TSetLayeredWindowAttributes;
  User32: THandle;
  dw: DWORD;
begin
  if Value = fAlphaBlend then Exit;
  fAlphaBlend := Value;
  User32 := GetModuleHandle( 'User32' );
  SetLayeredWindowAttributes := GetProcAddress( User32,
                             'SetLayeredWindowAttributes' );
  if Assigned( SetLayeredWindowAttributes ) then
  begin
    dw := GetWindowLong( GetWindowHandle, GWL_EXSTYLE );
    if Byte( Value ) < 255 then
    begin
      SetWindowLong( fHandle, GWL_EXSTYLE, dw or WS_EX_LAYERED );
      SetLayeredWindowAttributes( fHandle, 0, Value and $FF, LWA_ALPHA);
    end
       else
      SetWindowLong( fHandle, GWL_EXSTYLE, dw and not WS_EX_LAYERED );
  end;
end;

//[function TControl.SetPosition]
function TControl.SetPosition( X, Y: Integer ): PControl;
begin
  Left := X;
  Top := Y;
  Result := Self;
end;

//[function NewColorDialog]
function NewColorDialog( FullOpen: TColorCustomOption ): PColorDialog;
var I: Integer;
begin
  Result := PColorDialog.Create;
  Result.ColorCustomOption := FullOpen;
  for I := 1 to 16 do
    Result.CustomColors[ I ] := clWhite;
end;
//[END NewColorDialog]

{ TColorDialog }

//[function TColorDialog.Execute]
function TColorDialog.Execute: Boolean;
var CD: TChooseColor;
begin
  CD.lStructSize := Sizeof( CD );
  CD.hWndOwner := OwnerWindow;
  //CD.hInstance := 0;
  CD.rgbResult := Color2RGB( Color );
  CD.lpCustColors := @CustomColors[ 1 ];
  CD.Flags := CC_RGBINIT;
  case ColorCustomOption of
  ccoFullOpen: CD.Flags := CD.Flags or CC_FULLOPEN;
  ccoPreventFullOpen: CD.Flags := CD.Flags or CC_PREVENTFULLOPEN;
  end;
  Result := ChooseColor( CD );
  if Result then
    Color := CD.rgbResult;
end;

//[procedure TControl.SetMaxProgress]
procedure TControl.SetMaxProgress(const Index, Value: Integer);
begin
  // ignore index, and set Value via PBM_SETRANGE32:     ()
  Perform( PBM_SETRANGE32, 0, Value );
end;

//[procedure TControl.SetDroppedWidth]
procedure TControl.SetDroppedWidth(const Value: Integer);
begin
  FDroppedWidth := Value;
  Perform( CB_SETDROPPEDWIDTH, Value, 0 );
end;

//[function TControl.LVGetItemState]
function TControl.LVGetItemState(Idx: Integer): TListViewItemState;
type
  PListViewItemState = ^TListViewItemState;
var I: Byte;
begin
  I := Perform( LVM_GETITEMSTATE, Idx,
                LVIS_CUT or LVIS_DROPHILITED or LVIS_FOCUSED or LVIS_SELECTED );
  Result := PListViewItemState( @ I )^;
end;

//[procedure TControl.LVSetItemState]
procedure TControl.LVSetItemState(Idx: Integer; const Value: TListViewItemState);
var Data: TLVItem;
begin
  //FillChar( Data, Sizeof( Data ), 0 );
  //Data.mask := LVIF_DI_SETITEM or LVIF_STATE;
  Data.stateMask := LVIS_FOCUSED or LVIS_SELECTED or LVIS_CUT or LVIS_DROPHILITED;
  Data.state     := PByte( @ Value )^;
  //Data.iItem     := Idx;
  Perform( LVM_SETITEMSTATE, Idx, Integer( @Data ) );
end;

//[procedure TControl.LVSelectAll]
procedure TControl.LVSelectAll;
begin
  LVSetItemState( -1, [ lvisSelect ] );
end;

//[function TControl.LVItemInsert]
function TControl.LVItemInsert(Idx: Integer; const aText: String): Integer;
var LVI: TLVItem;
begin
  LVI.mask := LVIF_TEXT or LVIF_DI_SETITEM;
  LVI.iItem := Idx;
  LVI.iSubItem := 0;
  LVI.pszText := PChar( aText );
  Result := Perform( LVM_INSERTITEM, 0, Integer( @LVI ) );
end;

{$IFNDEF _FPC}
{$IFNDEF _D2}
//[function TControl.LVItemInsertW]
function TControl.LVItemInsertW(Idx: Integer;
  const aText: WideString): Integer;
var LVI: TLVItemW;
begin
  LVI.mask := LVIF_TEXT or LVIF_DI_SETITEM;
  LVI.iItem := Idx;
  LVI.iSubItem := 0;
  LVI.pszText := PWideChar( aText );
  Result := Perform( LVM_INSERTITEMW, 0, Integer( @LVI ) );
end;
{$ENDIF _D2}
{$ENDIF _FPC}

//[function TControl.LVItemAdd]
function TControl.LVItemAdd(const aText: String): Integer;
begin
  Result := LVItemInsert( Count, aText );
end;

{$IFNDEF _FPC}
{$IFNDEF _D2}
//[function TControl.LVItemAddW]
function TControl.LVItemAddW(const aText: WideString): Integer;
begin
  Result := LVItemInsertW( Count, aText );
end;
{$ENDIF _D2}
{$ENDIF _FPC}

//[function TControl.LVGetSttImgIdx]
function TControl.LVGetSttImgIdx(Idx: Integer): Integer;
begin
  Result := Perform( LVM_GETITEMSTATE, Idx, LVIS_STATEIMAGEMASK ) shr 12;
end;

//[procedure TControl.LVSetSttImgIdx]
procedure TControl.LVSetSttImgIdx(Idx: Integer; const Value: Integer);
var LVI: TLVItem;
begin
  LVI.stateMask := LVIS_STATEIMAGEMASK;
  LVI.state := Value shl 12;
  Perform( LVM_SETITEMSTATE, Idx, Integer( @LVI ) );
end;

//[function TControl.LVGetOvlImgIdx]
function TControl.LVGetOvlImgIdx(Idx: Integer): Integer;
begin
  Result := Perform( LVM_GETITEMSTATE, Idx, LVIS_OVERLAYMASK ) shr 8;
end;

//[procedure TControl.LVSetOvlImgIdx]
procedure TControl.LVSetOvlImgIdx(Idx: Integer; const Value: Integer);
var LVI: TLVItem;
begin
  LVI.stateMask := LVIS_OVERLAYMASK;
  LVI.state := Value shl 8;
  Perform( LVM_SETITEMSTATE, Idx, Integer( @LVI ) );
end;

//[function TControl.LVGetItemData]
function TControl.LVGetItemData(Idx: Integer): DWORD;
var LVI: TLVItem;
begin
  LVI.mask := LVIF_PARAM;
  LVI.iItem := Idx;
  LVI.iSubItem := 0;
  Perform( LVM_GETITEM, 0, Integer( @LVI ) );
  Result := LVI.lParam;
end;

//[procedure TControl.LVSetItemData]
procedure TControl.LVSetItemData(Idx: Integer; const Value: DWORD);
var LVI: TLVItem;
begin
  LVI.mask := LVIF_PARAM;
  LVI.iItem := Idx;
  LVI.iSubItem := 0;
  LVI.lParam := Value;
  Perform( LVM_SETITEM, 0, Integer( @LVI ) );
end;

//[function TControl.LVGetItemIndent]
function TControl.LVGetItemIndent(Idx: Integer): Integer;
var LI: TLVItem;
begin
  LI.mask := LVIF_INDENT;
  LI.iItem := Idx;
  LI.iSubItem := 0;
  Perform( LVM_GETITEM, 0, Integer( @LI ) );
  Result := LI.iIndent;
end;

//[procedure TControl.LVSetItemIndent]
procedure TControl.LVSetItemIndent(Idx: Integer; const Value: Integer);
var LI: TLVItem;
begin
  LI.mask := LVIF_INDENT or LVIF_DI_SETITEM;
  LI.iItem := Idx;
  LI.iSubItem := 0;
  LI.iIndent := Value;
  Perform( LVM_SETITEM, 0, Integer( @LI ) );
end;

type
  TNMLISTVIEW = packed Record
    hdr: TNMHDR;
    iItem: Integer;
    iSubItem: Integer;
    uNewState: Integer;
    uOldState: Integer;
    uChanged: Integer;
    ptAction: Integer;
    lParam: DWORD;
  end;
  PNMLISTVIEW = ^TNMLISTVIEW;

//[function WndProc_LVDeleteItem]
function WndProc_LVDeleteItem( Sender: PControl; var Msg: TMsg; var Rslt: Integer )
                          : Boolean;
var Hdr: PNMHDR;
    LV: PNMListView;
begin
  Result := FALSE;
  if Msg.message = WM_NOTIFY then
  begin
    Hdr := Pointer(Msg.lParam);
    if Hdr.hwndFrom = Sender.Handle then
    begin
      LV := Pointer( Hdr );
      if Hdr.code = LVN_DELETEITEM then
      begin
        if Assigned( Sender.OnDeleteLVItem ) then
          Sender.OnDeleteLVItem( Sender, LV.iItem );
        Result := TRUE;
      end
        else
      if Hdr.code = LVN_DELETEALLITEMS then
      begin
        if Assigned( Sender.OnDeleteAllLVItems ) then
        begin
          Sender.OnDeleteAllLVItems( Sender );
          Rslt := 0;
          if Assigned( Sender.OnDeleteLVItem ) then
            Rslt := 1;
        end;
        Result := TRUE;
      end;
    end;
  end;
end;

//[procedure TControl.SetOnDeleteAllLVItems]
procedure TControl.SetOnDeleteAllLVItems(const Value: TOnEvent);
begin
  fOnDeleteAllLVItems := Value;
  AttachProc( @WndProc_LVDeleteItem );
end;

//[procedure TControl.SetOnDeleteLVItem]
procedure TControl.SetOnDeleteLVItem(const Value: TOnDeleteLVItem);
begin
  fOnDeleteLVItem := Value;
  AttachProc( @WndProc_LVDeleteItem );
end;

//[function WndProc_LVData]
function WndProc_LVData( Sender: PControl; var Msg: TMsg; var Rslt: Integer )
                          : Boolean;
var Hdr: PNMHDR;
    DI: PLVDispInfo;
    Store: Boolean;
    Txt: String;
    LV: PControl;
    {$IFDEF UNICODE_CTRLS}
    TxtW: WideString;
    {$ENDIF UNICODE_CTRLS}
begin
  Result := FALSE;
  if Msg.message = WM_NOTIFY then
  begin
    Hdr := Pointer(Msg.lParam);
    if Hdr.hwndFrom = Sender.Handle then
    begin
      if (Hdr.code = LVN_GETDISPINFO)
         {$IFDEF UNICODE_CTRLS}
         or (Hdr.code = LVN_GETDISPINFOW)
         {$ENDIF UNICODE_CTRLS}
      then
      begin
        DI := Pointer( Hdr );
        LV := Sender;
        if LV <> nil then
        begin
          Txt := '';
          DI.item.iImage := -1;
          DI.item.state := 0;
          Store := FALSE;
          if (Assigned( LV.OnLVData )
               {$IFDEF UNICODE_CTRLS}
               or Assigned( LV.OnLVDataW )
               {$ENDIF UNICODE_CTRLS}
             )
             and (DI.item.iItem >= 0) then
          begin
            {$IFDEF UNICODE_CTRLS}
            TxtW := '';
            if Assigned( LV.ONLVDataW ) then
              LV.OnLVDataW( LV, DI.item.iItem, DI.item.iSubItem, TxtW,
                            DI.item.iImage, DWORD( DI.item.state ), Store )
            else
            {$ENDIF UNICODE_CTRLS}
            LV.OnLVData( LV, DI.item.iItem, DI.item.iSubItem, Txt,
                             DI.item.iImage, DWORD( DI.item.state ), Store );
            {$IFNDEF UNICODE_CTRLS}
            if (LV.fCaption = nil) or (Integer( StrLen( LV.fCaption ) ) <=
               Length( Txt ) ) then
            {$ENDIF UNICODE_CTRLS}
            begin
              if LV.fCaption <> nil then
                FreeMem( LV.fCaption );
              {$IFDEF UNICODE_CTRLS}
              GetMem( LV.fCaption, (Length( Txt ) + Length( TxtW ) + 1)
                      * Sizeof( WideChar ) );
              {$ELSE NOT_UNICODE_CTRLS}
              GetMem( LV.fCaption, Length( Txt ) + 1 );
              {$ENDIF NOT_UNICODE_CTRLS}
            end;
            {$IFDEF UNICODE_CTRLS}
            PWord( @ LV.fCaption[ 0 ] )^ := 0;
            {$ELSE}
            LV.fCaption[ 0 ] := #0;
            {$ENDIF}
            if Txt {$IFDEF UNICODE_CTRLS} + TxtW {$ENDIF UNICODE_CTRLS}
               <> '' then
            begin
              {$IFDEF UNICODE_CTRLS}
              if Hdr.code = LVN_GETDISPINFOW then
              begin
                if Txt <> '' then
                  TxtW := Txt;
                Move( TxtW[ 1 ], LV.fCaption[ 0 ], (Length( TxtW ) + 1) * Sizeof( WideChar ) );
              end else
              {$ENDIF UNICODE_CTRLS}
              StrCopy( LV.fCaption, @Txt[ 1 ] );
            end;
            DI.item.pszText := LV.fCaption;
            if Store then
              DI.item.mask := DI.item.mask or LVIF_DI_SETITEM;
          end;
          Result := TRUE;
        end;
      end;
    end;
  end;
end;

//[procedure TControl.SetOnLVData]
procedure TControl.SetOnLVData(const Value: TOnLVData);
begin
  fOnLVData := Value;
  AttachProc( @WndProc_LVData );
  Perform( LVM_SETCALLBACKMASK, LVIS_OVERLAYMASK or LVIS_STATEIMAGEMASK, 0 );
end;

{$IFNDEF _FPC}
{$IFNDEF _D2}
//[procedure TControl.SetOnLVDataW]
procedure TControl.SetOnLVDataW(const Value: TOnLVDataW);
begin
  fOnLVDataW := Value;
  AttachProc( @WndProc_LVData );
  Perform( LVM_SETCALLBACKMASK, LVIS_OVERLAYMASK or LVIS_STATEIMAGEMASK, 0 );
end;
{$ENDIF _D2}
{$ENDIF _FPC}

//[function WndProc_LVCustomDraw]
function WndProc_LVCustomDraw( Sender: PControl; var Msg: TMsg;
                               var Rslt: Integer ): Boolean;
var NMCustDraw: PNMLVCustomDraw;
    NMHdr: PNMHdr;
    ItemIdx, SubItemIdx: Integer;
    S: TListViewItemState;
    ItemState: TDrawState;
begin
  Result := FALSE;
  if Msg.message = WM_NOTIFY then
  begin
    NMHdr := Pointer( Msg.lParam );
    if (NMHdr.code = NM_CUSTOMDRAW) and Assigned( Sender.fOnLVCustomDraw ) then
    begin
      NMCustDraw := Pointer( Msg.lParam );
      ItemIdx := -1;
      SubItemIdx := -1;
      if LongBool( NMCustDraw.nmcd.dwDrawStage and CDDS_ITEM ) then
        ItemIdx := NMCustDraw.nmcd.dwItemSpec;
      if LongBool( NMCustDraw.nmcd.dwDrawStage and CDDS_SUBITEM ) then
        SubItemIdx := NMCustDraw.iSubItem;
      ItemState := [ ];
      if ItemIdx >= 0 then
      begin
        S := Sender.LVItemState[ ItemIdx ];
        if lvisFocus in S then
          ItemState := ItemState + [ odsFocused ];
        if lvisSelect in S then
          ItemState := ItemState + [ odsSelected ];
        if lvisBlend in S then
          ItemState := ItemState + [ odsGrayed ];
        if lvisHighlight in S then
          ItemState := ItemState + [ odsMarked ];
      end;

      Rslt := Sender.FOnLVCustomDraw( Sender, {Sender.Canvas.Handle} NMCustDraw.nmcd.hdc,
           NMCustDraw.nmcd.dwDrawStage, ItemIdx, SubItemIdx, NMCustDraw.nmcd.rc,
           ItemState, TColor( NMCustDraw.clrText ), TColor( NMCustDraw.clrTextBk ) );
      Result := TRUE;
    end;
  end;
end;

//[procedure TControl.SetOnLVCustomDraw]
procedure TControl.SetOnLVCustomDraw(const Value: TOnLVCustomDraw);
begin
  fOnLVCustomDraw := Value;
  AttachProc( @WndProc_LVCustomDraw );
end;

//[function CompareLVItems]
function CompareLVItems( Idx1, Idx2: Integer; ListView: PControl ): Integer; stdcall;
begin
  if Assigned( ListView.fOnCompareLVItems ) then
    Result := ListView.fOnCompareLVItems( ListView, Idx1, Idx2 )
  else
    Result := 0;
end;

//[procedure TControl.LVSort]
procedure TControl.LVSort;
begin
  Perform( LVM_SORTITEMSEX, Integer(Self), Integer(@CompareLVItems) );
end;

//[function CompareLVItemsData]
function CompareLVItemsData( D1, D2: DWORD; ListView: PControl ): Integer; stdcall;
begin
  if Assigned( ListView.fOnCompareLVItems ) then
    Result := ListView.fOnCompareLVItems( ListView, D1, D2 )
  else
    Result := 0;
end;

//[procedure TControl.LVSortData]
procedure TControl.LVSortData;
begin
  Perform( LVM_SORTITEMS, Integer( Self ), Integer( @CompareLVItemsData ) );
end;

//[function WndProc_LVColumnClick]
function WndProc_LVColumnClick( Sender: PControl; var Msg: TMsg; var Rslt: Integer )
                          : Boolean;
var Hdr: PNMHDR;
    LV: PNMListView;
begin
  Result := FALSE;
  if Msg.message = WM_NOTIFY then
  begin
    Hdr := Pointer(Msg.lParam);
    if Hdr.hwndFrom = Sender.Handle then
    begin
      LV := Pointer( Hdr );
      if Hdr.code = LVN_COLUMNCLICK then
      begin
        if Assigned( Sender.OnColumnClick ) then
          Sender.OnColumnClick( Sender, LV.iSubItem );
        Result := TRUE;
      end;
    end;
  end;
end;

//[procedure TControl.SetOnColumnClick]
procedure TControl.SetOnColumnClick(const Value: TOnLVColumnClick);
begin
  fOnColumnClick := Value;
  AttachProc( @WndProc_LVColumnClick );
end;

//[function WndProc_LVStateChange]
function WndProc_LVStateChange( Sender: PControl; var Msg: TMsg; var R: Integer ): Boolean;
var NMOD: PNMLVODStateChange;
    NMLV: PNMLISTVIEW;
begin
  if Msg.message = WM_NOTIFY then
  begin
    NMOD := Pointer( Msg.lParam );
    NMLV := Pointer( Msg.lParam );
    if NMOD.hdr.code = LVN_ODSTATECHANGED then
    begin
      if Assigned( Sender.OnLVStateChange ) then
        Sender.OnLVStateChange( Sender, NMOD.iFrom, NMOD.iTo,
                                NMOD.uOldState, NMOD.uNewState );
    end
      else
    if NMLV.hdr.code = LVN_ITEMCHANGED then
    begin
      if Assigned( Sender.OnLVStateChange ) then
        Sender.OnLVStateChange( Sender, NMLV.iItem, NMLV.iItem,
                                NMLV.uOldState, NMLV.uNewState );
    end;
  end;
  Result := FALSE;
end;

//[procedure TControl.SetOnLVStateChange]
procedure TControl.SetOnLVStateChange(const Value: TOnLVStateChange);
begin
  FOnLVStateChange := Value;
  AttachProc( WndProc_LVStateChange );
end;

//[function WndProc_LVDelete]
function WndProc_LVDelete( Sender: PControl; var Msg: TMsg; var R: Integer ): Boolean;
var NMLV: PNMLISTVIEW;
begin
  if Msg.message = WM_NOTIFY then
  begin
    NMLV := Pointer( Msg.lParam );
    if NMLV.hdr.code = LVN_DELETEITEM then
    begin
      if Assigned( Sender.OnLVDelete ) then
        Sender.OnLVDelete( Sender, NMLV.iItem );
    end;
  end;
  Result := FALSE;
end;

//[procedure TControl.SetOnLVDelete]
procedure TControl.SetOnLVDelete(const Value: TOnLVDelete);
begin
  FOnLVDelete := Value;
  Add2AutoFreeEx( Clear );
  AttachProcEx( WndProc_LVDelete, TRUE );
  if fParent <> nil then
  begin
    fParent.DetachProc( WndProcNotify );
    fParent.AttachProcEx( WndProcNotify, TRUE );
  end;
end;

//[function CompareLVColumns]
function CompareLVColumns( Idx1, Idx2: Integer; Sender: PControl ): Integer; stdcall;
var S1, S2: String;
begin
  //--- changed by Mike Gerasimov:
  S1 := Sender.LVItems[ Idx1, Sender.fColumn ];
  S2 := Sender.LVItems[ Idx2, Sender.fColumn ];
  If lvoSortAscending in Sender.fLVOptions Then
   Result := AnsiCompareStrNoCase( S1, S2 )
  Else
   If lvoSortDescending in Sender.fLVOptions Then
    Result := AnsiCompareStrNoCase( S2, S1 )
   Else
    Result:=0;
end;

//[procedure TControl.LVSortColumn]
procedure TControl.LVSortColumn(Idx: Integer);
begin
  fColumn := Idx;
  Perform( LVM_SORTITEMSEX, Integer(Self), Integer(@CompareLVColumns) );
end;

//[function TControl.LVIndexOf]
function TControl.LVIndexOf(const S: String): Integer;
begin
  Result := LVSearchFor( S, -1, FALSE );
end;

{$IFNDEF _FPC}
{$IFNDEF _D2}
//[function TControl.LVIndexOfW]
function TControl.LVIndexOfW(const S: WideString): Integer;
begin
  Result := LVSearchForW( S, -1, FALSE );
end;
{$ENDIF _D2}
{$ENDIF _FPC}

//[function TControl.LVSearchFor]
function TControl.LVSearchFor(const S: String; StartAfter: Integer;
  Partial: Boolean): Integer;
var f: TLVFindInfo;
begin
    f.lParam := 0;
    f.flags  := LVFI_STRING;
    if Partial then
      f.flags := LVFI_STRING or LVFI_PARTIAL;
    f.psz    := @s[1];
    result := Perform(LVM_FINDITEM,StartAfter,integer(@f));
end;

{$IFNDEF _FPC}
{$IFNDEF _D2}
//[function TControl.LVSearchForW]
function TControl.LVSearchForW(const S: WideString; StartAfter: Integer;
  Partial: Boolean): Integer;
var f: TLVFindInfoW;
begin
    f.lParam := 0;
    f.flags  := LVFI_STRING;
    if Partial then
      f.flags := LVFI_STRING or LVFI_PARTIAL;
    f.psz    := @s[1];
    result := Perform(LVM_FINDITEMW,StartAfter,integer(@f));
end;
{$ENDIF _D2}
{$ENDIF _FPC}

//[function TControl.IndexOf]
function TControl.IndexOf(const S: String): Integer;
begin
  Result := SearchFor( S, -1, FALSE );
end;

//[function TControl.SearchFor]
function TControl.SearchFor(const S: String; StartAfter: Integer;
  Partial: Boolean): Integer;
var Cmd: Integer;
    I: Integer;
begin
  Cmd := fCommandActions.aFindItem;
  if Partial then
    Cmd := fCommandActions.aFindPartial;
  if Cmd <> 0 then
    Result := Perform( Cmd, StartAfter, Integer( PChar( S ) ) )
  else
  begin
    Result := -1;
    for I := StartAfter+1 to Count-1 do
    begin
      if Partial and ( Copy( Items[ I ], 1, Length( S ) ) = S ) or
         ( Items[ I ] = S ) then
      begin
        Result := I;
        break;
      end;
    end;
  end;
end;

//[function TControl.DefaultBtnProc]
function TControl.DefaultBtnProc(var Msg: TMsg;
  var Rslt: Integer): Boolean;
var Btn: PControl;
    F: PControl;
    //Msg1: TMsg;
begin
  if Assigned( fOldOnMessage ) then
  begin
    Result := fOldOnMessage( Msg, Rslt );
    if Result then Exit;
  end;
  Result := FALSE;
  if AppletTerminated then Exit;
  F := Applet;
  if not F.fIsForm then
  begin
    F := F.fCurrentControl;
    if F = nil then Exit;
  end;
  Btn := nil;
  if ((Msg.message = WM_KEYDOWN) or (Msg.message = WM_KEYUP)) and
     ((Msg.wParam = VK_RETURN) or (Msg.wParam = VK_ESCAPE)) then
  begin
    if (Msg.wParam = VK_RETURN) and
       (F.fDefaultBtnCtl <> nil) and
       F.fDefaultBtnCtl.ToBeVisible and
       F.fDefaultBtnCtl.Enabled and
       ((F.fCurrentControl=nil) or (not F.fCurrentControl.fCancelBtn and
                                    not F.fCurrentControl.fIgnoreDefault)
                                or (F.fCurrentControl = F.fDefaultBtnCtl)
       ) then
       Btn := F.fDefaultBtnCtl
      else
    if (Msg.wParam = VK_ESCAPE) and
       (F.fCancelBtnCtl <> nil) and
       F.fCancelBtnCtl.ToBeVisible and
       F.fCancelBtnCtl.Enabled then
       Btn := F.fCancelBtnCtl
      else
    if (Msg.wParam = VK_RETURN) and
       (F.fAllBtnReturnClick or fAllBtnReturnClick) and
       (F.ActiveControl <> nil) and
       (F.ActiveControl.IsButton) and
       (F.ActiveControl.Count = 0) then
       Btn := F.ActiveControl;
    if Btn <> nil then
    begin
      if Msg.message = WM_KEYDOWN then
        Btn.Focused := TRUE;
      Btn.Perform( Msg.message, DWORD( ' ' ), Msg.lParam );
      Msg.wParam := 0;
      Result := TRUE;
      Rslt := 0;
      Exit;
    end
  end;
  Result := FALSE;
end;

//[procedure TControl.SetDefaultBtn]
procedure TControl.SetDefaultBtn(const Index: Integer;
  const Value: Boolean);
var F, C: PControl;
begin
  if Index = 13 then
  begin
    fDefaultBtn := Value;
    fCancelBtn := FALSE;
  end
    else
  if Index = 27 then
  begin
    fCancelBtn := Value;
    fDefaultBtn := FALSE;
  end;
  if Applet = nil then Exit;
  F := ParentForm;
  if F <> nil then
  begin
    if Value then
    begin
      if @ Applet.fOnMessage <> @ TControl.DefaultBtnProc  then
        Applet.fOldOnMessage := Applet.fOnMessage; // fixed by YS
      Applet.fOnMessage := Applet.DefaultBtnProc;
    end
      else
    begin
      Applet.fOnMessage := Applet.fOldOnMessage;
      Applet.fOldOnMessage := nil;
    end;
    C := nil;
    if Value then C := Self;
    if Index = 13 then
    begin
      F.fDefaultBtnCtl := C;
      if Value then
        Style := Style or BS_DEFPUSHBUTTON
      else
        Style := Style and not BS_DEFPUSHBUTTON;
    end
    else
    if Index = 27 then
      F.fCancelBtnCtl := C;
  end;
end;

{$IFDEF F_P}
//[function TControl.GetDefaultBtn]
function TControl.GetDefaultBtn(const Index: Integer): Boolean;
begin
  CASE Index OF
  13: Result := fDefaultBtn;
  27: Result := fCancelBtn;
  END;
end;
{$ENDIF F_P}

//[function TControl.AllBtnReturnClick]
function TControl.AllBtnReturnClick: PControl;
{$IFDEF ALL_BUTTONS_RESPOND_TO_ENTER}
begin
  // nothing: already implemented in WndProcBtnReturnClick
  Result := Self;
end;
{$ELSE}
var F: PControl;
begin
  SetDefaultBtn( 0, TRUE );
  F := ParentForm;
  if F <> nil then
    F.fAllBtnReturnClick := TRUE;
  Result := Self;
end;
{$ENDIF}

//[function WndProc_CNDrawItem]
function WndProc_CNDrawItem( Sender: PControl; var Msg: TMsg; var Rslt: Integer )
                          : Boolean;
type PDrawAction = ^TDrawAction;
     PDrawState = ^TDrawState;
var DI: PDrawItemStruct;
begin
  Result := FALSE;
  if Msg.message = CN_DRAWITEM then
  begin
    DI := Pointer( Msg.lParam );
    if Assigned( Sender.OnDrawItem ) then
    begin
      if Sender.OnDrawItem( Sender, DI.hDC, DI.rcItem, DI.itemID,
                         PDrawAction( @ DI.itemAction )^,
                         PDrawState( @ DI.itemState )^ )
        then Rslt := 1
        else Rslt := 0;
      Result := TRUE;
    end
      else Rslt := 0;
  end;
end;

//[procedure TControl.SetOnDrawItem]
procedure TControl.SetOnDrawItem(const Value: TOnDrawItem);
begin
  fOnDrawItem := Value;
  if Parent <> nil then
    Parent.AttachProc( @WndProc_DrawItem );
  AttachProc( @WndProc_CNDrawItem );
end;

//[function WndProc_MeasureItem]
function WndProc_MeasureItem( Sender: PControl; var Msg: TMsg; var Rslt: Integer )
                          : Boolean;
var MI: PMeasureItemStruct;
    Control: PControl;
    I: Integer;
begin
  Result := FALSE;
  if Msg.message = WM_MEASUREITEM then
  begin
    MI := Pointer( Msg.lParam );
    for I := 0 to Sender.ChildCount - 1 do
    begin
      Control := Sender.Children[ I ];
      if Control.Menu = MI.CtlID then
      begin
        if Assigned( Control.OnMeasureItem ) then
        begin
          MI.itemHeight := Control.OnMeasureItem( Control, MI.itemID );
          if MI.itemHeight > 0 then
          begin
            Rslt := 1;
            Result := TRUE;
          end;
        end;
        break;
      end;
    end;
  end;
end;

//[procedure TControl.SetOnMeasureItem]
procedure TControl.SetOnMeasureItem(const Value: TOnMeasureItem);
begin
  fOnMeasureItem := Value;
  if Parent <> nil then
    Parent.AttachProc( @WndProc_MeasureItem );
end;

//[function TControl.GetItemData]
function TControl.GetItemData(Idx: Integer): DWORD;
begin
  Result := 0;
  if fCommandActions.aGetItemData <> 0 then
    Result := Perform( fCommandActions.aGetItemData, Idx, 0 );
end;

//[procedure TControl.SetItemData]
procedure TControl.SetItemData(Idx: Integer; const Value: DWORD);
begin
  if fCommandActions.aSetItemData <> 0 then
    Perform( fCommandActions.aSetItemData, Idx, Value );
end;

//[function TControl.GetLVCurItem]
function TControl.GetLVCurItem: Integer;
begin
  Result := Perform( LVM_GETNEXTITEM, -1, LVNI_SELECTED );
end;

//[procedure TControl.SetLVCurItem]
procedure TControl.SetLVCurItem(const Value: Integer);
begin
  if (lvoMultiselect in LVOptions) or (Value <> LVCurItem ) then
    LVItemState[ -1 ] := [ ];
  if Value >= 0 then
    LVItemState[ Value ] := [ lvisSelect, lvisFocus ];
end;

//[function TControl.LVNextItem]
function TControl.LVNextItem(IdxPrev: Integer; Attrs: DWORD): Integer;
begin
  Result := Perform( LVM_GETNEXTITEM, IdxPrev, Attrs );
end;

//[function TControl.LVNextSelected]
function TControl.LVNextSelected(IdxPrev: Integer): Integer;
begin
  Result := Perform( LVM_GETNEXTITEM, IdxPrev, LVNI_SELECTED );
end;

//[procedure TControl.Close]
procedure TControl.Close;
begin
  PostMessage( Handle, WM_CLOSE, 0, 0 );
end;

//[function WndProcMinimize]
function WndProcMinimize( Sender: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var Wnd: PControl;
begin
  Result := FALSE;
  if (Msg.message = WM_SYSCOMMAND) and ((Msg.wParam and $FFF0) = SC_MINIMIZE)then
  begin
    if Applet <> nil then
    begin
      Wnd := Applet.FMinimizeWnd;
      if Wnd <> nil then
        SetWindowPos( Applet.Handle, 0, Wnd.Left, Wnd.Top, Wnd.Width, 0,
                      SWP_NOZORDER or SWP_NOREDRAW);
    end;
  end;
end;

//[procedure TControl.MinimizeNormalAnimated]
procedure TControl.MinimizeNormalAnimated;
var App: PControl;
begin
  App := Applet;
  if App = nil then
    App := Self;
  App.FMinimizeWnd := Self;
  App.AttachProc( @WndProcMinimize );
end;

//[function WndProcDropFiles]
function WndProcDropFiles( Sender: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var hDrop: THandle;
    Pt: TPoint;
    FList: String;
    I, N: Integer;
    Buf: array[ 0..MAX_PATH ] of Char;
begin
  if Msg.message = WM_DROPFILES then
  if Assigned( Sender.FOnDropFiles ) then
  begin
    hDrop := Msg.wParam;
    DragQueryPoint( hDrop, Pt );
    N := DragQueryFile( hDrop, $FFFFffff, nil, 0 );
    FList := '';
    for I := 0 to N-1 do
    begin
      if FList <> '' then
        FList := FList + #13;
      DragQueryFile( hDrop, I, Buf, Sizeof( Buf ) );
      FList := FList + Buf;
    end;
    DragFinish( hDrop );
    Sender.FOnDropFiles( Sender, FList, Pt );
    Rslt := 0;
    Result := TRUE;
    Exit;
  end;
  Result := FALSE;
end;

//[procedure TControl.SetOnDropFiles]
procedure TControl.SetOnDropFiles(const Value: TOnDropFiles);
begin
  FOnDropFiles := Value;
  AttachProc( @WndProcDropFiles );
  DragAcceptFiles( GetWindowHandle, Assigned( Value ) );
end;

//[function WndProcShowHide]
function WndProcShowHide( Sender: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var IsVisible: Boolean;
begin
  if Msg.message = WM_SHOWWINDOW then
  if Msg.hwnd = Sender.Handle then
  begin
    IsVisible := IsWindowVisible( Sender.Handle );
    if LongBool( Msg.wParam ) then
    begin
      Sender.fVisible := TRUE;
      if not IsVisible then
      if Assigned( Sender.FOnShow ) then
        Sender.FOnShow( Sender );
    end
      else
    begin
      Sender.fVisible := FALSE;
      if IsVisible then
      if Assigned( Sender.FOnHide ) then
        Sender.FOnHide( Sender );
    end;
  end;
  Result := FALSE;
end;

//[procedure TControl.SetOnHide]
procedure TControl.SetOnHide(const Value: TOnEvent);
begin
  FOnHide := Value;
  AttachProc( WndProcShowHide );
end;

//[procedure TControl.SetOnShow]
procedure TControl.SetOnShow(const Value: TOnEvent);
begin
  FOnShow := Value;
  AttachProc( WndProcShowHide );
end;

//[function TControl.BringToFront]
function TControl.BringToFront: PControl;
begin
  SetWindowPos( GetWindowHandle, HWND_TOP, 0, 0, 0, 0, SWP_NOSIZE or SWP_NOMOVE or
                SWP_NOACTIVATE or SWP_NOOWNERZORDER or SWP_SHOWWINDOW );
  Result := Self;
end;

//[function TControl.SendToBack]
function TControl.SendToBack: PControl;
begin
  SetWindowPos( GetWindowHandle, HWND_BOTTOM, 0, 0, 0, 0, SWP_NOSIZE or SWP_NOMOVE or
                SWP_NOACTIVATE or SWP_NOOWNERZORDER );
  Result := Self;
end;

//[procedure TControl.DragStart]
procedure TControl.DragStart;
begin
  PostMessage( GetWindowHandle, WM_SYSCOMMAND, $F012, 0 );
end;

//[function WndProcDragWindow]
function WndProcDragWindow( Sender: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var P: TPoint;
begin
  if Msg.message = WM_MOUSEMOVE then
  begin
    if Sender.FDragging then
    begin
      GetCursorPos( P );
      P.x := P.x - Sender.fMouseStartPos.x + Sender.fDragStartPos.x;
      P.y := P.y - Sender.fMouseStartPos.y + Sender.fDragStartPos.y;
      Sender.Position := P;
    end;
  end;
  Result := FALSE;
end;

//[procedure TControl.DragStartEx]
procedure TControl.DragStartEx;
var StartBounds: TRect;
begin
  GetCursorPos( fMouseStartPos );
  StartBounds := BoundsRect;
  fDragStartPos.x := StartBounds.Left;
  fDragStartPos.y := StartBounds.Top;
  SetCapture( GetWindowHandle );
  fDragging := TRUE;
  AttachProc( WndProcDragWindow );
end;

//[procedure TControl.DragStopEx]
procedure TControl.DragStopEx;
begin
  if FDragging then
  begin
    ReleaseCapture;
    FDragging := FALSE;
  end;
end;

//[function CallDragCallBack]
function CallDragCallBack( Sender: PControl; var Stop: Boolean ): Boolean;
var P: TPoint;
    Shape, ShapeWas: Integer;
begin
  GetCursorPos( P );
  Shape := LoadCursor( 0, IDC_HAND );
  ShapeWas := Shape;
  Result := Sender.fDragCallback( Sender, P.x, P.y, Shape, Stop );
  if not Stop then
  begin
    if not Result then
      if Shape = ShapeWas then
        Shape := LoadCursor( 0, IDC_NO );
    ScreenCursor := Shape;
  end
    else
  begin
    ScreenCursor := 0;
    Shape := Sender.fCursor;
  end;
  Windows.SetCursor( Shape );
end;

//[function WndProcDrag]
function WndProcDrag( Sender: PControl; var Msg: TMsg; var Rslt: Integer ): Boolean;
var Stop: Boolean;
begin
  if Sender.fDragging then
  begin
    Stop := FALSE;
    case Msg.message of
    WM_MOUSEMOVE:
      CallDragCallBack( Sender, Stop );
    WM_LBUTTONUP, WM_RBUTTONUP:
      begin
        Stop := TRUE;
        CallDragCallBack( Sender, Stop );
      end;
    else
      begin
        Result := FALSE;
        Exit;
      end;
    end;
    if Stop then
    begin
      ReleaseCapture;
      Sender.fDragging := FALSE;
    end
      else
    begin
      Result := TRUE;
      exit;
    end;
  end;
  Result := FALSE;
end;

//[procedure TControl.DragItem]
procedure TControl.DragItem(OnDrag: TOnDrag);
begin
  fDragCallback := OnDrag;
  fDragging := TRUE;
  SetCapture( GetWindowHandle );
  AttachProc( WndProcDrag );
end;



{ TCABFile }

//[function OpenCABFile]
function OpenCABFile( const APaths: array of String ): PCABFile;
var I: Integer;
begin
  Result := PCABFile.Create;
  Result.FSetupapi := LoadLibrary( 'setupapi.dll' );
  Result.FNames := NewStrList;
  Result.FPaths := NewStrList;
  for I := 0 to High( APaths ) do
    Result.FPaths.Add( APaths[ I ] );
end;

//[destructor TCABFile.Destroy]
destructor TCABFile.Destroy;
begin
  FNames.Free;
  FPaths.Free;
  FTargetPath := '';
  if FSetupapi <> 0 then
    FreeLibrary( FSetupapi );
  inherited;
end;

const
  SPFILENOTIFY_FILEINCABINET  = $11;
  SPFILENOTIFY_NEEDNEWCABINET = $12;

type
  PSP_FILE_CALLBACK = function( Context: Pointer; Notification, Param1, Param2: DWORD ): DWORD;
  stdcall;

  TSetupIterateCabinet = function ( CabinetFile: PChar; Reserved: DWORD;
         MsgHandler: PSP_FILE_CALLBACK; Context: Pointer ): Boolean; stdcall;
         //external 'setupapi.dll' name 'SetupIterateCabinetA';

  TSetupPromptDisk = function (
    hwndParent: HWND; 	// parent window of the dialog box
    DialogTitle: PChar;	// optional, title of the dialog box
    DiskName: PChar;	// optional, name of disk to insert
    PathToSource: PChar;// optional, expected source path
    FileSought: PChar;	// name of file needed
    TagFile: PChar;	// optional, source media tag file
    DiskPromptStyle: DWORD;	// specifies dialog box behavior
    PathBuffer: PChar;	// receives the source location
    PathBufferSize: DWORD;	// size of the supplied buffer
    PathRequiredSize: PDWORD	// optional, buffer size needed
   ): DWORD; stdcall;
   //external 'setupapi.dll' name 'SetupPromptForDiskA';

type
  TCabinetInfo = packed record
    CabinetPath: PChar;
    CabinetFile: PChar;
    DiskName: PChar;
    SetId: WORD;
    CabinetNumber: WORD;
  end;
  PCabinetInfo = ^TCabinetInfo;

  TFileInCabinetInfo = packed record
    NameInCabinet: PChar;
    FileSize: DWORD;
    Win32Error: DWORD;
    DosDate: WORD;
    DosTime: WORD;
    DosAttribs: WORD;
    FullTargetName: array[0..MAX_PATH-1] of Char;
  end;
  PFileInCabinetInfo = ^TFileInCabinetInfo;

//[function CABCallback]
function CABCallback( Context: Pointer; Notification, Param1, Param2: DWORD ): DWORD;
stdcall;
var CAB: PCABFile;
    CABPath, OldPath: String;
    CABInfo: PCabinetInfo;
    CABFileInfo: PFileInCabinetInfo;
    hr: Integer;
    SetupPromptProc: TSetupPromptDisk;
begin
  Result := 0;
  CAB := Context;
  case Notification of
  SPFILENOTIFY_NEEDNEWCABINET:
    begin
      OldPath := CAB.FPaths.Items[ CAB.FCurCAB ];
      Inc( CAB.FCurCAB );
      if CAB.FCurCAB = CAB.FPaths.Count then
        CAB.FPaths.Add( '?' );
      CABPath := CAB.FPaths.Items[ CAB.FCurCAB ];
      if CABPath = '?' then
      begin
        if Assigned( CAB.FOnNextCAB ) then
          CAB.FPaths.Items[CAB.FCurCAB ] := CAB.FOnNextCAB( CAB );
        CABPath := CAB.FPaths.Items[ CAB.FCurCAB ];
        if CABPath = '?' then
        begin
          SetLength( CABPath, MAX_PATH );
          CABInfo := Pointer( Param1 );
          if CAB.FSetupapi <> 0 then
            SetupPromptProc := GetProcAddress( CAB.FSetupapi, 'SetupPromptForDiskA' )
          else
            SetupPromptProc := nil;
          if Assigned( SetupPromptProc ) then
          begin
            hr := SetupPromptProc( 0, nil, nil, PChar( ExtractFilePath( OldPath ) ),
                 CABInfo.CabinetFile, nil, 2 {IDF_NOSKIP}, @CabPath[ 1 ], MAX_PATH, nil );
            case hr of
            0: // success
              begin
                StrCopy( PChar( Param2 ), PChar( CABPath ) );
                Result := 0;
              end;
            2: // skip file
              Result := 0;
            else // cancel
              Result := ERROR_FILE_NOT_FOUND;
            end;
          end;
        end
          else
        begin
          StrCopy( PChar( Param2 ), PChar( CABPath ) );
          Result := 0;
        end;
      end;
    end;
  SPFILENOTIFY_FILEINCABINET:
    begin
      CABFileInfo := Pointer( Param1 );
      if CAB.FGettingNames then
      begin
        CAB.FNames.Add( CABFileInfo.NameInCabinet );
        Result := 2; // FILEOP_SKIP
      end
        else
      begin
        CABPath := CABFileInfo.NameInCabinet;
        if Assigned( CAB.FOnFile ) then
        begin
          if CAB.FOnFile( CAB, CABPath ) then
          begin
            if ExtractFilePath( CABPath ) = '' then
            if CAB.FTargetPath <> '' then
              CABPath := CAB.TargetPath + CABPath;
            StrCopy( @CABFileInfo.FullTargetName[ 0 ], PChar( CABPath ) );
            Result := 1; // FILEOP_DOIT
          end
          else
            Result := 2
        end
        else
        begin
          if CAB.FTargetPath <> '' then
            StrCopy( @CABFileInfo.FullTargetName[ 0 ], PChar( CAB.TargetPath + CABPath ) );
          Result := 1;
        end;
      end;
    end;
  end;
end;

//[function TCABFile.Execute]
function TCABFile.Execute: Boolean;
var SetupIterateProc: TSetupIterateCabinet;
begin
  FCurCAB := 0;
  Result := FALSE;
  if FSetupapi = 0 then Exit;
  SetupIterateProc := GetProcAddress( FSetupapi, 'SetupIterateCabinetA' );
  if not Assigned( SetupIterateProc ) then Exit;
  Result := SetupIterateProc( PChar( FPaths.Items[ 0 ] ), 0, CABCallback, Self );
end;

//[function TCABFile.GetCount]
function TCABFile.GetCount: Integer;
begin
  GetNames( 0 );
  Result := FNames.Count;
end;

//[function TCABFile.GetNames]
function TCABFile.GetNames(Idx: Integer): String;
begin
  if FNames.Count = 0 then
  begin
    FGettingNames := TRUE;
    Execute;
    FGettingNames := FALSE;
  end;
  Result := '';
  if Idx < FNames.Count then
    Result := FNames.Items[ Idx ];
end;

//[function TCABFile.GetPaths]
function TCABFile.GetPaths(Idx: Integer): String;
begin
  Result := FPaths.Items[ Idx ];
end;

//[function TCABFile.GetTargetPath]
function TCABFile.GetTargetPath: String;
begin
  Result := FTargetPath;
  if Result <> '' then
  if Result[ Length( Result ) ] <> '\' then
    Result := Result + '\';
end;

//[procedure InvalidateExW]
procedure InvalidateExW( Wnd: HWnd );
begin
  InvalidateRect( Wnd, nil, TRUE );
  Wnd := GetWindow( Wnd, GW_CHILD );
  while Wnd <> 0 do
  begin
    InvalidateExW( Wnd );
    Wnd := GetWindow( Wnd, GW_HWNDNEXT );
  end;
end;

//[procedure TControl.InvalidateEx]
procedure TControl.InvalidateEx;
begin
  if fHandle = 0 then Exit;
  InvalidateExW( fHandle );
end;

//[procedure InvalidateNCW]
procedure InvalidateNCW( Wnd: HWnd; Recursive: Boolean );
begin
  SendMessage( Wnd, WM_NCPAINT, 1, 0 );
  if not Recursive then Exit;
  Wnd := GetWindow( Wnd, GW_CHILD );
  while Wnd <> 0 do
  begin
    InvalidateNCW( Wnd, Recursive );
    Wnd := GetWindow( Wnd, GW_HWNDNEXT );
  end;
end;

//[procedure TControl.InvalidateNC]
procedure TControl.InvalidateNC(Recursive: Boolean);
begin
  if fHandle = 0 then Exit;
  InvalidateNCW( fHandle, Recursive );
end;

//[procedure TControl.SetClientMargin]
procedure TControl.SetClientMargin(const Index, Value: Integer);
begin
  case Index of
  1: fClientTop := Value;
  2: fClientBottom := Value;
  3: fClientLeft := Value;
  4: fClientRight := Value;
  end;
  Global_Align( Self );
end;

{$IFDEF F_P}
//[function TControl.GetClientMargin]
function TControl.GetClientMargin(const Index: Integer): Integer;
begin
  CASE Index OF
  1: Result := fClientTop;
  2: Result := fClientBottom;
  3: Result := fClientLeft;
  4: Result := fClientRight;
  END;
end;
{$ENDIF F_P}

{ TBits }

//[function NewBits]
function NewBits: PBits;
begin
  Result := PBits.Create;
  Result.fList := NewList;
  Result.fList.fAddBy := 1;
end;

//[function TBits.Copy]
function TBits.Copy(From, BitsCount: Integer): PBits;
var Shift, N: Integer;
    FirstItemPtr: Pointer;
begin
  Result := NewBits;
  if BitsCount = 0 then Exit;
  Result.Capacity := BitsCount + 32;
  Result.fCount := BitsCount;
  Move( fList.fItems[ From shr 5 ], Result.fList.fItems[ 0 ], (Count + 31) div 32 );
  Shift := From and $1F;
  if Shift <> 1 then
  begin
    N := (BitsCount + 31) div 32;
    FirstItemPtr := @ Result.fList.fItems[ N - 1 ];
    asm
          PUSH  ESI
          PUSH  EDI
          MOV   ESI, FirstItemPtr
          MOV   EDI, ESI
          STD
          MOV   ECX, N
          XOR   EAX, EAX
          CDQ
    @@1:
          PUSH  ECX
          LODSD
          MOV   ECX, Shift
          SHRD  EAX, EDX, CL
          STOSD
          SUB   ECX, 32
          NEG   ECX
          SHR   EDX, CL
          POP   ECX

          LOOP  @@1

          CLD
          POP   EDI
          POP   ESI
    end {$IFDEF F_P} ['EAX','EDX','ECX'] {$ENDIF};
  end;
end;

//[destructor TBits.Destroy]
destructor TBits.Destroy;
begin
  fList.Free;
  inherited;
end;

//[function TBits.GetBit]
function TBits.GetBit(Idx: Integer): Boolean;
begin
  if Idx >= Count then Result := FALSE else
  Result := ( ( DWORD( fList.fItems[ Idx shr 5 ] ) shr (Idx and $1F)) and 1 ) <> 0;
end;

//[function TBits.GetCapacity]
function TBits.GetCapacity: Integer;
begin
  Result := fList.Capacity * 32;
end;

//[function TBits.GetSize]
function TBits.GetSize: Integer;
begin
  Result := (fList.fCount + 3) div 4;
end;

{$IFDEF ASM_noVERSION}
//[function TBits.IndexOf]
function TBits.IndexOf(Value: Boolean): Integer;
asm     //cmd    //opd
        PUSH     EDI
        MOV      EDI, [EAX].fList
        MOV      ECX, [EDI].TList.fCount
@@ret_1:
        OR       EAX, -1
        JECXZ    @@ret_EAX
        MOV      EDI, [EDI].TList.fItems
        TEST     DL, DL
        MOV      EDX, EDI
        JE       @@of_false
        INC      EAX
        REPZ     SCASD
        JE       @@ret_1
        MOV      EAX, [EDI-4]
        NOT      EAX
        JMP      @@calc_offset
        BSF      EAX, EAX
        SUB      EDI, EDX
        SHR      EDI, 2
        ADD      EAX, EDI
        JMP      @@ret_EAX
@@of_false:
        REPE     SCASD
        JE       @@ret_1
        MOV      EAX, [EDI-4]
@@calc_offset:
        BSF      EAX, EAX
        DEC      EAX
        SUB      EDI, 4
        SUB      EDI, EDX
        SHL      EDI, 3
        ADD      EAX, EDI
@@ret_EAX:
        POP      EDI
end;
{$ELSE ASM_VERSION} //Pascal
function TBits.IndexOf(Value: Boolean): Integer;
var I: Integer;
    D: DWORD;
begin
  Result := -1;
  if Value then
  begin
    for I := 0 to fList.Count-1 do
    begin
      D := DWORD( fList.fItems[ I ] );
      if D <> 0 then
      begin
        asm
          MOV  EAX, D
          BSF  EAX, EAX
          MOV  D, EAX
        end {$IFDEF F_P} [ 'EAX' ] {$ENDIF};
        Result := I * 32 + Integer( D );
        break;
      end;
    end;
  end
    else
  begin
    for I := 0 to fList.fCount-1 do
    begin
      D := DWORD( fList.fItems[ I ] );
      if D <> $FFFFFFFF then
      begin
        asm
          MOV  EAX, D
          NOT  EAX
          BSF  EAX, EAX
          MOV  D, EAX
        end {$IFDEF F_P} [ 'EAX' ] {$ENDIF};
        Result := I * 32 + Integer( D );
        break;
      end;
    end;
  end;
end;
{$ENDIF ASM_VERSION}

//[function TBits.OpenBit]
function TBits.OpenBit: Integer;
begin
  Result := IndexOf( FALSE );
  if Result < 0 then Result := Count;
end;

//[procedure TBits.SetBit]
procedure TBits.SetBit(Idx: Integer; const Value: Boolean);
var Msk: DWORD;
begin
  if Idx >= Capacity then
    Capacity := Idx + 1;
  Msk := 1 shl (Idx and $1F);
  if Value then
    fList.fItems[ Idx shr 5 ] := Pointer(
                  DWORD(fList.fItems[ Idx shr 5 ]) or Msk)
  else
    fList.fItems[ Idx shr 5 ] := Pointer(
                  DWORD(fList.fItems[ Idx shr 5 ]) and not Msk);
  if Idx >= fCount then
    fCount := Idx + 1;
end;

//[procedure TBits.SetCapacity]
procedure TBits.SetCapacity(const Value: Integer);
var OldCap: Integer;
begin
  OldCap := fList.Capacity;
  fList.Capacity := (Value + 31) div 32;
  if OldCap < fList.Capacity then
  FillChar( PChar( Integer( fList.fItems ) + OldCap * Sizeof( Pointer ) )^,
            (fList.Capacity - OldCap) * sizeof( Pointer ), 0 );
end;

{ ----------------------------------------------------------------------

                TAction and TActionList

----------------------------------------------------------------------- }
//[function NewActionList]
function NewActionList(AOwner: PControl): PActionList;
begin
    Result := PActionList.Create;
  with Result do begin
    FActions:=NewList;
    FOwner:=AOwner;
    RegisterIdleHandler(DoUpdateActions);
  end;
end;
//[END NewActionList]

//[function NewAction]
function NewAction(const ACaption, AHint: string; AOnExecute: TOnEvent): PAction;
begin
    Result := PAction.Create;
  with Result do begin
    FControls:=NewList;
    Enabled:=True;
    Visible:=True;
    Caption:=ACaption;
    Hint:=AHint;
    OnExecute:=AOnExecute;
  end;
end;
//[END NewAction]

{ TAction }

//[procedure TAction.LinkCtrl]
procedure TAction.LinkCtrl(ACtrl: PObj; ACtrlKind: TCtrlKind; AItemID: integer; AUpdateProc: TOnUpdateCtrlEvent);
var
  cr: PControlRec;
begin
  New(cr);
  with cr^ do begin
    Ctrl:=ACtrl;
    CtrlKind:=ACtrlKind;
    ItemID:=AItemID;
    UpdateProc:=AUpdateProc;
  end;
  FControls.Add(cr);
  AUpdateProc(cr);
end;

//[procedure TAction.LinkControl]
procedure TAction.LinkControl(Ctrl: PControl);
begin
  LinkCtrl(Ctrl, ckControl, 0, UpdateCtrl);
  Ctrl.OnClick:=DoOnControlClick;
end;

//[procedure TAction.LinkMenuItem]
procedure TAction.LinkMenuItem(Menu: PMenu; MenuItemIdx: integer);
{$IFDEF _FPC}
var
  arr1_DoOnMenuItem: array[ 0..0 ] of TOnMenuItem;
{$ENDIF _FPC}
begin
  LinkCtrl(Menu, ckMenu, MenuItemIdx, UpdateMenu);
  {$IFDEF _FPC}
  arr1_DoOnMenuItem[ 0 ] := DoOnMenuItem;
  Menu.AssignEvents(MenuItemIdx, arr1_DoOnMenuItem);
  {$ELSE}
  Menu.AssignEvents(MenuItemIdx, [ DoOnMenuItem ]);
  {$ENDIF}
end;

//[procedure TAction.LinkToolbarButton]
procedure TAction.LinkToolbarButton(Toolbar: PControl; ButtonIdx: integer);
{$IFDEF _FPC}
var
  arr1_DoOnToolbarButtonClick: array[ 0..0 ] of TOnToolbarButtonClick;
{$ENDIF _FPC}
begin
  LinkCtrl(Toolbar, ckToolbar, ButtonIdx, UpdateToolbar);
  {$IFDEF _FPC}
  arr1_DoOnToolbarButtonClick[ 0 ] := DoOnToolbarButtonClick;
  Toolbar.TBAssignEvents(ButtonIdx, arr1_DoOnToolbarButtonClick);
  {$ELSE}
  Toolbar.TBAssignEvents(ButtonIdx, [DoOnToolbarButtonClick]);
  {$ENDIF}
end;

//[destructor TAction.Destroy]
destructor TAction.Destroy;
begin
  FControls.ReleaseObjects;
  FCaption:='';
  FShortCut:='';
  FHint:='';
  inherited;
end;

//[procedure TAction.DoOnControlClick]
procedure TAction.DoOnControlClick(Sender: PObj);
begin
  Execute;
end;

//[procedure TAction.DoOnMenuItem]
procedure TAction.DoOnMenuItem(Sender: PMenu; Item: Integer);
begin
  Execute;
end;

//[procedure TAction.DoOnToolbarButtonClick]
procedure TAction.DoOnToolbarButtonClick(Sender: PControl; BtnID: Integer);
begin
  Execute;
end;

//[procedure TAction.Execute]
procedure TAction.Execute;
begin
  if Assigned(FOnExecute) and FEnabled then
    FOnExecute(PObj( Self ));
end;

//[procedure TAction.SetCaption]
procedure TAction.SetCaption(const Value: string);
var
  i: integer;
  c, ss: string;

begin
  i:=Pos(#9, Value);
  if i <> 0 then begin
    c:=Copy(Value, 1, i - 1);
    ss:=Copy(Value, i + 1, MaxInt);
  end
  else begin
    c:=Value;
    ss:='';
  end;
  if (FCaption = c) and (FShortCut = ss) then exit;
  FCaption:=c;
  FShortCut:=ss;
  UpdateControls;
end;

//[procedure TAction.SetChecked]
procedure TAction.SetChecked(const Value: boolean);
begin
  if FChecked = Value then exit;
  FChecked := Value;
  UpdateControls;
end;

//[procedure TAction.SetEnabled]
procedure TAction.SetEnabled(const Value: boolean);
begin
  if FEnabled = Value then exit;
  FEnabled := Value;
  UpdateControls;
end;

//[procedure TAction.SetHelpContext]
procedure TAction.SetHelpContext(const Value: integer);
begin
  if FHelpContext = Value then exit;
  FHelpContext := Value;
  UpdateControls;
end;

//[procedure TAction.SetHint]
procedure TAction.SetHint(const Value: string);
begin
  if FHint = Value then exit;
  FHint := Value;
  UpdateControls;
end;

//[procedure TAction.SetOnExecute]
procedure TAction.SetOnExecute(const Value: TOnEvent);
begin
  if @FOnExecute = @Value then exit;
  FOnExecute:=Value;
  UpdateControls;
end;

//[procedure TAction.SetVisible]
procedure TAction.SetVisible(const Value: boolean);
begin
  if FVisible = Value then exit;
  FVisible := Value;
  UpdateControls;
end;

//[procedure TAction.UpdateControls]
procedure TAction.UpdateControls;
var
  i: integer;
begin
  with FControls do
    for i:=0 to Count - 1 do
      PControlRec(Items[i]).UpdateProc(Items[i]);
end;

//[procedure TAction.UpdateCtrl]
procedure TAction.UpdateCtrl(Sender: PControlRec);
begin
  with Sender^, PControl(Ctrl) do begin
    if Caption <> Self.FCaption then
      Caption:=Self.FCaption;
    if Enabled <> Self.FEnabled then
      Enabled:=Self.FEnabled;
    if Checked <> Self.FChecked then
      Checked:=Self.FChecked;
    if Visible <> Self.FVisible then
      Visible:=Self.FVisible;
  end;
end;

//[procedure TAction.UpdateMenu]
procedure TAction.UpdateMenu(Sender: PControlRec);
var
  s: string;
begin
  with Sender^, PMenu(Ctrl).Items[ItemID] do begin
    s:=Self.FCaption;
    if Self.FShortCut <> '' then
      s:=s + #9 + Self.FShortCut;
    if Caption <> s then
      Caption:=s;
    if Enabled <> Self.FEnabled then
      Enabled:=Self.FEnabled;
    if Checked <> Self.FChecked then
      Checked:=Self.FChecked;
    if Visible <> Self.FVisible then
      Visible:=Self.FVisible;
    if HelpContext <> Self.FHelpContext then
      HelpContext:=Self.FHelpContext;
    Accelerator:=Self.FAccelerator;
  end;
end;

//[procedure TAction.UpdateToolbar]
procedure TAction.UpdateToolbar(Sender: PControlRec);
var
  i: integer;
  s: string;
begin
  with Sender^, PControl(Ctrl) do begin
    i:=TBIndex2Item(ItemID);
    s:=TBButtonText[i];
    if (s <> '') and (s <> Self.FCaption) then
      TBButtonText[i]:=Self.FCaption;
    TBSetTooltips(i, [PChar(Self.FHint)]);
    if TBButtonEnabled[ItemID] <> Self.FEnabled then
      TBButtonEnabled[ItemID]:=Self.FEnabled;
    if TBButtonVisible[ItemID] <> Self.FVisible then
      TBButtonVisible[ItemID]:=Self.FVisible;
    if TBButtonChecked[ItemID] <> Self.FChecked then
      TBButtonChecked[ItemID]:=Self.FChecked;
  end;
end;

//[procedure TAction.SetAccelerator]
procedure TAction.SetAccelerator(const Value: TMenuAccelerator);
begin
  if (FAccelerator.fVirt = Value.fVirt) and (FAccelerator.Key = Value.Key) then exit;
  FAccelerator := Value;
  UpdateControls;
end;

{ TActionList }

//[function TActionList.Add]
function TActionList.Add(const ACaption, AHint: string; OnExecute: TOnEvent): PAction;
begin
  Result:=NewAction(ACaption, AHint, OnExecute);
  FActions.Add(Result);
end;

//[procedure TActionList.Clear]
procedure TActionList.Clear;
begin
  while FActions.Count > 0 do
    Delete(0);
  FActions.Clear;
end;

//[procedure TActionList.Delete]
procedure TActionList.Delete(Idx: integer);
begin
  Actions[Idx].Free;
  FActions.Delete(Idx);
end;

//[destructor TActionList.Destroy]
destructor TActionList.Destroy;
begin
  UnRegisterIdleHandler(DoUpdateActions);
  Clear;
  FActions.Free;
  inherited;
end;

//[procedure TActionList.DoUpdateActions]
procedure TActionList.DoUpdateActions(Sender: PObj);
begin
  if Assigned(FOnUpdateActions) and (GetActiveWindow = FOwner.Handle) then
    FOnUpdateActions(PObj( Self ));
end;

//[function TActionList.GetActions]
function TActionList.GetActions(Idx: integer): PAction;
begin
  Result:=FActions.Items[Idx];
end;

//[function TActionList.GetCount]
function TActionList.GetCount: integer;
begin
  Result:=FActions.Count;
end;

{$IFDEF USE_CUSTOMEXTENSIONS}
  {$I CUSTOM_CODE_EXTENSION.inc} // See comments in TControl
{$ENDIF USE_CUSTOMEXTENSIONS}

//[initialization]
initialization
//[finalization]
finalization
{$IFDEF UNLOAD_RICHEDITLIB}
  if FRichEditModule <> 0 then
    FreeLibrary( FRichEditModule );
{$ENDIF UNLOAD_RICHEDITLIB}

//[END OF KOL.pas]
end.

