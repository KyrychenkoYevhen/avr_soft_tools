<html>
	<head>
		<meta content="http://schemas.microsoft.com/intellisense/ie5" name="vs_targetSchema">
		<LINK href="style.css" type="text/css" rel="stylesheet">
	</head>
	<body>
		<table class="mes_table" border="1">
			<tr class="prop_cap">
				<td width="10%"><IMG src="../elements/delphi/icon/Thread.ico"></td>
				<td align="center">Thread</td>
			</tr>
			<tr>
				<td style="PADDING-RIGHT: 4px; PADDING-LEFT: 4px" colSpan="2">
					<P align="justify">Компонент&nbsp;Thread - создает и запускает параллельный поток в 
						программе.</P>
					<P align="justify">&nbsp;<STRONG>doStart</STRONG> - запускает поток на выполнение. 
						Дальнейшее поведение потока зависит от значения св-ва FastStop. Если оно 
						установлено в True, то&nbsp;компонент&nbsp;вызовет однократно событие onExec, 
						затем onSyncExec(если оно используется) и после этого поток будет автоматически 
						завершен. В противном же случае циклически с заданным промежутком будут 
						вызываться события&nbsp;onExec и&nbsp;onSyncExec до вызова методов doStop или 
						doStopFlag. И наконец св-во&nbsp;BusyEvent, так же относящееся к моменту 
						запуска потока, определяет, что делать в случае уже запущенного потока. 
						Значение Ignore говорит компоненту о том, что ничего делать не 
						нужно(игнорировать) и управление будет возвращено немедленно. Restart - 
						заставляет компонент завершить поток и создать его заного с ожиданием 
						выполнения этого события. Т.е. в этом случае вы должны позаботиться о том, 
						чтобы метод doStart с этим значением св-ва&nbsp;BusyEvent не был вызван из 
						схемы, выполняемой в этом же потоке - в этом случае поток навсегда зациклится.</P>
					<P align="justify"><STRONG>&nbsp;doStop</STRONG> - остановка потока с ожиданием его 
						завершения. Этот метод так же стоит вызывать из схемы, выполняемой в этом 
						потоке.</P>
					<P align="justify"><STRONG>&nbsp;doStopFlag</STRONG> - устанавливает флаг 
						завершения потока и возвращает управление в программу. Этот метод может быть 
						вызван из любого места программы, т.к. всего навсего устанавливает флаг, а не 
						ждет непосредственного его завершения. В этом случае поток будет уничтожен 
						только тогда, когда получит управление после вызова метода onExec и doSyncExec.</P>
					<P align="justify">&nbsp;<STRONG>onExec</STRONG> - все компоненты, идущие после 
						этого метода вынолняются в отдельном потоке, т.е. параллельно с основным 
						процессом и другими потоками в программе(если такие есть). Благодаря этому 
						появляется ряд особенностей, о которых нужно помнить при 
						использование&nbsp;потоков в своей программе:</P>
					<UL>
						<LI>
							<DIV align="justify"><FONT color="#000000">Не рекомендуется изменять внешний вид 
									интерфейсных элементов из схемы, стоящей после метода doExec. Связано это с 
									тем, что все управление визуальными компонентами происходит с помощью 
									асинхронной посылки всевозможных сообщений элементу. Т.е. шевельнули мы мышкой 
									и Windows уже шлет окну или отдельному элементу сообщение о перемещение мыши с 
									её новыми координатами. Этот механизм иногда нарушается при одновременном 
									манипулирование одним и тем же элементом из основного процесса и из потока. 
									Проявляется это нарушение начиная от неверной прорисовки до аварийного 
									завершения программы.</FONT></DIV>
						<LI>
							<DIV align="justify"><FONT color="#000000">Стоит аккуратно изменять данные внутри 
									программы, к которым имеет доступ&nbsp;часть схемы,&nbsp;выполняемая в основном 
									процессе и в потоке.</FONT></DIV>
						<LI>
							<DIV align="justify"><FONT color="#000000"></FONT>Любое циклическое использование 
								потока без внутренней задержки(т.е. Delay=0)&nbsp;приведет к полной загрузке 
								процессора, если основной процесс не занят работой. Связано это с тем, что 
								внутри потока при ненулевой задержки происходит вызов специального метода, 
								который на заданное количество милисекунд полностью останавливает выполнение 
								текущего потока, усыпляет его, и процессор отдыхает в это время.</DIV>
						</LI>
					</UL>
					<P align="justify"><FONT color="#990033">&nbsp;<STRONG>onSyncExec </STRONG>- это 
							событие происходит сразу после события onExec и используется обычно для 
							обновления информации на форме в синхронном режиме. Если коротко, то вызов 
							этого метода заставляет поток приостановить свое выполнение и подождать, пока 
							форма обработает все сообщения Windows, о которых говорится выше. Затем 
							основной процесс так же прерывается на время выполнения всей схемы, идущей 
							после метода. После этого выполнение основного процесса и потока 
							возобновляется. Исходя из описанной логики работы этого метода, стоит отметить, 
							что выполнение большого количества элементов или слишком частое обращение к 
							элементам формы сведет на нет весь выигрыш от использования потоков.</FONT>
						<br>
					</P>
				</td>
			</tr>
			<tr>
				<td class="down_sel" colSpan="2">&nbsp;Примеры: <a href="*Example*example/media/midi.sha">
						MIDI</a>, <a href="*Example*example/system/thread.sha">Thread</a></td>
			</tr>
		</table>
	</body>
</html>
